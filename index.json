[{"content":"LeetCode 12/07 12/08 周赛/双周赛 双周赛 T3 3377. 使两个整数相等的数位操作 题目总结： 给定两个整数 n 和 m，要求将 n 转变为 m，转变过程中需要满足以下条件：\nn 和 m 的数位长度相同； 可以对 n的数位执行以下操作： 将 n 中的任意一个 不是 9 的数位 增加 1； 将 n 中的任意一个 不是 0 的数位 减少 1； 转变过程中，n 任何中间状态都 不能是质数； 需要返回从 n 变为 m 的最小代价，代价为转变过程中所有 n 的值之和； 如果无法将 n 变为 m，返回 -1。 实现思路： 质数筛选： 使用线性筛法生成 1~10000 范围内的质数表，用布尔数组 st 标记每个数是否为质数，避免重复计算质数判断。 判断是否是质数： 定义函数 isPrime(x)，通过 st[x] 快速判断一个数是否为质数。 特殊情况过滤： 如果 n 或 m 本身是质数，则直接返回 -1，因为无法满足条件。 最短路径求解： 使用 Dijkstra 算法 求解最小代价。 用优先队列（堆）存储当前的值和路径代价，起点为 n，终点为 m。 遍历当前数的每一位，分别尝试将该位增加或减少 1，生成新的数字 new_n： 如果 new_n 不为质数，并且更新的代价比当前已知代价更小，则将其加入堆中。 重复以上过程直到找到从 n 到 m 的最小代价。 返回结果： 如果在搜索中找到路径，返回最小代价；否则返回 -1 表示无法转换。 class Solution: def minOperations(self, n: int, m: int) -\u0026gt; int: N = 10000 primes = [] st = [False] * (N + 1) st[1] = True def sieve(n): for i in range(2, n + 1): if not st[i]: primes.append(i) for prime in primes: if i * prime \u0026gt; n: break st[i * prime] = True if i % prime == 0: break sieve(N) def isPrime(x): return not st[x] if isPrime(n) or isPrime(m): return -1 dis = [inf] * (N + 1) def dijkstra(): h = [(n, n)] dis[n] = n while h: dist, ver = heappop(h) if ver == m: return dist if dist \u0026gt; dis[ver]: continue str_n = list(str(ver)) for i in range(len(str_n)): ch = str_n[i] for delta in [-1, 1]: new_ch = chr(ord(ch) + delta) if \u0026#39;0\u0026#39; \u0026lt;= new_ch \u0026lt;= \u0026#39;9\u0026#39;: new_n = int(\u0026#34;\u0026#34;.join(str_n[:i] + [new_ch] + str_n[i+1:])) if not isPrime(new_n) and dist + new_n \u0026lt; dis[new_n]: dis[new_n] = dist + new_n heappush(h, (dis[new_n], new_n)) return dis[m] res = dijkstra() return res if res \u0026lt; inf else -1 T4 3378. 统计最小公倍数图中的连通块数目 题目大意 题目给定一个整数数组 nums 和一个正整数 threshold，定义一张由 nums 的元素组成的图。如果两个节点对应的值 nums[i] 和 nums[j] 的最小公倍数（LCM）小于等于 threshold，则在图中将两个节点相连。要求返回图中 连通块的数量，即所有相互连通的节点组成的独立子图的数量。\n解题思路 为了实现题目的要求，我们需要解决以下问题：\n构建图的连通性： 我们不用显式构建图，而是利用并查集（Union-Find）来动态合并满足条件的节点。 如果两个值 nums[i] 和 nums[j] 满足 LCM 的条件，则合并对应的连通块。 优化最小公倍数的计算： 对于任意两个数 a 和 b，它们的最小公倍数（LCM）可以通过公式计算： lcm(a, b) = a * b / gcd(a, b) 由于 nums 中元素互不相同，可通过因数来进行筛选而避免直接计算 LCM。 通过因数优化连接过程： 从小到大遍历所有的因数 g（从 1 到 threshold），对于 nums 中能被 g 整除的所有数，将这些数通过并查集进行合并。 这样可以避免逐一检查任意两数间的 LCM，极大地优化性能。 并查集维护连通性： 使用路径压缩和按秩合并优化的并查集，保证查找和合并操作的时间复杂度接近 O(1)。 class Solution: def countComponents(self, nums: List[int], threshold: int) -\u0026gt; int: n = len(nums) f = list(range(n)) # 非递归并查集 def find(x: int) -\u0026gt; int: while x != f[x]: f[x] = f[f[x]] x = f[x] return x # 记录每个数的下标 idx = {x: i for i, x in enumerate(nums)} for g in range(1, threshold + 1): fi = -1 for x in range(g, threshold + 1, g): if x in idx: fi = find(idx[x]) break if fi \u0026lt; 0: continue for y in range(x + g, g * threshold // x + 1, g): if y in idx: fj = find(idx[y]) if fj != fi: f[fj] = fi # 合并 idx[x] 和 idx[y] n -= 1 return n 周赛 T3 3381. 长度可被 K 整除的子数组的最大元素和 题目大意 给定一个整数数组 nums 和一个整数 k，要求找到一个非空子数组，使得其长度可以被 k 整除，同时该子数组的和最大。返回这个子数组的最大和。\n解题思路 为了解决这个问题，我们可以利用前缀和的思想，结合模运算来处理子数组长度的整除性问题。\n核心思想 前缀和性质： 对于任意子数组 [i, j] 的和，可以用前缀和 s 表示： 子数组和 = s[j + 1] - s[i] 如果子数组的长度 (j - i + 1) 可以被 k 整除，则有 (j + 1) % k == i % k。 因此，我们只需要记录每个前缀和的模 k 的最小值即可，随后用当前的前缀和减去此前的最小值得到最大的子数组和。 优化存储和计算： 使用一个哈希表 pre 来记录每个模值对应的最小前缀和。 遍历数组时，更新当前前缀和并检查是否存在满足条件的模值，计算出可能的最大子数组和。 特殊情况处理： 初始时，假设前缀和为 0 时，模值为 0（即可以整除），因此需要初始化 pre[0] = 0。 class Solution: def maxSubarraySum(self, nums: List[int], k: int) -\u0026gt; int: n = len(nums) s = 0 pre = {0: 0} res = float(\u0026#39;-inf\u0026#39;) for i in range(n): s += nums[i] l_mod = (i + 1) % k # length mod if l_mod in pre: res = max(res, s - pre[l_mod]) if l_mod not in pre: pre[l_mod] = s else: pre[l_mod] = min(pre[l_mod], s) return res T4 3382. 用点构造面积最大的矩形 II 题目大意 在无限平面上，给定一组点 (xCoord[i], yCoord[i])，要求找到四个点组成的矩形，满足以下条件：\n矩形的四个顶点必须是输入点中的点； 矩形的内部或边界上不能包含任何其他点； 矩形的边与坐标轴平行。 返回此类矩形的最大面积，如果无法形成这样的矩形，则返回 -1。\n解题思路 关键点 坐标映射与排序： 利用 xCoord 和 yCoord 分别构造点在横坐标和纵坐标上的分布，并记录每个点的信息。 通过对横坐标和纵坐标的排序，便于枚举可能的矩形点对。 构造规则矩形： 枚举每个点作为右上角 (x2, y2)，并通过预处理找到： 左下角 (x1, y1)； 矩形左上角 (x1, y2)； 矩形右下角 (x2, y1)。 通过这些点确定矩形的边界，并进行验证。 矩形内点的验证： 构造树状数组（或其他数据结构）支持快速统计某个矩形范围内的点数。 通过离线处理所有可能的矩形范围，利用前缀和或树状数组进行批量查询，确保效率。 记录面积： 如果一个矩形满足条件且正好包含 4 个顶点，则计算其面积并与当前最大面积比较。 # 树状数组模板 class Fenwick: def __init__(self, n: int): self.tree = [0] * (n + 1) def add(self, i: int) -\u0026gt; None: while i \u0026lt; len(self.tree): self.tree[i] += 1 i += i \u0026amp; -i # [1,i] 中的元素和 def pre(self, i: int) -\u0026gt; int: res = 0 while i \u0026gt; 0: res += self.tree[i] i \u0026amp;= i - 1 return res # [l,r] 中的元素和 def query(self, l: int, r: int) -\u0026gt; int: return self.pre(r) - self.pre(l - 1) class Solution: def maxRectangleArea(self, xCoord: List[int], yCoord: List[int]) -\u0026gt; int: x_map = defaultdict(list) y_map = defaultdict(list) for i, x in enumerate(xCoord): y = yCoord[i] x_map[x].append(y) y_map[y].append(x) # 预处理每个点的正下方的点 below = {} for x, ys in x_map.items(): ys.sort() for y1, y2 in pairwise(ys): below[(x, y2)] = y1 # 预处理每个点的正左边的点 left = {} for y, xs in y_map.items(): xs.sort() for x1, x2 in pairwise(xs): left[(x2, y)] = x1 # 离散化用 xs = sorted(x_map) ys = sorted(y_map) # 收集询问：矩形区域（包括边界）的点的个数 queries = [] # 枚举 (x2,y2) 作为矩形的右上角 for x2, list_y in x_map.items(): for y1, y2 in pairwise(list_y): # 计算矩形左下角 (x1,y1) x1 = left.get((x2, y2), None) # 矩形右下角的左边的点的横坐标必须是 x1 # 矩形左上角的下边的点的纵坐标必须是 y1 if x1 is not None and left.get((x2, y1), None) == x1 and below.get((x1, y2), None) == y1: queries.append(( bisect_left(xs, x1), # 离散化 bisect_left(xs, x2), bisect_left(ys, y1), bisect_left(ys, y2), (x2 - x1) * (y2 - y1), )) # 离线询问 qs = [[] for _ in range(len(xs))] for i, (x1, x2, y1, y2, _) in enumerate(queries): if x1 \u0026gt; 0: qs[x1 - 1].append((i, -1, y1, y2)) qs[x2].append((i, 1, y1, y2)) # 回答询问 res = [0] * len(queries) tree = Fenwick(len(ys)) for i, x in enumerate(xs): # 把横坐标为 x 的所有点都加到树状数组中 for y in x_map[x]: tree.add(bisect_left(ys, y) + 1) # 离散化 for qid, sign, y1, y2 in qs[i]: # 查询 [y1,y2] 中点的个数 res[qid] += sign * tree.query(y1 + 1, y2 + 1) ans = -1 for cnt, q in zip(res, queries): if cnt == 4: ans = max(ans, q[4]) return ans ","permalink":"https://kennems.github.io/posts/tech/leetcode-1207-1208-%E5%91%A8%E8%B5%9B%E5%8F%8C%E5%91%A8%E8%B5%9B/","summary":"LeetCode 12/07 12/08 周赛/双周赛 双周赛 T3 3377. 使两个整数相等的数位操作 题目总结： 给定两个整数 n 和 m，要求将 n 转变为 m，转变过程中需要满足以下条件： n 和 m 的数位","title":"LeetCode 12/07 12/08 周赛/双周赛"},{"content":"黑马头条（2） 从业务角度分析如何分表 滚屏分页的逻辑 大文本静态化方案：\nfreemarker minio 表的拆分-垂直分表 垂直分表：将一个表的字段分散到多个表中，每个表存储其中一部分字段。\n优势：\n减少IO争抢，减少锁表的几率，查看文章概述与文章详情互不影响 充分发挥高频数据的操作效率，对文章概述数据的操作的高效率不会被操作文章详情数据的低效率所拖累 拆分规则：\n把不常用的字段单独放在一张表 把text、blob等大字段拆分出来单独放在一张表 经常组合查询的字段单独放在一张表中 文章详情 FreeMarker FreeMarker是一款模板引擎：即一种基于模板和要改变的数据，并用来生成输出文本（HTML网页，电子邮件，配置文件，原代码等）的通用工具。它不是面向最终用户的，而是一个Java类库，是一款程序员可以嵌入所开发产品的组件。\n依赖导入： \u0026lt;dependencies\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;junit\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;junit\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;3.8.1\u0026lt;/version\u0026gt; \u0026lt;scope\u0026gt;test\u0026lt;/scope\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework.boot\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-boot-starter-web\u0026lt;/artifactId\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework.boot\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-boot-starter-freemarker\u0026lt;/artifactId\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework.boot\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-boot-starter-test\u0026lt;/artifactId\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;!-- lombok --\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.projectlombok\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;lombok\u0026lt;/artifactId\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;!-- apache 对 java io 的封装工具库 --\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.apache.commons\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;commons-io\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;1.3.2\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;/dependencies\u0026gt; controller中指定对应的数据： @Controller public class HelloController { @GetMapping(\u0026#34;/basic\u0026#34;) public String hello(Model model){ // name model.addAttribute(\u0026#34;name\u0026#34;, \u0026#34;freemarker\u0026#34;); Student student = new Student(); student.setName(\u0026#34;Kennem\u0026#34;); student.setAge(21); student.setBirthday(new Date(2003, 1, 15)); model.addAttribute(\u0026#34;stu\u0026#34;, student); return \u0026#34;01-basic\u0026#34;; } } template中指定对应的样式：01-basic.ftl 最终样式：\nFreemarker指令语法 注释，即\u0026lt;#– –\u0026gt;，介于其之间的内容会被freemarker忽略 \u0026lt;#--这里是注释--\u0026gt; 插值（Interpolation）：即${..}部分，freemarker会用真实的值代替${..} Hello ${name} FTL指令：和HTML标记类似，名字前加#予以区分，Freemarker会解析标签中的表达式或逻辑。 \u0026lt;# \u0026gt;FTL指令\u0026lt;/#\u0026gt; 文本，仅文本信息，这些不是freemarker的注释、插值、FTL指令的内容会被freemarker忽略 \u0026lt;#-- freemarker中的普通文本 --\u0026gt;\r这是普通文本 集合指令-List \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;utf-8\u0026#34;\u0026gt; \u0026lt;title\u0026gt;Hello World!\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;#--List 数据展示--\u0026gt; \u0026lt;b\u0026gt;List 数据展示：\u0026lt;/b\u0026gt; \u0026lt;br\u0026gt;\u0026lt;br\u0026gt; \u0026lt;table\u0026gt; \u0026lt;tr\u0026gt; \u0026lt;td\u0026gt;序号\u0026lt;/td\u0026gt; \u0026lt;td\u0026gt;姓名\u0026lt;/td\u0026gt; \u0026lt;td\u0026gt;年龄\u0026lt;/td\u0026gt; \u0026lt;td\u0026gt;钱包\u0026lt;/td\u0026gt; \u0026lt;/tr\u0026gt; \u0026lt;#list stus as stu\u0026gt; \u0026lt;tr\u0026gt; \u0026lt;td\u0026gt;${stu_index + 1}\u0026lt;/td\u0026gt; \u0026lt;td\u0026gt;${stu.name}\u0026lt;/td\u0026gt; \u0026lt;td\u0026gt;${stu.age}\u0026lt;/td\u0026gt; \u0026lt;td\u0026gt;${stu.money}\u0026lt;/td\u0026gt; \u0026lt;/tr\u0026gt; \u0026lt;/#list\u0026gt; \u0026lt;/table\u0026gt; \u0026lt;hr\u0026gt; \u0026lt;#--Map 数据展示--\u0026gt; \u0026lt;b\u0026gt;Map 数据展示：\u0026lt;/b\u0026gt;\u0026lt;br\u0026gt;\u0026lt;br\u0026gt; \u0026lt;a href=\u0026#34;###\u0026#34;\u0026gt;方式一：通过map[\u0026#39;keyname\u0026#39;].property\u0026lt;/a\u0026gt;\u0026lt;br/\u0026gt; 输出stu1的学生信息：\u0026lt;br/\u0026gt; 姓名：${stuMap[\u0026#39;stu1\u0026#39;].name}\u0026lt;br/\u0026gt; 年龄：${stuMap[\u0026#39;stu1\u0026#39;].age}\u0026lt;br/\u0026gt; 钱包：${stuMap[\u0026#39;stu1\u0026#39;].money}\u0026lt;br/\u0026gt; \u0026lt;hr\u0026gt; \u0026lt;br\u0026gt; \u0026lt;a href=\u0026#34;###\u0026#34;\u0026gt;方式二：通过map.keyname.property\u0026lt;/a\u0026gt;\u0026lt;br/\u0026gt; 输出stu2的学生信息：\u0026lt;br/\u0026gt; 姓名：${stuMap.stu2.name}\u0026lt;br/\u0026gt; 年龄：${stuMap.stu2.age}\u0026lt;br/\u0026gt; 钱包：${stuMap.stu2.money}\u0026lt;br/\u0026gt; \u0026lt;hr\u0026gt; \u0026lt;br/\u0026gt; \u0026lt;a href=\u0026#34;###\u0026#34;\u0026gt;遍历map中两个学生信息：\u0026lt;/a\u0026gt;\u0026lt;br/\u0026gt; \u0026lt;table\u0026gt; \u0026lt;tr\u0026gt; \u0026lt;td\u0026gt;序号\u0026lt;/td\u0026gt; \u0026lt;td\u0026gt;姓名\u0026lt;/td\u0026gt; \u0026lt;td\u0026gt;年龄\u0026lt;/td\u0026gt; \u0026lt;td\u0026gt;钱包\u0026lt;/td\u0026gt; \u0026lt;/tr\u0026gt; \u0026lt;#list stuMap?keys as key\u0026gt; \u0026lt;tr\u0026gt; \u0026lt;td\u0026gt;${key_index + 1}\u0026lt;/td\u0026gt; \u0026lt;td\u0026gt;${stuMap[key].name}\u0026lt;/td\u0026gt; \u0026lt;td\u0026gt;${stuMap[key].age}\u0026lt;/td\u0026gt; \u0026lt;td\u0026gt;${stuMap[key].money}\u0026lt;/td\u0026gt; \u0026lt;/tr\u0026gt; \u0026lt;/#list\u0026gt; \u0026lt;/table\u0026gt; \u0026lt;hr\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; if指令 \u0026lt;table\u0026gt; \u0026lt;tr\u0026gt; \u0026lt;td\u0026gt;序号\u0026lt;/td\u0026gt; \u0026lt;td\u0026gt;姓名\u0026lt;/td\u0026gt; \u0026lt;td\u0026gt;年龄\u0026lt;/td\u0026gt; \u0026lt;td\u0026gt;钱包\u0026lt;/td\u0026gt; \u0026lt;/tr\u0026gt; \u0026lt;#list stus as stu\u0026gt; \u0026lt;tr\u0026gt; \u0026lt;#if stu.name=\u0026#39;小红\u0026#39;\u0026gt; \u0026lt;td\u0026gt;${stu_index + 1}\u0026lt;/td\u0026gt; \u0026lt;td\u0026gt;\u0026lt;font color=\u0026#34;red\u0026#34;\u0026gt;${stu.name}\u0026lt;/font\u0026gt;\u0026lt;/td\u0026gt; \u0026lt;td\u0026gt;${stu.age}\u0026lt;/td\u0026gt; \u0026lt;td\u0026gt;${stu.money}\u0026lt;/td\u0026gt; \u0026lt;#else\u0026gt; \u0026lt;td\u0026gt;${stu_index + 1}\u0026lt;/td\u0026gt; \u0026lt;td\u0026gt;${stu.name}\u0026lt;/td\u0026gt; \u0026lt;td\u0026gt;${stu.age}\u0026lt;/td\u0026gt; \u0026lt;td\u0026gt;${stu.money}\u0026lt;/td\u0026gt; \u0026lt;/#if\u0026gt; \u0026lt;/tr\u0026gt; \u0026lt;/#list\u0026gt; \u0026lt;/table\u0026gt; 运算符 算术运算符 FreeMarker表达式中完全支持算术运算，FreeMarker支持的算术运算符包括：\n加法：+ 减法：- 乘法：* 除法：/ 求模（求余）：% 比较运算符 =或者==\n!=\n\u0026gt; 或者 gt\n\u0026gt;= 或者 gte\n\u0026lt;或者lt\n\u0026lt;=或者lte\n逻辑运算符 逻辑与：\u0026amp;\u0026amp; 逻辑或：|| 逻辑非：！ 空值处理 判断某变量是否存在使用?? 用法为：variable??，如果该变量存在，返回true，否则返回false\n\u0026lt;#if stus??\u0026gt; \u0026lt;#list stus as stu\u0026gt; \u0026lt;tr\u0026gt; \u0026lt;#if stu.name=\u0026#39;小红\u0026#39;\u0026gt; \u0026lt;td\u0026gt;${stu_index + 1}\u0026lt;/td\u0026gt; \u0026lt;td\u0026gt;\u0026lt;font color=\u0026#34;red\u0026#34;\u0026gt;${stu.name}\u0026lt;/font\u0026gt;\u0026lt;/td\u0026gt; \u0026lt;td\u0026gt;${stu.age}\u0026lt;/td\u0026gt; \u0026lt;td\u0026gt;${stu.money}\u0026lt;/td\u0026gt; \u0026lt;#else\u0026gt; \u0026lt;td\u0026gt;${stu_index + 1}\u0026lt;/td\u0026gt; \u0026lt;td\u0026gt;${stu.name}\u0026lt;/td\u0026gt; \u0026lt;td\u0026gt;${stu.age}\u0026lt;/td\u0026gt; \u0026lt;td\u0026gt;${stu.money}\u0026lt;/td\u0026gt; \u0026lt;/#if\u0026gt; \u0026lt;/tr\u0026gt; \u0026lt;/#list\u0026gt; \u0026lt;/#if\u0026gt; 缺失变量默认值使用! 使用!要以指定一个默认值，当变量为空时显示默认值 例如：${name!''}表示如果name为空显示空字符串 如果是嵌套对象则建议使用()括起来 例如：${(stu.name)''}表示，如果stu或name为空默认显示空字符串 内建函数 内建函数语法格式：变量 + ？+ 函数名称\n1.集合的大小 ${集合名?size} 2.日期格式化 当前的日期：${today?date}\u0026lt;br/\u0026gt; 当前的日期：${today?time}\u0026lt;br/\u0026gt; 当前的日期：${today?datetime}\u0026lt;br/\u0026gt; 当前的日期：${today?string(\u0026#34;yyyy-MM-mm\u0026#34;)}\u0026lt;br/\u0026gt; 3.内建函数c //长数值类型 model.addAttribute(\u0026#34;point\u0026#34;, 6549255147894651651L); 默认每三位使用逗号分隔\n如果不想显示为每三位分隔的数字，可以使用c函数将数字型转成字符串输出\n${point?c} 4.将json字符串转成对象 一个例子：\n其中用到了assign标签，assign的作用是定义一个变量\n输出静态化文件 代码补全时注意选择哪一个包\n@SpringBootTest(classes = FreemarkerDemoApplication.class) @RunWith(SpringRunner.class) public class FreemarkerTest { @Autowired private Configuration configuration; @Test public void test() throws IOException, TemplateException { Template template = configuration.getTemplate(\u0026#34;02-list.ftl\u0026#34;); /** * 合成方法 * * 参数1：数据模型 * 参数2：输出流 */ Map map = getData(); template.process(map, new FileWriter(\u0026#34;d:/test/list.html\u0026#34;)); } private Map getData() { Map\u0026lt;String, Object\u0026gt; map = new HashMap\u0026lt;\u0026gt;(); //------------------------------------ Student stu1 = new Student(); stu1.setName(\u0026#34;小强\u0026#34;); stu1.setAge(18); stu1.setMoney(1000.86f); stu1.setBirthday(new Date()); //小红对象模型数据 Student stu2 = new Student(); stu2.setName(\u0026#34;小红\u0026#34;); stu2.setMoney(200.1f); stu2.setAge(19); //将两个对象模型数据存放到List集合中 List\u0026lt;Student\u0026gt; list = new ArrayList\u0026lt;\u0026gt;(); list.add(stu1); list.add(stu2); //向model中存放List集合数据 map.put(\u0026#34;stus\u0026#34;, list); //------------------------------------ //创建Map数据 Map\u0026lt;String, Student\u0026gt; stuMap = new HashMap\u0026lt;\u0026gt;(); stuMap.put(\u0026#34;stu1\u0026#34;, stu1); stuMap.put(\u0026#34;stu2\u0026#34;, stu2); // 3.1 向model中存放Map数据 map.put(\u0026#34;stuMap\u0026#34;, stuMap); map.put(\u0026#34;today\u0026#34;, new Date()); //长数值类型 map.put(\u0026#34;point\u0026#34;, 6549255147894651651L); return map; } } 输出对应含有数据的html文件 MinIO 对象存储的方式对比：\n存储方式 优点 缺点 FastDFS 1. 主备服务，高可用2. 支持主从文件，支持自定义扩展名3. 支持动态扩容 1. 没有完善的官方文档，近几年没有更新2. 环境搭建较为麻烦 MinIO 1. 性能高，准硬件条件下它能达到55GB/s的读、35GB/s的写速率2. 部署自带管理界面3. MinIO Inc运营的开源项目，社区活跃度高4. 提供了所有主流开发语言的SDK 1. 不支持动态增加节点 docker部署 docker search minio docker run -p 9000:9000 --name minio -d --restart=always -e \u0026#34;MINIO_ACCESS_KEY=minio\u0026#34; -e \u0026#34;MINIO_SECRET_KEY=minio123\u0026#34; -v /home/data:/data -v /home/config:/root/.minio minio/minio server /data 基本概念 bucket-类比于文件系统的目录 Object-类比文件系统的文件 Keys-类比文件名 上传文件进行静态访问 public class MinIOTest { public static void main(String[] args){ try { FileInputStream fileInputStream = new FileInputStream(\u0026#34;D:\\\\test\\\\list.html\u0026#34;); // 获取minio的链接信息， 创建一个minio的客户端 MinioClient minioClient = MinioClient.builder().credentials(\u0026#34;minio\u0026#34;, \u0026#34;minio123\u0026#34;).endpoint(\u0026#34;http://192.168.200.130:9000/\u0026#34;).build(); // 上传 PutObjectArgs putObjectArgs = PutObjectArgs.builder() .object(\u0026#34;list.html\u0026#34;) .contentType(\u0026#34;text/html\u0026#34;) .bucket(\u0026#34;leadnews\u0026#34;) .stream(fileInputStream, fileInputStream.available(), -1).build(); minioClient.putObject(putObjectArgs); } catch (Exception e) { throw new RuntimeException(e); } } } 封装MinIO为starter MinIO为starter\n错误： @Autowire不成功\n解决方法： 检查启动类是否有@SpringBootApplication\n模块内导入依赖：\n","permalink":"https://kennems.github.io/posts/tech/%E9%BB%91%E9%A9%AC%E5%A4%B4%E6%9D%A12/","summary":"黑马头条（2） 从业务角度分析如何分表 滚屏分页的逻辑 大文本静态化方案： freemarker minio 表的拆分-垂直分表 垂直分表：将一个表的字段分散到多个表中，每个表存储","title":"黑马头条（2）"},{"content":"LeetCode 11/24 11/25 周赛/双周赛 太长时间不参加周赛手生了很多，有时间就打，没时间刷熟 LeetCode Hot 100 + 面试题150 + LCR\n双周赛 T3 3362. 零数组变换 III 题目大意 给定一个整数数组 nums 和二维数组 queries，每个操作 [li, ri] 可以将 nums[li] 到 nums[ri] 范围内的每个元素 最多减 1。\n求最多可以删除多少个操作，使剩余操作仍能将 nums 变为全零数组。如果无法变为零数组，返回 -1。\n代码实现 class Solution: def maxRemoval(self, nums: List[int], queries: List[List[int]]) -\u0026gt; int: n = len(nums) # 数组长度 # 用于存储每个起点的终点区间 g = defaultdict(list) for l, r in queries: g[l].append(r) ans = 0 # 被选中（未删除）的 queries 数量 sel = [] # 当前被选中区间的终点（小根堆） hq = [] # 当前可选区间的终点（大根堆，用负数模拟） # 遍历 nums 的每一个位置 for i, x in enumerate(nums): # 移除已经过期的区间（小于当前下标 i 的） while sel and sel[0] \u0026lt; i: heappop(sel) # 将起点为 i 的所有区间终点加入大根堆 for r in g[i]: heappush(hq, -r) # 需要为当前下标 i 的值 x 找到足够的区间来覆盖 while x \u0026gt; len(sel): # 如果当前没有可用的区间或区间不合法，返回 -1 if not hq or -hq[0] \u0026lt; i: return -1 # 从最大终点区间中选取一个 heappush(sel, -heappop(hq)) ans += 1 # 统计被选中的区间数 # 返回最多可以删除的 queries 数量 return len(queries) - ans T4 3363. 最多可收集的水果数目 题目大意 给定一个 n x n 的网格 fruits，其中 fruits[i][j] 表示房间 (i, j) 中的水果数量。三个小朋友分别从 (0,0)、(0,n-1) 和 (n-1,0) 出发，每人移动 n-1 次到达 (n-1,n-1)。 他们会收集经过房间的水果，且同一房间的水果只能被一个小朋友收集。求三人最多可以收集的水果总数。\n代码实现 class Solution: def maxCollectedFruits(self, fruits: List[List[int]]) -\u0026gt; int: n = len(fruits) # 定义一个递归函数，计算从 (i, j) 到终点的最大收集水果数 @cache def dfs(i: int, j: int) -\u0026gt; int: # 检查坐标是否越界（限制在网格内） if not (n - 1 - i \u0026lt;= j \u0026lt; n): return -inf # 如果到达起点 (0, x)，直接返回房间中的水果数量 if i == 0: return fruits[i][j] # 三种可能的移动方式 return max( dfs(i - 1, j - 1), # 左上 dfs(i - 1, j), # 上 dfs(i - 1, j + 1) # 右上 ) + fruits[i][j] # 统计第一条路径 (0, 0) 出发的小朋友收集的水果 ans = sum(fruits[i][i] for i in range(n)) # 计算第二条路径，从右上角 (0, n-1) 出发 ans += dfs(n - 2, n - 1) # 从倒数第二行往上递归计算 dfs.cache_clear() # 对网格转置，相当于主对角线翻转，用于计算第三条路径 fruits = list(zip(*fruits)) # 计算第三条路径，从左下角 (n-1, 0) 出发 ans += dfs(n - 2, n - 1) return ans 周赛 T3 3366. 最小数组和 题目大意 给定一个整数数组 nums 和三个整数 k、op1 和 op2，你需要通过以下两种操作尽可能减少数组元素的和：\n操作 1: 选择一个下标 i，将 nums[i] 除以 2 并向上取整。每个下标最多只能应用一次此操作，最多可以应用 op1 次。 操作 2: 选择一个下标 i，仅当 nums[i] \u0026gt;= k 时，从 nums[i] 中减去 k。每个下标最多只能应用一次此操作，最多可以应用 op2 次。 两种操作可以应用于同一个下标，但每种操作最多只能应用一次。\n你需要计算出经过任意次数的操作后，数组元素和的最小可能值。\n代码实现（含注释） class Solution: def minArraySum(self, nums: List[int], k: int, op1: int, op2: int) -\u0026gt; int: # 初始化变量 n = len(nums) # 创建 DP 表 f，其中 f[i][j][x] 表示处理前 i 个元素时，使用 j 次操作 1 和 x 次操作 2 的最小和 f = [[[float(\u0026#39;inf\u0026#39;)] * (op2 + 1) for _ in range(op1 + 1)] for _ in range(2)] f[0][0][0] = 0 # 初始状态，未操作时和为 0 # 动态规划迭代 for i in range(1, n + 1): # 遍历每个元素 cur, prev = i % 2, (i - 1) % 2 # 当前和前一状态的索引 for j in range(op1 + 1): # 遍历操作 1 的使用次数 for x in range(op2 + 1): # 遍历操作 2 的使用次数 # 不对 nums[i-1] 操作 f[cur][j][x] = f[prev][j][x] + nums[i - 1] # 如果可以使用操作 1 if j \u0026gt; 0: f[cur][j][x] = min( f[cur][j][x], f[prev][j - 1][x] + math.ceil(nums[i - 1] / 2) ) # 如果可以使用操作 2 且 nums[i-1] \u0026gt;= k if x \u0026gt; 0 and nums[i - 1] \u0026gt;= k: f[cur][j][x] = min( f[cur][j][x], f[prev][j][x - 1] + max(nums[i - 1] - k, 0) ) # 如果可以同时使用操作 1 和操作 2 if j \u0026gt; 0 and x \u0026gt; 0: reduced = math.ceil(nums[i - 1] / 2) # 操作 1 后的值 if reduced \u0026gt;= k: # 操作 1 后仍可应用操作 2 f[cur][j][x] = min( f[cur][j][x], f[prev][j - 1][x - 1] + max(reduced - k, 0) ) if nums[i - 1] \u0026gt;= k: # 操作 2 后仍可应用操作 1 after_sub = nums[i - 1] - k f[cur][j][x] = min( f[cur][j][x], f[prev][j - 1][x - 1] + math.ceil(after_sub / 2) ) # 计算最终结果 res = float(\u0026#39;inf\u0026#39;) for j in range(op1 + 1): for x in range(op2 + 1): res = min(res, f[n % 2][j][x]) # 取所有可能状态的最小值 return res T4 3367. 移除边之后的权重最大和 题目大意 给定一棵有 nnn 个节点的无向树，树中每条边有权重，节点编号从 000 到 n−1n-1n−1。输入是一个长度为 n−1n-1n−1 的二维整数数组 edges，其中每个元素 [u_i, v_i, w_i]表示节点 ui 和 vi之间有一条权重为 wi 的边。\n任务是：\n移除零条或多条边，使得每个节点与最多 kkk 个其他节点直接相连。 在满足上述条件下，剩余边的权重之和最大化。 返回满足条件的 最大可能权重和。\n代码实现 class Solution: def maximizeSumOfWeights(self, edges: List[List[int]], k: int) -\u0026gt; int: # 建立邻接表存储树的结构 graph = defaultdict(list) for x, y, weight in edges: graph[x].append((y, weight)) graph[y].append((x, weight)) # 深度优先搜索，返回 (不选当前节点的最大权重和, 选当前节点的最大权重和) def dfs(node: int, parent: int) -\u0026gt; Tuple[int, int]: # `not_choose` 表示当前节点不选择时的最大权重和 not_choose = 0 # `inc` 存储所有子树中权重的增量值（选择 vs 不选择子树） increments = [] # 遍历子节点 for neighbor, weight in graph[node]: if neighbor == parent: continue # 跳过父节点，避免回环 nc, c = dfs(neighbor, node) # 子节点递归计算 not_choose += nc # 累加子节点不选时的最大权重和 # 如果选择子节点可以增加权重，将增量存入 `increments` delta = c + weight - nc if delta \u0026gt; 0: increments.append(delta) # 按增量从大到小排序，取前 k 或 k-1 个 increments.sort(reverse=True) choose_k = not_choose + sum(increments[:k]) # 选 k 个增量 choose_k_minus_1 = not_choose + sum(increments[:k - 1]) # 选 k-1 个增量 return choose_k, choose_k_minus_1 # 递归从根节点开始，返回最大可能的权重和 return max(dfs(0, -1)) ","permalink":"https://kennems.github.io/posts/tech/leetcode-1124-1125-%E5%91%A8%E8%B5%9B%E5%8F%8C%E5%91%A8%E8%B5%9B/","summary":"LeetCode 11/24 11/25 周赛/双周赛 太长时间不参加周赛手生了很多，有时间就打，没时间刷熟 LeetCode Hot 100 + 面试题150 + LCR 双周赛 T3 3362. 零数组变换 III 题目大意 给定一个整数数组","title":"LeetCode周赛425 \u0026 144(241124)"},{"content":"黑马头条（1） 微服务架构开发 Springboot Spring cloud Nacos 环境搭建 目标：接口测试工具及前后端联调\n类似今日头条\n业务说明 技术栈 综合知识的运用：\nSpringBoot SpringCloud nacos redis docker elasticSearch kafka seata 业务或技术解决方案：\n分布式事务 分布式任务调度 延迟队列 异步线程 热数据的处理 评论系统 关注点赞 软硬编程思想提升\n业务分析 设计 编码 测试 部署 nacos部署 docker run --env MODE=standalone --name nacos --restart=always -d -p 8848:8848 nacos/nacos-server:1.2.0 开发环境说明 项目依赖环境：\nJDK1.8 Idea maven-3.6.1 Git 全局异常 tinyInt类型：占1个字节，不指定unsigned（非负数），值范围（-128， 127），指定了unsigned， 值范围（0，255）\ntinyInt通常表示小范围的数值，或者表示true或false，通常值为0表示false，值为1表示true\n项目中的持久层使用的是mybatis-plus，一般都使用mybatis-plus逆向生成对应的实体类\nsalt-盐值 手动加密（md5 + 随机字符串）\nmd5是不可逆加密，md5相同的密码每次加密都一样，不太安全。在md5的基础上手动加盐（salt）处理\napp登录 接口路径 ： /api/v1/login/login_auth\n请求方式：POST\n参数：LoginDto\n响应结果：ResponseResult\nResponseResult Postman测试 Swagger测试 前后端分离开发\n项目基于前后端分离的架构进行开发，前后端分离架构总体上包括前端和服务端，通常是多人协作开发\nSwagger是一个规范和完整的框架，用于生成、描述、调用和可视化RESTful风格的Web服务\n主要作用：\n使得前后端分离开发更加方便，有利于团队协作 接口的文档在线自动生成，降低后端开发人员编写接口文档的负担 功能测试 knife4j测试 knife4j是为Java MVC框架集成Swagger生成Api文档的增强解决方案，前身是swagger-bootstrap-ui\napp端网关 认证过滤器 全局过滤器实现jwt校验\napp前端项目集成 全英文目录放置nginx：\nnginx存放目录 ： d:develop\n配置nginx：\n指定前端页面的目录：\n修改配置后需要使用命令重新加载：\nnginx -s reload ","permalink":"https://kennems.github.io/posts/tech/%E9%BB%91%E9%A9%AC%E5%A4%B4%E6%9D%A11/","summary":"黑马头条（1） 微服务架构开发 Springboot Spring cloud Nacos 环境搭建 目标：接口测试工具及前后端联调 类似今日头条 业务说明 技术栈 综合知识的运用： SpringBoot SpringCloud nacos redis docker elasticSearch kafka seata 业务或技","title":"黑马头条（1）"},{"content":"面经（2） 腾讯面经\n1. 自我介绍与项目 在自我介绍环节，建议突出以下几点：\n背景和教育经历：说明你的专业、学校和毕业时间。如果有相关的学术成果或者奖项也可以提及。 实习和项目经验：重点介绍和面试岗位高度相关的实习或项目经历。比如，可以概括性地描述你负责的模块、使用的技术栈、解决的核心问题和取得的成效。 技术栈：可以具体介绍精通的编程语言（如Java、Python），掌握的框架或工具（如Spring Boot、Django），以及数据库和开发工具的经验（如MySQL、Git）。 项目细节：对于项目，可以选择一两个具有代表性的项目进行详细说明。建议结构如下： 项目背景及目标 你在项目中的角色及承担的主要工作 项目过程中遇到的挑战和你如何解决这些问题 项目的最终成果及其影响（数据和结果能帮助量化） 2. 操作系统 虚拟线程 虚拟线程（virtual thread）是现代编程语言（如Java）中为提高并发性能而引入的轻量级线程机制。相比传统线程，虚拟线程的创建和销毁代价更低，更适合高并发场景。\n虚拟线程的内存置换 在操作系统中，线程切换时一般涉及线程上下文的保存和恢复，主要是寄存器的内容。虚拟线程并不直接影响内存置换的实现，内存置换是操作系统管理内存时根据页面使用情况进行的。\n操作系统的内存置换机制 在操作系统中，内存置换的实现方式通常包括：\n分页机制：操作系统将进程的内存分为多个大小固定的页面，当内存不足时，通过页面置换将部分页面交换到磁盘中。 页面置换算法：页面置换算法决定哪些页面需要被交换，例如FIFO、LRU（最近最少使用）、LFU（最少使用频率）、Clock算法等。 进程、线程、协程的区别 特性 进程 线程 协程 定义 操作系统资源分配的基本单位 进程内的执行单位 用户空间的轻量级线程 调度方式 由操作系统调度 由操作系统调度 由程序自行控制（协作调度） 内存独立性 进程间相互独立 线程共享同一进程的内存空间 运行在线程内共享线程的内存 切换开销 高 较低 极低 使用场景 适用于隔离性要求高的任务 并发执行IO密集型或CPU密集型任务 高并发IO操作、协同任务处理 3. 计算机网络 开放性问题：A机器发送报文到B机器途中有哪些可能原因会导致丢包？\n可能导致报文丢失的原因如下：\n网络拥塞：路由器、交换机等中间设备处理能力有限，当流量超过其处理能力时，可能会丢弃部分报文。 链路错误：在传输介质（如铜线、光纤）上可能会受到电磁干扰、噪声等影响导致数据错误而被丢弃。 TTL（生存时间）超时：IP报文有一个TTL字段，每经过一个路由器减少1，若TTL为0报文会被丢弃。 防火墙过滤：网络路径中某些防火墙设置可能会根据报文内容或端口策略丢弃某些报文。 ARP缓存未更新：A机器可能没有B机器的最新ARP记录，导致数据发送错误。 设备故障：路由器、交换机或网卡等设备故障也可能导致丢包。 4. 算法题：LCR 023. 相交链表 题目描述： 给定两个单链表，判断它们是否相交，如果相交，返回相交的起始节点。假设链表结构不可变，且不使用额外内存空间。\n解题思路：\n双指针法：使用两个指针分别从两个链表的头开始遍历。当某一指针遍历完一条链表后，从另一条链表头开始，最终在相交点相遇。 代码实现：\nclass ListNode: def __init__(self, x): self.val = x self.next = None def getIntersectionNode(headA: ListNode, headB: ListNode) -\u0026gt; ListNode: if not headA or not headB: return None pA, pB = headA, headB # 两个指针走过相同长度（A链表+B链表），最终相遇或到达None while pA != pB: # 如果pA到达末尾则转到headB，否则继续向下 pA = pA.next if pA else headB # 如果pB到达末尾则转到headA，否则继续向下 pB = pB.next if pB else headA return pA # 返回相交节点或None（不相交） 复杂度分析：\n时间复杂度：O(m + n)，m和n是两个链表的长度。 空间复杂度：O(1)，只用了两个指针，不需要额外空间。 解释： 通过双指针法，两个指针的总路程相同，如果链表相交，指针会在相交节点处相遇；如果不相交，最终两个指针都会走到链表尾部的None。\n","permalink":"https://kennems.github.io/posts/tech/%E9%9D%A2%E7%BB%8F2/","summary":"面经（2） 腾讯面经 1. 自我介绍与项目 在自我介绍环节，建议突出以下几点： 背景和教育经历：说明你的专业、学校和毕业时间。如果有相关的学术成果或者奖","title":"面经（2）"},{"content":"RabbitMQ 同步通讯 和 异步通讯\n同步调用 同步调用的问题：\n拓展性差 性能下降 级联失败 异步调用 异步调用方式其实就是基于消息通知的方式，一般包含三个角色：\n消息发送者：投递消息的人，就是原来的调用方 消息代理：管理、暂存、转发消息，可以理解为微信服务器 消息接收者：接受和处理消息的人，就是原来的服务提供方 支付服务不再同步调用业务关联度低的服务，而是发送消息通知到Broker。\n具备下列优势：\n解除耦合，拓展性强 无需等待，性能好 故障隔离 缓存消息，流量削峰填谷 缺点：\n不能立刻得到调用结果，时效性差 不确定下游业务执行是否成功 业务安全依赖于Broker的可靠性 MQ MQ（MessageQueue），消息队列，存放消息的队列，也就是异步调用中的Broker。\n特性 RabbitMQ ActiveMQ RocketMQ Kafka 公司/社区 Rabbit Apache 阿里 Apache 开发语言 Erlang Java Java Scala \u0026amp; Java 协议支持 AMQP, XMPP, SMTP, STOMP OpenWire, STOMP, REST, XMPP, AMQP 自定义协议 自定义协议 可用性 高 一般 高 非常高 单机吞吐量 一般 差 高 非常高 消息延迟 微秒级 毫秒级 毫秒级 毫秒以内 消息可靠性 高 一般 高 一般 RabbitMQ的整体架构及核心概念 virtual-host：虚拟主机，起到数据隔离的作用 publisher：消息发送者 consumer：消息的消费者 queue：队列，存储消息 exchange：交换机，负责路由消息 快速入门 启动MQ docker run \\ -e RABBITMQ_DEFAULT_USER=itheima \\ -e RABBITMQ_DEFAULT_PASS=123321 \\ -v mq-plugins:/plugins \\ --name mq \\ --hostname mq \\ -p 15672:15672 \\ -p 5672:5672 \\ --network hmall \\ -d \\ rabbitmq:3.8-management 程序控制 AMQP Advanced Message Queuing Protocol， 是用于在应用程序之间传递业务消息的开放标准。改协议与语言和平台无关，更符合微服务中独立性的要求。\nSpring AMQP Spring AMQP 是基于AMQP协议定义的一套API规范，提供了模板来发送和接受消息。包含两部分，其中spring-amqp是基础抽象，spring-rabbit是底层的默认实现。\n发送者 @SpringBootTest public class SpringAmqpTest { @Autowired private RabbitTemplate rabbitTemplate; @Test void testSendMessage2Queue(){ String queueName = \u0026#34;simple.queue\u0026#34;; String msg = \u0026#34;hello, rabbitmq\u0026#34;; rabbitTemplate.convertAndSend(queueName, msg); } } 监听者 @Slf4j @Component public class MqListener { @RabbitListener(queues = \u0026#34;simple.queue\u0026#34;) public void listenSimpleQueue(String msg) { System.out.println(\u0026#34;消费者收到消息：【\u0026#34; + msg + \u0026#34;】\u0026#34;); } } Work模型的使用：\n多个消费者绑定到一个队列，可以加快消息处理速度 同一条消息只会被一个消费者处理 通过设置prefetch来控制消费者预取的消息数量，处理完一条再处理下一条，实现能者多劳 交换机 真正生产环境都会经过exchange来发送消息，而不是直接发送到队列，交换机的类型有以下三种：\nFanout：广播 Direct：定向 Topic：话题 Fanout交换机 Fanout Exchange会将接受到的消息广播到每一个跟其绑定的queue，所以也叫广播模式\nDirect交换机 Direct Exchange会将接收到的消息根据规则路由到指定的Queue，因此称为定向路由。\n每一个Queue都与Exchange设置一个BindingKey 发布者发送消息时，指定消息的RoutingKey Exchange将消息路由到BindingKey与消息RoutingKey一致的队列 Topic交换机 TopicExchange与DirectExchange类似，区别在于routingKey可以时多个单词的列表，并且以，分割。\nQueue与Exchange指定BindingKey时可以使用通配符：\n# ：代指0个或多个单词 *：代指一个单词 声明队列和交换机 SpringAMQP提供了几个类，用来声明队列、交换机及其绑定关系：\nQueue：用于声明队列，可以用工厂类QueueBuilder构建 Exchange：用于声明交换机，可以用工厂类ExchangeBuilder构建 Binding：用于声明队列和交换机的绑定关系，可以用工厂类BindingBuilder构建 @Configuration public class DirectConfiguration { @Bean public DirectExchange directExchange() { return new DirectExchange(\u0026#34;hmall.direct\u0026#34;); } @Bean public Queue directQueue1() { return new Queue(\u0026#34;direct.queue1\u0026#34;); } @Bean public Binding directQueue1BindingRed(Queue directQueue1, DirectExchange directExchange) { return BindingBuilder.bind(directQueue1).to(directExchange).with(\u0026#34;red\u0026#34;); } @Bean public Binding directQueue1BindingBlue(Queue directQueue1, DirectExchange directExchange) { return BindingBuilder.bind(directQueue1).to(directExchange).with(\u0026#34;blue\u0026#34;); } @Bean public Queue directQueue2() { return new Queue(\u0026#34;direct.queue2\u0026#34;); } @Bean public Binding directQueue2BindingRed(Queue directQueue2, DirectExchange directExchange) { return BindingBuilder.bind(directQueue2).to(directExchange).with(\u0026#34;red\u0026#34;); } @Bean public Binding directQueue2BindingYellow(Queue directQueue2, DirectExchange directExchange) { return BindingBuilder.bind(directQueue2).to(directExchange).with(\u0026#34;yellow\u0026#34;); } } 基于注解声明 @RabbitListener(bindings = @QueueBinding( value = @Queue(name = \u0026#34;direct.queue1\u0026#34;, durable = \u0026#34;true\u0026#34;), exchange = @Exchange(name = \u0026#34;hmall.direct\u0026#34;, type = ExchangeTypes.DIRECT), key = {\u0026#34;red\u0026#34;, \u0026#34;blue\u0026#34;, \u0026#34;Kennem\u0026#34;} )) public void listenDirectQueue1(String msg) throws InterruptedException { System.out.println(\u0026#34;消费者1 收到 direct.queue1 消息：【\u0026#34; + msg + \u0026#34;】.......\u0026#34;); } @RabbitListener(bindings = @QueueBinding( value = @Queue(name = \u0026#34;direct.queue2\u0026#34;, durable = \u0026#34;true\u0026#34;), exchange = @Exchange(name = \u0026#34;hmall.direct\u0026#34;, type = ExchangeTypes.DIRECT), key = {\u0026#34;red\u0026#34;, \u0026#34;yellow\u0026#34;} )) public void listenDirectQueue2(String msg) throws InterruptedException { System.out.println(\u0026#34;消费者2 收到 direct.queue1 消息：【\u0026#34; + msg + \u0026#34;】.......\u0026#34;); } 消息转换器 导入依赖\n\u0026lt;!--Jackon--\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;com.fasterxml.jackson.dataformat\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;jackson-dataformat-xml\u0026lt;/artifactId\u0026gt; \u0026lt;/dependency\u0026gt; 定义转换器\n@Bean public MessageConverter jackonMessageConverter() { return new Jackson2JsonMessageConverter(); } 业务改造 需求：改造余额支付功能，不再同步调用交易服务的OpenFeign接口，而是采用异步MQ通知交易服务更新订单状态\nMQ高级 消息可靠性问题 发送者的可靠性 生产者重连 由于网络波动，可能会出现客户端连接MQ失败的情况。通过配置我们可以开启连接失败后的重连机制。\nspring: rabbitmq: connection-timeout: 1s template: retry: enabled: true SpringAMQP提供的重试机制是阻塞式的重试，也就是说多次重试等待的过程中，当前线程是被阻塞的，会影响业务性能。\n如果对于业务性能有要求，建议禁用重试机制。如果一定要用，请合理配置等待时长和重试次数，也可以考虑使用异步线程来执行发送消息的代码\n生产者确认 RabbitMQ提供了Publisher Confirm和Publisher Return两种确认机制。开启确认机制后会返回确认消息给生产者。返回的结果有以下几种情况：\n消息投递到了MQ，但是路由失败。此时会通过PublisherReturn返回路由异常原因，然后返回ACK，告知投递成功 临时消息投递到了MQ，并且入队成功，返回ACK，告知投递成功 持久消息投递到了MQ，并且入队完成持久化，返回ACK，告知投递成功 其他情况都会返回NACK，告知投递失败 在publisher这个微服务的application.yml中添加配置： spring: rabbitmq: publisher-confirm-type: correlated publisher-returns: true 配置说明：\npublisher-comfirm-type有三种模式可选：\nnone：关闭confirm机制 simple：同步阻塞等待MQ的回执消息 correlated：MQ异步回调方式返回回执消息 每个RabbitTemplate只能配置ReturnCallback，因此需要在项目启动过程中配置： @Slf4j @Configuration public class CommonConfig implements ApplicationContextAware { @Override public void setApplicationContext(ApplicationContext applicationContext) throws BeansException { // 获取RabbitTemplate RabbitTemplate rabbitTemplate = applicationContext.getBean(RabbitTemplate.class); // 设置ReturnCallback rabbitTemplate.setReturnCallback((message, replyCode, replyText, exchange, routingKey) -\u0026gt; { log.info(\u0026#34;消息发送失败, 应答码{}, 原因{}, 交换机{}, 路由键{},消息{}\u0026#34;, replyCode, replyText, exchange, routingKey, message.toString()); }); } } 发送消息，指定消息ID、消息ConfirmCallback @Test void testPublisherConfirm() throws InterruptedException { // 1. 创建CorrelationData CorrelationData cd = new CorrelationData(); // 2. 给Future添加ConfirmCallback cd.getFuture().addCallback(new ListenableFutureCallback\u0026lt;CorrelationData.Confirm\u0026gt;() { @Override public void onFailure(Throwable ex) { // 2.1.Future发生异常时的处理逻辑,基本不会触发 log.error(\u0026#34;handle message ack fail\u0026#34;, ex); } @Override public void onSuccess(CorrelationData.Confirm result) { // 2.2.Future接收到回执的处理逻辑,参数中的result就是回执内容 if(result.isAck()){ // result.isAck(), boolean类型, true代表ack回执, false 代表 nack回执 log.debug(\u0026#34;发送消息成功, 收到 ack!\u0026#34;); }else{ // result.getReason(), String类型, 返回nack时的异常描述 log.error(\u0026#34;发送消息失败, 收到 nack, reason : {}\u0026#34;, result.getReason()); } } }); // 3. 发送消息 rabbitTemplate.convertAndSend(\u0026#34;hmall.direct\u0026#34;, \u0026#34;red1\u0026#34;, \u0026#34;hello\u0026#34;, cd);d } 生产者确认需要额外的网络和系统资源开销，尽量不要使用 如果一定要用，无需开启Publisher-Return机制，因为一般路由失败是自己业务问题 对于nack消息可以有限次数重试，依然失败则记录异常消息 MQ的可靠性 在默认情况下，RabbitMQ会将接收到的消息保存在内存中以降低消息收发的延迟。这样会导致两个问题：\n一旦MQ宕机，内存中的消息会丢失 内存空间有限，当消费者故障或处理过慢时，会导致消息积压，引发MQ阻塞 数据持久化 Rabbit MQ实现的数据持久化包括3个方面：\n交换机持久化 指定durable 队列持久化 指定durable 消息持久化 指定persistent LazyQueue 从RabbitMQ的3.6.0版本开始，就增加了Lazy Queue的概念，也就是惰性队列\n惰性队列的特征如下：\n接收到消息后直接存入磁盘而非内存（内存中只保留最近的消息，默认2048条） 消费者要消费消息时才会从磁盘中读取并加载到内存 支持数百万条的消息存储 在3.12版本之后，所有队列都是Lazy Queue模式，无法更改\n定义queue形式\n@Bean public Queue lazyQueue(){ return QueueBuilder .durable(\u0026#34;lazy.queue\u0026#34;) .lazy() // 开启Lazy模式 .build(); } 基于注解形式：\n@RabbitListener(queuesToDeclare = @Queue( name = \u0026#34;lazy.queue\u0026#34;, durable = \u0026#34;true\u0026#34;, arguments = @Argument(name = \u0026#34;x-queue-mode\u0026#34;, value = \u0026#34;lazy\u0026#34;) )) public void listenLazyQueue(String msg){ log.info(\u0026#34;接收到 lazy.queue的消息: {}\u0026#34;, msg); } 开启持久化和生产者确认时，RabbitMQ只有在消息持久化完成后才会给生产者返回ACK回执。 消费者的可靠性 消费者确认机制 为了确认消费者是否成功处理消息，RabbitMQ提供了消费者确认机制（Consumer Acknowledgement）。当消费者处理消息结束后，应该向RabbitMQ发送一个回执，告知RabbitMQ自己消息处理状态。回执有三种可选值：\nack：成功处理消息，RabbitMQ从队列中删除消息 nack：消息处理失败，RabbitMQ需要再次投递消息 reject：消息处理失败并拒绝该消息，RabbitMQ从队列中删除该消息 SpringAMQP已经实现了消息确认功能。并允许我们通过配置文件选择ACK处理方式，有三种方式：\nnone：不处理。即消息投递给消费者后立刻ack，消息会立刻从MQ删除。非常不安全，不建议使用 manual：手动模式。需要自己在业务代码中调用api，发送ack和reject，存在业务入侵，但更灵活 auto：自动模式。SpringAMQP利用AOP对我们的消息处理逻辑做了环绕增强，当业务正常执行时刻自动返回ack，当业务出现异常时，根据异常判断返回不同结果： 如果业务异常，会自动返回nack 如果是消息处理或校验异常，自动返回reject 失败消息处理策略 在开启重试模式后，重试次数耗尽，如果消息依然失败，则需要有MessageRecoverer接口来处理，它包含三种不同的实现：\nRejectAndDontRequeueRecoverer：重试耗尽后，直接reject，丢弃消息。默认就是这种方式。 ImmediateRequeueMessageRecoverer：重试耗尽后，返回nack，消息重新入队 RepublishMessageRecoverer：重试耗尽后，将失败消息投递到指定的交换机 RepublishMessageRecoverer 多次重试耗尽后，将错误转发到error.direct交换机中\n@Configuration @ConditionalOnProperty(prefix = \u0026#34;spring.rabbitmq.listener.simple.retry\u0026#34;, name = \u0026#34;enabled\u0026#34;, havingValue = \u0026#34;true\u0026#34;) public class ErrorConfiguration { @Bean public DirectExchange errorExchange(){ return new DirectExchange(\u0026#34;error.direct\u0026#34;); } @Bean public Queue errorQueue(){ return new Queue(\u0026#34;error.queue\u0026#34;); } @Bean public Binding errorBinding(Queue errorQueue, DirectExchange errorExchange){ return BindingBuilder.bind(errorQueue).to(errorExchange).with(\u0026#34;error\u0026#34;); } @Bean public MessageRecoverer messageRecoverer(RabbitTemplate rabbitTemplate){ return new RepublishMessageRecoverer(rabbitTemplate, \u0026#34;error.direct\u0026#34;, \u0026#34;error\u0026#34;); } } 业务幂等性 幂等是一个数学概念，用函数表达式来描述：$f(x) = f(f(x))$。在程序开发中，则指同一个业务，执行多次对业务状态的影响是一致的。\n查询和删除操作天生幂等 唯一消息Id 方案一，给每个消息都设置一个唯一的id，利用id区分是否是重复消息：\n每一条消息都生成一个唯一的id，与消息一起投递给消费者 消费者接收到消息后处理自己的业务，业务处理成功后将消息ID保存到数据库中 如果下次又收到相同的消息，去数据库查询判断是否存在，存在则为重复消息放弃处理 @Bean public MessageConverter jackonMessageConverter() { Jackson2JsonMessageConverter jjmc = new Jackson2JsonMessageConverter(); jjmc.setCreateMessageIds(true); return jjmc; } 方案二，结合业务逻辑，基于业务本身做判断。\n面试题 如果保证支付服务与交易服务之间的订单状态一致性？ 首先，支付服务会正在用户支付成功以后利用MQ消息通知交易服务，完成订单状态同步。 其次，为了保证MQ消息的可靠性，我们采用了生产者确认机制、消费者确认、消费者失败重试等策略，确保消息投递和处理的可靠性。同时也开启了MQ的持久化，避免因服务宕机导致消息丢失。 最后，我们还在交易服务更新订单状态时做了业务幂等判断，避免了因为重复消费导致订单状态异常。 如果交易服务消息处理失败，有没有什么兜底方案？ 我们可以在交易服务设置定时任务，定时查询订单支付状态。这样即便MQ通知失败，还可以利用定时任务作为兜底方案，确保订单支付状态的最终一致性。 延迟消息 延迟消息：生产者发送消息时指定一个时间，消费者不会立刻收到消息，而是在指定时间之后才收到消息\n延迟任务：设置在一定时间之后才执行的任务\n死信交换机 当一个队列中的消息满足下列情况之一时，就会成为死信（dead letter）：\n消费者使用 basic.reject 或 basic.nack 声明消费失败，并且消息的requeue参数设置为false 消息是一个过期消息（达到了队列或消息本身设置的过期时间），超时无人消费 要投递的队列消息堆积满了，最早的消息可能称为死信 如果队列通过dead-letter-exchange属性制定了一个交换机，那么该队列中的死信就会投递到这个交换机中。这个交换机称为死信交换机（Dead Letter Exchange， 简称DLX）\n延迟消息插件 ","permalink":"https://kennems.github.io/posts/tech/rabbitmq/","summary":"RabbitMQ 同步通讯 和 异步通讯 同步调用 同步调用的问题： 拓展性差 性能下降 级联失败 异步调用 异步调用方式其实就是基于消息通知的方式，一般包含三个角色： 消息发","title":"RabbitMQ"},{"content":"苍穹外卖前端开发(Day1) node.js安装 配置全局下载包地址和缓存地址 npm config set prefix \u0026#34;E:x\\nodejs\\node_global\u0026#34; npm config set cache \u0026#34;E:\\x\\nodejs\\node_cache\u0026#34; 最新的配置淘宝镜像的淘宝官方提供的方法 npm config set registry https://registry.npmmirror.com 安装Vue npm i @vue/cli -g 创建Vue项目 命令行创建（只能在cmd， 不能用powershell）\nvue create vue-demo-1 用网页的形式创建\nvue ui Vue目录结构 node_modules：当前项目依赖的js包 assets：静态资源存放目录 components：公共组件存放目录 App.vue：项目的主组件，页面的入口文件 main.js：整个项目的入口文件 package.json：项目的配置信息、依赖包管理 vue.config.js：vue-cli配置文件 启动Vue项目工程 在Vue项目文件夹中：\nnpm run serve Vue的基本使用方式 Vue组件 Vue的组件文件以.vue结尾，每个组件由三部分组成\n结构 \u0026lt;template\u0026gt; 只有一个根元素 由它生成HTML代码 样式 \u0026lt;style\u0026gt; 编写CSS，控制页面展示效果 全局样式：影响所有组件 局部样式：只作用于当前组件 逻辑 \u0026lt;script\u0026gt; 编写JS代码 控制模板的数据来源和行为 Vue基本使用方式 文本插值 作用：用来绑定data方法返回的对象属性 用法：{{}} 先定义data()\n\u0026lt;script\u0026gt; export default { name: \u0026#34;HelloWorld\u0026#34;, props: { msg: String, }, data() { return { name: \u0026#34;张三\u0026#34;, age: 30, }; }, }; \u0026lt;/script\u0026gt; 之后在template中使用\n\u0026lt;div class=\u0026#34;hello\u0026#34;\u0026gt; {{ name }} {{ age \u0026gt; 60 ? \u0026#34;老年\u0026#34; : \u0026#34;青年\u0026#34; }} \u0026lt;/div\u0026gt; 属性绑定 作用：为标签的属性绑定data方法中返回的属性 用法：v-bind:xxx 简写为:xxx \u0026lt;input type=\u0026#34;text\u0026#34; v-bind:value=\u0026#34;name\u0026#34;/\u0026gt; \u0026lt;input type=\u0026#34;text\u0026#34; :value=\u0026#34;age\u0026#34;/\u0026gt; \u0026lt;img :src=\u0026#34;src\u0026#34;/\u0026gt; 事件绑定 作用：为元素绑定对应的事件 用法：v-on:xxx，简写为@xxx \u0026lt;input type=\u0026#34;button\u0026#34; value=\u0026#34;保存\u0026#34; v-on:click=\u0026#34;handleSave\u0026#34; /\u0026gt; \u0026lt;input type=\u0026#34;button\u0026#34; value=\u0026#34;保存\u0026#34; @click=\u0026#34;handleSave\u0026#34; /\u0026gt; \u0026lt;script\u0026gt; export default { methods: { handleSave() { alert(\u0026#34;你点击了保存按钮！\u0026#34;) }, }, }; \u0026lt;/script\u0026gt; 双向绑定 作用：表单输入项和data方法中的属性进行绑定，任意一方改变都会同步给另一方 用法：v-model \u0026lt;input type=\u0026#34;text\u0026#34; v-model=\u0026#34;name\u0026#34;/\u0026gt; 条件渲染 作用：根据表达式的值来动态渲染页面元素 用法：v-if、v-else、v-else-if \u0026lt;div v-if=\u0026#34;sex == 1\u0026#34;\u0026gt;男\u0026lt;/div\u0026gt; \u0026lt;div v-else-if=\u0026#34;sex == 2\u0026#34;\u0026gt;女\u0026lt;/div\u0026gt; \u0026lt;div v-else\u0026gt;未知\u0026lt;/div\u0026gt; Vue的基本使用方式 - axios Axios是一个基于promise的网络请求库，作用于浏览器和node.js中\n安装命令\nnpm install axios 导入命令：\nimport axios from \u0026#39;axios\u0026#39; axios的API列表 请求 备注 axios.get(url[, config]) ⭐ axios.delete(url[, config]) axios.head(url[, config]) axios.options(url[, config]) axios.post(url[, data[, config]]) ⭐ axios.put(url[, data[, config]]) axios.patch(url[, data[, config]]) url：请求路径 data：请求体数据，最常见的是JSON格式数据 config：配置对象，可以设置查询参数，请求头信息 \u0026lt;script\u0026gt; import axios from \u0026#34;axios\u0026#34;; export default { methods: { handleSendPOST() { // 通过axios发送HTTP请求 axios .post(\u0026#34;/api/admin/employee/login\u0026#34;, { username: \u0026#34;admin\u0026#34;, password: \u0026#34;123456\u0026#34;, }) .then((res) =\u0026gt; { console.log(res.data); }) .catch((error) =\u0026gt; { console.log(error.response); }); }, handleSendGET() { // 通过 axios 发送get请求 axios .get(\u0026#34;/api/admin/shop/status\u0026#34;, { headers: { token: \u0026#34;eyJhbGciOiJIUzI1NiJ9.eyJlbXBJZCI6MSwiZXhwIjoxNzI5OTMzMjU4fQ.JV9g9K6u4UPzdSIMzcX5crMM3VXImspm6PbvolDpkSg\u0026#34;, }, }) .then((res) =\u0026gt; { console.log(res.data); }); }, }, }; \u0026lt;/script\u0026gt; Vue的基本使用方式 - axios axios 统一使用方式 axios(config)\n\u0026lt;script\u0026gt; import axios from \u0026#34;axios\u0026#34;; export default { handleSend() { // 通过 axios 发送get请求 axios({ url: \u0026#34;/api/admin/employee/login\u0026#34;, method: \u0026#34;post\u0026#34;, data: { //data表示通过请求体传参 username: \u0026#34;admin\u0026#34;, password: \u0026#34;123456\u0026#34;, }, }).then((res) =\u0026gt; { console.log(res.data.data.token) axios({ url:\u0026#39;api/admin/shop/status\u0026#39;, method:\u0026#39;get\u0026#39;, headers:{ token: res.data.data.token } } ) }); }, }, }; \u0026lt;/script\u0026gt; Vue-Router vue属于单页面应用，所谓的路由，就是根据浏览器路径的不同，用不同的视图组件替换这个页面内容\n创建Vue项目时勾选router选项\n老项目中使用\nnpm install vue-router 路由配置 路由组成\nVueRouter：路由器，根据路由请求在路由视图中动态渲染对应的视图组件 \u0026lt;router-link\u0026gt;：路由链接组件，浏览器会解析成\u0026lt;a\u0026gt; \u0026lt;router-view\u0026gt;：路由视图组件，用来展示与路由路径匹配的视图组件 router/index.js中指定路由表 App.vue中指定路由的位置 嵌套路由 嵌套路由：组件内要切换内容，就需要用到嵌套路由（子路由） // 维护路由表，某个路由路径对应哪个视图组件 const routes = [ { path: \u0026#39;/\u0026#39;, name: \u0026#39;home\u0026#39;, component: HomeView }, { path: \u0026#39;/about\u0026#39;, name: \u0026#39;about\u0026#39;, component: () =\u0026gt; import(\u0026#39;../views/AboutView.vue\u0026#39;) }, { path: \u0026#39;/404\u0026#39;, component: () =\u0026gt; import(\u0026#39;../views/404View.vue\u0026#39;) }, { path: \u0026#39;/c\u0026#39;, component: () =\u0026gt; import(\u0026#39;../views/container/ContainerView.vue\u0026#39;), redirect: \u0026#39;/c/p1\u0026#39;, // 嵌套路由（子路由） children:[ { path:\u0026#39;/c/p1\u0026#39;, component: () =\u0026gt; import(\u0026#39;../views/container/P1View.vue\u0026#39;), }, { path: \u0026#39;/c/p2\u0026#39;, component: () =\u0026gt; import(\u0026#39;../views/container/P2View.vue\u0026#39;), }, { path: \u0026#39;/c/p3\u0026#39;, component: () =\u0026gt; import(\u0026#39;../views/container/P3View.vue\u0026#39;), } ] }, { //重定向到404 path: \u0026#39;/*\u0026#39;, redirect: \u0026#39;/404\u0026#39; }, ] 状态管理vuex vuex是一个专门为Vue.js应用程序开发的状态管理库 vuex可以在多个组件之间共享数据，并且共享的数据是响应式的，即数据的变更能及时渲染到模板 vuex采用集中式存储管理所有组件的状态 vuex介绍 state：状态对象，集中定义各个组件共享的数据 mutations：类似于一个事件，用于修改共享数据，要求必须是同步函数 actions：类似于mutation，可以包含异步操作，通过调用mutation来改变共享数据 定义和展示共享数据 // 集中管理多个组件共享的数据 export default new Vuex.Store({ // 集中定义共享数据 state: { name: \u0026#39;未登录游客\u0026#39; }, getters: { }, mutations: { }, actions: { }, modules: { } }) 使用共享数据：\n\u0026lt;div id=\u0026#34;app\u0026#34;\u0026gt; 欢迎你，{{$store.state.name}} \u0026lt;img alt=\u0026#34;Vue logo\u0026#34; src=\u0026#34;./assets/logo.png\u0026#34;\u0026gt; \u0026lt;HelloWorld msg=\u0026#34;Welcome to Your Vue.js App\u0026#34;/\u0026gt; \u0026lt;/div\u0026gt; 在mutations中定义函数，修改共享数据 export default new Vuex.Store({ state: { }, getters: { }, // 通过当前属性中定义的函数修改共享数据，必须都是同步操作 mutations: { setName(state, newName){ state.name = newName } }, actions: { }, modules: { } }) 在vue中调用mutations中的函数 \u0026lt;script\u0026gt; import HelloWorld from \u0026#39;./components/HelloWorld.vue\u0026#39; export default { name: \u0026#39;App\u0026#39;, components: { HelloWorld }, methods: { handleUpdate(){ // mutations中定义的函数不能直接调用，必须通过这种方式来调用 this.$store.commit(\u0026#34;setName\u0026#34;, \u0026#34;Kennem\u0026#34;) } }, } \u0026lt;/script\u0026gt; 在actions中定义函数，用于调用mutation \u0026lt;script\u0026gt; import HelloWorld from \u0026#34;./components/HelloWorld.vue\u0026#34;; export default { name: \u0026#34;App\u0026#34;, components: { HelloWorld, }, methods: { handleUpdate() { // mutations中定义的函数不能直接调用，必须通过这种方式来调用 this.$store.commit(\u0026#34;setName\u0026#34;, \u0026#34;Kennem\u0026#34;); }, handleCallAction(){ //调用actions中定义的函数，setNameByAxios为函数名称 this.$store.dispatch(\u0026#39;setNameByAxios\u0026#39;) } }, }; \u0026lt;/script\u0026gt; // 集中管理多个组件共享的数据 export default new Vuex.Store({ // 集中定义共享数据 state: { name: \u0026#39;未登录游客\u0026#39; }, getters: { }, // 通过当前属性中定义的函数修改共享数据，必须都是同步操作 mutations: { setName(state, newName) { state.name = newName } }, actions: { setNameByAxios(context) { axios({ url: \u0026#39;/api/admin/employee/login\u0026#39;, method: \u0026#39;post\u0026#39;, data: { username: \u0026#39;admin\u0026#39;, password: \u0026#39;123456\u0026#39; } }).then(res=\u0026gt;{ if(res.data.code == 1){ // 异步请求后，需要修改共享数据 // 在actions中调用mutations中定义的setName函数 context.commit(\u0026#39;setName\u0026#39;, res.data.data.name) } }) } }, modules: { } }) TypeScript function hello(msg:string){ console.log(msg) } hello(\u0026#34;123\u0026#34;) TS 为什么要增加类型支持？ TS属于静态类型编程语言，JS属于动态类型编程语言 静态类型在编译期做类型检查，动态类型在执行期做类型检查 对于JS来说，需要等到代码执行的时候才能发现错误（晚） 对于TS来说，在代码编译的时候就可以发现错误（早） 配合VSCode开发工具，TS可以体检到在编写代码的同时就发现代码错误，减少Bug，改Bug的时间。 如何理解TS？ 是JS的超集，兼容JavaScript 扩展了JavaScript的语法，文件扩展名为ts 可以编译成标准的JavaScript，并且可以在编译时进行类型检查 全局安装npm install -g typescript 使用tsc命令将ts文件编译成js文件 类型 例 备注 字符串类型 string 数字类型 number 布尔类型 boolean 数组类型 number[], string[], boolean[] 依此类推 任意类型 any 相当于又回到了没有类型的时代 复杂类型 type 与 interface 函数类型 () =\u0026gt; void 对函数的参数和返回值进行说明 字面量类型 \u0026ldquo;a\u0026rdquo; | \u0026ldquo;b\u0026rdquo; | \u0026ldquo;c\u0026rdquo; 限制变量或参数的取值 class 类 class Animal TypeScript常用类型 类型标注的位置 标注变量 标注参数 标注返回值 // 字符串类型 let username: string = \u0026#39;Kennem\u0026#39; // 数字类型 let age: number = 20 // 布尔类型 let isTrue: boolean = true 字面量类型 类似Java中的枚举，限制变量的取值 // 字面量类型 function printText(s, alignment) { console.log(s, alignment); } printText(\u0026#39;hello\u0026#39;, \u0026#39;center\u0026#39;); interface类型 interface Cat { name: string, age?: number // 当前属性为可选 } const c1: Cat = {name: \u0026#39;Kennem\u0026#39;, age:1} const c2: Cat = {name: \u0026#39;Kennem\u0026#39;} class类-基本使用 使用class关键字来定义类，类中可以包含属性、构造方法、普通方法\n//定义一个类 class User{ name: string constructor(name: string){ this.name = name } study(){ console.log(this.name + \u0026#39; is studying\u0026#39;); } } const user = new User(\u0026#39;Kennem\u0026#39;) console.log(user.name); user.study(); class类-实现接口 interface Animal { name: string eat(): void } class Bird implements Animal { name: string constructor(name: string) { this.name = name } eat() { console.log(this.name + \u0026#39; is eating\u0026#39;); } } // 创建类型为bird的对象 const b1: Bird = new Bird(\u0026#39;燕子\u0026#39;) console.log(b1.name); b1.eat() class类-类的继承 class Parrot extends Bird { fly() { console.log(this.name + \u0026#39; is flying\u0026#39;); } } const myParrot: Parrot = new Parrot(\u0026#39;鹦鹉一号\u0026#39;) myParrot.fly() myParrot.eat() ","permalink":"https://kennems.github.io/posts/tech/%E8%8B%8D%E7%A9%B9%E5%A4%96%E5%8D%96%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91day1/","summary":"苍穹外卖前端开发(Day1) node.js安装 配置全局下载包地址和缓存地址 npm config set prefix \u0026#34;E:x\\nodejs\\node_global\u0026#34; npm config set cache \u0026#34;E:\\x\\nodejs\\node_cache\u0026#34; 最新的配置淘宝镜像的淘宝官方提供的方法 npm config set registry","title":"苍穹外卖前端开发(Day1)"},{"content":"苍穹外卖后端开发(Day12) 工作台 名词解释：\n营业额：已完成订单的总金额 有效订单：已完成订单的数量 订单完成率：有效订单数 / 总订单数 * 100% 平均客单价：营业额 / 有效订单数 新增用户：新增用户的数量 Apache POI Apache POI 是一个处理Microsoft Office 各种文件格式的开源项目。\n@SpringBootTest public class POITest { public static final String filePath = \u0026#34;D:\\\\test\\\\test.xlsx\u0026#34;; /** * 通过POI向文件内写入内容 */ public static void write() throws Exception { XSSFWorkbook excel = new XSSFWorkbook(); XSSFSheet sheet = excel.createSheet(\u0026#34;info\u0026#34;); // rowNumber 从 0 开始 XSSFRow row = sheet.createRow(1); XSSFCell cell = row.createCell(0); row.createCell(1).setCellValue(\u0026#34;姓名\u0026#34;); row.createCell(2).setCellValue(\u0026#34;城市\u0026#34;); row = sheet.createRow(2); row.createCell(1).setCellValue(\u0026#34;张三\u0026#34;); row.createCell(2).setCellValue(\u0026#34;北京\u0026#34;); row = sheet.createRow(3); row.createCell(1).setCellValue(\u0026#34;李四\u0026#34;); row.createCell(2).setCellValue(\u0026#34;南京\u0026#34;); // 通过输出流将内存中的excel文件写入到硬盘中 FileOutputStream outputStream = new FileOutputStream(new File(filePath)); excel.write(outputStream); outputStream.close(); excel.close(); System.out.println(\u0026#34;写入成功！\u0026#34;); } public static void read() throws Exception{ // 读取已有的excel文件 FileInputStream inputStream = new FileInputStream(new File(filePath)); XSSFWorkbook excel = new XSSFWorkbook(inputStream); // 读取excel文件中的第一个sheet页 XSSFSheet sheet = excel.getSheetAt(0); // 获取sheet中最后一行行号 int lastRowNum = sheet.getLastRowNum(); for (int i = 1; i \u0026lt;= lastRowNum; i++) { XSSFRow row = sheet.getRow(i); // 获取单元格对象 String stringCellValue1 = row.getCell(1).getStringCellValue(); String stringCellValue2 = row.getCell(2).getStringCellValue(); System.out.println(stringCellValue1 + \u0026#34; \u0026#34; + stringCellValue2); } inputStream.close(); excel.close(); } public static void main(String[] args) throws Exception { write(); read(); } } 导出运营数据Excel报表 实现一个无返回值的接口\n/** * 导出运营数据报表 * @param response */ @GetMapping(\u0026#34;/export\u0026#34;) @ApiOperation(\u0026#34;导出运营数据报表\u0026#34;) public void export(HttpServletResponse response) throws IOException { reportService.exportBusinessData(response); } 准备好创建好格式的Excel文件：\nService实现层完成相关操作 /** * 导出运营报表 * * @param response */ public void exportBusinessData(HttpServletResponse response) { // 查询数据库，获取营业数据--查询最近30天的运营数据 LocalDate dateBegin = LocalDate.now().minusDays(30); LocalDate dateEnd = LocalDate.now().minusDays(1); // 查询概览数据 BusinessDataVO businessDataVO = workspaceService.getBusinessData(LocalDateTime.of(dateBegin, LocalTime.MIN), LocalDateTime.of(dateEnd, LocalTime.MAX)); // 通过POI将数据写入到Excel文件中 InputStream inputStream = this.getClass().getClassLoader().getResourceAsStream(\u0026#34;template/运营数据报表模板.xlsx\u0026#34;); try { XSSFWorkbook excel = new XSSFWorkbook(inputStream); XSSFSheet sheet = excel.getSheet(\u0026#34;Sheet1\u0026#34;); // 填充数据-时间 sheet.getRow(1).getCell(1).setCellValue(\u0026#34;时间：\u0026#34; + dateBegin + \u0026#34;至\u0026#34; + dateEnd); XSSFRow row = sheet.getRow(3); row.getCell(2).setCellValue(businessDataVO.getTurnover()); row.getCell(4).setCellValue(businessDataVO.getOrderCompletionRate()); row.getCell(6).setCellValue(businessDataVO.getNewUsers()); row = sheet.getRow(4); row.getCell(2).setCellValue(businessDataVO.getValidOrderCount()); row.getCell(4).setCellValue(businessDataVO.getUnitPrice()); for (int i = 0; i \u0026lt; 30; i++) { LocalDate date = dateBegin.plusDays(i); // 查询某一天的营业数据 BusinessDataVO businessData = workspaceService.getBusinessData(LocalDateTime.of(date, LocalTime.MIN), LocalDateTime.of(date, LocalTime.MAX)); // 获得某一行 row = sheet.getRow(7 + i); row.getCell(1).setCellValue(date.toString()); row.getCell(2).setCellValue(businessData.getTurnover()); row.getCell(3).setCellValue(businessData.getValidOrderCount()); row.getCell(4).setCellValue(businessData.getOrderCompletionRate()); row.getCell(5).setCellValue(businessData.getUnitPrice()); row.getCell(6).setCellValue(businessData.getNewUsers()); } ServletOutputStream outputStream = response.getOutputStream(); // 通过输出流将Excel文件下载到客户端浏览器 excel.write(outputStream); //关闭资源 outputStream.close(); excel.close(); } catch (Exception e) { e.printStackTrace(); } } ","permalink":"https://kennems.github.io/posts/tech/%E8%8B%8D%E7%A9%B9%E5%A4%96%E5%8D%96%E5%90%8E%E7%AB%AF%E5%BC%80%E5%8F%91day12/","summary":"苍穹外卖后端开发(Day12) 工作台 名词解释： 营业额：已完成订单的总金额 有效订单：已完成订单的数量 订单完成率：有效订单数 / 总订单数 * 100% 平均客","title":"苍穹外卖后端开发(Day12)"},{"content":"苍穹外卖后端开发(Day11) Apache ECharts https://echarts.apache.org/zh/index.html\n营业额统计 销量排名Top10 根据返回结果设计VO对象\nSalesTop10ReportVO\n\u0026lt;select id=\u0026#34;getSalesTop10\u0026#34; resultType=\u0026#34;com.sky.dto.GoodsSalesDTO\u0026#34;\u0026gt; SELECT name, sum(od.number) number from order_detail od, orders o where od.order_id = o.id and o.status = 5 \u0026lt;if test=\u0026#34;begin != null\u0026#34;\u0026gt; and o.order_time \u0026amp;gt; #{begin} \u0026lt;/if\u0026gt; \u0026lt;if test=\u0026#34;end != null\u0026#34;\u0026gt; and o.order_time \u0026amp;lt; #{end} \u0026lt;/if\u0026gt; GROUP BY od.name ORDER BY number DESC LIMIT 10; \u0026lt;/select\u0026gt; ","permalink":"https://kennems.github.io/posts/tech/%E8%8B%8D%E7%A9%B9%E5%A4%96%E5%8D%96%E5%90%8E%E7%AB%AF%E5%BC%80%E5%8F%91day11/","summary":"苍穹外卖后端开发(Day11) Apache ECharts https://echarts.apache.org/zh/index.html 营业额统计 销量排名Top10 根据返回结果设计VO对象 SalesTop10ReportVO \u0026lt;select id=\u0026#34;getSalesTop10\u0026#34; resultType=\u0026#34;com.sky.dto.GoodsSalesDTO\u0026#34;\u0026gt; SELECT name, sum(od.number) number from order_detail od, orders o where od.order_id = o.id and o.status = 5 \u0026lt;if test=\u0026#34;begin != null\u0026#34;\u0026gt; and","title":"苍穹外卖后端开发(Day11)"},{"content":"苍穹外卖后端开发(Day10) Spring Task Spring Task 是 Spring 框架提供的任务调度工具，可以按照约定的时间自动执行某个代码逻辑。\ncron 表达式 cron 表达式其实就是一个字符串，通过cron表达式可以定义任务触发的时间\n构成规则：分为6个或7个域，由空格分隔开，每个域代表一个含义\n每个域的含义分别为：秒、分钟、小时、日、月、周、年（可选）\nSpring Task 使用步骤：\n导入maven坐标 spring-context 启动类添加注解 @EnableScheduling 开启任务调度 自定义定时任务类 订单状态定时处理 需求分析 用户下单后可能存在的情况\n下单后未支付，订单一直处于“待支付”状态 用户收货后管理端未点击完成按钮，订单一直处于“派送中”状态 对于上面两种情况需要通过定时任务来修改订单状态，具体逻辑为：\n通过定时任务每分钟检查一次是否存在支付超时订单（下单后超过15分钟仍未支付则判定未支付超时订单），如果存在则修改订单状态为“已取消”。 通过定时任务每天凌晨1点检查一次是否存在“派送中”的订单，如果存在则修改订单状态为“已完成”。 WebSocket WebSocket是基于TCP的一种新的网络协议。它实现了浏览器与服务器全双工通信——浏览器和服务器只需要完成一次握手，两者之间就可以创建持久性的连接，并进行双向数据传输。\nHTTP协议和WebSocket协议对比：\nHTTP是短连接 WebSocket是长连接 HTTP通信是单向的，基于请求响应模式 WebSocket支持双向通信 HTTP和WebSocket底层都是TCP连接 设计：\n通过WebSocket实现管理端页面和服务端保持长连接状态 当客户支付后，调用WebSocket的相关API实现服务端向客户端推送消息 客户端浏览器解析服务端推送的消息，判断是来单提醒还是客户催单，进行相应的消息提示和语言播报 约定服务端发送给客户端浏览器的格式为JSON，字段包括：type, orderId, content type为消息类型，1为来电提醒 2为客户催单 orderId为订单id content为消息内容 用户下单提醒 用户催单提醒 ","permalink":"https://kennems.github.io/posts/tech/%E8%8B%8D%E7%A9%B9%E5%A4%96%E5%8D%96%E5%90%8E%E7%AB%AF%E5%BC%80%E5%8F%91day10/","summary":"苍穹外卖后端开发(Day10) Spring Task Spring Task 是 Spring 框架提供的任务调度工具，可以按照约定的时间自动执行某个代码逻辑。 cron 表达式 cron 表达式其实就是一个字符串","title":"苍穹外卖后端开发(Day10)"},{"content":"苍穹外卖后端开发(Day7) 缓存菜品 用户端小程序展示的菜品数据都是通过查询数据库获得，如果用户端访问量比较大，数据库访问的压力随之增大。\n实现思路 通过Redis来缓存菜品数据，减少数据库查询操作。\n缓存逻辑分析：\n每个分类下的菜品保存一份缓存数据 数据库中菜品数据有变更时清理缓存数据 /** * 根据分类id查询菜品 * * @param categoryId * @return */ @GetMapping(\u0026#34;/list\u0026#34;) @ApiOperation(\u0026#34;根据分类id查询菜品\u0026#34;) public Result\u0026lt;List\u0026lt;DishVO\u0026gt;\u0026gt; list(Long categoryId) { // 构造redis中的 key, 规则：dish_分类id String key = \u0026#34;dish_\u0026#34; + categoryId; // 查询redis中是否存在菜品数据 List\u0026lt;DishVO\u0026gt; list = (List\u0026lt;DishVO\u0026gt;) redisTemplate.opsForValue().get(key); if (list != null \u0026amp;\u0026amp; list.size()\u0026gt; 0) { // 如果存在，直接返回，无须查询数据库 return Result.success(list); } Dish dish = new Dish(); dish.setCategoryId(categoryId); dish.setStatus(StatusConstant.ENABLE);//查询起售中的菜品 // 如果不存在，查询数据库，将查询到的数据放入redis中 list = dishService.listWithFlavor(dish); redisTemplate.opsForValue().set(key, list); return Result.success(list); } Spring Cache Spring Cache 是一个框架，实现了基于注解的缓存功能，只需要简单地加一个注解，就能实现缓存功能\nSpring Cache 提供了一层抽象，底层可以切换不同的缓存实现，例如：\nEHCache \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework.boot\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-boot-starter-cache\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;2.7.3\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; Caffeine Redis 常用注解 注解 说明 @EnableCaching 开启缓存注解功能，通常加在启动类上 @Cacheable 在方法执行前先查询缓存中是否有数据，如果有数据，则直接返回缓存数据；如果没有缓存数据，调用方法并将方法返回值放到缓存中。 @CachePut 将方法的返回值放到缓存中 @CacheEvict 将一条或多条数据从缓存中删除 缓存套餐 添加购物车 /** * 添加购物车 * @param shoppingCartDTO * @return */ @PostMapping(\u0026#34;/add\u0026#34;) @ApiOperation(\u0026#34;添加购物车\u0026#34;) public Result add(@RequestBody ShoppingCartDTO shoppingCartDTO){ log.info(\u0026#34;添加购物车，商品信息为：{}\u0026#34;,shoppingCartDTO); shoppingCartService.addShoppingCart(shoppingCartDTO); return Result.success(); } 查看购物车 @GetMapping(\u0026#34;/list\u0026#34;) @ApiOperation(\u0026#34;查看购物车\u0026#34;) public Result\u0026lt;List\u0026lt;ShoppingCart\u0026gt;\u0026gt; list(){ List\u0026lt;ShoppingCart\u0026gt; list = shoppingCartService.showShoppingCart(); return Result.success(list); } 清空购物车 导入地址簿功能 用户下单 需求分析和设计\n用户下单业务说明：\n再电商系统中，用户是通过下单的方式通知商家，用户已经购买了商品，需要商家进行备货和发货。\n数据库设计 订单表 orders 订单明细表 order_detail 订单支付 内网穿透 Cpolar cpolar.exe http 80 将对应的端口号进行内网穿透\n","permalink":"https://kennems.github.io/posts/tech/%E8%8B%8D%E7%A9%B9%E5%A4%96%E5%8D%96%E5%90%8E%E7%AB%AF%E5%BC%80%E5%8F%91day7/","summary":"苍穹外卖后端开发(Day7) 缓存菜品 用户端小程序展示的菜品数据都是通过查询数据库获得，如果用户端访问量比较大，数据库访问的压力随之增大。 实现","title":"苍穹外卖后端开发(Day7)"},{"content":"苍穹外卖后端开发(Day6) HttpClient HttpClient是 Apache Jakarta Common 下的子项目，可以用来提供高效的、最新的、功能丰富的支持HTTP协议的客户端编程工具包，并且它支持HTTP协议最新的版本和建议。\n\u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.apache.httpcomponents\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;httpclient\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;4.5.13\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; 核心API：\nHttpClient HttpClients CloseableHttpClient HttpGet HttpPost 发送请求步骤：\n创建HttpClient对象 创建Http请求对象 调用HttpClient的execute方法发送请求 /** * 测试通过httpclient发送GET方式的请求 */ @Test public void testGet() throws Exception { //创建HTTP对象 CloseableHttpClient httpClient = HttpClients.createDefault(); // 创建请求对象 HttpGet httpGet = new HttpGet(\u0026#34;http://localhost:8080/user/shop/status\u0026#34;); //发送请求，接收响应结果 CloseableHttpResponse response = httpClient.execute(httpGet); // 获取服务端返回的状态码 int statusCode = response.getStatusLine().getStatusCode(); System.out.println(\u0026#34;服务端返回的状态码是:\u0026#34; + statusCode); HttpEntity entity = response.getEntity(); String body = EntityUtils.toString(entity); System.out.println(\u0026#34;服务端返回的数据为:\u0026#34; + body); //关闭资源 response.close(); httpClient.close(); } /** * 测试通过httpclient发送POST方式的请求 */ @Test public void testPOST() throws Exception { // 创建httpclient对象 CloseableHttpClient httpClient = HttpClients.createDefault(); // 创建请求对象 HttpPost httpPost = new HttpPost(\u0026#34;http://localhost:8080/admin/employee/login\u0026#34;); JSONObject jsonObject = new JSONObject(); jsonObject.put(\u0026#34;username\u0026#34;, \u0026#34;admin\u0026#34;); jsonObject.put(\u0026#34;password\u0026#34;, \u0026#34;123456\u0026#34;); StringEntity entity = new StringEntity(jsonObject.toString()); // 指定请求编码方式 entity.setContentEncoding(\u0026#34;UTF-8\u0026#34;); // 数据格式 entity.setContentType(\u0026#34;application/json\u0026#34;); httpPost.setEntity(entity); // 发送请求 CloseableHttpResponse response = httpClient.execute(httpPost); //解析返回结果 int statusCode = response.getStatusLine().getStatusCode(); System.out.println(\u0026#34;响应码为：:\u0026#34; + statusCode); HttpEntity entity1 = response.getEntity(); String body = EntityUtils.toString(entity1); System.out.println(\u0026#34;响应数据为：\u0026#34; + body); //关闭资源 response.close(); httpClient.close(); } 微信小程序 小程序包含一个描述整体程序的app和多个描述各自页面的page。一个小程序主体部分由三个文件组成，必须放在项目的根目录，如下：\n文件 必需 作用 app.js 是 小程序逻辑 app.json 是 小程序公共配置 app.wxss 否 小程序公共样式表 需求分析和设计 业务规则：\n基于微信登录实现小程序的登录功能 如果是新用户需要自动完成注册 添加UserController 添加拦截器 /** * jwt令牌校验的拦截器 */ @Component @Slf4j public class JwtTokenUserInterceptor implements HandlerInterceptor { @Autowired private JwtProperties jwtProperties; /** * 校验jwt * * @param request * @param response * @param handler * @return * @throws Exception */ public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception { System.out.println(\u0026#34;当前线程的id:\u0026#34; + Thread.currentThread().getId()); //判断当前拦截到的是Controller的方法还是其他资源 if (!(handler instanceof HandlerMethod)) { //当前拦截到的不是动态方法，直接放行 return true; } //1、从请求头中获取令牌 String token = request.getHeader(jwtProperties.getUserTokenName()); //2、校验令牌 try { log.info(\u0026#34;jwt校验:{}\u0026#34;, token); Claims claims = JwtUtil.parseJWT(jwtProperties.getUserSecretKey(), token); Long userId = Long.valueOf(claims.get(JwtClaimsConstant.USER_ID).toString()); log.info(\u0026#34;当前用户id：{}\u0026#34;, userId); BaseContext.setCurrentId(userId); //3、通过，放行 return true; } catch (Exception ex) { //4、不通过，响应401状态码 response.setStatus(401); return false; } } } ","permalink":"https://kennems.github.io/posts/tech/%E8%8B%8D%E7%A9%B9%E5%A4%96%E5%8D%96%E5%90%8E%E7%AB%AF%E5%BC%80%E5%8F%91day6/","summary":"苍穹外卖后端开发(Day6) HttpClient HttpClient是 Apache Jakarta Common 下的子项目，可以用来提供高效的、最新的、功能丰富的支持HTTP协议的客户端编程工具","title":"苍穹外卖后端开发(Day6)"},{"content":"苍穹外卖后端开发(Day5) Redis Redis 是一个基于内存的key-value结构数据库的\n基于内存存储，读写性能高 适合存储热点数据（热点商品，资讯，新闻） 企业应用广泛 Redis安装和使用 安装Redis\n启动Redis\nredis-server.exe redis.windows.conf 之后在另一个窗口中连接Redis\nredis-cli.exe -h localhost -p 6379 -a 123456 其中-a后面是密码， 默认没有密码，\n五种常用数据类型介绍 Redis存储的是key-value结构的数据，其中key是字符串类型，value有5种常用的数据类型：\n字符串 string 哈希 hash 列表 list 集合 set 有序集合 sorted set / zset 字符串（string）：普通字符串，Redis种最简单的数据类型 哈希（hash）：也叫散列，类似于Java种HashMap结构 列表（list）：按照插入顺序排序，可以有重复元素，类似于Java种的LinkedList 集合（set）：无序集合，没有重复元素，类似于Java种的HashSet 有序集合（sorted set / zset）：集合种每个元素关联一个分数（score），根据分数升序排列，没有重复元素 Redis命令 字符串操作命令 SET key value 设置指定key的值 GET key 获取指定key的值 SETEX key seconds value 设置指定 key 的值， 并将 key 的过期时间设为seconds 秒 SETNX key value 只有在key不存在时设置key的值 哈希操作命令 Redis hash 是一个 string 类型的 field 和 value 的映射表，hash特别适合用于存储对象，常用命令：\nHSET key field value 将哈希表 key 种的字段field的值设为 value HGET key field 获取存储在哈希表中指定字段的值 HDEL key field 删除存储在哈希表种的指定字段 HKEYS key 获取哈希表种所有字段 HVALS key 获取哈希表种所有值 列表操作命令 Redis列表是最简单的字符串列表，按照插入顺序排序，常用命令：\nLPUSH key value1 [value2] 将一个或多个值插入到列表头部 LRANGE key start stop 获取列表指定范围内的元素 RPOP key 移除并获取列表最后一个元素 LLEN key 获取列表长度 集合操作命令 Redis set 是 string 类型的无序集合。集合成员是唯一的，集合中不能出现重复的数据，常用命令：\nSADD key member1 [member2] 向集合添加一个或多个成员 SMEMBERS key 返回集合中的所有成员 SCARD key 获取集合的成员数 SINTER key1 [key2] 返回给定所有集合的交集 SUNION key1 [key2] 返回所有给定集合的并集 SREM key member1 [member2] 删除集合种一个或多个成员 有序集合操作命令 Redis有序集合是string类型元素的集合， 且不允许有重复成员。每个元素都会关联一个double类型的分数。常用命令：\nZADD key score1 member1 [score2 member2] 向有序集合添加一个或多个成员 ZRANGE key start stop [WITHSCORES] 通过索引区间返回有序集合种指定区间内的成员 ZINCRBY key increment member 有序集合中对指定成员的分数加上增量 increment ZREM key member [member … ] 移除有序集合中的一个或多个成员 通用命令 Redis 的通用命令是不分数据类型的，都可以使用的命令：\nKEYS pattern 查找所有符合给定模式（pattern）的key EXISTS key 检查给定key是否存在 TYPE key 返回key所存储的值的类型 DEL key 用于在key存在时删除key Redis的Java客户端 Jedis Lettuce Spring Data Redis Spring Data Redis 是 Spring 的一部分， 对 Redis 底层开发包进行了高度封装。\n在Spring项目中，可以使用Spring Data Redis来简化操作。\nSpring Data Redis 使用方式 操作步骤：\n导入Spring Data Redis 的 maven 坐标 配置Redis数据源 编写配置类，创建RedisTemplate对象 通过RedisTemplate对象操作Redis pom.xml \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework.boot\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-boot-starter-data-redis\u0026lt;/artifactId\u0026gt; \u0026lt;/dependency\u0026gt; application.yml spring: redis: host: localhost port: 6379 password: 123456 配置类 @Configuration @Slf4j public class RedisConfiguration { @Bean public RedisTemplate redisTemplate(RedisConnectionFactory redisConnectionFactory) { Log.info(\u0026#34;开始创建redis模板类...\u0026#34;); RedisTemplate redisTemplate = new RedisTemplate(); // 设置Key的序列化器，默认为JdkSerializationRedisSerializer redisTemplate.setKeySerializer(new StringRedisSerializer()); redisTemplate.setConnectionFactory(redisConnectionFactory); return redisTemplate; } } Java程序中进行字符串操作 ","permalink":"https://kennems.github.io/posts/tech/%E8%8B%8D%E7%A9%B9%E5%A4%96%E5%8D%96%E5%90%8E%E7%AB%AF%E5%BC%80%E5%8F%91day5/","summary":"苍穹外卖后端开发(Day5) Redis Redis 是一个基于内存的key-value结构数据库的 基于内存存储，读写性能高 适合存储热点数据（热点商品，资讯，新闻","title":"苍穹外卖后端开发(Day5)"},{"content":"苍穹外卖后端开发(Day3) 菜品管理 公共字段自动填充 对于创建时间、创建人id，修改时间，修改人id等字段 重复性代码进行统一编写\n自定义注解AutoFill，用于标识需要进行公共字段自动填充的方法 package com.sky.annotation; /** * 自定义注解，用于标识某个方法需要进行功能字段自动填充处理。 * 这个注解可以应用于方法上，用于指示在特定的数据库操作时 * 需要自动填充某些功能字段。 */ @Target(ElementType.METHOD) // 指定注解可以用于方法 @Retention(RetentionPolicy.RUNTIME) // 指定注解在运行时可用 public @interface AutoFill { /** * 数据库操作类型：用于指示自动填充的操作类型。 * 可选值包括 UPDATE 和 INSERT。 * * @return 操作类型 */ OperationType value(); } 自定义切面类AutoFillAspect， 统一拦截加入了AutoFill注解的方法，通过反射为公共字段赋值。 package com.sky.aspect; /** * 自定义切面， 实现公共字段自动填充 */ @Aspect @Component @Slf4j public class AutoFillAspect { /** * 定义切入点，匹配com.sky.mapper包下的所有方法，并且方法上需有@AutoFill注解 */ @Pointcut(\u0026#34;execution(* com.sky.mapper.*.*(..)) \u0026amp;\u0026amp; @annotation(com.sky.annotation.AutoFill)\u0026#34;) public void autoFillPointCut() { } /** * 前置通知，在目标方法执行前进行公共字段赋值 * * @param joinPoint 连接点，表示被拦截的方法调用 */ @Before(\u0026#34;autoFillPointCut()\u0026#34;) public void autoFill(JoinPoint joinPoint) { log.info(\u0026#34;开始进行公共字段自动填充...\u0026#34;); // 获取当前被拦截方法的签名（方法信息） MethodSignature signature = (MethodSignature) joinPoint.getSignature(); // 从方法签名中获取@AutoFill注解 AutoFill autoFill = signature.getMethod().getAnnotation(AutoFill.class); // 获取操作类型（INSERT或UPDATE） OperationType operationType = autoFill.value(); // 获取目标方法的参数（假设第一个参数是实体对象） Object[] args = joinPoint.getArgs(); if (args == null || args.length == 0) { return; // 如果没有参数则直接返回 } // 获取实体对象（目标方法的第一个参数） Object entity = args[0]; // 获取当前时间和当前操作用户ID LocalDateTime now = LocalDateTime.now(); Long currentId = BaseContext.getCurrentId(); // 根据操作类型判断是INSERT还是UPDATE操作 if (operationType == OperationType.INSERT) { try { // 通过反射调用实体对象的set方法，赋值创建和更新时间、创建和更新用户 Method setCreateTime = entity.getClass().getDeclaredMethod(AutoFillConstant.SET_CREATE_TIME, LocalDateTime.class); Method setCreateUser = entity.getClass().getDeclaredMethod(AutoFillConstant.SET_CREATE_USER, Long.class); Method setUpdateTime = entity.getClass().getDeclaredMethod(AutoFillConstant.SET_UPDATE_TIME, LocalDateTime.class); Method setUpdateUser = entity.getClass().getDeclaredMethod(AutoFillConstant.SET_UPDATE_USER, Long.class); // 调用方法进行赋值 setCreateTime.invoke(entity, now); setCreateUser.invoke(entity, currentId); setUpdateTime.invoke(entity, now); setUpdateUser.invoke(entity, currentId); } catch (Exception e) { e.printStackTrace(); // 捕获异常并打印 } } else if (operationType == OperationType.UPDATE) { try { // 通过反射调用实体对象的set方法，赋值更新时间和更新用户 Method setUpdateTime = entity.getClass().getDeclaredMethod(AutoFillConstant.SET_UPDATE_TIME, LocalDateTime.class); Method setUpdateUser = entity.getClass().getDeclaredMethod(AutoFillConstant.SET_UPDATE_USER, Long.class); // 调用方法进行赋值 setUpdateTime.invoke(entity, now); setUpdateUser.invoke(entity, currentId); } catch (Exception e) { e.printStackTrace(); // 捕获异常并打印 } } } } 在Mapper的方法上加入AutoFill注解 @AutoFill(value = OperationType.INSERT) @AutoFill(value = OperationType.UPDATE) 新增菜品 产品原型 业务规则： 菜品名称必须是唯一的 菜品必须属于某个分类下，不能单独存在 新增菜品时可以根据情况选择菜品的口味 每个菜品必须对应一张图片 接口设计： 根据类型查询分配 文件上传 新增菜品 数据库设计（dish菜品表和dish_flavor口味表）： 配置OSS图像存储服务\n可以通过下面的Properties文件配置OSS的属性。\npackage com.sky.properties; @Component @ConfigurationProperties(prefix = \u0026#34;sky.alioss\u0026#34;) @Data public class AliOssProperties { private String endpoint; private String accessKeyId; private String accessKeySecret; private String bucketName; } 在application-dev中详细配置id, key等。\n通用接口 package com.sky.controller.admin; /** * 通用接口 */ @RestController @RequestMapping(\u0026#34;/admin/common\u0026#34;) @Api(tags = \u0026#34;通用接口\u0026#34;) @Slf4j public class CommonController { @Autowired private AliOssUtil aliOssUtil; /** * 文件上传 * @param file * @return */ @PostMapping(\u0026#34;/upload\u0026#34;) public Result\u0026lt;String\u0026gt; upload(MultipartFile file){ log.info(\u0026#34;文件上传：{}\u0026#34;,file); try { // 原始文件名 String originalFilename = file.getOriginalFilename(); // 截取原始文件名的后缀 String extension = originalFilename.substring(originalFilename.lastIndexOf(\u0026#39;.\u0026#39;)); // 构造新文件名称 String objectName = UUID.randomUUID().toString() + extension; // 文件的请求路径 String filePath = aliOssUtil.upload(file.getBytes(), objectName); return Result.success(filePath); } catch (IOException e) { log.error(\u0026#34;文件上传失败：{}\u0026#34;, e); } return Result.error(MessageConstant.UPLOAD_FAILED); } } 菜品接口 package com.sky.controller.admin; @RestController @RequestMapping(\u0026#34;/admin/dish\u0026#34;) @Api(tags = \u0026#34;菜品相关接口\u0026#34;) @Slf4j public class DishController { @Autowired private DishService dishService; @PostMapping @ApiOperation(\u0026#34;新增菜品\u0026#34;) public Result save(@RequestBody DishDTO dishDTO){ log.info(\u0026#34;新增菜品：{}\u0026#34;, dishDTO); dishService.saveWithFlavor(dishDTO); return Result.success(); } } 在DishServiceImpl中实现saveWithFlavor\npackage com.sky.service.impl; @Service public class DishServiceImpl implements DishService { @Autowired private DishMapper dishMapper; @Autowired private DishFlavorMapper dishFlavorMapper; /** * 新增菜品和对应的口味 * @param dishDTO */ @Transactional public void saveWithFlavor(DishDTO dishDTO) { Dish dish = new Dish(); BeanUtils.copyProperties(dishDTO, dish); // 向菜品表插入1条数据 dishMapper.insert(dish); Long dishId = dish.getId(); List\u0026lt;DishFlavor\u0026gt; flavors = dishDTO.getFlavors(); if (flavors != null \u0026amp;\u0026amp; flavors.size() \u0026gt; 0) { flavors.forEach(dishFlavor -\u0026gt; dishFlavor.setDishId(dishId)); // 向口味表插入n条数据 dishFlavorMapper.insertBatch(flavors); } } } 在Mapper中实现SQL DishMapper \u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;UTF-8\u0026#34; ?\u0026gt; \u0026lt;!DOCTYPE mapper PUBLIC \u0026#34;-//mybatis.org//DTD Mapper 3.0//EN\u0026#34; \u0026#34;http://mybatis.org/dtd/mybatis-3-mapper.dtd\u0026#34; \u0026gt; \u0026lt;mapper namespace=\u0026#34;com.sky.mapper.DishMapper\u0026#34;\u0026gt; \u0026lt;insert id=\u0026#34;insert\u0026#34; useGeneratedKeys=\u0026#34;true\u0026#34; keyProperty=\u0026#34;id\u0026#34;\u0026gt; insert into dish (name, category_id, price, image, description, create_time, update_time, create_user, update_user) values (#{name}, #{categoryId}, #{price}, #{image}, #{description}, #{createTime}, #{updateTime}, #{createUser}, #{updateUser}) \u0026lt;/insert\u0026gt; \u0026lt;/mapper\u0026gt; useGeneratedKeys=\u0026quot;true\u0026quot;: 表示在插入操作后，使用数据库生成的主键值。这个选项通常与主键自增（如 MySQL 的 AUTO_INCREMENT）一起使用。\nkeyProperty=\u0026quot;id\u0026quot;: 指定存储生成主键值的对象属性。在插入成功后，数据库生成的主键值会被设置到这个属性上。\nDishFlavorMapper \u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;UTF-8\u0026#34; ?\u0026gt; \u0026lt;!DOCTYPE mapper PUBLIC \u0026#34;-//mybatis.org//DTD Mapper 3.0//EN\u0026#34; \u0026#34;http://mybatis.org/dtd/mybatis-3-mapper.dtd\u0026#34; \u0026gt; \u0026lt;mapper namespace=\u0026#34;com.sky.mapper.DishFlavorMapper\u0026#34;\u0026gt; \u0026lt;insert id=\u0026#34;insertBatch\u0026#34;\u0026gt; insert into dish_flavor(dish_id, name, value) VALUES \u0026lt;foreach collection=\u0026#34;flavors\u0026#34; item=\u0026#34;df\u0026#34; separator=\u0026#34;,\u0026#34;\u0026gt; (#{df.dishId}, #{df.name}, #{df.value}) \u0026lt;/foreach\u0026gt; \u0026lt;/insert\u0026gt; \u0026lt;/mapper\u0026gt; 菜品分页查询 需求分析和设计 DishController /** * 菜品分页查询 * @param dishPageQueryDTO * @return */ @GetMapping(\u0026#34;/page\u0026#34;) @ApiOperation(\u0026#34;菜品分页查询\u0026#34;) public Result\u0026lt;PageResult\u0026gt; page(DishPageQueryDTO dishPageQueryDTO){ log.info(\u0026#34;菜品分页查询{}\u0026#34;, dishPageQueryDTO); PageResult pageResult = dishService.pageQuery(dishPageQueryDTO); return Result.success(pageResult); } 实现pageQuery @Override public PageResult pageQuery(DishPageQueryDTO dishPageQueryDTO) { PageHelper.startPage(dishPageQueryDTO.getPage(), dishPageQueryDTO.getPageSize()); Page\u0026lt;DishVO\u0026gt; page = dishMapper.pageQuery(dishPageQueryDTO); return new PageResult(page.getTotal(), page.getResult()); } Mapper \u0026lt;select id=\u0026#34;pageQuery\u0026#34; resultType=\u0026#34;com.sky.vo.DishVO\u0026#34;\u0026gt; select d.*, c.name as categoryName from dish d left join category c on d.category_id = c.id \u0026lt;where\u0026gt; \u0026lt;if test=\u0026#34;name != null\u0026#34;\u0026gt; and d.name like concat(\u0026#39;%\u0026#39;, #{name},\u0026#39;%\u0026#39;) \u0026lt;/if\u0026gt; \u0026lt;if test=\u0026#34;categoryId != null\u0026#34;\u0026gt; and d.category_id = #{categoryId} \u0026lt;/if\u0026gt; \u0026lt;if test=\u0026#34;status != null\u0026#34;\u0026gt; and d.status = #{status} \u0026lt;/if\u0026gt; \u0026lt;/where\u0026gt; order by d.create_time desc \u0026lt;/select\u0026gt; 菜品删除 业务规则：\n可以一次删除一个菜品，也可以批量删除多个菜品 启售的菜品不能删除 被套餐关联的菜品不能删除 删除菜品后，关联的口味数据也需要删除掉 @DeleteMapping @ApiOperation(\u0026#34;菜品批量删除\u0026#34;) public Result delete(@RequestParam List\u0026lt;Long\u0026gt; ids){ log.info(\u0026#34;菜品批量删除:{}\u0026#34;,ids); dishService.deleteBatch(ids); return Result.success(); } ","permalink":"https://kennems.github.io/posts/tech/%E8%8B%8D%E7%A9%B9%E5%A4%96%E5%8D%96%E5%90%8E%E7%AB%AF%E5%BC%80%E5%8F%91day3/","summary":"苍穹外卖后端开发(Day3) 菜品管理 公共字段自动填充 对于创建时间、创建人id，修改时间，修改人id等字段 重复性代码进行统一编写 自定义注解Au","title":"苍穹外卖后端开发(Day3)"},{"content":"苍穹外卖后端开发(Day2) 新增员工 管理端发出的请求， 统一使用/admin作为前缀 用户端发出的请求，统一使用/user作为前缀 代码开发 根据新增员工接口设计对应的DTO\n注意 ： 当前端提交的数据和实体类中对应的属性差别比较大时，建议使用DTO来封装数据\n功能测试 功能测试方式：\n通过接口文档测试 通过前后端联调测试 注意：由于开发阶段前端和后端时并行开发的，后端完成某个功能后，此时前端对应的功能可能还没有开发完成，导致无法进行前后端联调测试。所以在开发阶段，后端测试主要以接口文档测试为主。\n代码完善 录入的用户名已存在，抛出异常后没有处理 新增员工时，创建人id和修改人id设置为了固定值 ThreadLocal 并不是一个Thread，而是Thread的局部变量。\nThreadLocal为每个线程提供单独一份存储空间，具有线程隔离的效果， 只有在线程内才能获取到对应的值，线程外则不能访问。\nThreadLocal常用方法：\npublic void set(T value) //设置当前线程的线程局部变量的值 public T get() //返回当前线程所对应的线程局部变量的值 public void remove() //移除当前线程的线程局部变量 员工分页查询 需求分析和设计 业务规则 ：\n根据页码展示员工信息 每页展示10条数据 分页查询时可以根据需要，输入员工姓名进行查询 代码开发 /** * 员工分页查询 * @param employeePageQueryDTO * @return */ @GetMapping(\u0026#34;/page\u0026#34;) @ApiOperation(\u0026#34;员工分页查询\u0026#34;) public Result\u0026lt;PageResult\u0026gt; page(EmployeePageQueryDTO employeePageQueryDTO){ log.info(\u0026#34;员工分页查询， 参数为：{}\u0026#34;, employeePageQueryDTO); PageResult pageResult = employeeService.pageQuery(employeePageQueryDTO); return Result.success(pageResult); } 根据分页查询接口设计对应的DTO：\n解决方式：\n方式一：在属性上加入注解，对日期进行格式化 //更新时间 @JsonFormat(pattern = \u0026#34;yyyy-MM-dd HH:mm:ss\u0026#34;) private LocalDateTime updateTime; 方式二：在WebMvcConfiguration中扩展Spring MVC的消息转换器，统一对日期类型进行格式化处理 /** * 扩展mvc框架的消息转换器 * @param converters */ protected void extendMessageConverters(List\u0026lt;HttpMessageConverter\u0026lt;?\u0026gt;\u0026gt; converters) { Log.info(\u0026#34;开始扩展消息转换器...\u0026#34;); // 创建一个消息转换器对象 MappingJackson2HttpMessageConverter converter = new MappingJackson2HttpMessageConverter(); // 设置对象转换器，可以将Java对象转为json字符串 converter.setObjectMapper(new JacksonObjectMapper()); // 将我们自己的转换器放入Spring MVC框架的容器中 converters.add(0, converter); } 启用禁用员工账号 业务规则：\n可以对状态为”启用“的员工账号进行“禁用”操作 可以对状态为“禁用”的员工账号进行“启用”操作 状态为“禁用”的员工账号不能登录系统 代码开发 /** * 启用禁用员工账号 * @param status * @param id * @return */ @PostMapping(\u0026#34;status/{status}\u0026#34;) @ApiOperation(\u0026#34;启用禁用员工账号\u0026#34;) public Result startOrStop(@PathVariable(\u0026#34;status\u0026#34;) Integer status, Long id){ log.info(\u0026#34;启用禁用员工账号：{}, {}\u0026#34;, status, id); employeeService.startOrStop(status, id); return Result.success(); } 编辑员工 涉及到两个接口：\n根据id查询员工信息 编辑员工信息 代码开发 @GetMapping(\u0026#34;/{id}\u0026#34;) @ApiOperation(\u0026#34;根据id查询员工信息\u0026#34;) public Result\u0026lt;Employee\u0026gt; getById(@PathVariable Long id) { Employee employee = employeeService.getById(id); return Result.success(employee); } @PutMapping @ApiOperation(\u0026#34;编辑修改员工信息\u0026#34;) public Result update(@RequestBody EmployeeDTO employeeDTO) { log.info(\u0026#34;编辑员工信息{}\u0026#34;, employeeDTO); employeeService.update(employeeDTO); return Result.success(); } 导入分类模块功能代码 业务规则：\n分类名称必须是唯一的 分类按照类型可以分为菜品分类和套餐分类 新添加的分类状态默认为“禁用” ","permalink":"https://kennems.github.io/posts/tech/%E8%8B%8D%E7%A9%B9%E5%A4%96%E5%8D%96%E5%90%8E%E7%AB%AF%E5%BC%80%E5%8F%91day2/","summary":"苍穹外卖后端开发(Day2) 新增员工 管理端发出的请求， 统一使用/admin作为前缀 用户端发出的请求，统一使用/user作为前缀 代码开发 根据新","title":"苍穹外卖后端开发(Day2)"},{"content":"Docker 快速构建、运行、管理应用的工具\nDocker打印所有容器（包括关闭的）\ndocker ps -a 正在运行的\ndocker ps 删除容器\ndocker rm \u0026lt;container_id\u0026gt; 启动已有的容器\ndocker start \u0026lt;容器ID或名称\u0026gt; 启动容器并进入其交互式终端\ndocker start -i \u0026lt;容器ID或名称\u0026gt; 启动后直接进入容器的 bash 终端\ndocker exec -it \u0026lt;容器ID或名称\u0026gt; /bin/bash 停止容器\ndocker stop \u0026lt;container_id\u0026gt; docker run -d \\ --name mysql \\ -p 3306:3306 \\ -e TZ=Asia/Shanghai \\ -e MYSQL_ROOT_PASSWORD=123 \\ mysql Docker基础知识 Docker 数据卷 作用：宿主机目录和docker容器内目录做一个关联\nMySql容器的数据挂载 docker run -d \\ --name mysql \\ -p 3307:3306 \\ -e TZ=Asia/Shanghai \\ -e MYSQL_ROOT_PASSWORD=123 \\ -v /root/mysql/data:/var/lib/mysql \\ -v /root/mysql/init:/docker-entrypoint-initdb.d \\ -v /root/mysql/conf:/etc/mysql/conf.d \\ mysql 自定义镜像 DokerFile DockerFile就是一个文本文件， 其中包括一个个的指令（Instruction），用指令来说明要执行什么操作来构建镜像。将来Docker可以根据DockerFile帮我们构建镜像。\n网络 加入自定义网络的容器才可以通过容器互相访问， Docker的网络操作命令如下：\n命令 说明 docker network ls 列出所有 Docker 网络 docker network inspect \u0026lt;network\u0026gt; 显示指定网络的详细信息 docker network create \u0026lt;network\u0026gt; 创建一个新的 Docker 网络 docker network rm \u0026lt;network\u0026gt; 删除指定的 Docker 网络 docker network connect \u0026lt;network\u0026gt; \u0026lt;container\u0026gt; 将容器连接到指定的网络 docker network disconnect \u0026lt;network\u0026gt; \u0026lt;container\u0026gt; 将容器从指定的网络断开 docker network prune 删除所有未使用的 Docker 网络 docker run --network \u0026lt;network\u0026gt; \u0026lt;image\u0026gt; 运行容器并指定使用的网络 docker network create --driver \u0026lt;driver\u0026gt; \u0026lt;network\u0026gt; 使用指定的驱动程序创建网络（bridge, overlay, host等） docker network inspect --format \u0026lt;template\u0026gt; \u0026lt;network\u0026gt; 以自定义格式显示网络的详细信息 docker network connect --ip \u0026lt;ip\u0026gt; \u0026lt;network\u0026gt; \u0026lt;container\u0026gt; 将容器连接到指定网络并分配静态 IP docker network create --subnet \u0026lt;subnet\u0026gt; \u0026lt;network\u0026gt; 指定子网和 IP 范围创建网络（例：\u0026ndash;subnet=192.168.1.0/24） docker network create --gateway \u0026lt;gateway\u0026gt; \u0026lt;network\u0026gt; 创建网络时指定网关 IP docker network disconnect -f \u0026lt;network\u0026gt; \u0026lt;container\u0026gt; 强制将容器从指定的网络断开 docker network connect --alias \u0026lt;alias\u0026gt; \u0026lt;network\u0026gt; \u0026lt;container\u0026gt; 将网络中的容器添加别名（便于服务发现） 部署流程 部署Java应用\n部署nginx\ndocker run -d \\ --name nginx \\ -p 18080:18080 \\ -p 18081:18081 \\ -v /root/nginx/html:/usr/share/nginx/html \\ -v /root/nginx/nginx.conf:/etc/nginx/nginx.conf \\ --network kennem \\ nginx DockerCompose DockerCompose通过一个单独的docker-compose.yml模板文件（YAML格式）来定义一组相关联的应用容器， 帮助我们实现多个相互关联的Docker容器的快速部署。\nversion: \u0026#34;3.8\u0026#34; services: mysql: image: mysql container_name: mysql ports: - \u0026#34;3306:3306\u0026#34; environment: TZ: Asia/Shanghai MYSQL_ROOT_PASSWORD: 123 volumes: - \u0026#34;./mysql/conf:/etc/mysql/conf.d\u0026#34; - \u0026#34;./mysql/data:/var/lib/mysql\u0026#34; - \u0026#34;./mysql/init:/docker-entrypoint-initdb.d\u0026#34; networks: - hm-net hmall: build: context: . dockerfile: Dockerfile container_name: hmall ports: - \u0026#34;8080:8080\u0026#34; networks: - hm-net depends_on: - mysql nginx: image: nginx container_name: nginx ports: - \u0026#34;18080:18080\u0026#34; - \u0026#34;18081:18081\u0026#34; volumes: - \u0026#34;./nginx/nginx.conf:/etc/nginx/nginx.conf\u0026#34; - \u0026#34;./nginx/html:/usr/share/nginx/html\u0026#34; depends_on: - hmall networks: - hm-net networks: hm-net: name: hmall ","permalink":"https://kennems.github.io/posts/tech/docker/","summary":"Docker 快速构建、运行、管理应用的工具 Docker打印所有容器（包括关闭的） docker ps -a 正在运行的 docker ps 删除容器 docker rm \u0026lt;container_id\u0026gt; 启动已有的容器 docker start \u0026lt;容器ID或","title":"Docker"},{"content":"苍穹外卖后端开发(Day1) 软件开发流程 需求分析 ： 需求规格说明说、产品原型\n设计 ： UI设计、 数据库设计、接口设计\n编码 ： 项目代码、单元测试\n测试 ： 测试用例、测试报告\n上线运维 ： 软件环境安装、配置\n角色分工 项目经理：对整个项目负责，任务分配，把控进度。 产品经理：进行需求调研，输出需求调研文档、产品原型等 UI设计师：根据产品原型输出界面效果图 架构师：项目整体架构设计、技术选型等 开发工程师：代码实现 测试工程师：编写测试用例，输出测试报告 运维工程师：软件环境搭建，项目上线 软件环境 开发环境（development）：开发人员在开发阶段使用的环境，一般外部用户无法访问 测试环境（testing）：专门给测试人员使用的环境，用于测试项目，一般外部用户无法访问 生产环境（production）：即线上环境，正式提供对外服务的环境。 苍穹外卖项目介绍 项目介绍 定位 ： 专门为餐饮企业（餐厅、饭店）定制的一款软件产品\n产品原型 产品原型 ：用于展示项目的业务功能，一般由产品经理进行设计\n技术选型 技术选型 ： 展示项目中使用到的技术框架和中间件等。\n整体结构 前端环境搭建 Nginx服务器 后端环境搭建 后端工程基于maven进行项目构建，并且进行分模块开发\nsky-take-out : maven 父工程， 统一管理依赖版本， 聚合其他子模块 sky-common : 子模块， 存放公共类，例如 ： 工具类、常量类、异常类等 sky-pojo : 子模块 ，存放实体类，VO， DTO等 名称 说明 Entity 实体，通用和数据库中的对应 DTO 数据传输对象，通用用程序中各层之间传递数据 VO 视图对象，为前端展示数据提供的对象 POJO 普通Java对象，只有属性和对应的getter和setter sky-server : 子模块，后端服务，存放配置文件, 配置类，拦截器，Controller， Service， Mapper等 数据库环境搭建 MySQL + Navicat\n后端环境搭建 - 前后端联调 后端的初始工程中已经实现了登录功能， 直接进行前后端联调测试即可。\n前后端请求地址不对应，但是前后端联调成功\nnginx反向代理， 就是讲前端发送的动态请求由nginx转发到后端服务器\nnginx反向代理的好处：\n提高访问速度 进行负载均衡 保证后端服务安全 nginx负载均衡策略：\n名称 说明 轮询 默认为方式 weight 权重方式，默认为，权重越高，被分配的客户终端资源就越多 ip_hash 依赖于IP地址分配，这样每个访客可以固定访问同一个后端服务 least_conn 依赖于连接数，把请求优先分配到连接数最少的后端服务 url_hash 依赖于请求的URL，这样请求对应的服务名称会被优先分配 fair 依赖于响应时间，响应时间越短的服务将被优先分配 完善登录功能 将密码加密后存储，提高安全性\n将后续需要完善的代码用 TODO 标识出来\npassword = DigestUtils.md5DigestAsHex(password.getBytes()); 导入接口文档 使用apifox导入json文件\nSwagger 测试工具\n使用Swagger只需要按照它的规范去定义接口以及接口相关的信息，就可以做到生成接口文档，以及在线接口调试页面\nKnife4j 是为 Java MVC 框架集成Swagger生成 Api 文档的增强解决方案。\n1、导入knife4j坐标\n\u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;com.github.xiaoymin\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;knife4j-spring-boot-starter\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;3.0.2\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; 2、在配置类中加入knife4j相关配置\n@Bean public Docket docket() { ApiInfo apiInfo = new ApiInfoBuilder() .title(\u0026#34;苍穹外卖项目接口文档\u0026#34;) .version(\u0026#34;2.0\u0026#34;) .description(\u0026#34;苍穹外卖项目接口文档\u0026#34;) .build(); Docket docket = new Docket(DocumentationType.SWAGGER_2) .apiInfo(apiInfo) .select() // 指定生成接口需要扫描的包 .apis(RequestHandlerSelectors.basePackage(\u0026#34;com.sky.controller\u0026#34;)) .paths(PathSelectors.any()) .build(); return docket; } 3、设置静态资源映射，否则接口文档页面无法访问\n/** * 设置静态资源映射 * @param registry */ protected void addResourceHandlers(ResourceHandlerRegistry registry) { log.info(\u0026#34;开始设置静态资源映射...\u0026#34;); registry.addResourceHandler(\u0026#34;/doc.html\u0026#34;).addResourceLocations(\u0026#34;classpath:/META-INF/resources/\u0026#34;); registry.addResourceHandler(\u0026#34;/webjars/**\u0026#34;).addResourceLocations(\u0026#34;classpath:/META-INF/resources/webjars/\u0026#34;); } YAPI(ApiFox)用于设计接口时使用， 而Swagger用于后端开发好之后测试使用。\n常用注解 注解 说明 @Api 用在类上，例如Controller，表示对类的说明 @ApiModel 用在类上，例如entity、DTO、VO @ApiModelProperty 用在属性上，描述属性信息 @ApiOperation 用在方法上，例如Controller的方法，说明方法的用途、作用 ","permalink":"https://kennems.github.io/posts/tech/%E8%8B%8D%E7%A9%B9%E5%A4%96%E5%8D%96%E5%90%8E%E7%AB%AF%E5%BC%80%E5%8F%91day1/","summary":"苍穹外卖后端开发(Day1) 软件开发流程 需求分析 ： 需求规格说明说、产品原型 设计 ： UI设计、 数据库设计、接口设计 编码 ： 项目代码、单元测试 测试 ：","title":"苍穹外卖后端开发(Day1)"},{"content":"Prompt 要求：字数尽可能多，内容需要全面，可以不按照我的标题来写，可以适当添加一些内容，但是内容一定一定要多，要专业 请根据以上内容以及你的数据库内容，撰写 ： 数据处理与分析 海浪波谱仪采集的数据需要经过复杂的处理与分析，才能生成有用的波谱图。数据处理过程包括去噪、滤波、频谱分析等步骤。常用的频谱分析方法包括快速傅里叶变换（FFT）和小波变换等。通过对海浪频谱的分析，可以提取出海浪的主导频率、波高分布、能量谱等重要信息。\r详细 我现在需要写实验报告，请缩写上部分内容，但是不要损失其表达的意思 文章生成 “我想写一篇科普文章，标题是：‘[在此处插入你的标题]’。你能帮我分析一下这个标题吗？它是否有吸引力，有没有可以改进的地方来增强其吸引力？”\r文章生成：\r“在优化标题后，帮我生成一篇文章。文章的目标是向读者科普关于[插入主题]的知识。请确保内容易于普通读者理解，同时保持科学的准确性和趣味性。文章应包括以下部分：引言、定义、示例、现实应用以及结论。语气要保持信息性，但尽量亲切、易懂。” 朗读内容 先重复下面的内容，然后加一个简短的总结 Leetcode题目总结 下面我给出一个题目，代码实现，和对题目的总结和实现思路， 你需要的是学习我是如何总结的，如果你看懂了则回复我你懂了, 不用回复别的\r\u0026#34;\u0026#34;\u0026#34;\r给你一个 n 个节点的树（也就是一个无环连通无向图），节点编号从 0 到 n - 1 ，且恰好有 n - 1 条边，每个节点有一个值。树的 根节点 为 0 号点。\r给你一个整数数组 nums 和一个二维数组 edges 来表示这棵树。nums[i] 表示第 i 个点的值，edges[j] = [uj, vj] 表示节点 uj 和节点 vj 在树中有一条边。\r当 gcd(x, y) == 1 ，我们称两个数 x 和 y 是 互质的 ，其中 gcd(x, y) 是 x 和 y 的 最大公约数 。\r从节点 i 到 根 最短路径上的点都是节点 i 的祖先节点。一个节点 不是 它自己的祖先节点。\r请你返回一个大小为 n 的数组 ans ，其中 ans[i]是离节点 i 最近的祖先节点且满足 nums[i] 和 nums[ans[i]] 是 互质的 ，如果不存在这样的祖先节点，ans[i] 为 -1 。\r示例 1：\r输入：nums = [2,3,3,2], edges = [[0,1],[1,2],[1,3]]\r输出：[-1,0,0,1]\r解释：上图中，每个节点的值在括号中表示。\r- 节点 0 没有互质祖先。\r- 节点 1 只有一个祖先节点 0 。它们的值是互质的（gcd(2,3) == 1）。\r- 节点 2 有两个祖先节点，分别是节点 1 和节点 0 。节点 1 的值与它的值不是互质的（gcd(3,3) == 3）但节点 0 的值是互质的(gcd(2,3) == 1)，所以节点 0 是最近的符合要求的祖先节点。\r- 节点 3 有两个祖先节点，分别是节点 1 和节点 0 。它与节点 1 互质（gcd(3,2) == 1），所以节点 1 是离它最近的符合要求的祖先节点。\r示例 2：\r输入：nums = [5,6,10,2,3,6,15], edges = [[0,1],[0,2],[1,3],[1,4],[2,5],[2,6]]\r输出：[-1,0,-1,0,0,0,-1]\r提示：\rnums.length == n\r1 \u0026lt;= nums[i] \u0026lt;= 50\r1 \u0026lt;= n \u0026lt;= 105\redges.length == n - 1\redges[j].length == 2\r0 \u0026lt;= uj, vj \u0026lt; n\ruj != vj\r代码实现：\rclass Solution:\rdef getCoprimes(self, nums: List[int], edges: List[List[int]]) -\u0026gt; List[int]:\rn = len(nums)\rg = [[]*n for _ in range(n)]\rret = [-1]*n\rstore = [[] for _ in range(51)]\rmem = [(-1, -1)]*(51) for i in range(1, 51):\rfor j in range(1, 51):\rif gcd(i, j)==1:\rstore[i].append(j)\rfor u, v in edges:\rg[u].append(v)\rg[v].append(u)\rdef dfs(u, last, level):\rret[u] = max(mem[i] for i in store[nums[u]])[1]\rtmp = mem[nums[u]]\rmem[nums[u]] = (level, u)\rfor son in g[u]:\rif son==last:\rcontinue\rdfs(son, u, level+1)\rmem[nums[u]] = tmp\rdfs(0, -1, 0)\rreturn ret\r\u0026#34;\u0026#34;\u0026#34; 好的，你现在需要做的是 ： 我给你其他题目，并给出已经AC的代码实现，你需要补充：1、题目大意 2、实现思路\r如果你已经了解了我的需求，请回复我懂了 ","permalink":"https://kennems.github.io/posts/tech/prompt/","summary":"Prompt 要求：字数尽可能多，内容需要全面，可以不按照我的标题来写，可以适当添加一些内容，但是内容一定一定要多，要专业 请根据以上内容以及你的数据库内","title":"Prompt"},{"content":"MIT6.S081(13)-Coordination (sleep\u0026amp;wakeup) plan Re-emphasize a few points about xv6 thread switching sequence coordination sleep \u0026amp; wakeup lost wakeup problem termination\nWhy hold p-\u0026gt;lock across swtch()? this is an important point and affects many situations in xv6 [diagram: P1, STACK1, swtch, STACK_SCHED] yield:\nacquire(\u0026amp;p-\u0026gt;lock); p-\u0026gt;state = RUNNABLE; swtch(); scheduler:\nswtch(); release(\u0026amp;p-\u0026gt;lock); the main point of holding p-\u0026gt;lock across swtch(): prevent another core\u0026rsquo;s scheduler from seeing p-\u0026gt;state == RUNNABLE until after the original core has stopped executing the thread and after the original core has stopped using the thread\u0026rsquo;s stack\nWhy does sched() forbid spinlocks from being held when yielding the CPU? (other than p-\u0026gt;lock) i.e. sched() checks that noff == 1 on a single-core machine, imagine this:\nP1 P2\racq(L)\rsched()\racq(L) this is a deadlock: P2 will spin until P1 releases \u0026ndash; and P2 won\u0026rsquo;t yield the CPU but P1 won\u0026rsquo;t release until it runs again with multiple cores, deadlock can also arise; more spinlocks must be involved solution: do not hold spinlocks and yield the CPU!\ntopic: sequence coordination threads need to wait for specific events or conditions: wait for disk read to complete (event is from an interrupt) wait for pipe writer to produce data (event is from a thread) wait for any child to exit\ncoordination is a fundamental building-block for thread programming.\noften straightforward to use. but (like locks) subject to rules that sometimes present difficult puzzles.\nwhy not just have a while-loop that spins until event happens? pipe read:\nwhile buffer is empty {\r} pipe write:\nput data in buffer better solution: coordination primitives that yield the CPU\nthere are a bunch e.g. barriers, semaphores, event queues. xv6 uses sleep \u0026amp; wakeup\nexample: uartwrite() and uartintr() in uart.c I have modified these functions! not the same as default xv6 see \u0026ldquo;code\u0026rdquo; link on schedule page the basic idea: the UART can only accept one (really a few) bytes of output at a time takes a long time to send each byte, perhaps millisecond processes writing the console must wait until UART sends prev char the UART interrupts after it has sent each character writing thread should give up the CPU until then write() calls uartwrite() uartwrite() writes first byte (if it can) uartwrite() calls sleep() to wait for the UART\u0026rsquo;s interrupt uartintr() calls wakeup() the \u0026ldquo;\u0026amp;tx_chan\u0026rdquo; argument serves to link the sleep and wakeup simple and flexible: sleep/wakeup don\u0026rsquo;t need to understand what you\u0026rsquo;re waiting for no need to allocate explicit coordination objects\nWhy the lock argument to sleep()? sadly you cannot design sleep() as cleanly as you might hope sleep() cannot simply be \u0026ldquo;wait for this event\u0026rdquo; the problem is called \u0026ldquo;lost wakeups\u0026rdquo; it lurks behind all sequence coordination schemes, and is a pain here\u0026rsquo;s the story\nsuppose just sleep(chan); how would we implement? here\u0026rsquo;s a BROKEN sleep/wakeup broken_sleep(chan) sleeps on a \u0026ldquo;channel\u0026rdquo;, a number/address identifies the condition/event we are waiting for\np-\u0026gt;state = SLEEPING;\rp-\u0026gt;chan = chan;\rsched();\rwakeup(chan) ​ wakeup wakes up all threads sleeping on chan ​ may wake up more than one thread\nfor each p:\rif p-\u0026gt;state == SLEEPING \u0026amp;\u0026amp; p-\u0026gt;chan == chan:\rp-\u0026gt;state = RUNNABLE how would uart code use this (broken) sleep/wakeup? int done uartwrite(buf): for each char c: while not done: sleep(\u0026amp;done) send c done = false uartintr(): done = true wakeup(\u0026amp;done) done==true is the condition we\u0026#39;re waiting for \u0026amp;done is the sleep channel (not really related to the condition)\nbut what about locking? driver\u0026rsquo;s data structures e.g. done\nUART hardware\nboth uartwrite() and uartintr() need to lock should uartwrite() hold a lock for the whole sequence? no: then uartintr() can\u0026rsquo;t get lock and set done maybe uartwrite() could release the lock before sleep()? let\u0026rsquo;s try it \u0026ndash; modify uart.c to call broken_sleep()\nrelease(\u0026amp;uart_tx_lock); broken_sleep(\u0026amp;tx_chan); acquire(\u0026amp;uart_tx_lock); what goes wrong when uartwrite() releases the lock before broken_sleep()? uartwrite() saw that the previous character wasn\u0026rsquo;t yet done being sent interrupt occurred after release(), before broken_sleep() uartwrite() went to sleep EVEN THOUGH UART TX WAS DONE now there is nothing to wake up uartwrite(), it will sleep forever\nthis is the \u0026ldquo;lost wakeup\u0026rdquo; problem.\nwe need to eliminate the window between uartwrite()\u0026rsquo;s check of the condition, and sleep() marking the process as asleep. we\u0026rsquo;ll use locks to prevent wakeup() from running during the entire window.\nwe\u0026rsquo;ll change the sleep() interface and the way it\u0026rsquo;s used. we\u0026rsquo;ll require that there be a lock that protects the condition, and that the callers of both sleep() and wakeup() hold the \u0026ldquo;condition lock\u0026rdquo; sleep(chan, lock) caller must hold lock sleep releases lock, re-acquires before returning wakeup(chan) caller must hold lock (repair uart.c)\nlet\u0026rsquo;s look at wakeup(chan) in proc.c it scans the process table, looking for SLEEPING and chan it grabs each p-\u0026gt;lock remember also that caller acquired condition lock before calling wakeup() so wakeup() holds BOTH the condition lock and each p-\u0026gt;lock\nlet\u0026rsquo;s look at sleep() in proc.c sleep must release the condition lock since we can\u0026rsquo;t hold locks when calling swtch(), other than p-\u0026gt;lock\nQ: how can sleep() prevent wakeup() from running after it releases the condition lock? A: acquire p-\u0026gt;lock before releasing condition lock since wakeup() holds both locks, it\u0026rsquo;s enough for sleep() to hold either in order to force wakeup() to spin rather than look at this process now wakeup() can\u0026rsquo;t proceed until after swtch() completes so wakeup() is guaranteed to see p-\u0026gt;state==SLEEPING and p-\u0026gt;chan==chan thus: no lost wakeups!\nnote that uartwrite() wraps the sleep() in a loop i.e. re-checks the condition after sleep() returns, may sleep again\ntwo reasons: ​ maybe multiple waiters, another thread might have consumed the event ​ kill() wakes up processes even when condition isn\u0026rsquo;t true all uses of sleep are wrapped in a loop, so they re-check\nAnother example: piperead() the condition is data waiting to be read (nread != nwrite) pipewrite() calls wakeup() at the end what is the race if piperead() used broken_sleep()? note the the loop around sleep() multiple processes may be reading the same pipe why the wakeup() at the end of piperead()?\nthe sleep/wakeup interface/rules are a little complex sleep() doesn\u0026rsquo;t need to understand the condition, but it needs the condition lock sleep/wakeup is pretty flexible, though low-level there are other schemes that are cleaner but perhaps less general-purpose e.g. the counting semaphore in today\u0026rsquo;s reading all have to cope with lost wakeups, one way or another\nanother coordination challenge \u0026ndash; how to terminate a thread? a puzzle: we want need to free resources that might still be in use\nproblem: thread X cannot just destroy thread Y what if Y is executing on another core? what if Y holds locks? what if Y is in the middle of a complex update to important data structures?\nproblem: a thread cannot free all of its own resources e.g. its own stack, which it is still using e.g. its struct context, which it may need to call swtch()\nxv6 has two ways to get rid of processes: exit() and kill() ordinary case: process voluntarily quits with exit() system call some freeing in exit(), some in parent\u0026rsquo;s wait() exit() in proc.c:\nclose open files\rchange parent of children to PID 1 (init)\rwake up wait()ing parent\rp-\u0026gt;state = ZOMBIE ​ dying but not yet dead ​ won\u0026rsquo;t run again ​ won\u0026rsquo;t (yet) be re-allocated by fork(), eithe·r ​ (note stack and proc[] entry are still allocated\u0026hellip;) ​ swtch() to scheduler wait() in proc.c (parent, or init, will eventually call): ​ sleep()s waiting for any child exit() ​ scans proc[] table for children with p-\u0026gt;state==ZOMBIE ​ calls freeproc() ​ (p-\u0026gt;lock held\u0026hellip;) ​ trapframe, pagetable, \u0026hellip;, p-\u0026gt;state=UNUSED thus: wait() is not just for app convenience, but for O/S as well ​ every process must be wait()ed for ​ thus the re-parenting of children of an exiting process some complexity due to ​ child exits concurrently with its own parent ​ parent-then-child locking order to avoid deadlock\nwhat about kill(pid)? problem: may not be safe to forcibly terminate a process it might be executing in the kernel using its kernel stack, page table, proc[] entry, trapframe it might hold locks e.g. in the middle of fork()ing a new process and must finish to restore invariants so: kill() can\u0026rsquo;t directly destroy the target! solution: kill() sets p-\u0026gt;killed flag, nothing else the target process itself checks for p-\u0026gt;killed and calls exit() itself look for \u0026ldquo;if(p-\u0026gt;killed) exit(-1);\u0026rdquo; in usertrap() no locks are held at that point so it\u0026rsquo;s safe to exit()\nwhat if kill() target is sleep()ing? in that case it doesn\u0026rsquo;t hold locks, and isn\u0026rsquo;t executing! is it OK for kill() destroy the target right away? might be OK: waiting for console input might not be OK: waiting for disk midway through file creation\nxv6 solution to kill() of sleep()ing process see kill() in proc.c changes SLEEPING to RUNNABLE \u0026ndash; like wakeup() so sleep() will return, probably before condition is true some sleep loops check for p-\u0026gt;killed e.g. piperead(), consoleread() otherwise read could hang indefinitely for a killed process some sleep loops don\u0026rsquo;t check p-\u0026gt;killed e.g. virtio_disk.c OK not to check p-\u0026gt;killed since disk reads are pretty quick so a kill()ed process may continue for a while but usertrap() will exit() after the system call finishes\nxv6 spec for kill if target is in user space will die next time it makes a system call or takes a timer interrupt if target is in the kernel target will never execute another user instruction but may spend quite a while yet in the kernel\nSummary sleep/wakeup let threads wait for specific events concurrency means we have to worry about lost wakeups termination is a pain in threading systems\nLab: locks Memory allocator (moderate) 优化xv6的内存分配器，减少锁争用。当前的实现使用一个全局的自由列表和单一的锁保护，导致多核系统中多个进程并发执行时锁争用严重。你需要将单一自由列表改为每个CPU都有自己的自由列表，每个自由列表有自己的锁。这样，多个CPU可以并行进行内存分配和释放，从而减少锁争用。\n任务分解： 创建每个CPU的自由列表： 每个CPU有自己独立的自由内存块列表，并且每个列表有自己的锁。 使用NCPU（在param.h中定义）确定CPU的数量。 为每个CPU创建一个对应的锁，用于保护其自由列表。 修改freerange函数： freerange应该根据当前CPU，将空闲内存块分配到当前CPU的自由列表中。你可以使用cpuid来获取当前CPU编号，但要确保调用它时中断已关闭。 使用push_off()和pop_off()来关闭和开启中断，保证调用cpuid时的安全性。 实现内存分配和释放： 修改kalloc和kfree，使它们只操作当前CPU的自由列表。通过使用当前CPU的锁来保护并发访问。 当某个CPU的自由列表为空时，需要从其他CPU的自由列表中“偷取”内存块。 实现跨CPU的内存“偷取”： 如果当前CPU的自由列表为空，查找其他CPU的自由列表，尝试从中“偷取”部分内存。 “偷取”过程可能引入锁争用，但由于偷取发生较少，可以将争用控制在较低范围。 锁的命名： 根据要求，所有涉及的锁必须以“kmem”开头。你可以使用initlock函数来初始化锁，并使用合适的名称（如kmem_cpu0、kmem_cpu1等）。 测试： 运行kalloctest，观察kmem锁的争用情况，争用次数应明显减少。 运行usertests sbrkmuch测试内存分配器，确保所有内存分配和释放功能正常。 实现步骤： 1、定义每个CPU的自由列表： 在kmem结构中，添加一个数组保存每个CPU的自由列表和对应的锁 struct { struct spinlock lock[NCPU]; struct run *freelist[NCPU]; } kmem; 2、初始化每个CPU的锁和自由列表： 在freerange函数中，为当前CPU的自由列表分配内存，并用initlock为每个CPU的锁进行初始化： 3、修改kalloc函数： 使用当前CPU的自由列表分配内存，并在列表为空时从其他CPU的自由列表中“偷取”内存： void * kalloc(void) { struct run *r; int id = cpuid(); push_off(); // 关闭中断，防止竞态 acquire(\u0026amp;kmem.lock[id]); r = kmem.freelist[id]; // 从当前CPU的空闲列表中分配 if (r) { kmem.freelist[id] = r-\u0026gt;next; } // 如果当前CPU空闲列表为空，尝试从其他CPU窃取内存 release(\u0026amp;kmem.lock[id]); if (r == 0) { for (int i = 0; i \u0026lt; NCPU; i++) { if (i != id) { acquire(\u0026amp;kmem.lock[i]); r = kmem.freelist[i]; if (r) { kmem.freelist[i] = r-\u0026gt;next; release(\u0026amp;kmem.lock[i]); break; } release(\u0026amp;kmem.lock[i]); } } } pop_off(); if (r) memset((char *)r, 5, PGSIZE); // fill with junk return (void *)r; } 4、修改kfree函数： 将释放的内存块放入当前CPU的自由列表，并使用当前CPU的锁保护： 5、(之前第3步中已经包括下面的代码实现）实现“偷取”机制： 在kalloc函数中，当当前CPU的自由列表为空时，遍历其他CPU的自由列表并“偷取”内存块，具体逻辑可能如下： for (int i = 0; i \u0026lt; NCPU; i++) { if (i != id) { acquire(\u0026amp;kmem.lock[i]); r = kmem.freelist[i]; if (r) { kmem.freelist[i] = r-\u0026gt;next; release(\u0026amp;kmem.lock[i]); break; } release(\u0026amp;kmem.lock[i]); } } 最终检查： 运行kalloctest和usertests sbrkmuch，确保所有内存分配、释放和并发处理正常，同时锁争用显著减少。 Buffer cache (hard) 修改 xv6 的块缓存（block cache）机制，减少多个进程同时访问缓存时对锁 bcache.lock 的争用。你需要特别优化 bget 和 brelse 函数，确保并发读取和释放不同的缓存块时不会冲突。最终的目标是让运行 bcachetest 时，所有与块缓存相关的锁的获取次数接近零（理想情况下总和小于500）。此外，你需要通过 usertests 测试，并且确保实现中的锁名都以“bcache”开头。\n实现步骤详细说明： 理解现有锁争用： bcache.lock 保护了缓存块列表、缓存块的引用计数 b-\u0026gt;refcnt 以及缓存块的标识 b-\u0026gt;dev 和 b-\u0026gt;blockno。多个进程同时访问时可能发生锁争用。 使用哈希表替代全局缓存锁： 使用一个哈希表来存储缓存块，并为每个哈希桶设置单独的锁。通过哈希分桶机制，你可以减少并发访问不同缓存块时对同一个锁的争用。 可以选择使用一个质数（例如13）作为哈希桶的数量，以减少哈希冲突的概率。 修改 bget 和 brelse： bget：这是获取缓存块的函数。你需要修改它，使得在查找和获取缓存块时，只对相应的哈希桶进行加锁，而不是全局加锁。同时，确保如果缓存中没有对应的块，需要选择一个替换块时，替换逻辑是原子的，并且防止哈希冲突导致的死锁。 brelse：这是释放缓存块的函数。你可以通过使用时间戳（如 ticks）来记录缓存块的最后使用时间，从而避免在释放块时必须获取全局 bcache.lock。当 brelse 被调用时，只需要更新时间戳，而不需要加锁。 替换缓存块的管理机制： 取消全局缓存块链表（如 bcache.head 等），而是通过时间戳记录缓存块的最后使用时间。这样，你可以在 bget 中根据时间戳选择最近未使用的缓存块，而不需要遍历全局列表。 防止死锁： 在缓存替换和哈希桶移动时，可能需要持有多个锁（如全局 bcache.lock 和哈希桶锁）。你需要小心避免在锁的顺序上出现死锁的情况，特别是在缓存块从一个哈希桶移动到另一个桶时。 逐步调试： 你可以在实现哈希桶锁后，先保留 bget 开始和结束时的全局锁 bcache.lock，以确保没有竞争条件。一旦验证代码没有竞态条件后，再移除全局锁，处理并发问题。 可以运行 make CPUS=1 qemu 进行单核测试，确保初步实现正确后，再扩展到多核环境。 usertests不通过\n// Buffer cache. // // The buffer cache is a linked list of buf structures holding // cached copies of disk block contents. Caching disk blocks // in memory reduces the number of disk reads and also provides // a synchronization point for disk blocks used by multiple processes. // // Interface: // * To get a buffer for a particular disk block, call bread. // * After changing buffer data, call bwrite to write it to disk. // * When done with the buffer, call brelse. // * Do not use the buffer after calling brelse. // * Only one process at a time can use a buffer, // so do not keep them longer than necessary. #include \u0026#34;types.h\u0026#34; #include \u0026#34;param.h\u0026#34; #include \u0026#34;spinlock.h\u0026#34; #include \u0026#34;sleeplock.h\u0026#34; #include \u0026#34;riscv.h\u0026#34; #include \u0026#34;defs.h\u0026#34; #include \u0026#34;fs.h\u0026#34; #include \u0026#34;buf.h\u0026#34; #define NBUCKETS 23 // 哈希桶数量，使用质数以减少冲突 struct { struct spinlock lock; struct buf buf[NBUF]; // 实际的缓存块 struct { struct buf *head; // 每个桶的缓存块链表 struct spinlock lock; // 每个桶的锁 } buckets[NBUCKETS]; } bcache; // 计算块号和设备号的哈希值 static uint hash(uint dev, uint blockno) { return (dev ^ blockno) % NBUCKETS; } void binit(void) { struct buf *b; initlock(\u0026amp;bcache.lock, \u0026#34;bcache\u0026#34;); // 初始化每个桶的锁 for (int i = 0; i \u0026lt; NBUCKETS; i++) { initlock(\u0026amp;bcache.buckets[i].lock, \u0026#34;bcache.bucket\u0026#34;); bcache.buckets[i].head = 0; } // 初始化缓存块 for (b = bcache.buf; b \u0026lt; bcache.buf + NBUF; b++) { initsleeplock(\u0026amp;b-\u0026gt;lock, \u0026#34;buffer\u0026#34;); b-\u0026gt;refcnt = 0; } } // 修改 bget 函数进行哈希表查找 // 为了使用哈希表，bget 函数需要进行以下修改： // 计算块号的哈希值，确定所在桶。 // 获取桶的锁，并在桶中查找块。 // 如果未找到块，则选择一个未使用或最近最少使用的块进行替换。 static struct buf * bget(uint dev, uint blockno) { struct buf *b; uint h = hash(dev, blockno); acquire(\u0026amp;bcache.buckets[h].lock); // 在桶中查找块 for (b = bcache.buckets[h].head; b; b = b-\u0026gt;next) { if (b-\u0026gt;dev == dev \u0026amp;\u0026amp; b-\u0026gt;blockno == blockno) { b-\u0026gt;refcnt++; release(\u0026amp;bcache.buckets[h].lock); acquiresleep(\u0026amp;b-\u0026gt;lock); return b; } } // 如果未找到块，尝试找到一个未使用的块或替换最近最少使用的块 struct buf *lru = 0; for (b = bcache.buf; b \u0026lt; bcache.buf + NBUF; b++) { if (b-\u0026gt;refcnt == 0 \u0026amp;\u0026amp; (lru == 0 || b-\u0026gt;lastuse \u0026lt; lru-\u0026gt;lastuse)) lru = b; } if (lru == 0) panic(\u0026#34;bget: no buffers\u0026#34;); release(\u0026amp;bcache.buckets[h].lock); // 从旧桶中移除块 h = hash(lru-\u0026gt;dev, lru-\u0026gt;blockno); acquire(\u0026amp;bcache.buckets[h].lock); struct buf **prev = \u0026amp;bcache.buckets[h].head; for (b = bcache.buckets[h].head; b; prev = \u0026amp;b-\u0026gt;next, b = b-\u0026gt;next) { if (b == lru) { *prev = b-\u0026gt;next; break; } } // 将新块插入适当的桶 lru-\u0026gt;dev = dev; lru-\u0026gt;blockno = blockno; lru-\u0026gt;valid = 0; lru-\u0026gt;refcnt = 1; lru-\u0026gt;lastuse = ticks; release(\u0026amp;bcache.buckets[h].lock); h = hash(dev, blockno); acquire(\u0026amp;bcache.buckets[h].lock); lru-\u0026gt;next = bcache.buckets[h].head; bcache.buckets[h].head = lru; release(\u0026amp;bcache.buckets[h].lock); acquiresleep(\u0026amp;lru-\u0026gt;lock); return lru; } // Return a locked buf with the contents of the indicated block. struct buf * bread(uint dev, uint blockno) { struct buf *b; b = bget(dev, blockno); if (!b-\u0026gt;valid) { virtio_disk_rw(b, 0); b-\u0026gt;valid = 1; } return b; } // Write b\u0026#39;s contents to disk. Must be locked. void bwrite(struct buf *b) { if (!holdingsleep(\u0026amp;b-\u0026gt;lock)) panic(\u0026#34;bwrite\u0026#34;); virtio_disk_rw(b, 1); } // Release a locked buffer. // Move to the head of the most-recently-used list. void brelse(struct buf *b) { if (!holdingsleep(\u0026amp;b-\u0026gt;lock)) panic(\u0026#34;brelse\u0026#34;); releasesleep(\u0026amp;b-\u0026gt;lock); uint h = hash(b-\u0026gt;dev, b-\u0026gt;blockno); acquire(\u0026amp;bcache.buckets[h].lock); b-\u0026gt;refcnt--; if (b-\u0026gt;refcnt == 0) { // 块不再被使用，更新时间戳 b-\u0026gt;lastuse = ticks; } release(\u0026amp;bcache.buckets[h].lock); } void bpin(struct buf *b) { uint h = hash(b-\u0026gt;dev, b-\u0026gt;blockno); acquire(\u0026amp;bcache.buckets[h].lock); b-\u0026gt;refcnt++; release(\u0026amp;bcache.buckets[h].lock); } void bunpin(struct buf *b) { uint h = hash(b-\u0026gt;dev, b-\u0026gt;blockno); acquire(\u0026amp;bcache.buckets[h].lock); b-\u0026gt;refcnt--; release(\u0026amp;bcache.buckets[h].lock); } // Buffer cache. // // The buffer cache is a linked list of buf structures holding // cached copies of disk block contents. Caching disk blocks // in memory reduces the number of disk reads and also provides // a synchronization point for disk blocks used by multiple processes. // // Interface: // * To get a buffer for a particular disk block, call bread. // * After changing buffer data, call bwrite to write it to disk. // * When done with the buffer, call brelse. // * Do not use the buffer after calling brelse. // * Only one process at a time can use a buffer, // so do not keep them longer than necessary. #include \u0026#34;types.h\u0026#34; #include \u0026#34;param.h\u0026#34; #include \u0026#34;spinlock.h\u0026#34; #include \u0026#34;sleeplock.h\u0026#34; #include \u0026#34;riscv.h\u0026#34; #include \u0026#34;defs.h\u0026#34; #include \u0026#34;fs.h\u0026#34; #include \u0026#34;buf.h\u0026#34; #define NBUCKET 13 #undef NBUF #define NBUF (NBUCKET * 3) struct { struct spinlock lock; struct buf buf[NBUF]; } bcache; struct bucket { struct spinlock lock; struct buf head; }hashtable[NBUCKET]; int hash(uint dev, uint blockno) { return blockno % NBUCKET; } void binit(void) { struct buf *b; initlock(\u0026amp;bcache.lock, \u0026#34;bcache\u0026#34;); for(b = bcache.buf; b \u0026lt; bcache.buf+NBUF; b++){ initsleeplock(\u0026amp;b-\u0026gt;lock, \u0026#34;buffer\u0026#34;); } b = bcache.buf; for (int i = 0; i \u0026lt; NBUCKET; i++) { initlock(\u0026amp;hashtable[i].lock, \u0026#34;bcache_bucket\u0026#34;); for (int j = 0; j \u0026lt; NBUF / NBUCKET; j++) { b-\u0026gt;blockno = i; b-\u0026gt;next = hashtable[i].head.next; hashtable[i].head.next = b; b++; } } } // Look through buffer cache for block on device dev. // If not found, allocate a buffer. // In either case, return locked buffer. static struct buf* bget(uint dev, uint blockno) { // printf(\u0026#34;dev: %d blockno: %d Status: \u0026#34;, dev, blockno); struct buf *b; int idx = hash(dev, blockno); struct bucket* bucket = hashtable + idx; acquire(\u0026amp;bucket-\u0026gt;lock); // Is the block already cached? for(b = bucket-\u0026gt;head.next; b != 0; b = b-\u0026gt;next){ if(b-\u0026gt;dev == dev \u0026amp;\u0026amp; b-\u0026gt;blockno == blockno){ b-\u0026gt;refcnt++; release(\u0026amp;bucket-\u0026gt;lock); acquiresleep(\u0026amp;b-\u0026gt;lock); // printf(\u0026#34;Cached %p\\n\u0026#34;, b); return b; } } // Not cached. // First try to find in current bucket. int min_time = 0x8fffffff; struct buf* replace_buf = 0; for(b = bucket-\u0026gt;head.next; b != 0; b = b-\u0026gt;next){ if(b-\u0026gt;refcnt == 0 \u0026amp;\u0026amp; b-\u0026gt;timestamp \u0026lt; min_time) { replace_buf = b; min_time = b-\u0026gt;timestamp; } } if(replace_buf) { // printf(\u0026#34;Local %d %p\\n\u0026#34;, idx, replace_buf); goto find; } // Try to find in other bucket. acquire(\u0026amp;bcache.lock); refind: for(b = bcache.buf; b \u0026lt; bcache.buf + NBUF; b++) { if(b-\u0026gt;refcnt == 0 \u0026amp;\u0026amp; b-\u0026gt;timestamp \u0026lt; min_time) { replace_buf = b; min_time = b-\u0026gt;timestamp; } } if (replace_buf) { // remove from old bucket int ridx = hash(replace_buf-\u0026gt;dev, replace_buf-\u0026gt;blockno); acquire(\u0026amp;hashtable[ridx].lock); if(replace_buf-\u0026gt;refcnt != 0) // be used in another bucket\u0026#39;s local find between finded and acquire { release(\u0026amp;hashtable[ridx].lock); goto refind; } struct buf *pre = \u0026amp;hashtable[ridx].head; struct buf *p = hashtable[ridx].head.next; while (p != replace_buf) { pre = pre-\u0026gt;next; p = p-\u0026gt;next; } pre-\u0026gt;next = p-\u0026gt;next; release(\u0026amp;hashtable[ridx].lock); // add to current bucket replace_buf-\u0026gt;next = hashtable[idx].head.next; hashtable[idx].head.next = replace_buf; release(\u0026amp;bcache.lock); // printf(\u0026#34;Global %d -\u0026gt; %d %p\\n\u0026#34;, ridx, idx, replace_buf); goto find; } else { panic(\u0026#34;bget: no buffers\u0026#34;); } find: replace_buf-\u0026gt;dev = dev; replace_buf-\u0026gt;blockno = blockno; replace_buf-\u0026gt;valid = 0; replace_buf-\u0026gt;refcnt = 1; release(\u0026amp;bucket-\u0026gt;lock); acquiresleep(\u0026amp;replace_buf-\u0026gt;lock); return replace_buf; } // Return a locked buf with the contents of the indicated block. struct buf* bread(uint dev, uint blockno) { struct buf *b; b = bget(dev, blockno); if(!b-\u0026gt;valid) { virtio_disk_rw(b, 0); b-\u0026gt;valid = 1; } return b; } // Write b\u0026#39;s contents to disk. Must be locked. void bwrite(struct buf *b) { if(!holdingsleep(\u0026amp;b-\u0026gt;lock)) panic(\u0026#34;bwrite\u0026#34;); virtio_disk_rw(b, 1); } // Release a locked buffer. // Move to the head of the most-recently-used list. void brelse(struct buf *b) { if(!holdingsleep(\u0026amp;b-\u0026gt;lock)) panic(\u0026#34;brelse\u0026#34;); releasesleep(\u0026amp;b-\u0026gt;lock); int idx = hash(b-\u0026gt;dev, b-\u0026gt;blockno); acquire(\u0026amp;hashtable[idx].lock); b-\u0026gt;refcnt--; if (b-\u0026gt;refcnt == 0) { // no one is waiting for it. b-\u0026gt;timestamp = ticks; } release(\u0026amp;hashtable[idx].lock); } void bpin(struct buf *b) { int idx = hash(b-\u0026gt;dev, b-\u0026gt;blockno); acquire(\u0026amp;hashtable[idx].lock); b-\u0026gt;refcnt++; release(\u0026amp;hashtable[idx].lock); } void bunpin(struct buf *b) { int idx = hash(b-\u0026gt;dev, b-\u0026gt;blockno); acquire(\u0026amp;hashtable[idx].lock); b-\u0026gt;refcnt--; release(\u0026amp;hashtable[idx].lock); } 实现步骤 1、定义桶大小，以及全局的buffer大小 2、添加bucket结构体 3、实现哈希函数 4、初始化实现全局buffer初始化，以及每个桶内的buffer初始化 void binit(void) { struct buf *b; initlock(\u0026amp;bcache.lock, \u0026#34;bcache\u0026#34;); for (b = bcache.buf; b \u0026lt; bcache.buf + NBUF; b++) { initsleeplock(\u0026amp;b-\u0026gt;lock, \u0026#34;buffer\u0026#34;); b-\u0026gt;refcnt = 0; } b = bcache.buf; for (int i = 0; i \u0026lt; NBUCKET; i++) { initlock(\u0026amp;hashtable[i].lock, \u0026#34;bcache_bucket\u0026#34;); for (int j = 0; j \u0026lt; NBUF / NBUCKET; j++) { b-\u0026gt;blockno = i; b-\u0026gt;refcnt = 0; b-\u0026gt;next = hashtable[i].head.next; hashtable[i].head.next = b; b++; } } } 5、重点， 重构bget()，桶内寻找是否已经缓存-\u0026gt;桶内寻找空白缓存 -\u0026gt;寻找全局空白缓存 static struct buf * find_replacement_in_bucket(struct bucket *bucket, uint *min_time) { struct buf *replace_buf = 0; struct buf *b; for (b = bucket-\u0026gt;head.next; b != 0; b = b-\u0026gt;next) { if (b-\u0026gt;refcnt == 0 \u0026amp;\u0026amp; (*min_time == 0 || b-\u0026gt;timestamp \u0026lt; *min_time)) { replace_buf = b; *min_time = b-\u0026gt;timestamp; } } return replace_buf; } static struct buf * find_replacement_in_global(struct buf *replace_buf, uint *min_time) { struct buf *b; for (b = bcache.buf; b \u0026lt; bcache.buf + NBUF; b++) { if (b-\u0026gt;refcnt == 0 \u0026amp;\u0026amp; (*min_time == 0 || b-\u0026gt;timestamp \u0026lt; *min_time)) { replace_buf = b; *min_time = b-\u0026gt;timestamp; } } return replace_buf; } static void move_buf_to_bucket(struct buf *replace_buf, int idx) { int ridx = hash(replace_buf-\u0026gt;dev, replace_buf-\u0026gt;blockno); acquire(\u0026amp;hashtable[ridx].lock); if (replace_buf-\u0026gt;refcnt == 0) { struct buf *pre = \u0026amp;hashtable[ridx].head; struct buf *p = hashtable[ridx].head.next; while (p != replace_buf) { pre = pre-\u0026gt;next; p = p-\u0026gt;next; } pre-\u0026gt;next = p-\u0026gt;next; release(\u0026amp;hashtable[ridx].lock); // Add to current bucket replace_buf-\u0026gt;next = hashtable[idx].head.next; hashtable[idx].head.next = replace_buf; } else { release(\u0026amp;hashtable[ridx].lock); } } static struct buf* bget(uint dev, uint blockno) { struct buf *b; int h = hash(dev, blockno); struct bucket *bucket = \u0026amp;hashtable[h]; acquire(\u0026amp;bucket-\u0026gt;lock); // Check if block is already cached 桶内寻找 for (b = bucket-\u0026gt;head.next; b != 0; b = b-\u0026gt;next) { if (b-\u0026gt;dev == dev \u0026amp;\u0026amp; b-\u0026gt;blockno == blockno) { b-\u0026gt;refcnt++; release(\u0026amp;bucket-\u0026gt;lock); acquiresleep(\u0026amp;b-\u0026gt;lock); return b; } } // Not cached, find replacement buffer 桶内的空白buf uint min_time = 0; struct buf *replace_buf; replace_buf = find_replacement_in_bucket(bucket, \u0026amp;min_time); if (!replace_buf) { acquire(\u0026amp;bcache.lock); // 寻找桶外的空白buf replace_buf = find_replacement_in_global(replace_buf, \u0026amp;min_time); if (replace_buf) { move_buf_to_bucket(replace_buf, h); } else { release(\u0026amp;bcache.lock); panic(\u0026#34;bget: no buffers\u0026#34;); } release(\u0026amp;bcache.lock); } // Initialize and return the replacement buffer replace_buf-\u0026gt;dev = dev; replace_buf-\u0026gt;blockno = blockno; replace_buf-\u0026gt;valid = 0; replace_buf-\u0026gt;refcnt = 1; release(\u0026amp;bucket-\u0026gt;lock); acquiresleep(\u0026amp;replace_buf-\u0026gt;lock); return replace_buf; } 6、锁的释放，更新引用计数，当refcnt == 0时更新时间戳 7、更新 bpin() 和 bunpin(), 只需要持有对应桶的锁即可\n","permalink":"https://kennems.github.io/posts/tech/mit6.s08113-coordination-sleepwakeup/","summary":"MIT6.S081(13)-Coordination (sleep\u0026amp;wakeup) plan Re-emphasize a few points about xv6 thread switching sequence coordination sleep \u0026amp; wakeup lost wakeup problem termination Why hold p-\u0026gt;lock across swtch()? this is an important point and affects many situations in xv6 [diagram: P1, STACK1, swtch, STACK_SCHED] yield: acquire(\u0026amp;p-\u0026gt;lock); p-\u0026gt;state = RUNNABLE; swtch(); scheduler: swtch(); release(\u0026amp;p-\u0026gt;lock); the main point of holding p-\u0026gt;lock across swtch(): prevent another core\u0026rsquo;s scheduler from seeing p-\u0026gt;state == RUNNABLE until after the","title":"MIT6.S081(13)-Coordination (sleep\u0026wakeup)"},{"content":"周赛250922 小号第一次AK， 题比较简单。\n3295. 举报垃圾信息 题目大意 给定两个字符串数组 message 和 bannedWords，你需要判断 message 是否属于“垃圾信息”。如果 message 中至少有两个单词出现在 bannedWords 中，则该数组被视为垃圾信息，返回 true；否则返回 false。\n实现思路 集合操作优化：为了快速判断 message 中的单词是否在 bannedWords 中，将 bannedWords 转换为一个 set 集合，利用集合的 O(1) 时间复杂度来快速查找单词是否存在。 统计匹配次数：遍历 message 数组，对每个单词检查它是否在 bannedWords 集合中，记录出现在 bannedWords 中的单词数。 判断垃圾信息：若匹配到的单词数量大于等于 2，则返回 true（即认为 message 是垃圾信息）；否则返回 false。 class Solution: def reportSpam(self, message: List[str], bannedWords: List[str]) -\u0026gt; bool: bannedWords = set(bannedWords) return sum(m in bannedWords for m in message) \u0026gt;= 2 Q2. 移山所需的最少秒数 题目大意 给定一个整数 mountainHeight 表示山的高度和一个数组 workerTimes，表示工人们降低山高度所需的工作时间。工人们可以同时工作，每个工人 i 在降低山的过程中，其降低 1 个高度需要 workerTimes[i] 秒，降低 2 个高度需要 workerTimes[i] + 2 * workerTimes[i] 秒，以此类推。题目要求返回工人们将山的高度降低到 0 所需的最少秒数。\n实现思路 工人的工作能力：工人 i 降低 x 的高度需要的时间是 workerTimes[i] * (1 + 2 + ... + x)，即等差数列求和公式。根据时间 t，工人 i 能降低的最大高度可以通过二分查找确定。 二分查找最小时间：我们可以通过二分法来确定最少需要的时间，设定一个时间范围 [0, 10^16]，每次取中间值 mid 作为当前时间，判断在这段时间内，所有工人能否把山降低到 0。我们使用一个 work 函数来计算工人在给定时间内可以降低的最大高度。 计算每个工人能降低的高度：对于每个工人，我们通过二分查找计算出当前时间内该工人能降低的最大高度，如果所有工人的总降低高度超过了山的高度，则说明当前时间 mid 可以满足需求，继续向更小的时间查找，否则向更大的时间查找。 最终结果：在二分法中找到的最小时间即为答案。 class Solution: def minNumberOfSeconds(self, m: int, w: List[int]) -\u0026gt; int: # 找到 当前的工作最大时间内 此工人能降低的最大高度 def work(wt, t): lo, hi = 0, t while lo \u0026lt; hi: mid = (lo + hi + 1) // 2 if wt * mid * (mid + 1) // 2 \u0026lt;= t: lo = mid else: hi = mid - 1 return lo # 10^5 * (1 + 10^5) // 2 * 10 ^ 4 = l, r = 0, 10**16 # 二分答案 while l \u0026lt; r: mid = (l + r) // 2 tot = 0 for wt in w: tot += work(wt, mid) if tot \u0026gt;= m: break if tot \u0026gt;= m: r = mid else: l = mid + 1 return l Q3 \u0026amp; Q4 3297. 统计重新排列后包含另一个字符串的子字符串数目 I 题目大意 给定两个字符串 word1 和 word2，如果某个子字符串 x 的重新排列能够包含 word2 作为其前缀，那么这个子字符串是合法的。问题要求返回 word1 中合法子字符串的数目。\n为了满足问题中的内存限制，要求实现一个线性复杂度的解法。\n实现思路 前缀匹配和字符计数： 为了判断一个子字符串的重新排列是否可以包含 word2 作为前缀，需要对 word2 中的字符进行统计。 使用 Counter 对 word2 中每个字符出现的次数进行记录，并使用滑动窗口技术遍历 word1 的子字符串。 滑动窗口法： 维护一个窗口，用来记录当前窗口内的字符计数，并在窗口移动的过程中检查当前窗口能否重新排列成 word2 的前缀。 窗口通过左右指针扩展和收缩，每次遇到合法情况时，记录当前窗口能产生的合法子字符串的数量。 窗口内匹配字符数： 定义变量 m，用于记录当前窗口内有多少字符已经完全匹配了 word2 中对应字符的数量。当 m 等于 word2 中不同字符的总数时，意味着当前窗口可以重新排列出 word2 的前缀。 具体步骤： 初始化 word2 中字符的计数器 w2_cnt。 使用滑动窗口遍历 word1，对每个窗口内的字符进行计数。如果某个字符的计数达到 word2 中相应字符的数量，增加匹配字符数 m。 当 m 达到 word2 不同字符数的总数时，表示窗口中的子字符串可以包含 word2 作为前缀。 每当窗口合法时，计算从当前窗口右边界开始到 word1 末尾的所有子字符串都可以被重新排列成合法子字符串。 class Solution: def validSubstringCount(self, w1: str, w2: str) -\u0026gt; int: w2_cnt = Counter(w2) res = 0 win = Counter() m = 0 # the number of matched char l = 0 for r in range(len(w1)): if w1[r] in w2_cnt: win[w1[r]] += 1 if win[w1[r]] == w2_cnt[w1[r]]: m += 1 while m == len(w2_cnt): res += len(w1) - r # (len(w1) - (r + 1) + 1) 因为r是下标 if w1[l] in w2_cnt: if win[w1[l]] == w2_cnt[w1[l]]: m -= 1 win[w1[l]] -= 1 l += 1 return res ","permalink":"https://kennems.github.io/posts/tech/%E5%91%A8%E8%B5%9B240924/","summary":"周赛250922 小号第一次AK， 题比较简单。 3295. 举报垃圾信息 题目大意 给定两个字符串数组 message 和 bannedWords，你需要判断 message 是否属于“垃圾信","title":"LeetCode周赛416(250922)"},{"content":"MIT6.S081(11)- Thread switching Topic: more \u0026ldquo;under the hood\u0026rdquo; with xv6 Previously: system calls, interrupts, page tables, locks Today: process/thread switching\nWhy support multiple tasks? Time-sharing: many users and/or many running programs. program structure: prime number sieve. parallel speedup on multi-core hardware.\nThreads are an abstraction to simplify programming when there are many tasks. thread = an independent serial execution \u0026ndash; registers, pc, stack the threading system interleaves the execution of multiple threads\nTwo main strategies: ​ multiple CPUs, each CPU runs a different thread ​ each CPU \u0026ldquo;switches\u0026rdquo; between threads, runs one at a time\nthreads can share memory, or not xv6 kernel threads: they share kernel memory (thus locks) xv6 user processes: one thread per process, so no sharing linux: supports multiple threads sharing a user process\u0026rsquo;s memory\nthere are other techniques for interleaving multiple tasks look up event-driven programming, or state machines threads are not the most efficient, but they are usually the most convenient\nThread design challenges How to interleave many threads on a few CPUs?\nHow to make interleaving transparent?\n\u0026ldquo;scheduling\u0026rdquo; = the process of choosing which thread to run next\nWhat to save while a thread isn\u0026rsquo;t running?\nHow to cope with compute-bound threads?\nHow to cope with compute-bound threads?\neach CPU has timer hardware, which interrupts periodically kernel uses timer interrupts to grab control from looping threads kernel saves thread state, switches, eventually resumes, restores that saved state for transparency\nRUNNING vs RUNNABLE\nthis is \u0026ldquo;pre-emptive\u0026rdquo; scheduling \u0026ndash; a forced yield of unaware code as opposed to cooperative scheduling, in which code yields voluntarily\nWhat to do with a thread that isn\u0026rsquo;t running? We need to set aside its state: registers, stack, memory though no need to worry about memory, it won\u0026rsquo;t go anywhere so implementation provides each thread with a stack and register save area need to track status of each thread RUNNING vs RUNNABLE vs SLEEPING\nin xv6:\n[simple diagram: processes, user stack, trapframe, kernel stack]\neach process has two threads, one user, one kernel a process is either executing its user thread, or in a system call or interrupt in its kernel thread kernel threads share kernel memory / data structures thus the kernel is a parallel program we\u0026rsquo;ll use \u0026ldquo;process\u0026rdquo; and \u0026ldquo;kernel thread\u0026rdquo; and \u0026ldquo;thread\u0026rdquo; as synonyms\noverview of thread switching in xv6 (the point: switch among threads to interleave many threads on each CPU)\n[diagram: P1, TF1, STACK1, swtch(), CTX1; CTXs, swtch(), STACKs, scheduler(), \u0026amp;c]\nTF = trapframe = saved user registers\rCTX = context = saved RISC-V registers getting from one process to another involves multiple transitions:\n​ user -\u0026gt; kernel; saves user registers in trapframe ​ kernel thread -\u0026gt; scheduler thread; saves kernel thread registers in context ​ scheduler thread -\u0026gt; kernel thread; restores kernel thread registers from ctx ​ kernel -\u0026gt; user; restores user registers from trapframe \u0026ldquo;context switch\u0026rdquo; \u0026ndash; the switch from one thread to another\nscheduler threads There\u0026rsquo;s one per core; each has a stack and a struct context kernel threads (processes) always switch to the current core\u0026rsquo;s scheduler thread which switches to another kernel thread, if one is RUNNABLE there are never direct kernel thread to kernel thread switches the reason: the scheduler\u0026rsquo;s separate stack simplifies cases like switching away from an exiting process the scheduler thread keeps scanning the process table until it finds a RUNNABLE thread (there may not be one!) if there is not RUNNABLE thread, the scheduler is \u0026ldquo;idle\u0026rdquo;\nnote: each core is either running its scheduler thread, or some other thread a given core runs only one thread at a time each thread is either running on exactly one core, or its registers are saved in its context if a thread isn\u0026rsquo;t running, its saved context refers to a call to swtch()\nstruct proc in proc.h p-\u0026gt;trapframe holds saved user thread\u0026rsquo;s registers p-\u0026gt;context holds saved kernel thread\u0026rsquo;s registers p-\u0026gt;kstack points to the thread\u0026rsquo;s kernel stack p-\u0026gt;state is RUNNING, RUNNABLE, SLEEPING, \u0026amp;c p-\u0026gt;lock protects p-\u0026gt;state (and other things\u0026hellip;)\nCode pre-emptive switch demonstration user/spin.c \u0026ndash; two CPU-bound processes my qemu has only one CPU let\u0026rsquo;s watch xv6 switch between them\nmake qemu-gdb gdb (gdb) c show user/spin.c spin you can see that they alternate, despite running continuously. xv6 is switching its one CPU between the two processes. how does the switching work?\nI\u0026rsquo;m going to cause a break-point at the timer interrupt.\n(gdb) b trap.c:207 (gdb) c (gdb) finish (gdb) where we\u0026rsquo;re in usertrap(), handling a device interrupt from the timer (timerinit() in kernel/start.c configures the RISC-V timer hardware).\nwhat was running when the timer interrupt happened?\n(gdb) print p-\u0026gt;name (gdb) print p-\u0026gt;pid (gdb) print/x *(p-\u0026gt;trapframe) (gdb) print/x p-\u0026gt;trapframe-\u0026gt;epc let\u0026rsquo;s look for the saved epc in user/spin.asm timer interrupted user code in the increment loop, no surprise\n(gdb) step ... into yield() in proc.c (gdb) next (gdb) print p-\u0026gt;state change p-\u0026gt;state from RUNNING to RUNNABLE -\u0026gt; give up CPU but want to run again. note: yield() acquires p-\u0026gt;lock since modifying p-\u0026gt;state and to prevent another CPU from running this RUNNABLE thread!\n(gdb) next 2 (gdb) step (into sched()) sched() makes some sanity checks, then calls swtch()\n(gdb) next 7 this is the context switch from a process\u0026rsquo;s kernel thread to the scheduler thread swtch will save the current RISC-V registers in first argument (p-\u0026gt;context) and restore previously-saved registers from 2nd argument (c-\u0026gt;context) let\u0026rsquo;s see what register values swtch() will restore\n(gdb) print/x cpus[0].context where is cpus[0].context.ra? i.e. where will swtch() return to? kernel.asm says it\u0026rsquo;s in the scheduler() function in proc.c\n(gdb) tbreak swtch (gdb) c we\u0026rsquo;re in kernel/swtch.S a0 is the first argument, p-\u0026gt;context a1 is the second argument, cpus[0].context swtch() saves current registers in xx(a0) (p-\u0026gt;context) swtch() then restores registers from xx(a1) (cpus[0].context) then swtch returns\nQ: swtch() neither saves nor restores $pc (program counter)! so how does it know where to start executing in the target thread?\nQ: why does swtch() save only 14 registers (ra, sp, s0..s11)? the RISC-V has 32 registers \u0026ndash; what about the other 18? zero, gp, tp t0-t6, a0-a7 note we\u0026rsquo;re talking about kernel thread registers all 32 user register have already been saved in the trapframe\nregisters at start of swtch:\n(gdb) print $pc -- swtch (gdb) print $ra -- sched (gdb) print $sp registers at end of swtch:\n(gdb) stepi 28 -- until ret (gdb) print $pc -- swtch (gdb) print $ra -- scheduler (gdb) print $sp -- stack0+??? -- entry.S set this up at boot (gdb) where (gdb) stepi we\u0026rsquo;re in scheduler() now, in the \u0026ldquo;scheduler thread\u0026rdquo;, on the scheduler\u0026rsquo;s stack\nscheduler() just returned from a call to swtch() it made that call a while ago, to switch to our process\u0026rsquo;s kernel thread that previous call saved scheduler()\u0026rsquo;s registers our processes\u0026rsquo;s call to swtch() restored scheduler()\u0026rsquo;s saved registers p here refers to the interrupted process\n(gdb) print p-\u0026gt;name (gdb) print p-\u0026gt;pid (gdb) print p-\u0026gt;state remember yield() acquired the process\u0026rsquo;s lock now scheduler releases it the scheduler() code looks like an ordinary acquire/release pair but in fact scheduler acquires, yield releases then yield acquires, scheduler releases unusual: the lock is released by a different thread than acquired it!\nQ: why hold p-\u0026gt;lock across swtch()? yield() acquires scheduler() releases could we release p-\u0026gt;lock just before calling swtch()?\np-\u0026gt;lock protects a few things: makes these steps atomic:\np-\u0026gt;state=RUNNABLE save registers in p-\u0026gt;context stop using p\u0026rsquo;s kernel stack ​ so other CPU\u0026rsquo;s scheduler won\u0026rsquo;t start running p until all steps complete\nmakes these steps atomic and uninterruptable:\np-\u0026gt;state=RUNNING move registers from context to RISC-V registers ​ so an interrupt won\u0026rsquo;t yield() and save not-yet-initialized\n​ RISC-V registers in context.\nscheduler()\u0026rsquo;s loop looks at all processes, finds one that\u0026rsquo;s RUNNABLE keeps looping until it finds something \u0026ndash; may be idle for a while in this demo, will find the other spin process let\u0026rsquo;s fast-forward to when scheduler() finds a RUNNABLE process\n(gdb) tbreak proc.c:474 (gdb) c scheduler() locked the new process, then set state to RUNNING now another CPUs\u0026rsquo; scheduler won\u0026rsquo;t run it\nit\u0026rsquo;s the other \u0026ldquo;spin\u0026rdquo; process:\n(gdb) print p-\u0026gt;name (gdb) print p-\u0026gt;pid (gdb) print p-\u0026gt;state let\u0026rsquo;s see where the new thread will start executing after swtch() by looking at $ra (return address) in its context\n(gdb) print/x p-\u0026gt;context (gdb) x/4i p-\u0026gt;context-\u0026gt;ra new thread will return into sched()\nlook at kernel/swtch.S (again)\n(gdb) tbreak swtch (gdb) c (gdb) stepi 28 -- now just about to execute swtch()\u0026#39;s ret (gdb) print $ra (gdb) where now we\u0026rsquo;re in a timer interrupt in the other spin process in the past it was interrupted, called yield() / sched() / swtch() but now it will resume, and return to user space\nnote: only swtch() writes contexts (except for initialization) only sched() and scheduler() call swtch() so for a kernel thread, context.ra always points into sched() and for a scheduler thread, context.ra always points into scheduler()\nnote: sched() calls swtch() \u0026ndash; then swtch() returns to sched() but it\u0026rsquo;s typically a different thread returning\nsched() and scheduler() are \u0026ldquo;co-routines\u0026rdquo; each knows what it is swtch()ing to each knows where swtch() return is coming from e.g. yield() and scheduler() cooperate about p-\u0026gt;lock and p-\u0026gt;state different from ordinary thread switching, where neither party typically knows which thread comes before/after\nQ: what is the \u0026ldquo;scheduling policy\u0026rdquo;?\ni.e. how does xv6 decide what to run next if multiple threads are RUNNABLE? is it a good policy?\nQ: is there pre-emptive scheduling of kernel threads?\nyes \u0026ndash; timer interrupt and yield() can occur while in kernel. yield() called by kerneltrap() in kernel/trap.c where to save registers of interrupted kernel code? not in p-\u0026gt;trapframe, since already has user registers. not in p-\u0026gt;context, since we\u0026rsquo;re about to call yield() and swtch() kernelvec.S pushes them on the kernel stack (since already in kernel). is pre-emption in the kernel useful? not critical in xv6. valuable if some system calls have lots of compute. or if we need a strict notion of thread priority.\nQ: why does scheduler() briefly enable interrupts, with intr_on()?\nThere may be no RUNNABLE threads They may all be waiting for I/O, e.g. disk or console Enable interrupts so device has a chance to signal completion and thus wake up a thread Otherwise, system will freeze\nQ: why does sched() forbid locks from being held when yielding the CPU?\n(other than p-\u0026gt;lock) i.e. sched() checks that noff == 1 suppose process P1 holding lock L1, yields CPU process P2 runs, tries acquire(L1) P2\u0026rsquo;s acquire spins with interrupts turned off so timer interrupts won\u0026rsquo;t occur so P2 won\u0026rsquo;t yield the CPU so P1 can\u0026rsquo;t execute so P1 won\u0026rsquo;t release L1, ever\nQ: can we get rid of the separate per-cpu scheduler thread?\ncould sched() directly swtch() to a new thread? so that sched() looks for next process to run? that would be faster \u0026ndash; avoids one of the swtch() calls yes \u0026ndash; but: scheduling loop would run on a thread\u0026rsquo;s kernel stack what if that thread is exiting? what if another cpu wants to run the thread? what if there are fewer threads than CPUs \u0026ndash; i.e. too few stacks? can be dealt with \u0026ndash; give it a try!\nSummary xv6 provides a convenient thread model for kernel code pre-emptive via timer interrupts transparent via switching registers and stack multi-core requires careful handling of stacks, locks next lecture: mechanisms for threads to wait for each other\nLab: Multithreading Uthread: switching between threads (moderate) 设计并实现用户级线程系统的上下文切换机制。xv6系统中提供了两个文件：uthread.c 和 uthread_switch.S，以及一个用于构建 uthread 程序的Makefile规则。uthread.c 包含了一个基本的用户级线程包以及三个测试线程的代码，但缺少创建线程和线程切换的部分代码。\n任务要求包括：\n实现线程创建和上下文切换的代码。 在线程第一次运行时，确保执行创建时传递的函数，并使用该线程的栈。 实现 thread_switch 来保存当前线程的寄存器，并恢复下一个线程的寄存器，以继续其执行。 1.添加utcontext结构体\n2.添加utcontext字段\nthread_create中保存ra和sp 4.补全uthread_switch.S， 完全参照swtch.S\n5.调用thread_switch，调用 thread_switch 切换上下文，传递当前线程和下一个线程的上下文， 注意这里上下文切换需要在最后实现，因为这会影响next_thread, 所以一定要在更新current_thread之后调用thread_switch。\nUsing threads (moderate) 目标：实现线程并行编程，使用pthread库在多线程环境下操作哈希表，并确保其线程安全。\n任务环境：在支持多核的真实Linux或MacOS计算机上完成，不使用xv6或qemu。\n初始问题：提供的哈希表仅在单线程情况下正确，多线程环境下会有缺失键的问题。\n步骤：\n使用pthread库对哈希表进行并发操作。 运行测试ph 1和ph 2，观察不同线程下的插入和获取性能。 分析缺失键出现的原因，提交解释（sequence of events）。 解决方案：在put()和get()函数中添加锁机制，确保多线程操作时没有键丢失。\n使用pthread_mutex_t相关函数实现加锁和解锁。 修改代码，通过测试ph_safe，确保两线程下无键丢失。 进一步优化：尝试在某些情况下允许并行插入操作，例如使用每个哈希桶（bucket）一个锁，以提高性能。\n修改代码，使其通过ph_safe和ph_fast测试，要求双线程至少达到单线程1.25倍的插入速度。 1.定义锁， 定义全局锁可以保证多线程情况下不会丢失key, 为每一个桶加锁可以在保证不丢失key的情况下保证性能\n2.初始化锁\n3.在put()和get()中加锁以及解锁\nBarrier(moderate) 实现一个线程屏障（barrier），即所有线程在同一点等待，直到所有线程都到达该点后再继续。需要使用 pthread 的条件变量 (pthread_cond_wait 和 pthread_cond_broadcast) 来协调线程。任务是在 barrier.c 中修复已存在的问题，确保所有线程在调用 barrier() 时都被阻塞，直到全部线程到达。\n关键要求：\n使用条件变量实现线程同步。 处理多次循环中的屏障调用，每次屏障都代表一个“回合”。 避免一个线程快速离开屏障并影响其他线程。 确保解决断言错误并通过测试。 在每一个thread中调用barrier， 记录所有到达的thread数量， 如果数量等于设置的线程数，则开始下一round，否则将此线程执行此操作 ：\npthread_cond_wait(\u0026amp;bstate.barrier_cond, \u0026amp;bstate.barrier_mutex); // Release mutex and wait 保证该线程处于等待状态，等待所有线程都完成此round。\n","permalink":"https://kennems.github.io/posts/tech/mit6.s08111--thread-switching/","summary":"MIT6.S081(11)- Thread switching Topic: more \u0026ldquo;under the hood\u0026rdquo; with xv6 Previously: system calls, interrupts, page tables, locks Today: process/thread switching Why support multiple tasks? Time-sharing: many users and/or many running programs. program structure: prime number sieve. parallel speedup on multi-core hardware. Threads are an abstraction to simplify programming when there are many tasks. thread = an independent serial execution \u0026ndash; registers, pc, stack the threading system interleaves the execution of","title":"MIT6.S081(11)- Thread switching"},{"content":"MIT6.S081(10)-Locking Why talk about locking? apps want to use multi-core processors for parallel speed-up so kernel must deal with parallel system calls and thus parallel access to kernel data (buffer cache, processes, \u0026amp;c) locks help with correct sharing of data locks can limit parallel speedup\nWhat goes wrong if we don\u0026rsquo;t have locks Case study: delete acquire/release in kalloc.c Boot kernel works! Run usertests all tests pass! except we lose some pages Why do we lose pages? picture of shared-memory multiprocessor race between two cores calling kfree() BUMMER: we need locks for correctness but loose performance (kfree is serialized)\nThe lock abstraction:\nlock l\racquire(l)\rx = x + 1 -- \u0026#34;critical section\u0026#34;\rrelease(l) a lock is itself an object if multiple threads call acquire(l) only one will return right away the others will wait for release() \u0026ndash; \u0026ldquo;block\u0026rdquo; a program typically has lots of data, lots of locks if different threads use different data, then they likely hold different locks, so they can execute in parallel \u0026ndash; get more work done. note that lock l is not specifically tied to data x the programmer has a plan for the correspondence\nWhen to Lock ? A conservative rule to decide when you need to lock: any time two threads use a memory location, and at least one is a write don\u0026rsquo;t touch shared data unless you hold the right lock!\n(too strict: program logic may sometimes rule out sharing; lock-free)\n(too loose: printf(); not always simple lock/data correspondence)\nCould locking be automatic? perhaps the language could associate a lock with every data object compiler adds acquire/release around every use less room for programmer to forget! that idea is often too rigid:\nrename(\u0026#34;d1/x\u0026#34;, \u0026#34;d2/y\u0026#34;):\rlock d1, erase x, unlock d1\rlock d2, add y, unlock d2 ​ problem: the file didn\u0026rsquo;t exist for a while! ​ rename() should be atomic ​ other system calls should see before, or after, not in between ​ otherwise too hard to write programs ​ we need:\nlock d1 ; lock d2\rerase x, add y\runlock d2; unlock d1 that is, programmer often needs explicit control over the region of code during which a lock is held in order to hide awkward intermediate states\nWays to think about what locks achieve locks help avoid lost updates locks help you create atomic multi-step operations \u0026ndash; hide intermediate states locks help operations maintain invariants on a data structure assume the invariants are true at start of operation operation uses locks to hide temporary violation of invariants operation restores invariants before releasing locks\nProblem: deadlock notice rename() held two locks what if:\ncore A core B\rrename(d1/x, d2/y) rename(d2/a, d1/b)\rlock d1 lock d2\rlock d2 ... lock d1 ... solution: ​ programmer works out an order for all locks ​ all code must acquire locks in that order ​ i.e. predict locks, sort, acquire \u0026ndash; complex!\nLocks versus modularity locks make it hard to hide details inside modules to avoid deadlock, I need to know locks acquired by functions I call and I may need to acquire them before calling, even if I don\u0026rsquo;t use them i.e. locks are often not the private business of individual modules\nLocks and parallelism locks prevent parallel execution to get parallelism, you often need to split up data and locks in a way that lets each core use different data and different locks \u0026ldquo;fine grained locks\u0026rdquo; choosing best split of data/locks is a design challenge whole FS; directory/file; disk block whole kernel; each subsystem; each object you may need to re-design code to make it work well in parallel example: break single free memory list into per-core free lists helps if threads were waiting a lot on lock for single free list such re-writes can require a lot of work!\nLock granularity advice start with big locks, e.g. one lock protecting entire module less deadlock since less opportunity to hold two locks less reasoning about invariants/atomicity required measure to see if there\u0026rsquo;s a problem big locks are often enough \u0026ndash; maybe little time spent in that module re-design for fine-grained locking only if you have to\nLet\u0026rsquo;s look at locking in xv6.\nA typical use of locks: uart.c typical of many O/S\u0026rsquo;s device driver arrangements diagram: user processes, kernel, UART, uartputc, remove from uart_tx_buf, uartintr() sources of concurrency: processes, interrupt only one lock in uart.c: uart_tx_lock \u0026ndash; fairly coarse-grained uartputc() \u0026ndash; what does uart_tx_lock protect? 1. no races in uart_tx_buf operations 2. if queue not empty, UART h/w is executing head of queue 3. no concurrent access to UART write registers uartintr() \u0026ndash; interrupt handler acquires lock \u0026ndash; might have to wait at interrupt level! removes character from uart_tx_buf hands next queued char to UART h/w (2) touches UART h/w registers (3)\nHow to implement locks?\nwhy not:\rstruct lock { int locked; }\racquire(l) {\rwhile(1){\rif(l-\u0026gt;locked == 0){ // A\rl-\u0026gt;locked = 1; // B\rreturn;\r}\r}\r} oops: race between lines A and B how can we do A and B atomically?\nAtomic swap instruction:\na5 = 1\rs1 = \u0026amp;lk-\u0026gt;locked\ramoswap.w.aq a5, a5, (s1) does this in hardware:\nlock addr globally (other cores cannot use it)\rtemp = *s5\r*addr = a5\ra5 = temp\runlock addr RISC-V h/w provides a notion of locking a memory location different CPUs have had different implementations diagram: cores, bus, RAM, lock thing so we are really pushing the problem down to the hardware h/w implements at granularity of cache-line or entire bus memory lock forces concurrent swamp to run one at a time, not interleaved\nLook at xv6 spinlock implementation\nacquire(l){\rwhile(__sync_lock_test_and_set(\u0026amp;lk-\u0026gt;locked, 1) != 0)\r} if l-\u0026gt;locked was already 1, sync_lock_test_and_set sets to 1 (again), returns 1, and the loop continues to spin if l-\u0026gt;locked was 0, at most one lock_test_and_set will see the 0; it will set it to 1 and return 0; other test_an_set will return 1 this is a \u0026ldquo;spin lock\u0026rdquo;, since waiting cores \u0026ldquo;spin\u0026rdquo; in acquire loop\nwhat is the push_off() about? why disable interrupts? release(): sets lk-\u0026gt;locked = 0 and re-enables interrupts\nDetail: memory read/write ordering suppose two cores use a lock to guard a counter, x and we have a naive lock implementation\nCore A: Core B:\rlocked = 1\rx = x + 1 while(locked == 1)\rlocked = 0 ...\rlocked = 1\rx = x + 1\rlocked = 0 the compiler AND the CPU re-order memory accesses i.e. they do not obey the source program\u0026rsquo;s order of memory references e.g. the compiler might generate this code for core A:\nlocked = 1\rlocked = 0\rx = x + 1 ​ i.e. move the increment outside the critical section! ​ the legal behaviors are called the \u0026ldquo;memory model\u0026rdquo; release()\u0026rsquo;s call to __sync_synchronize() prevents re-order ​ compiler won\u0026rsquo;t move a memory reference past a __sync_synchronize() ​ and (may) issue \u0026ldquo;memory barrier\u0026rdquo; instruction to tell the CPU acquire()\u0026rsquo;s call to __sync_synchronize() has a similar effect: if you use locks, you don\u0026rsquo;t need to understand the memory ordering rules ​ you need them if you want to write exotic \u0026ldquo;lock-free\u0026rdquo; code\nWhy spin locks? don\u0026rsquo;t they waste CPU while waiting? why not give up the CPU and switch to another process, let it run? what if holding thread needs to run; shouldn\u0026rsquo;t waiting thread yield CPU? spin lock guidelines: hold spin locks for very short times don\u0026rsquo;t yield CPU while holding a spin lock systems provide \u0026ldquo;blocking\u0026rdquo; locks for longer critical sections waiting threads yield the CPU but overheads are typically higher you\u0026rsquo;ll see some xv6 blocking schemes later\nAdvice: don\u0026rsquo;t share if you don\u0026rsquo;t have to start with a few coarse-grained locks instrument your code \u0026ndash; which locks are preventing parallelism? use fine-grained locks only as needed for parallel performance use an automated race detector\nLab: Copy-on-Write Fork for xv6 Implement copy-on write(hard) ","permalink":"https://kennems.github.io/posts/tech/mit6.s08110-locks/","summary":"MIT6.S081(10)-Locking Why talk about locking? apps want to use multi-core processors for parallel speed-up so kernel must deal with parallel system calls and thus parallel access to kernel data (buffer cache, processes, \u0026amp;c) locks help with correct sharing of data locks can limit parallel speedup What goes wrong if we don\u0026rsquo;t have locks Case study: delete acquire/release in kalloc.c Boot kernel works! Run usertests all tests pass! except we lose","title":"MIT6.S081(10)-Locking"},{"content":"MIT6.S081(9)-Interrupts 6.S081 2020 Lecture 9: Interrupts\nInterrupts hardware wants attention now! e.g., pkt arrived, clock interrupt software must set aside current work and respond on RISC-V use same trap mechanism as for syscalls and exceptions new issues/complications: asynchronous interrupts running process interrupt handler may not run in context of process who caused interrupt concurrency devices and process run in parallel programming devices device can be difficult to program\nWhere do device interrupts come from? diagram: Fig 1 of SiFive board in FU540-C000-v1.0.pdf CPUs, CLINT, PLIC, devices Fig 3 has more detail for interrupts Section 8 and 9 of FU540-C000-v1.0.pdf UART (universal asynchrnonous receiver/transmitter) See Section 13 of FU540-C000-v1.0.pdf Although the QEMU version is slightly different Follows http://byterunner.com/16550.html the interrupt tells the kernel the device hardware wants attention the driver (in the kernel) knows how to tell the device to do things often the interrupt handler calls the relevant driver but other arrangements are possible (schedule a thread; poll) [diagram: top-half/bottom-half]\nCase study: console output and keyboard input $ ls how does $ show up on console? printing to simulated console: driver puts characters into UART\u0026rsquo;s send FIFO interrupt when character has been sent informs driver that it can send more how are the characters l and s read from keyboard (and echo to console)? reading from simulated keyboard user hits key, which returns in UART interrupt driver gets character from UART\u0026rsquo;s receive FIFO\nhow does kernel know which device interrupted? each device has a unique source/IRQ (interrupt request) number defined by hardware platform UART0 is 10 on qemu (see kernel/memlayout.h) different on SiFive board\nRISC-V interrupt-related registers sie \u0026mdash; supervisor interrupt enabled register one bit per software interrupt, external interrupt, timer interrupt sstatus \u0026mdash; supervisor status register one bit to enable interrupts sip \u0026mdash; supervisor interrupt pending register scause \u0026mdash; supervisor cause register stvec \u0026mdash; supervisor trap vector register mdeleg \u0026mdash; machine delegate register\nLet\u0026rsquo;s look at how xv6 sets up the interrupt machinery start(): w_sie(r_sie() | SIE_SEIE | SIE_STIE | SIE_SSIE); main(): consoleinit(); uartinit() plicinit(); scheduler(); intr_on(); w_sstatus(r_sstatus() | SSTATUS_SIE);\nPrinting \u0026ldquo;$\u0026rdquo; shell is started with fd 0, 1, 2 for \u0026ldquo;console\u0026rdquo; setup by init Unix presents console device as a file!\nprintf() putc() write(2, \u0026ldquo;$\u0026rdquo;, 1)\nsys_write() filewrite() consolewrite() uartputc() add \u0026ldquo;$\u0026rdquo; to buffer uartstart() // kick off sending character put the character in UART fifo return to user space \u0026hellip; while at the same time UART is sending character to console\nshell calls sys_read() to wait for input (see below)\nUART completes sending character and raises interrupt PLIC passes interrupt on to a CPU the CPU performs the following steps on interrupt: - If the trap is a device interrupt, and the SIE bit is clear, don\u0026rsquo;t do any of the following. - Disable interrupts by clearing SIE. Prevents interrupts being interrupted - Copy the pc to sepc - Save the current mode (user or supervisor) in the SPP bit in sstatus. - Set scause to reflect the interrupt\u0026rsquo;s cause. - Set the mode to supervisor. - Copy stvec to the pc. stvec contains kernelvec or usertrap, depending if interrupt happened in user space or kernel space - Start executing at the new pc. same mechanism we have seen before systems calls, pgfaults, etc.\nboth kernelvec/usertrap call devintr() to check for interrupts\rexternal interrupt for UART\rplic_claim()\ruartintr()\rif there are more characters send them\rmay send multiple characters\rplic_complete()\rreturn from kernelvec/usertrap\rresumes interrupted computation\rWhat if several interrupts arrive? The PLIC distributes interrupts among cores Interrupts can be handled in parallel If no CPU claims the interrupt, the interrupt stays pending Eventually each interrupt is delivered to some CPU\nInterrupts expose several forms of concurrency\nBetween device and CPU Producer/consumer parallelism\rInterrupt may interrupt the CPU that is returning to shell (still in kernel) Disable interrupts when code must be atomic\rInterrupt may run on different CPU in parallel with shell (or returning to shell) Locks; topic for Wed\rProducer/consumer parallelism For printing shell is producer device is consumer To decouple the two: a buffer in the driver top-half puts chars into buffer wait if there is no room runs in the context of the calling process bottom half remove chars from buffer interrupt handler wakes up producers may not run the context of the shell Note: bottom half and top half may run in parallel on different CPUs We will get to this in a later lecture\nInterrupts interrupt running code Interrupts run between my code For example, my code is 1. addi sp,sp,-48 2. sd ra,40(sp) Q: Might other code run between 1 and 2? Yes! Interrupt may happen between 1 and 2 e.g., timer interrupt or uart interrupt For user code maybe not that bad Kernel will resume user code in in the same state For kernel code could be difficult Interrupt handler may update state that is observable by my code my code: interrupt: x = 0 if x = 0 then x = 1 f() f() may be executed or may not be executed! To make a block of code \u0026ldquo;atomic\u0026rdquo;, turn off interrupts intr_off(): w_sstatus(r_sstatus() \u0026amp; ~SSTATUS_SIE); RISC-V turns of interrupt on a trap (interrupt/exception) Can kernel handle interrupt in trampoline.S? Our first glimps of \u0026ldquo;concurrency\u0026rdquo; We\u0026rsquo;ll get back to this when discussing locking\n$ shell is in read system call to get input from console usertrap() for system call w_stvec((uint64)kernelvec); consoleread() sleep() scheduler() intr_on()\n$ l user hits l, which causes UART interrupt\nkernelvec: save space on current stack; which stack? save registers on the current stack in our example, the scheduler thread\u0026rsquo;s stack kerneltrap() devintr() uartintr() c = uartgetc() consoleintr(c) handle ctrl characters echo character (\u0026rsquo;l\u0026rsquo;) using uartput_sync() put c in buffer wakeup reader return from devintr() return from kerneltrap() load registers back sret Q: where does sret return too where ever the interrupt happened (in scheduler loop in this case) scheduler runs shell so that it can collect \u0026rsquo;l'\nProducer/consumer parallelism For reading from keyboard opposite from printing shell is consumer device is producer\nInterrupt evolution Interrupts used to be relatively fast; now they are slow old approach: every event causes an interrupt, simple h/w, smart s/w new approach: h/w completes lots of work before interrupting Some devices generate events faster than one per microsecond e.g. gigabit ethernet can deliver 1.5 million small packets / second An interrupt takes on the order of a microsecond save/restore state cache misses what to do if interrupt comes in faster than 1 per microsecond?\nPolling: another way of interacting with devices Processor spins until device wants attention Wastes processor cycles if device is slow One example in xv6: uartputc_sync() But inexpensive if device is fast No saving of registers etc. If events are always waiting, no need to keep alerting the software\nPolling versus interrupts Polling rather than interrupting, for high-rate devices Interrupt for low-rate devices, e.g. keyboard constant polling would waste CPU Switch between polling and interrupting automatically interrupt when rate is low (and polling would waste CPU cycles) poll when rate is high (and interrupting would waste CPU cycles) Faster forwarding of interrupts to user space for page faults and user-handled devices h/w delivers directly to user, w/o kernel intervention? faster forwarding path through kernel? We will be seeing many of these topics later in the course\nhardware wants attention now ! Driver RISC-V support for interrupts SIE : supervisor interrupt enabled register\nSSTATUS ：supervisor status register one bit to enable interrupts\nSIP : supervisor interrupt pending register\nSCAUSE : supervisor cause register\nSTVEC : supervisor trap vector register\nMDELEG : machine delegate register\nProducer / consumer parallelism For reading from keyboard opposite from printing\nshell is consumer device is producer Interrupt evolution Polling\nPolling versus interrupts Polling rather than interrupting, for high-rate devices\nInterrupt for low-rate devices, e.g. keyboard\n","permalink":"https://kennems.github.io/posts/tech/mit6.s0819-interrupts/","summary":"MIT6.S081(9)-Interrupts 6.S081 2020 Lecture 9: Interrupts Interrupts hardware wants attention now! e.g., pkt arrived, clock interrupt software must set aside current work and respond on RISC-V use same trap mechanism as for syscalls and exceptions new issues/complications: asynchronous interrupts running process interrupt handler may not run in context of process who caused interrupt concurrency devices and process run in parallel programming devices device can be difficult to program Where do","title":"MIT6.S081(9)-Interrupts"},{"content":"MIT6.S081(8)-Page faults plan: cool things you can do with vm\nBetter performance/efficiency e.g., one zero-filled page e.g., copy-on-write fork New features e.g., memory-mapped files virtual memory: several views\nprimary purpose: isolation each process has its own address space Virtual memory provides a level-of-indirection provides kernel with opportunity to do cool stuff already some examples: shared trampoline page guard page but more possible\u0026hellip; Key idea: change page tables on page fault Page fault is a form of a trap (like a system call) Xv6 panics on page fault But you don\u0026rsquo;t have to panic! Instead: update page table instead of panic restart instruction (see userret() from traps lecture) Combination of page faults and updating page table is powerful!\nRISC-V page faults 3 of 16 exceptions are related to paging Exceptions cause controlled transfers to kernel See traps lecture\nInformation we might need at page fault to do something interesting:\nThe virtual address that caused the fault See stval register; page faults set it to the fault address The type of violation that caused the fault See scause register value (instruction, load, and Store page fault) The instruction and mode where the fault occurred User IP: tf-\u0026gt;epc U/K mode: implicit in usertrap/kerneltrap lazy/on-demand page allocation\nsbrk() is old fashioned; applications often ask for memory they need for example, the allocate for the largest possible input but an application will typically use less if they ask for much, sbrk() could be expensive for example, if all memory is in use, have to wait until kernel has evicted some pages to free up memory sbrk allocates memory that may never be used. moderns OSes allocate memory lazily plan: allocate physical memory when application needs it adjust p-\u0026gt;sz on sbrk, but don\u0026rsquo;t allocate when application uses that memory, it will result in page fault on pagefault allocate memory resume at the fault instruction may use less memory if not used, no fault, no allocation spreads the cost of allocation over the page faults instead of upfront in sbrk() demo modify sysproc.c modify trap.c modify vm.c one zero-filled page (zero fill on demand)\napplications often have large part of memory that must zero global arrays, etc. the \u0026ldquo;block starting symbol\u0026rdquo; (bbs) segment thus, kernel must often fill a page with zeros idea: memset one page with zeros map that page copy-on-write when kernel needs zero-filled page on write make copy of page and map it read/write in app address space copy-on-write fork\nobservation: xv6 fork copies all pages from parent (see fork()) but fork is often immediately followed by exec idea: share address space between parent and child modify fork() to map pages copy-on-write use extra available system bits (RSW) in PTEs on page fault, make copy of page and map it read/write demand paging\nobservation: exec loads the complete file into memory (see exec.c) expensive: takes time to do so (e.g., file is stored on a slow disk) unnecessary: maybe not the whole file will be used idea: load pages from the file on demand allocate page table entries, but mark them on-demand on fault, read the page in from the file and update page table entry need to keep some meta information about where a page is located on disk this information is typically in structure called virtual memory area (VMA) challenge: file larger than physical memory (see next idea) use virtual memory larger than physical memory\nobservation: application may need more memory than there is physical memory idea: store less-frequently used parts of the address space on disk page-in and page-out pages of the address address space transparently works when working sets fits in physical memory most popular replacement strategy: least-recently used (LRU) the A(cess) bit in the PTE helps the kernel implementing LRU demo: run top and vmstat on laptop and dialup.athena.mit.edu see VIRT RES MEM SHR columns memory-mapped files\nidea: allow access to files using load and store can easily read and writes part of a file e.g., don\u0026rsquo;t have to change offset using lseek system call Unix systems a new system call for m-mapped files: void *mmap(void *addr, size_t length, int prot, int flags, int fd, off_t offset); kernel page-in pages of a file on demand when memory is full, page-out pages of a file that are not frequently used shared virtual memory\nidea: allow processes on different machines to share virtual memory gives the illusion of physical shared memory, across a network replicate pages that are only read invalidate copies on write TLB management CPUs caches paging translation for speed xv6 flushes entire TLB during user/kernel transitions why? RISC-V allows more sophisticated plans\nPTE_G: global TLB bits what page could use this? ASID numbers TLB entries are tagged with ASID, so kernel can flush selectively SATP takes an ASID number sfence.vma also takes an ASID number Large pages 2MB and 1GB Virtual memory is still evolving Recent changes in Linux PKTI to handle meltdown side-channel (https://en.wikipedia.org/wiki/Kernel_page-table_isolation) xv6 basically implements KPTI Somewhat recent changes Support for 5-level page tables (57 address bits!) Support for ASIDs Less recent changes Support for large pages NX (No eXecute) PTE_X flag\n\u0026mdash; COW in Linux\nhttps://lwn.net/Articles/849876/\nPage faults Virtual Memory Benefits Isolation Level of Indirection Va -\u0026gt; Pa\nInformation Needed the faulting va ( va -\u0026gt; stval register) the type of page fault ( scause ) the va of instruction that cause the page fault (sepc, trapframe) Allocation : sbrk() sbrk() -\u0026gt; eager allocation\napplcations tend to over ask.\nLazy allocation sbrk() do nothing\nonly grow p-\u0026gt;sz\nPgFault : va \u0026lt; p-\u0026gt;sz \u0026gt; stack\nallocate 1 page\nzero the page\nmap the page\nrestart instruction\nCopy-on-Write(Cow) - Fork Zero-fill-on-demand Demand paging Memory-mapped-files shared virtual memory Lab: xv6 lazy page allocation Eliminate allocation from sbrk() (easy) Lazy allocation (moderate) Lazytests and Usertests (moderate) ","permalink":"https://kennems.github.io/posts/tech/mit6.s0818-page-faults/","summary":"MIT6.S081(8)-Page faults plan: cool things you can do with vm Better performance/efficiency e.g., one zero-filled page e.g., copy-on-write fork New features e.g., memory-mapped files virtual memory: several views primary purpose: isolation each process has its own address space Virtual memory provides a level-of-indirection provides kernel with opportunity to do cool stuff already some examples: shared trampoline page guard page but more possible\u0026hellip; Key idea: change page tables on page fault","title":"MIT6.S081(8)-Page faults"},{"content":"周赛250915 时隔多日再才重新开启周赛。这场DP居多。\nT2-3290. 最高乘法得分 题目大意： 给定两个数组 a 和 b，数组 a 长度为 4，数组 b 长度至少为 4。需要从 b 中选择 4 个递增下标 i0 \u0026lt; i1 \u0026lt; i2 \u0026lt; i3，计算 a[0] * b[i0] + a[1] * b[i1] + a[2] * b[i2] + a[3] * b[i3]，并返回最大得分。\n代码实现思路： 使用动态规划的思想解决问题。定义 f[i][j] 表示在前 i 个元素中选择了 j 个数时的最大得分。 初始化 f[0][0] = 0，表示在没有元素的情况下选择 0 个数时得分为 0，其余情况初始化为负无穷大。 遍历数组 b，对于每一个位置 i，我们可以选择保留当前状态（即不选第 i 个元素，继承上一个状态的值），或者选择第 i 个元素（更新当前状态，计算乘积并加到上一个状态 f[i-1][j-1] 中）。 最后，结果就是从长度为 4 的选择中得到的最大得分 max(f[i][4])。 class Solution: def maxScore(self, a: List[int], b: List[int]) -\u0026gt; int: n = len(b) f = [[-inf]*5 for _ in range(n + 1)] # f[i][j] 表示 b 中 前 i 个数字(不包括i)中选 j 个可以获得的最大得分 f[0][0] = 0 for i in range(1, n + 1): for j in range(min(4, i) + 1): f[i][j] = f[i-1][j] if j: f[i][j] = max(f[i][j], f[i-1][j-1] + a[j - 1] * b[i - 1]) return max(f[i][4] for i in range(4, n + 1)) T3\u0026amp;4-3291. 形成目标字符串需要的最少字符串数 I 题目大意： 给定一个字符串数组 words 和一个目标字符串 target，需要通过连接 words 中的有效前缀字符串组成目标字符串 target。要求计算连接有效字符串形成 target 所需的最少字符串数量。如果无法组成 target，返回 -1。\n代码实现思路： 使用 Z 函数 计算 words 中每个字符串与 target 对应位置的最长匹配前缀，得到每个位置能匹配的最大长度 nxt 数组。 动态规划数组 f[i] 表示到达 target 的第 i 个字符所需的最少字符串数量，初始时 f[0] = 0，表示到达初始位置需要 0 个字符串。 遍历 target，如果某个位置无法通过前面的组合到达，则返回 -1；否则根据前面的匹配情况不断更新 f 数组，记录当前能够延伸的最长有效前缀 last。 在遍历过程中，如果找到一个位置 i，可以用更少的字符串覆盖更长的前缀，则更新 f 数组和 last。 最后返回 f[n]，即完整匹配 target 所需的最少字符串数。 def z_function(s): n = len(s) z = [0] * n l, r = 0, 0 for i in range(1, n): if i\u0026lt;=r and z[i - l] \u0026lt; r - i + 1: z[i] = z[i-l] else: z[i] = max(0, r - i + 1) while i + z[i] \u0026lt; n and s[z[i]] == s[i + z[i]]: z[i] += 1 if i + z[i] - 1 \u0026gt; r: l, r = i, i + z[i] - 1 return z class Solution: def minValidStrings(self, words: List[str], target: str) -\u0026gt; int: n = len(target) nxt = [0] * n for w in words: s = w + \u0026#39;#\u0026#39; + target z = z_function(s) for i in range(n): nxt[i] = max(nxt[i], z[i + len(w) + 1]) f = [-1] * (n + 1) f[0] = 0 last = 0 # 所有 words 可以拓展到的target的最长长度 for i in range(n): if f[i] == -1: continue if i \u0026gt; last: return -1 nx = nxt[i] if i + nx \u0026gt; last: for j in range(last + 1, i + nx + 1): f[j] = f[i] + 1 last = i + nx if last == n: break return f[n] ","permalink":"https://kennems.github.io/posts/tech/%E5%91%A8%E8%B5%9B240915/","summary":"周赛250915 时隔多日再才重新开启周赛。这场DP居多。 T2-3290. 最高乘法得分 题目大意： 给定两个数组 a 和 b，数组 a 长度为 4，数组 b 长度至少为 4。需要","title":"LeetCode周赛415(250915)"},{"content":"MIT6.S081(7)-Q\u0026amp;A Plan: answering your questions Approach: walk through staff solutions start with pgtbl lab because it was the hardest your questions are at bottom of this file\nPgtbl lab comments few lines of code, but difficult-to-debug bugs\nworst case: qemu/xv6 stops running \u0026ldquo;best\u0026rdquo; case: kernel panic hard to debug for staff too there are so many possible reasons why you discovered once we hadn\u0026rsquo;t seen yet likely to be the most challenging lab historically the first VM lab is hard this year too, even though we made a new lab to provide a gentler intro to VM Part 1 of pgtbl lab Explain vm output in terms of fig 3-4\npage table 0x0000000087f67000 ..0: pte 0x0000000021fd8c01 pa 0x0000000087f63000 fl 0x0000000000000001 .. ..0: pte 0x0000000021fd8801 pa 0x0000000087f62000 fl 0x0000000000000001 .. .. ..0: pte 0x0000000021fd901f pa 0x0000000087f64000 fl 0x000000000000001f .. .. ..1: pte 0x0000000021fd840f pa 0x0000000087f61000 fl 0x000000000000000f .. .. ..2: pte 0x0000000021fd801f pa 0x0000000087f60000 fl 0x000000000000001f ..255: pte 0x0000000021fd9801 pa 0x0000000087f66000 fl 0x0000000000000001 .. ..511: pte 0x0000000021fd9401 pa 0x0000000087f65000 fl 0x0000000000000001 .. .. ..510: pte 0x0000000021fdd807 pa 0x0000000087f76000 fl 0x0000000000000007 .. .. ..511: pte 0x0000000020001c0b pa 0x0000000080007000 fl 0x000000000000000b\nwhat is entry 0, 1, and 2?\rwhat is 510 and 511?\r- 511: trampoline\r- 510: trapframe\rwhy are the protection bits as they are?\r- 510: RWV\r- 511: XV\r- 1: no U\rare the physical addresses contiguous?\rPart 2 of pgtbl lab Add a kernel page table to each process in prep for Part 3\nexact copy of the kernel_pagetable How hard can this be? hard! some reasons:\nxv6 code specialized to one kernel page table no kvmcreate_page_table() kvminit() isn\u0026rsquo;t the full story also mappings in procinit(), and virtio_disk.c cleanup must be done care don\u0026rsquo;t free kernel stacks easy to make a small error even small errors are time consuming Two possible approaches to part II\ngeneralize kvminit() create a new per-process kernel page table\rshare kernel_pagetable make the per-process kernel page table share much with kernel_pagetable\r- my solutions takes approach 2; other staff members too approach 1\r- i took approach 2 mostly out of \u0026quot;laziness\u0026quot;\rdon't have to think too hard what is in the kernel_pagetable\rdidn't want to write much code\r- not sure it is shorter, though\rapproach 2 has some benefits I didn't realize\r- avoided certain class of bugs (e.g., kernel stacks)\rImplementation approach: small incremental baby steps keep existing code working allows comparing old and new easily allows rolling back easily\nApproach 2\nkvmcreate() copy entries 1..512 add a few devices that live in 0 anything below 1G (i.e., all devices) kvmfree() only entry 0 is worth considering just need to free intermediate pages (see 3-level pic) a bit ugly where to call kvmfree() exit()? freeproc()? scheduler() usertrapret() Part 3 of pgtbl lab map user pgtbl of process into bottom of process\u0026rsquo;s kernel page table\ndraw figure why? convenient for kernel programmers can replace copyin with copy_new() copyin_new is just a memmove(), avoid the walkaddr()\u0026rsquo;s hardware can do the walks for us mapping user page tables into kernel page table\nkvmmapuser() copies upte into kpte, adjust permissions Using kvmmapuser():\nuserinit() exec() no need to replace kernel page table fork() sbrk() memmove()\nwhy the checks before the memmove()? what does each case cover Syscall lab systems calls look like functions calls BUT they are not function calls\nU/K boundary transition user/usys.pl generates stubs for stubs kernel/syscall.c demultiplexes system calls trace proc.h fork() sysinfo copyout() Util lab primes\nclose fd\u0026rsquo;s to terminate correctly xargs setting up argv === Questions ===\nHW\n===\nIn the page table lab, the kernel\u0026rsquo;s hardware address translator won\u0026rsquo;t allow kernel to dereference user pages. More specifically, if the page table entry has \u0026ldquo;PTE_U\u0026rdquo; bit set, which means user can access it, then kernel won\u0026rsquo;t be able to access it through the hardware address translator unless we set \u0026ldquo;PTE_U\u0026rdquo; to false in the per-process kernel page table. Is there a specific reason for this?\n===\nWhy is the kernel not allowed to read memory mapped with the PTE_U flag? To prevent malicious memory from being read?\n===\nIn the last lecture, it was mentioned that even the kernel in supervisor mode could not directly edit anything and everything in the memory. The kernel accesses memory through the kernel page table, and thus is limited. However, couldn\u0026rsquo;t the kernel just set the satp register to 0, and then there is no MMU translation, the CPU directly accesses physical addresses. Could that situation not arise? That certainly the case before page tables are set up and paging is enabled.\n===\nA minor question: why the specific order of the trapframe in proc.h (t0..t2, then s0, s1, a0..a7, s2..s11)?\n===\nPGTBL LAB\nI\u0026rsquo;m confused why the kernel can directly dereference the pointer in part 3 of pagetable because we have now mapped the user\u0026rsquo;s virtual address into the user\u0026rsquo;s kernel pagetable. Since it is still a virtual address, doesn\u0026rsquo;t it need to just walk the user\u0026rsquo;s kernel page table? Or is it because the user code now enters the kernel, and the kernel\u0026rsquo;s pagetable directly maps virtual addresses to physical addressses? However, in my implementation, it seems to be that the kernel still maps the same virtual addresses to the same physical addresses as the user\u0026rsquo;s page table, , which is not a direct mapping.\n===\nIn the pgtbl lab, during Part 3 (copyin), I ran into an interesting bug while changing a process\u0026rsquo;s user mappings. In fork(), I was calling my helper function to copy the user mappings from the process\u0026rsquo;s user page table to its kernel page table. When I tried to copy the parent process\u0026rsquo;s user page table, running \u0026ldquo;usertests\u0026rdquo; in the xv6 kernel just caused it to return and none of the tests were run. However, copying the child\u0026rsquo;s user page table worked. Shouldn\u0026rsquo;t either instruction be ok, since the child\u0026rsquo;s user page table was just copied over from the parent?\n===\nFor the page tables lab, what was the correct way to copy and change the process\u0026rsquo;s kernel page table the same way in fork(), exec(), and sbrk()? I tried to copy over a range of entries from the process\u0026rsquo;s page table into the process\u0026rsquo;s kernel page table directly, but my code was panicking when trying to use mappages() after my change to the 3 functions.\n===\nIf xv6 was written with the modifications from the pgtbl lab, we would not need to worry about switching the pagetables in the trampline code, right? Would there even be a need for the trampoline code to be mapped in the user pages? My understanding was that that code can be mapped in the per-process kernel pgtbls and be used from there during the trap handling. I was also curious about why when a PTE has the PTE_U bit is set, code in supervisor mode cannot access that page table. It is confusing to me because I thought that the kernel has the whole memory mapped and it can modify any virtual address even if some user data lives there. In the last lab, we could even know the exact va that the user pgtbl has for each of the pa that it uses and I think maybe be able to corrupt user\u0026rsquo;s data.\n===\nIs there a more efficient way to free each process\u0026rsquo;s kernel pagetable? I basically copied the freewalk function and removed the panic for leaves. Although this seemed fast enough for the tests, it still seemed a little slow. When I tried to optimize it by reducing recursion depth, I ran into troubles. Overall, this seems like a computationally intensive task, especially if all physical memory is mapped in the kernel pagetable for all processes. I was a little worried about breaking something, but could I have stopped mapping all physical memory?\n===\nDo operating systems using hierarchical pagetables ever set up the pagetable pages so that the lower parts of the hierachy are (atleast in part) shared?\n===\nFor the pagetable lab, I was trying to implement copyin/copyinstr. However, I got stuck in an infinite loop with the scheduler because the scheduler seemed to have no process that needs to be run. I am curious as to what could happen to the pagetable so that the OS would stop a process from running (especially the main process). What part of the code does the operating system set the state of a process to not running if the pagetable is broken?\n===\nI don\u0026rsquo;t understand why when I moved\nw_satp(MAKE_SATP(kernel_pagetable)); sfence_vma();\noutside of\nif(found == 0) { intr_on(); asm volatile(\u0026ldquo;wfi\u0026rdquo;); }\nin scheduler that everything in part 2 of the page table lab worked. Because before then, it worked to a certain degree, where sometimes it\u0026rsquo;d pass and sometimes it\u0026rsquo;d fail.\n===\nIn the pagetable lab, is there a significant impact on performance from copying to per-process kernel page tables so frequently? If so, how does this balance out with the improvements that come from being able to directly de-reference user address in kernel space?\n===\nHow are pipes implemented in xv6, and how would the changes to the page tables implemented in the pgtbl lab effect this implementation? Do the per-process page tables hinder each process\u0026rsquo; ability to communicate with each other?\n===\nWhy did uvmfree/freewalk originally panic at a leaf, and why did we need to change that.\nWhy does the inclusion of the user PTE_U bit not allow the kernel to access the PTE?\n===\nThe lab mentioned that \u0026ldquo;the goal of this section and the next is to allow the kernel to directly dereference user pointers.\u0026rdquo; However, I didn\u0026rsquo;t understand how this adds functionality to the kernel, or why this is an important function for the kernel to be able to do.\n===\nFor the page table lab, I had some questions on access rights. If the user bit is set, does that mean in user mode both read/write/execute options can be performed, or can only read/write/execute be done in kernel mode?\nAlso, are there pages in the kernel page table accessible in user mode?\n===\nIn the pgtbl lab, we added kernel pagetables to each process in order to simplify reading userspace pointers. Was there any reason we couldn\u0026rsquo;t do the same for copying data out to userspace? I think you\u0026rsquo;d have to be a little careful in exec(), since copyout is used there while setting up the process, but apart from that?\nAlso, one of the challenge exercises for that lab is to remove the PLIC limit. How would you do that\u0026ndash;set up a new pagetable for PLIC access, and switch to that when trying to access PLIC registers?\n===\nI was talking to some friends who solved the pagetable part 3 by using a modified uvmcopy but they needed to limit the pages they were copying to pass the runtime limit. What\u0026rsquo;s taking so long in that function? Does the walking make the copy function less optimized for the job?\n===\nQuestion: About the page table lab, when I was debugging my code, I realized for reparent test, I sometimes pass it but I sometimes fail. I fixed this issue by realizing I need to switch back to kernel_pagetable in the scheduler after exiting the process\u0026rsquo;s kernal pagetable. I wonder why such mistakes would cause reparent to behave non-deterministaclly? Was there some sort of race condition?\n===\nIn our \u0026ldquo;copy user page table to kernel page table\u0026rdquo; functions in the pagetable lab, why was it necessary to panic when a pagetable entry didn\u0026rsquo;t exist or was not valid for a given virtual address? Why couldn\u0026rsquo;t we have just skipped that virtual address? More broadly, how could we assume that all of the user page table values that we were copying over were present and valid?\n===\nIt really messes with my head that you have to define a C function for allocating memory (kalloc). This is one of the first things xv6 does in main.c, directly after which it creates the kernel page table (using a call to kalloc). Given the way kalloc works, is the kernel page table always going to be at the \u0026ldquo;end\u0026rdquo; address in the kernel\u0026rsquo;s virtual memory space since its the first piece of memory to be allocated? And do you have to be careful about using memory prior to calling kinit in main.c?\n===\nThis question is regarding the pgtbl lab. I had some confusion about the exact motivation for the lab, specifically creating a separate kernel page table for each process. I wasn\u0026rsquo;t sure what the lab meant by \u0026ldquo;directly dereferencing the user address\u0026rdquo;. From my understanding, what the kernel currently does to translate the virtual address of the user process is to \u0026ldquo;walk\u0026rdquo; down the user pagetable.\nSo if you essentially combine the kernel page table and user page tables, wouldn\u0026rsquo;t you still \u0026ldquo;walk\u0026rdquo; down the new per-process kernel page table to get the physical address? I don\u0026rsquo;t understand how this changes anything since the two approaches differ only in which page table the kernel is walking down.\n===\nFor question 1 in the page table lab, was page 1 the guard page? This made sense to me since it has the user flag off so it would cause errors if the user tried to access it. However I believe the textbook said that the guard page will have its valid bit off in which case it would not show up in vmprint.\n====\nWhy does the initial page table ( as printed in vmprint ) have indices 0 and 255?I deduced that these pages should eventually point towards the initial user program data ( text, guard page and stack ) and the trampoline/trapframe respectively. However, the trampoline should be at the very top of the virtual address space, so it should have the highest possible virtual address. Therefore, shouldn\u0026rsquo;t the root page table contain pages 0 and 511 rather than 0 and 255?\n====\nVM IN GENERAL\n====\nHow was copyin with per process kernel pagetables exploited, as mentioned in the pgtbl lab?\n===\nThis is less of a question, but I\u0026rsquo;d love to hear more about how Xv6 compares to various other operating systems that we might use in our day-to-day lives.\nI don\u0026rsquo;t have specific questions, but for example:\nHow does Linux set up its page tables? The lab mentioned this may have changed with Spectre/Meltdown, but what do they do now?\nDo we know how pages/traps are handled in Windows or macOS, or what tradeoffs were made in the design decisions there? I read somewhere that Windows XP source code leaked - did we learn anything interesting from that, or does Microsoft just use standard techniques?\nDoes x86-64 have instructions that significantly simplify or combine or increase performance of particular parts of the pagetable or traps chain of code in interesting ways?\nHow active is the development of OS techniques like syscalls, pagetables, etc.? Are they mostly considered a \u0026ldquo;solved\u0026rdquo; problem by modern operating systems and only really experimented on in research?\n===\nSYSCALL LAB\n===\nCould you possibly walk through the roles of the different places we had to update when we added a new system call? (e.g. user/user.h, user/usys.pl, kernel/syscall.h, and a few others)\nI\u0026rsquo;m mostly wondering (1) in what order these are visited when the code is compiled and (2) why there isn\u0026rsquo;t a more centralized way to do this? For example, in kernel/syscall.c, why do we need to manually edit both the extern list and the syscalls array beneath it?\n===\nUTIL LAB\n===\nOne of the challenges for the first lab was to add history/tab completion. However, one thing that gave me some trouble was being able to parse single keystrokes (namely the arrow keys). Is there a way to read a single character (not having to press enter)?\n","permalink":"https://kennems.github.io/posts/tech/mit6.s0817-qa/","summary":"MIT6.S081(7)-Q\u0026amp;A Plan: answering your questions Approach: walk through staff solutions start with pgtbl lab because it was the hardest your questions are at bottom of this file Pgtbl lab comments few lines of code, but difficult-to-debug bugs worst case: qemu/xv6 stops running \u0026ldquo;best\u0026rdquo; case: kernel panic hard to debug for staff too there are so many possible reasons why you discovered once we hadn\u0026rsquo;t seen yet likely to be the","title":"MIT6.S081(7)-Q\u0026A"},{"content":"MIT6.S081(6)-System Call Entry/Exit Today: user -\u0026gt; kernel transition system calls, faults, interrupts enter the kernel in the same way important for isolation and performance lots of careful design and important detail\nWhat needs to happen when a program makes a system call, e.g. write()? [CPU | user/kernel diagram] CPU resources are set up for user execution (not kernel) 32 registers, sp, pc, privilege mode, satp, stvec, sepc, \u0026hellip; what needs to happen? save 32 user registers and pc switch to supervisor mode switch to kernel page table switch to kernel stack jump to kernel C code high-level goals don\u0026rsquo;t let user code interfere with user-\u0026gt;kernel transition e.g. don\u0026rsquo;t execute user code in supervisor mode! transparent to user code \u0026ndash; resume without disturbing\nToday we\u0026rsquo;re focusing on the user/kernel transition and ignoring what the system call implemenation does once in the kernel but the sys call impl has to be careful and secure also!\nWhat does the CPU\u0026rsquo;s \u0026ldquo;mode\u0026rdquo; protect? i.e. what does switching mode from user to supervisor allow? supervisor can use CPU control registers: satp \u0026ndash; page table physical address stvec \u0026ndash; ecall jumps here in kernel; points to trampoline sepc \u0026ndash; ecall saves user pc here sscratch \u0026ndash; address of trapframe supervisor can use PTEs that have no PTE_U flag but supervisor has no other powers! e.g. can\u0026rsquo;t use addresses that aren\u0026rsquo;t the in page table so kernel has to carefully set things up so it can work\npreview: write() write() returns User uservec() in trampoline.S userret() in trampoline.S Kernel usertrap() in trap.c usertrapret() in trap.c syscall() in syscall.c ^ sys_write() in sysfile.c \u0026mdash;|\nlet\u0026rsquo;s watch an xv6 system call entering/leaving the kernel xv6 shell writing its $ prompt sh.c line 137: write(2, \u0026ldquo;$ \u0026ldquo;, 2); user/usys.S line 29 this is the write() function, still in user space a7 tells the kernel what system call we want \u0026ndash; SYS_write = 16 ecall \u0026ndash; triggers the user/kernel transition\nlet\u0026rsquo;s start by putting a breakpoint on the ecall user/sh.asm says write()\u0026rsquo;s ecall is at address 0xde6\n$ make qemu-gdb (gdb) b *0xde6 (gdb) c (gdb) delete 1 (gdb) x/3i 0xde4\nlet\u0026rsquo;s look at the registers (gdb) print $pc (gdb) info reg\n$pc and $sp are at low addresses \u0026ndash; user memory starts at zero C on RISC-V puts function arguments in a0, a1, a2, \u0026amp;c write() arguments: a0 is fd, a1 is buf, a2 is n\n(gdb) x/2c $a1\nthe shell is printing the $ prompt\nwhat page table is in use? (gdb) print/x $satp not very useful qemu: control-a c, info mem there are mappings for six pages instructions, data, stack guard (no PTE_U), stack, then two high mystery pages: trapframe and trampoline there are no mappings for kernel memory, devices, physical mem\nlet\u0026rsquo;s execute the ecall\n(gdb) stepi\nwhere are we? (gdb) print $pc we\u0026rsquo;re executing at a very high virtual address (gdb) x/6i 0x3ffffff000 these are the instructions we\u0026rsquo;re about to execute see uservec in kernel/trampoline.S it\u0026rsquo;s the start of the kernel\u0026rsquo;s trap handling code (gdb) info reg the registers hold user values (except $pc) qemu: info mem we\u0026rsquo;re still using the user page table note that $pc is in the trampoline page, the very last page\nwe\u0026rsquo;re executing in the \u0026ldquo;trampoline\u0026rdquo; page, which contains the start of the kernel\u0026rsquo;s trap handling code. ecall doesn\u0026rsquo;t switch page tables, so these kernel instructions have to exist somewhere in the user page table. the trampoline page is the answer: the kernel maps it at the top of every user page table. the kernel sets $stvec to the trampoline page\u0026rsquo;s virtual address. the trampoline is protected: no PTE_U flag.\n(gdb) print/x $stvec\ncan we tell that we\u0026rsquo;re in supervisor mode? I don\u0026rsquo;t know a way to find the mode directly but observe $pc is executing in a page with no PTE_U flag lack of crash implies we are in supervisor mode\nhow did we get here? ecall did three things: change mode from user to supervisor save $pc in $sepc (gdb) print/x $sepc jump to $stvec (i.e. set $pc to $stvec) the kernel previously set $stvec, before jumping to user space\nnote: ecall lets user code switch to supervisor mode but the kernel immediately gains control via $stvec so the user program itself can\u0026rsquo;t execute as supervisor\nwhat needs to happen now? save the 32 user register values (for later transparent resume) switch to kernel page table set up stack for kernel C code jump to kernel C code\nwhy didn\u0026rsquo;t the RISC-V designers have ecall do these things for us? ecall does as little as possible: to give O/S designers scope for very fast syscalls / faults / intrs maybe O/S can handle some traps w/o switching page tables maybe we can map BOTH user and kernel into a single page table so no page table switch required maybe some registers do not have to be saved maybe no stack is required for simple system calls\nthere have been many clever schemes invented for kernel entry! different amounts of work by CPU different strategies for handler s/w performance here is often super important\nwhat are our options at this point for saving user registers? can we just write them somewhere convenient in physical memory? no, even supervisor mode is constrained to use the page table can we first set satp to the kernel page table? supervisor mode is allowed to set satp\u0026hellip; but we don\u0026rsquo;t know the address of the kernel page table at this point! and we need a free register to even execute csrw satp, $xx\ntwo parts to the solution for where to save the 32 user registers:\nxv6 maps a 2nd kernel page, the trapframe, into every user page table it has space to hold the saved registers the kernel gives each process a different trapframe page the page at 0x3fffffe000 is the trapframe page see struct trapframe in kernel/proc.h (but we still need a register holding the trapframe\u0026rsquo;s address\u0026hellip;) RISC-V provides the sscratch register the kernel puts a pointer to the trapframe in sscratch before entering user space supervisor code can swap any register with sscratch thus both getting hold of the value in sscratch, and simultaneously saving the register\u0026rsquo;s user value see this at the start of uservec in trapframe.S: csrrw a0, sscratch, a0\nthe csrrw has already been executed due to some gdb quirk\u0026hellip;\n(gdb) print/x $a0 address of the trapframe (gdb\u0026gt; print/x $sscratch 0x2, the old first argument (fd)\nnow uservec() has 32 saves of user registers to the trapframe, via a0 so they can be restored later, when the system call returns let\u0026rsquo;s skip them\n(gdb) b *0x3ffffff076 (gdb) c\nnow we\u0026rsquo;re setting up to be able to run C code in the kernel first a stack previously, kernel put a pointer to top of this process\u0026rsquo;s kernel stack in trapframe look at struct trapframe in kernel/proc.h \u0026ldquo;ld sp, 8(a0)\u0026rdquo; fetches the kernel stack pointer remember a0 points to the trapframe at this point the only kernel data the code can get at is the trapframe, so everything has to be loaded from there.\n(gdb) stepi\nretrieve hart ID into tp\n(gdb) stepi\nwe want to jump to the kernel C function usertrap(), which the kernel previously saved in the trapframe. \u0026ldquo;ld t0, 16(a0)\u0026rdquo; fetches it into t0, we\u0026rsquo;ll use it in a moment, after switching to the kernel page table\n(gdb) stepi\nload a pointer to the kernel pagetable from the trapframe, and load it into satp, and issue an sfence to clear the TLB.\n(gdb) stepi (gdb) stepi (gdb) stepi\nwhy isn\u0026rsquo;t there a crash at this point? after all we just switched page tables while executing! answer: the trampoline page is mapped at the same virtual address in the kernel page table as well as every user page table\n(gdb) print $pc qemu: info mem\nwith the kernel page table we can now use kernel functions and data\nthe jr t0 is a jump to usertrap() (using t0 retrieved from trapframe)\n(gdb) print/x $t0 (gdb) x/4i $t0 (gdb) stepi (gdb) tui enable\nwe\u0026rsquo;re now in usertrap() in kernel/trap.c various traps come here, e.g. errors, device interrupts, and system calls usertrap() looks in the scause register to see the trap cause see Figure 10.3 on page 102 of The RISC-V Reader scause = 8 is a system call\n(gdb) next \u0026hellip; until syscall() (gdb) step (gdb) next\nnow we\u0026rsquo;re in syscall() kernel/syscall.c myproc() uses tp to retrieve current struct proc * p-\u0026gt;xxx is usually a slot in the current process\u0026rsquo;s struct proc\nsyscall() retrieves the system call number from saved register a7 p-\u0026gt;trapframe points to the trapframe, with saved registers p-\u0026gt;trapframe-\u0026gt;a7 holds 16, SYS_write p-\u0026gt;trapframe-\u0026gt;a0 holds write() first argument \u0026ndash; fd p-\u0026gt;trapframe-\u0026gt;a1 holds buf p-\u0026gt;trapframe-\u0026gt;a2 holds n\n(gdb) next \u0026hellip; (gdb) print num\nthen dispatches through syscall[num], a table of functions\n(gdb) next \u0026hellip; (gdb) step\naha, we\u0026rsquo;re in sys_write. at this point system call implementations are fairly ordinary C code. let\u0026rsquo;s skip to the end, to see how a system call returns to user space.\n(gdb) finish\nnotice that write() produced console output (the shell\u0026rsquo;s $ prompt) back to syscall() the p-\u0026gt;tf-\u0026gt;a0 assignment causes (eventually) a0 to hold the return value the C calling convention on RISC-V puts return values in a0\n(gdb) next\nback to usertrap()\n(gdb) print p-\u0026gt;trapframe-\u0026gt;a0\nwrite() returned 2 \u0026ndash; two characters \u0026ndash; $ and space\n(gdb) next (gdb) step\nnow we\u0026rsquo;re in usertrapret(), which starts the process of returning to the user program\nwe need to prepare for the next user-\u0026gt;kernel transition stvec = uservec (the trampoline), for the next ecall traframe satp = kernel page table, for next uservec traframe sp = top of kernel stack trapframe trap = usertrap trapframe hartid = hartid (in tp)\nat the end, we\u0026rsquo;ll use the RISC-V sret instruction we need to prepare a few registers that sret uses sstatus \u0026ndash; set the \u0026ldquo;previous mode\u0026rdquo; bit to user sepc \u0026ndash; the saved user program counter (from trap entry)\nwe\u0026rsquo;re going to switch to the user page table while executing not OK in usertrapret(), since it\u0026rsquo;s not mapped in the user page table. need a page that\u0026rsquo;s mapped in both user and kernel page table \u0026ndash; the trampoline. jump to userret in trampoline.S\n(gdb) tui disable (gdb) step (gdb) x/8i 0x3ffffff090\na0 holds TRAPFRAME a1 holds user page table address the csrw satp switches to the user address space\n(gdb) stepi (gdb) stepi (gdb) stepi\nthe csrw scratch puts the user a0 into sscratch just before sret we\u0026rsquo;ll do a swap, so that a0 holds the user a0 and sscratch holds trapframe pointer. which is what uservec expects.\nnow 32 loads from the trapframe into registers these restore the user registers let\u0026rsquo;s skip over them\n(gdb) b *0x3ffffff10a (gdb) c\nhere\u0026rsquo;s the csrw that swaps a0 with sscratch\n(gdb) stepi (gdb) print/x $a0 \u0026ndash; the return value from write() (gdb) print/x $sscratch \u0026ndash; trapframe address for uservec\nnow we\u0026rsquo;re at the sret instruction\n(gdb) print $pc (gdb) stepi (gdb) print $pc\nnow we\u0026rsquo;re back in the user program ($pc = 0x0xdea) returning 2 from the write() function\n(gdb) print/x $a0\nand we\u0026rsquo;re done with a system call!\nsummary system call entry/exit is far more complex than function call much of the complexity is due to the requirement for isolation and the desire for simple and fast hardware mechanisms a few design questions to ponder: can an evil program abuse the entry mechanism? can you think of ways to make the hardware or software simpler? can you think of ways to make traps faster?\nLab: traps RISC-V assembly (easy) Which registers contain arguments to functions? For example, which register holds 13 in main\u0026rsquo;s call to printf? 13 -\u0026gt; a2\n12 -\u0026gt; a1\n第一个参数-\u0026gt; a0 在printf中代表格式化字符串的地址，在exit(0)中代表参数0\nra(返回地址)\ns0(保存帧指针)\nauipc xx, 0x0 通过将当前PC的高20位加上一个立即数（在这个例子中是0x0，表示没有偏移）来形成一个高地址部分。这个结果会存储在目标寄存器 xx 中。\nWhere is the call to function f in the assembly code for main? Where is the call to g? (Hint: the compiler may inline functions.) printf(\u0026#34;%d %d\\n\u0026#34;, f(8)+1, 13); 24:\t4635 li\ta2,13 26:\t45b1 li\ta1,12 这里直接将计算后的值写入到寄存器中，通过内联的方式调用函数。\nAt what address is the function printf located? 34:\t600080e7 jalr\t1536(ra) # 630 \u0026lt;printf\u0026gt; $0x630$ 位置\nWhat value is in the register ra just after the jalr to printf in main? 30:\t00000097 auipc\tra,0x0 34:\t600080e7 jalr\t1536(ra) # 630 \u0026lt;printf\u0026gt; $0x630 = 0x30(ra) + 1536, ra = 0x30$\nRun the following code. unsigned int i = 0x00646c72; printf(\u0026#34;H%x Wo%s\u0026#34;, 57616, \u0026amp;i); 输出 ： He110 World\n其中57616十六进制数组的ascii码为110\n因为 RISC-V 是 little-endian. 内存中存储i为逆序的，所以会倒序 ：\n0x72 (ASCII \u0026lsquo;r\u0026rsquo;)\n0x6c (ASCII \u0026rsquo;l')\n0x64 (ASCII \u0026rsquo;d')\n0x00 (null terminator)\nIn the following code, what is going to be printed after 'y='? (note: the answer is not a specific value.) Why does this happen? printf(\u0026#34;x=%d y=%d\u0026#34;, 3); 因为printf会尝试从栈或者内存上读取这个缺失的参数，这会导致未定义的行为，可能会获取到任意的内存产生未知的值，具体取决于栈和内存的的状态，编译行为和优化，运行环境和内存的管理。\nBacktrace (moderate) defs.h void backtrace(void); printf.c void backtrace(void) { uint64 p = r_fp(); while (p != PGROUNDUP(p)) { uint64 ra = *(uint64 *)(p - 8); uint64 fp = *(uint64 *)(p - 16); printf(\u0026#34;%p\\n\u0026#34;, ra); p = fp; } } riscv.h Alarm (hard) proc.c p-\u0026gt;alarm_interval = 0; p-\u0026gt;alarm_handler = 0; p-\u0026gt;alarm_tick_count = 0; p-\u0026gt;alarm_handling = 0; if ((p-\u0026gt;alarm_trapframe = (struct trapframe *)kalloc()) == 0) { release(\u0026amp;p-\u0026gt;lock); return 0; } p-\u0026gt;alarm_interval = 0; p-\u0026gt;alarm_handler = 0; p-\u0026gt;alarm_tick_count = 0; p-\u0026gt;alarm_handling = 0; if (p-\u0026gt;alarm_trapframe) kfree((void *)p-\u0026gt;alarm_trapframe); // sys_sigalarm - 系统调用，用于设置一个进程的定时闹钟信号处理程序 // // 参数： // 无直接参数。使用了argint()和argaddr()来从系统调用参数中提取值。 // 返回值： // 成功返回0，失败返回-1。 // // 功能： // 该函数设置一个进程的定时闹钟，当计时器达到指定的tick数时，触发 // 用户定义的信号处理程序（handler）。 // // 具体来说： // 1. 从系统调用参数中获取指定的tick数和信号处理程序的地址。 // 2. 在失败的情况下返回-1。 // 3. 如果成功获取到这些参数，更新当前进程的alarm_interval（闹钟间隔） // 和alarm_handler（闹钟处理程序），并重置闹钟的计数器和状态。 uint64 sys_sigalarm(void) { int ticks; // 用于存储用户传入的tick数（间隔时间） void (*handler)(); // 用于存储用户传入的信号处理程序的指针 // 从第一个参数获取tick数，argint用于获取整数类型的参数。 if (argint(0, \u0026amp;ticks) \u0026lt; 0) return -1; // 获取失败，返回-1 // 从第二个参数获取信号处理程序的地址，argaddr用于获取指针类型的参数。 if (argaddr(1, (uint64 *)\u0026amp;handler) \u0026lt; 0) return -1; // 获取失败，返回-1 // 获取当前的进程结构体指针 struct proc *p = myproc(); // 设置进程的闹钟间隔 p-\u0026gt;alarm_interval = ticks; // 设置进程的信号处理程序 p-\u0026gt;alarm_handler = handler; // 重置闹钟的计数器 p-\u0026gt;alarm_tick_count = 0; // 初始化闹钟处理状态为未处理 p-\u0026gt;alarm_handling = 0; // 设置成功，返回0 return 0; } // sys_sigreturn - 系统调用，用于从信号处理程序返回到主程序 // // 参数： // 无直接参数。 // 返回值： // 成功返回0。 // // 功能： // 该函数用于当信号处理程序（如通过sys_sigalarm设置的处理程序）执行完毕时， // 恢复进程的上下文状态，使其返回到处理信号前的执行状态。具体步骤包括： // 1. 恢复陷阱帧（trapframe），将保存的alarm_trapframe内容恢复到当前的trapframe中。 // 2. 重置闹钟的计数器和处理状态，表示信号处理已经完成。 uint64 sys_sigreturn(void) { struct proc *p = myproc(); // 获取当前进程的指针 // 恢复进程的trapframe，将保存的alarm_trapframe内容复制回当前trapframe。 // trapframe保存了进程在处理信号之前的CPU寄存器状态。 *(p-\u0026gt;trapframe) = *(p-\u0026gt;alarm_trapframe); // 重置闹钟的计数器，表示闹钟信号处理程序已经执行完毕。 p-\u0026gt;alarm_tick_count = 0; // 重置闹钟的处理状态，表示当前不在信号处理程序中。 p-\u0026gt;alarm_handling = 0; // 成功返回 return 0; } proc.h int alarm_interval; void (*alarm_handler)(); int alarm_tick_count; int alarm_handling; struct trapframe *alarm_trapframe; riscv.h static inline uint64 r_fp() { uint64 x; asm volatile(\u0026#34;mv %0, s0\u0026#34; : \u0026#34;=r\u0026#34;(x)); return x; } syscall.c syscall.h trap.c // ok if (which_dev == 2) { if (p-\u0026gt;alarm_interval != 0 \u0026amp;\u0026amp; !p-\u0026gt;alarm_handling) { ++p-\u0026gt;alarm_tick_count; if (p-\u0026gt;alarm_tick_count == p-\u0026gt;alarm_interval) { *(p-\u0026gt;alarm_trapframe) = *(p-\u0026gt;trapframe); p-\u0026gt;trapframe-\u0026gt;epc = (uint64)(p-\u0026gt;alarm_handler); p-\u0026gt;alarm_handling = 1; } } } user.h usys.pl ","permalink":"https://kennems.github.io/posts/tech/mit6.s0816-system-call-entryexit/","summary":"MIT6.S081(6)-System Call Entry/Exit Today: user -\u0026gt; kernel transition system calls, faults, interrupts enter the kernel in the same way important for isolation and performance lots of careful design and important detail What needs to happen when a program makes a system call, e.g. write()? [CPU | user/kernel diagram] CPU resources are set up for user execution (not kernel) 32 registers, sp, pc, privilege mode, satp, stvec, sepc, \u0026hellip; what needs","title":"MIT6.S081(6)-System Call Entry/Exit"},{"content":"MIT6.S081(5)-RISC-V calling convention, stack frames, and gdb C code is compiled to machine instructions. How does the machine work at a lower level? How does this translation work? How to interact between C and asm Why this matters: sometimes need to write code not expressible in C And you need this for the syscall lab!\nRISC-V abstract machine No C-like control flow, no concept of variables, types \u0026hellip; Base ISA: Program counter, 32 general-purpose registers (x0\u0026ndash;x31)\nreg | name | saver | description \u0026mdash;\u0026mdash;-+\u0026mdash;\u0026mdash;-+\u0026mdash;\u0026mdash;\u0026ndash;+\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash; x0 | zero | | hardwired zero x1 | ra | caller | return address x2 | sp | callee | stack pointer x3 | gp | | global pointer x4 | tp | | thread pointer x5-7 | t0-2 | caller | temporary registers x8 | s0/fp | callee | saved register / frame pointer x9 | s1 | callee | saved register x10-11 | a0-1 | caller | function arguments / return values x12-17 | a2-7 | caller | function arguments x18-27 | s2-11 | callee | saved registers x28-31 | t3-6 | caller | temporary registers pc | | | program counter\nRunning example: sum_to(n)\nint sum_to(int n) {\rint acc = 0;\rfor (int i = 0; i \u0026lt;= n; i++) {\racc += i;\r}\rreturn acc;\r} What does this look like in assembly code?\nsum_to(n) expects argument in a0 returns result in a0 sum_to:\rmv t0, a0 # t0 \u0026lt;- a0\rli a0, 0 # a0 \u0026lt;- 0\rloop:\radd a0, a0, t0 # a0 \u0026lt;- a0 + t0\raddi t0, t0, -1 # t0 \u0026lt;- t0 - 1\rbnez t0, loop # if t0 != 0: pc \u0026lt;- loop\rret Limited abstractions No typed, positional arguments No local variables Only registers\nMachine doesn\u0026rsquo;t even see assembly code Sees binary encoding of machine instructions Each instruction: 16 bits or 32 bits E.g. mv t0, a0 is encoded as 0x82aa Not quite 1-to-1 encoding from asm, but close\nHow would another function call sum_to?\nmain: li a0, 10 # a0 \u0026lt;- 10 call sum_to\nWhat are the semantics of call?\ncall label := ra \u0026lt;- pc + 4 ; ra \u0026lt;- address of next instruction pc \u0026lt;- label ; jump to label\nMachine doesn\u0026rsquo;t understand labels Translated to either pc-relative or absolute jumps\nWhat are the semantics of return?\nret := pc \u0026lt;- ra\nLet\u0026rsquo;s try it out: demo1.S\n(gdb) file user/_demo1 (gdb) break main (gdb) continue Why does it stop before running demo1?\n(gdb) layout split (gdb) stepi (gdb) info registers (gdb) p $a0 (gdb) advance 18 (gdb) si (gdb) p $a0 What if we wanted a function calling another function?\nsum_then_double(n) expects argument in a0 returns result in a0 sum_then_double: call sum_to li t0, 2 # t0 \u0026lt;- 2 mul a0, a0, t0 # a0 \u0026lt;- a0 * t0 ret\nmain: li a0, 10 call sum_then_double\nLet\u0026rsquo;s try it out: demo2.S We get stuck in an infinite loop Why: overwrote return address (ra)\nHow to fix: save ra somewhere In another register? Won\u0026rsquo;t work, just defers problem. Solution: save on stack\nsum_then_double: addi sp, sp, 16 # function prologue: sd ra, 0(sp) # make space on stack, save registers call sum_to li t0, 2 mul a0, a0, t0 ld ra, 0(sp) # function epilogue: addi sp, sp, -16 # restore registers, restore stack pointer ret\nLet\u0026rsquo;s try it out: demo3.S (gdb) \u0026hellip; (gdb) nexti\nSo far, our functions coordinated with each other This worked because we were writing all the code involved Could have written it any other way E.g. passing arguments in t2, getting return value in t3\nConventions surrounding this: \u0026ldquo;calling convention\u0026rdquo; How are arguments passed? a0, a1, \u0026hellip;, a7, rest on stack How are values returned? a0, a1 Who saves registers? Designated as caller or callee saved Could ra be a callee-saved register? Our assembly code should follow this convention C code generated by GCC follows this convention This means that everyone\u0026rsquo;s code can interop, incl C/asm interop Read: demo4.c / demo4.asm Can see function prologue, body, epilogue Why doesn\u0026rsquo;t it save ra? Leaf function, not needed What is going on with s0/fp? We compiled with -fno-omit-frame-pointer\nStack . . +-\u0026gt; . | +\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026ndash;+ | | | return address | | | | previous fp \u0026mdash;\u0026mdash;+ | | saved registers | | | local variables | | | \u0026hellip; | \u0026lt;-+ | +\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026ndash;+ | | | return address | | +\u0026mdash;\u0026mdash; previous fp | | | saved registers | | | local variables | | +-\u0026gt; | \u0026hellip; | | | +\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026ndash;+ | | | return address | | | | previous fp \u0026mdash;\u0026mdash;+ | | saved registers | | | local variables | | | \u0026hellip; | \u0026lt;-+ | +\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026ndash;+ | | | return address | | +\u0026mdash;\u0026mdash; previous fp | | | saved registers | | | local variables | | $fp \u0026ndash;\u0026gt; | \u0026hellip; | | +\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026ndash;+ | | return address | | | previous fp \u0026mdash;\u0026mdash;+ | saved registers | $sp \u0026ndash;\u0026gt; | local variables | +\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026ndash;+\nDemo program: demo5.c (gdb) break g (gdb) si (gdb) si (gdb) si (gdb) si (gdb) p $sp (gdb) p $fp (gdb) x/g $fp-16 (gdb) x/g 0x0000000000002fd0-16\nStack diagram:\n0x2fe0 |\r0x2fd8 | \u0026lt;garbage ra\u0026gt; \\\r0x2fd0 | \u0026lt;garbage fp\u0026gt; / stack frame for main\r0x2fc8 | ra into main \\\r$fp \u0026ndash;\u0026gt; 0x2fc0 | 0x0000000000002fe0 / stack frame for f 0x2fb8 | ra into f $sp \u0026ndash;\u0026gt; 0x2fb0 | 0x0000000000002fd0 / stack frame for g\nGDB can automate this reasoning for us Plus, it can use debug info to reason about leaf functions, etc. (gdb) backtrace (gdb) info frame (gdb) frame 1 (gdb) info frame (gdb) frame 2 (gdb) info frame\nCalling C from asm / calling asm from C Follow calling convention and everything will work out Write function prototype so C knows how to call assembly Demo: demo6.c / demo6_asm.S Why do we use s0/s1 instead of e.g. t0/t1? (gdb) b sum_squares_to (gdb) si \u0026hellip; (gdb) x/4g $sp (gdb) si \u0026hellip;\nInline assembly\nStructs C struct layout rules Why: misaligned load/store can be slow or unsupported (platform-dependent) attribute((packed)) How to access and manipulate C structs from assembly? Generally passed by reference Need to know struct layout Demo: demo7.c / demo7_asm.S\nDebugging examine: inspect memory contents x/nfu addr n: count f: format u: unit size step/next/finish step: next line of C code next: next line of C code, skipping over function calls finish: continue executing until end of current function call stepi/nexti stepi: next assembly instruction nexti: next assembly instruction, skipping over function calls layout next steps through layouts conditional breakpoints break, only when a condition holds (e.g. variable has a certain value) watchpoints break when a memory location changes value GDB is a very powerful tool Read the manual for more! But you probably don\u0026rsquo;t need all the fancy features for this class\nReferences RISC-V ISA specification: https://riscv.org/specifications/ Contains detailed information RISC-V ISA Reference: https://rv8.io/isa Overview of instructions RISC-V assembly language reference: https://rv8.io/asm Overview of directives, pseudo-instructions, and more\nGDB 单步执行 当程序运行到断点时，可以使用以下命令单步调试：\nnext (或 n)：执行下一行代码，但不会进入函数内部。 step (或 s)：执行下一行代码，如果是函数调用则进入函数内部。 continue (或 c)：继续执行程序，直到下一个断点或程序结束。 finish：继续运行直到当前函数返回。 info b delete 删除breakpoint 查看变量 在程序中，可以查看变量的值：\n(gdb) print x # 打印变量 x 的值 (gdb) print *p # 打印指针 p 指向的值 修改变量值 可以在调试过程中修改变量的值：\n(gdb) set variable x = 10 # 将变量 x 的值设置为 10 查看调用栈 当程序暂停时，可以查看当前的调用栈（即函数调用的层级）：\n(gdb) backtrace # 显示调用栈信息 切换栈帧 可以通过 frame 命令切换到特定的栈帧，查看不同层级的函数状态：\n(gdb) frame 2 # 切换到调用栈中的第 2 层 跳过某行代码 通过 jump 命令可以直接跳到特定行：\n(gdb) jump 42 # 跳到第 42 行 Traps and system calls traps: ecall : 在RISC-V架构中，ecall是一个用于出发环境调用（Environment Call），从用户态转换成更高级别请求系统服务，当程序 exception interrupt 重要的寄存器及含义 stvec (Supervisor Trap Vector Base Address Register) 存储内核的陷阱处理程序的地址。当发生陷阱（trap）时，RISC-V会跳转到stvec指定的地址来处理该陷阱 sepc (Supervisor Exception Program Counter) 用于保存发生陷阱时的程序计数器（PC）的值。当陷阱发生时，PC的值会被保存到sepc中，而PC会被重置为stvec中的地址。之后内核可以使用sret（返回陷阱指令）将sepc的值恢复到PC，从而返回到正确的执行位置。 scause (Supervisor Cause Register) scause寄存器记录了导致陷阱发生的原因。它包含一个数值，表示出发陷阱的时间类型，例如设备中断，系统调用和非法指令。 sscratch (Supervisor Scratch Register) 是一个临时寄存器，内核可以在陷阱处理程序开始时用它来保存重要值，方便处理器处理陷阱的初始阶段。 sstatus(Supervisor Status Register) 用于控制和反映当前处理器的状态，其包含若干控制位： SIE（Supervisor Interrupt Enable）：控制设备中断是否启用。如果内核清除SIE位，RISC-V会推迟处理设备中断，直到内核重新设置该位。 SPP（Supervisor Previous Privilege）：指示陷阱来自用户模式（User Mode）还是监督模式（Supervisor Mode），并控制sret指令返回的模式。 ","permalink":"https://kennems.github.io/posts/tech/mit6.s0815-risc-v-calling-convention-stack-frames-and-gdb/","summary":"MIT6.S081(5)-RISC-V calling convention, stack frames, and gdb C code is compiled to machine instructions. How does the machine work at a lower level? How does this translation work? How to interact between C and asm Why this matters: sometimes need to write code not expressible in C And you need this for the syscall lab! RISC-V abstract machine No C-like control flow, no concept of variables, types \u0026hellip; Base ISA:","title":"MIT6.S081(5)-RISC-V calling convention, stack frames, and gdb"},{"content":"C 语言指针 C语言中的内存 静态内存（Static Memory)\nGlobal variables, accessible throughout the whole program. Defined with static keywork, as well as variables defined in global scope. 栈内存（Stack Memory)\nLocal variables with functions. Destroyed after function exits. 堆内存（Heap Memory）\nYou control creation and destruction of these variables: malloc(), free() Can lead to memory leaks, use-after-free issues. 指针 （变量）= 内存地址\n定义指针的 * ： 标记\n定义格式 ：\n数据类型 * 变量名 int a = 10; int *p1 = \u0026amp;a; double b = 10; double *p2 = \u0026amp;b; 指针的作用 指针是一个 64 位整数，其值为内存中的地址。\n查询数据 * ： 解引用运算符\nint a = 10; int *p1 = \u0026amp;a; printf(\u0026#34;%d\\n\u0026#34;, *p1); // 10 指针变量的数据类型要和指向变量的类型保持一致\n指针变量占用的大小，跟数据类型无关，跟编译器有关（32位 ： 4字节；64位：8字节）\n给指针变量赋值的时候，不能把一个数赋值给指针变量\nint a = 10; int *p1 = \u0026amp;a; // int *p1 = 100; 错误，将100看成内存地址 printf(\u0026#34;%d\\n\u0026#34;, *p1); // 10 *p1 = 20; printf(\u0026#34;%d\\n\u0026#34;, *p1); // 20 操作其他函数中的变量 #include \u0026lt;stdlib.h\u0026gt; #include \u0026lt;stdio.h\u0026gt; void swap(int *p1, int *p2) { int tmp = *p1; *p1 = *p2; *p2 = tmp; } int main(int argc, char const *argv[]) { int a = 10, b = 20; printf(\u0026#34;%d, %d\\n\u0026#34;, a, b); swap(\u0026amp;a, \u0026amp;b); printf(\u0026#34;%d, %d\\n\u0026#34;, a, b); return 0; } 函数返回多个值 #include \u0026lt;stdio.h\u0026gt; void getMaxAndMin(int arr[], int len, int *max, int *min) { *max = arr[0]; *min = arr[0]; for (int i = 1; i \u0026lt; len; i++) { if (arr[i] \u0026gt; *max) { *max = arr[i]; } } for (int i = 1; i \u0026lt; len; i++) { if (arr[i] \u0026lt; *min) { *min = arr[i]; } } } int main(int argc, char const *argv[]) { int arr[] = {1, 2, 3, 100, 4, 5, 6, 7, 8}; int len = sizeof(arr) / sizeof(arr[0]); int max = arr[0]; int min = arr[0]; getMaxAndMin(arr, len, \u0026amp;max, \u0026amp;min); printf(\u0026#34;Max: %d\\n\u0026#34;, max); printf(\u0026#34;Min: %d\\n\u0026#34;, min); return 0; } 函数的结果和计算状态分开 #include \u0026lt;stdio.h\u0026gt; int getRemainder(int num1, int num2, int *remainder) { if (num2 == 0) { return 1; } *remainder = num1 % num2; return 0; } int main(int argc, char const *argv[]) { int a = 10; int b = 2; int res = 0; int flag = getRemainder(a, b, \u0026amp;res); if (!flag) { printf(\u0026#34;Quotient: %d\\n\u0026#34;, res); } return 0; } 方便的操作数组和函数 #include \u0026lt;stdio.h\u0026gt; int main(int argc, char const *argv[]) { /* 指针运算 步长：指针移动一次，走的字节数目 char : 1 short : 2 int : 4 long : 4 long long : 8 加法/减法 */ int a = 10; int *p = \u0026amp;a; printf(\u0026#34;p = %p, *p = %d\\n\u0026#34;, p, *p); printf(\u0026#34;%p\\n\u0026#34;, p + 1); printf(\u0026#34;%p\\n\u0026#34;, p - 1); printf(\u0026#34;%p\\n\u0026#34;, p + 2); long x = 10; int x = 10; return 0; } #include \u0026lt;stdio.h\u0026gt; int main(int argc, char const *argv[]) { /* 指针运算 步长：指针移动一次，走的字节数目 char : 1 short : 2 int : 4 long : 4 long long : 8 加法/减法 */ int arr[] = {1, 2, 3, 4, 5, 6, 7, 8, 9}; int *p1 = \u0026amp;arr[0]; printf(\u0026#34;p1 指向的元素: %d\\n\u0026#34;, *p1); printf(\u0026#34;p1 + 1 指向的元素: %d\\n\u0026#34;, *(p1 + 1)); int *p2 = \u0026amp;arr[5]; printf(\u0026#34;%d\\n\u0026#34;, p1); printf(\u0026#34;%d\\n\u0026#34;, p2); printf(\u0026#34;%d\\n\u0026#34;, p2 - p1); return 0; } 指向不明的指针 野指针：指针指向的空间未分配\n悬空指针：指针指向的空间已经分配，但是被释放了\n#include \u0026lt;stdio.h\u0026gt; int *method() { int num = 13; int *p = \u0026amp;num; return p; } int main(int argc, char const *argv[]) { int a = 10; int *p1 = \u0026amp;a; printf(\u0026#34;%p\\n\u0026#34;, p1); printf(\u0026#34;%d\\n\u0026#34;, *p1); // p2 野指针 int *p2 = p1 + 10; printf(\u0026#34;%p\\n\u0026#34;, p2); printf(\u0026#34;%d\\n\u0026#34;, *p2); // 悬空指针：指针指向的内存已分配，但是被释放了 int *p3 = method(); printf(\u0026#34;delay some time\\n\u0026#34;); printf(\u0026#34;%p\\n\u0026#34;, p3); printf(\u0026#34;%d\\n\u0026#34;, *p3); return 0; } 没有类型的指针 特点：无法获取数据，无法计算，但是可以接受任意地址\n#include \u0026lt;stdio.h\u0026gt; // swap 函数用于交换两个内存区域的内容 // p1 和 p2 是指向要交换的内存地址的指针，len 是要交换的字节数 void swap(void *p1, void *p2, int len) { // 将 void 指针转换为 char 指针，便于字节级别的操作 char *pc1 = p1; char *pc2 = p2; char temp = 0; // 临时变量，用于存储字节内容 // 循环 len 次，逐字节交换内容 for (int i = 0; i \u0026lt; len; i++) { temp = *pc1; // 保存 pc1 指向的字节 *pc1 = *pc2; // 将 pc2 指向的字节赋值给 pc1 *pc2 = temp; // 将原 pc1 指向的字节赋值给 pc2 pc1++; // 移动到下一个字节 pc2++; // 移动到下一个字节 } } int main(int argc, char const *argv[]) { int a = 10; // 整数变量 a short b = 20; // 短整型变量 b int *p1 = \u0026amp;a; // 指向 a 的指针 short *p2 = \u0026amp;b; // 指向 b 的指针 // 打印变量 a 和 b 的值 printf(\u0026#34;a = %d, b = %d\\n\u0026#34;, a, b); printf(\u0026#34;*p1 = %d, *p2 = %d\\n\u0026#34;, *p1, *p2); // 不同类型的指针之间不能直接赋值 // void 指针可以接受任何类型的指针 char *p3 = (char *)p1; // 将整型指针 p1 转换为字符型指针 // printf(\u0026#34;%c\\n\u0026#34;, *p3); // 不建议解引用，因为 p3 可能指向非字符数据 void *p4 = p1; // 使用 void 指针 p4 存储 p1 的地址 printf(\u0026#34;%p\\n\u0026#34;, p4); // 打印 p4 的地址 printf(\u0026#34;%p\\n\u0026#34;, p4 + 1); // 虽然可以进行指针算术运算，但这里的结果不安全 void *p5 = p2; // 使用 void 指针 p5 存储 p2 的地址 // printf(\u0026#34;%d\\n\u0026#34;, *p5); // 不建议解引用，因为 p5 是 void 指针 // 使用 swap 函数交换两个 long long int 类型的值 long long int c = 100; // 声明 long long int 变量 c long long int d = 200; // 声明 long long int 变量 d printf(\u0026#34;%lld,%lld\\n\u0026#34;, c, d); // 打印 c 和 d 的值 swap(\u0026amp;c, \u0026amp;d, sizeof(long long int)); // 调用 swap 函数进行交换 printf(\u0026#34;%lld,%lld\\n\u0026#34;, c, d); // 打印交换后的 c 和 d 的值 return 0; } 二级指针和多级指针 指针数据类型：跟指向空间中，数据的类型是保持一致的。\n作用：二级指针可以操作一级指针记录的地址\n#include \u0026lt;stdio.h\u0026gt; int main(int argc, char const *argv[]) { int a = 10; int b = 20; int *p = \u0026amp;a; int **pp = \u0026amp;p; // 作用一：利用二级指针修改一级指针里面记录的内存地址 *pp = \u0026amp;b; printf(\u0026#34;%p\\n\u0026#34;, \u0026amp;a); printf(\u0026#34;%p\\n\u0026#34;, \u0026amp;b); printf(\u0026#34;%p\\n\u0026#34;, p); // 作用二：利用二级指针获取变量中记录的数据 printf(\u0026#34;%d\\n\u0026#34;, **pp); return 0; } 数组指针的基本用法 概念：指向数组的指针，叫做数组指针\n#include \u0026lt;stdio.h\u0026gt; int main(int argc, char const *argv[]) { int arr[] = {10, 20, 30, 40, 50}; int len = sizeof(arr) / sizeof(int); int *p1 = arr; int *p2 = \u0026amp;arr[0]; printf(\u0026#34;%p\\n\u0026#34;, p1); printf(\u0026#34;%p\\n\u0026#34;, p2); printf(\u0026#34;%d\\n\u0026#34;, *p1); printf(\u0026#34;%d\\n\u0026#34;, *(p1 + 1)); printf(\u0026#34;%d\\n\u0026#34;, *(p1 + 2)); printf(\u0026#34;%d\\n\u0026#34;, *(p1 + 3)); for (int i = 0; i \u0026lt; len; i++) { printf(\u0026#34;%d\\n\u0026#34;, *p1++); } return 0; } arr参与计算的时候，会退化为第一个元素的指针 特殊情况： sizeof 运算的时候，不会退化，arr还是整体 \u0026amp;arr获取地址的时候，不会退化 #include \u0026lt;stdio.h\u0026gt; int main(int argc, char const *argv[]) { int arr[] = {10, 20, 30, 40, 50}; int len = sizeof(arr) / sizeof(int); // sizeof 运算的时候，arr还是整体 printf(\u0026#34;%zu\\n\u0026#34;, sizeof(arr)); printf(\u0026#34;%p\\n\u0026#34;, arr); // \u0026amp;arr 时， arr还是整体 printf(\u0026#34;%p\\n\u0026#34;, \u0026amp;arr); printf(\u0026#34;%p\\n\u0026#34;, arr + 1); printf(\u0026#34;%p\\n\u0026#34;, \u0026amp;arr + 1); return 0; } 通过指针便利数组 #include \u0026lt;stdio.h\u0026gt; int main(int argc, char const *argv[]) { /* 二维数组的定义和遍历方式 定义格式方式一: int arr[行数][列数] = { {元素1, 元素2, ...}, {元素1, 元素2, ...}, ... }; */ // 定义一个 3x5 的二维数组并初始化 int arr[3][5] = { {1, 2, 3, 4, 5}, // 第一行 {1, 2, 3, 4, 5}, // 第二行 {1, 2, 3, 4, 5} // 第三行 }; // 定义一个指向包含 5 个整数的数组的指针，指向 arr int(*p)[5] = arr; // 遍历二维数组 for (int i = 0; i \u0026lt; 3; i++) // 外层循环遍历行 { for (int j = 0; j \u0026lt; 5; j++) // 内层循环遍历列 { // 使用指针解引用和偏移来访问数组元素 printf(\u0026#34;%d \u0026#34;, *(*p + j)); // 打印当前行的元素 } printf(\u0026#34;\\n\u0026#34;); // 换行以分隔不同的行 p += 1; // 移动指针到下一行 } return 0; // 返回 0 表示程序正常结束 } #include \u0026lt;stdio.h\u0026gt; int main(int argc, char const *argv[]) { /* 二维数组的定义和遍历方式 定义格式方式二: 通过一维数组的指针数组来实现二维数组的效果。 */ // 定义三个一维数组 int arr1[3] = {1, 2, 3}; // 第一个数组，包含 3 个元素 int arr2[5] = {1, 2, 3, 4, 5}; // 第二个数组，包含 5 个元素 int arr3[9] = {1, 2, 3, 4, 5, 6, 7, 8, 9}; // 第三个数组，包含 9 个元素 // 计算每个数组的长度 int len1 = sizeof(arr1) / sizeof(int); // arr1 的长度 int len2 = sizeof(arr2) / sizeof(int); // arr2 的长度 int len3 = sizeof(arr3) / sizeof(int); // arr3 的长度 // 将数组长度存入一个一维数组 int len[3] = {len1, len2, len3}; // 存储各数组的长度 // 定义一个指针数组，指向三个一维数组 int *arr[3] = {arr1, arr2, arr3}; // arr 数组中的每个元素都是指向整型的指针 // 定义一个指向指针数组的指针 int **p = arr; // p 是指向指向整型的指针的指针 // 遍历指针数组 for (int i = 0; i \u0026lt; 3; i++) // 外层循环遍历指针数组的行 { for (int j = 0; j \u0026lt; len[i]; j++) // 内层循环遍历当前数组的列 { // 使用指针解引用，打印当前数组的元素 printf(\u0026#34;%d \u0026#34;, *(*p + j)); // 打印当前行的第 j 个元素 } printf(\u0026#34;\\n\u0026#34;); // 换行以分隔不同的数组 p += 1; // 移动指针到下一个数组 } return 0; // 返回 0 表示程序正常结束 } 数组指针和指针数组 数组指针：指向数组的指针\n作用：方便的操作数组中的各种数据\n举例：int* p = arr; （步长为：int 4个字节）\n举例：int (*p)[5] = \u0026amp;arr; （步长为 ：int 乘5 20个字节）\n指针数组：存放指针的数组\n作用：用来存放指针\n举例：int *p[5]， 这个数组里面存放着int类型的指针\n函数和指针 格式：返回值类型（*指针名）（形参列表）\n作用：利用函数指针，可以动态的调用函数\n#include \u0026lt;stdio.h\u0026gt; // 定义一个无参数无返回值的函数 void method1() { printf(\u0026#34;method1\\n\u0026#34;); // 打印函数名 } // 定义一个接受两个整数并返回整数的函数 int method2(int num1, int num2) { printf(\u0026#34;method2\\n\u0026#34;); // 打印函数名 return num1 + num2; // 返回两个参数的和 } int main(int argc, char const *argv[]) { // 声明一个指向无参数无返回值函数的指针 void (*p1)() = method1; // p1 指向 method1 函数 // 声明一个指向接受两个整数并返回整数的函数的指针 int (*p2)(int, int) = method2; // p2 指向 method2 函数 // 调用无参数函数 p1(); // 通过指针调用 method1 // 调用有参数的函数，并存储返回值 int num = p2(1, 2); // 通过指针调用 method2，传递参数 1 和 2 printf(\u0026#34;%d\\n\u0026#34;, num); // 打印 method2 的返回值 return 0; // 返回 0 表示程序正常结束 } 函数指针 #include \u0026lt;stdio.h\u0026gt; // 定义加法函数 int add(int num1, int num2) { return num1 + num2; // 返回两个数的和 } // 定义减法函数 int subtract(int num1, int num2) { return num1 - num2; // 返回第一个数减去第二个数的结果 } // 定义乘法函数 int multiply(int num1, int num2) { return num1 * num2; // 返回两个数的积 } // 定义除法函数 int divide(int num1, int num2) { return num1 / num2; // 返回第一个数除以第二个数的结果 } int main(int argc, char const *argv[]) { int a = 10; // 示例变量 a int b = 20; // 示例变量 b // 创建一个函数指针数组，存储四个基本运算函数 int (*arr[4])(int, int) = {add, subtract, multiply, divide}; // 提示用户输入两个数字 printf(\u0026#34;please input two number to calculate\\n\u0026#34;); int num1, num2; scanf(\u0026#34;%d%d\u0026#34;, \u0026amp;num1, \u0026amp;num2); // 读取用户输入的两个数字 printf(\u0026#34;%d\\n\u0026#34;, num1); // 打印第一个数字 printf(\u0026#34;%d\\n\u0026#34;, num2); // 打印第二个数字 // 提示用户选择运算 int choose; printf(\u0026#34;please input one number to specify the operation you need\\n\u0026#34;); scanf(\u0026#34;%d\u0026#34;, \u0026amp;choose); // 读取用户输入的选择 // 调用相应的运算函数并存储结果 int res = (arr[choose - 1])(num1, num2); // 根据选择调用函数 printf(\u0026#34;%d\\n\u0026#34;, res); // 打印运算结果 return 0; // 返回 0 表示程序正常结束 } ","permalink":"https://kennems.github.io/posts/tech/c-%E8%AF%AD%E8%A8%80%E6%8C%87%E9%92%88/","summary":"C 语言指针 C语言中的内存 静态内存（Static Memory) Global variables, accessible throughout the whole program. Defined with static keywork, as well as variables defined in global scope. 栈内存（Stack Memory) Local variables with functions. Destroyed after function exits. 堆内存（Heap M","title":"C 语言指针"},{"content":"MIT6.S081(4)-Virtual Memory Plan: Address spaces\nPaging hardware\nxv6 VM code\nVirtual memory overview Today\u0026rsquo;s problem: [user/kernel diagram] [memory view: diagram with user processes and kernel in memory]\nSuppose the shell has a bug:\nsometimes it writes to a random memory address how can we keep it from wrecking the kernel? and from wrecking other processes?\nwe want isolated address spaces each process has its own memory it can read and write its own memory it cannot read or write anything else\nchallenge: How to multiplex several memories over one physical memory?\nwhile maintaining isolation between memories\nxv6 uses RISC-V\u0026rsquo;s paging hardware to implement AS(Address Space)\u0026rsquo;s ask questions! this material is important topic of next lab (and shows up in several other labs) paging provides a level of indirection for addressing\nCPU -\u0026gt; MMU -\u0026gt; RAM\rVA PA s/w can only ld/st to virtual addresses, not physical kernel tells MMU how to map each virtual address to a physical address MMU（Memory Management Unit） essentially has a table, indexed by va, yielding pa called a \u0026ldquo;page table\u0026rdquo; one page table per address space MMU can restrict what virtual addresses user code can use By programming the MMU, the kernel has complete control over va-\u0026gt;pa mapping Allows for many interesting OS features/tricks\nRISC-V maps 4-KB \u0026ldquo;pages\u0026rdquo; and aligned \u0026ndash; start on 4 KB boundaries $4 KB = 12 bits$ the RISC-V used in xv6 has 64-bit for addresses thus page table index is top 64-12 = 52 bits of VA except that the top 25 of the top 52 are unused no RISC-V has that much memory now can grow in future so, index is 27 bits. MMU translation see Figure 3.1 of book use index bits of VA to find a page table entry (PTE) construct physical address using PPN from PTE + offset of VA What is in PTE? each PTE is 64 bits, but only 54 are used top 44 bits of PTE are top bits of physical address \u0026ldquo;physical page number\u0026rdquo; low 10 bits of PTE flags Present, Writeable, \u0026amp;c note: size virtual addresses != size physical addresses\nWhere is the page table stored? in RAM \u0026ndash; MMU loads (and stores) PTEs o/s can read/write PTEs read/write memory location corresponding to PTEs\nWould it be reasonable for page table to just be an array of PTEs? how big is it? 2^27 is roughly 134 million 64 bits per entry 134*8 MB for a full page table wasting roughly 1GB per page table one page table per address space one address space per application would waste lots of memory for small programs! you only need mappings for a few hundred pages so the rest of the million entries would be there but not needed\nRISC-V 64 uses a \u0026ldquo;three-level page table\u0026rdquo; to save space see figure 3.2 from book page directory page (PD) PD has 512 PTEs PTEs point to another PD or is a leaf so 512512512 PTEs in total PD entries can be invalid those PTE pages need not exist so a page table for a small address space can be small\nhow does the mmu know where the page table is located in RAM? satp holds phys address of top PD pages can be anywhere in RAM \u0026ndash; need not be contiguous rewrite satp when switching to another address space/application\nhow does RISC-V paging hardware translate a va? need to find the right PTE satp register points to PA of top/L2 PD top 9 bits index L2 PD to get PA of L1 PD next 9 bits index L1 PD to get PA of L0 PD next 9 bits index L0 PD to get PA of PTE PPN from PTE + low-12 from VA\nflags in PTE V, R, W, X, U xv6 uses all of them\nwhat if V bit not set? or store and W bit not set? \u0026ldquo;page fault\u0026rdquo; forces transfer to kernel trap.c in xv6 source kernel can just produce error, kill process in xv6: \u0026ldquo;usertrap(): unexpected scause \u0026hellip; pid=\u0026hellip; sepc=\u0026hellip; stval=\u0026hellip;\u0026rdquo; or kernel can install a PTE, resume the process e.g. after loading the page of memory from disk\nindirection allows paging h/w to solve many problems e.g. phys memory doesn\u0026rsquo;t have to be contiguous avoids fragmentation e.g. lazy allocation (a lab) e.g. copy-on-write fork (another lab) many more techniques topic of next lecture Q: why use virtual memory in kernel? It is clearly good to have page tables for user processes but why have a page table for the kernel? could the kernel run with using only physical addresses? top-level answer: yes most standard kernels do use virtual addresses why do standard kernels do so? some reasons are lame, some are better, none are fundamental\nthe hardware makes it difficult to turn it off e.g. on entering a system call, one would have to disable VM the kernel itself can benefit from virtual addresses mark text pages X, but data not (helps tracking down bugs) unmap a page below kernel stack (helps tracking down bugs) map a page both in user and kernel (helps user/kernel transition) Virtual memory in xv6 kernel page table See figure 3.3 of book simple maping mostly map virtual to physical one-on-one note double-mapping of trampoline note permissions why map devices? Trampoline 的作用 为内核和用户态之间的切换提供一个统一的入口。由于其在每个进程的页表都映射到相同的物理地址，内核和用户进程都能够在切换过程中使用这段代码，可以确保 ：\n上下文的保存和恢复：保存当前的CPU状态（寄存器，堆栈等），并在返回用户态时恢复。 地址空间切换 ： 在进程切换时，从用户地址空间切换到内核地址空间，并确保安全。 trampoline成为用户态和内核态之间安全且一致的桥梁。\nEach process has its own address space and its own page table\nsee figure 3.4 of book\nnote:\ntrampoline and trapframe aren\u0026rsquo;t writable by user process\nkernel switches page tables (i.e. sets satp) when switching processes\nQ: why this address space arrangement? user virtual addresses start at zero of course user va 0 maps to different pa for each process $16,777,216 GB$ for user heap to grow contiguously but needn\u0026rsquo;t have contiguous phys mem \u0026ndash; no fragmentation problem both kernel and user map trampoline and trapframe page eases transition user -\u0026gt; kernel and back kernel doesn\u0026rsquo;t map user applications not easy for kernel to r/w user memory need translate user virtual address to kernel virtual address good for isolation (see spectre attacks) easy for kernel to r/w physical memory pa x mapped at va x\nQ: does the kernel have to map all of phys mem into its virtual address space? Code walk through setup of kernel address space kvmmap()\n// 在内核页表中添加一个映射。 // 仅在启动时使用。 // 该函数不刷新 TLB 或启用分页。 void kvmmap(uint64 va, uint64 pa, uint64 sz, int perm) { // 调用 mappages 函数将虚拟地址 va 映射到物理地址 pa，映射大小为 sz，权限为 perm if(mappages(kernel_pagetable, va, sz, pa, perm) != 0) // 如果映射失败，则触发系统错误 panic(\u0026#34;kvmmap\u0026#34;); } Q: what is address 0x10000000 (256M)\n$ 0x10000000 = 256 MB$\nQ: how much address space does 1 L2 entry cover? (1G)\n$512×2 MB=1 GB$\nQ: how much address space does 1 L1 entry cover? (2MB)\n$512 × 4096B = 2MB$\nQ: how much address space does 1 L0 entry cover? (4096)\n每个 L0 条目指向一个 4KB 的页，因此每个 L0 条目覆盖 4096 字节的地址空间\nprint kernel page table\nQ: what is size of address space? (512G)\n每个L2覆盖 $1GB$, 共覆盖$512GB$\nQ: how much memory is used to represent it after 1rst kvmmap()?\n($3 pages$)\nQ: how many entries is CLINT?\n($16 pages$)\nQ: how many entries is PLIC?\n(1024 pages, two level 1 PDs)\nQ: how many pages is kernel text\n$ (8 pages)$\nQ: how many pages is kernel total\n$ (128M = 64 * 2MB)$\nQ: Is trampoline mapped twice?\n(yes, last entry and direct-mapped, entry [2, 3, 7])\nkvminithart(); Q: after executing w_satp() why will the next instruction be sfence_vma()?\nmappages() in vm.c // 为从 va 开始的虚拟地址创建 PTE（页表条目）， // 这些条目引用从 pa 开始的物理地址。 // va 和 size 可能不是页面对齐的。 // 成功返回 0，失败时返回 -1（如果 walk() 无法分配所需的页表页面）。 int mappages(pagetable_t pagetable, uint64 va, uint64 size, uint64 pa, int perm) { uint64 a, last; // 定义变量 a 和 last，用于跟踪当前地址 pte_t *pte; // 定义指针 pte，用于访问页表条目 // 将虚拟地址 va 向下对齐到页面边界 a = PGROUNDDOWN(va); // 将最后一个虚拟地址向下对齐到页面边界 last = PGROUNDDOWN(va + size - 1); // 循环创建页表条目 for(;;){ // 获取当前虚拟地址 a 对应的页表条目 if((pte = walk(pagetable, a, 1)) == 0) return -1; // 如果 walk 失败，返回 -1 // 检查当前页表条目是否已经有效 if(*pte \u0026amp; PTE_V) panic(\u0026#34;remap\u0026#34;); // 如果已经映射，触发错误 // 设置页表条目，映射物理地址 pa，并设置权限和有效位 *pte = PA2PTE(pa) | perm | PTE_V; // 如果当前地址 a 是最后一个地址，退出循环 if(a == last) break; // 继续到下一个页面 a += PGSIZE; // 移动到下一个虚拟地址 pa += PGSIZE; // 移动到下一个物理地址 } return 0; // 成功创建所有页表条目，返回 0 } arguments are top PD, va, size, pa, perm adds mappings from a range of va\u0026rsquo;s to corresponding pa\u0026rsquo;s rounds b/c some uses pass in non-page-aligned addresses for each page-aligned address in the range call walkpgdir to find address of PTE need the PTE\u0026rsquo;s address (not just content) b/c we want to modify put the desired pa into the PTE mark PTE as valid w/ PTE_P\nwalk() in vm.c pte_t * walk(pagetable_t pagetable, uint64 va, int alloc) { // 检查虚拟地址是否超过最大虚拟地址 if(va \u0026gt;= MAXVA) panic(\u0026#34;walk\u0026#34;); // 从最高级别的页表开始，逐级向下查找 for(int level = 2; level \u0026gt; 0; level--) { // 获取当前级别的页表条目指针 pte_t *pte = \u0026amp;pagetable[PX(level, va)]; // 如果页表条目有效 if(*pte \u0026amp; PTE_V) { // 获取物理地址并进入下一层页表 pagetable = (pagetable_t)PTE2PA(*pte); } else { // 如果不分配，或者分配失败，返回0 if(!alloc || (pagetable = (pde_t*)kalloc()) == 0) return 0; // 初始化新的页表为0 memset(pagetable, 0, PGSIZE); // 设置页表条目为新分配的页表的物理地址，标记为有效 *pte = PA2PTE(pagetable) | PTE_V; } } // 返回最低级别页表中对应虚拟地址的页表条目 return \u0026amp;pagetable[PX(0, va)]; } mimics how the paging h/w finds the PTE for an address PX extracts the 9 bits at Level level \u0026amp;pagetable[PX(level, va)] is the address of the relevant PTE\nif PTE_V\rthe relevant page-table page already exists\rPTE2PA extracts the PPN from the PDE\rif not PTE_V\ralloc a page-table page\rfill in pte with PPN (using PA2PTE) now the PTE we want is in the page-table page\nprocinit() in proc.c // 在启动时初始化进程表。 void procinit(void) { struct proc *p; // 初始化进程 ID 锁，以确保对进程 ID 的安全访问。 initlock(\u0026amp;pid_lock, \u0026#34;nextpid\u0026#34;); // 遍历进程表中的每个进程 for(p = proc; p \u0026lt; \u0026amp;proc[NPROC]; p++) { // 初始化每个进程的锁，以保护进程结构的并发访问。 initlock(\u0026amp;p-\u0026gt;lock, \u0026#34;proc\u0026#34;); // 为进程的内核栈分配一页内存。 // 将其映射到高地址内存，并跟随一个无效的保护页。 char *pa = kalloc(); // 分配一页内存 if(pa == 0) panic(\u0026#34;kalloc\u0026#34;); // 如果分配失败，触发系统错误 // 计算该进程内核栈的虚拟地址 uint64 va = KSTACK((int) (p - proc)); // 在内核页表中映射虚拟地址 va 到物理地址 pa，大小为 PGSIZE，权限为可读和可写 kvmmap(va, (uint64)pa, PGSIZE, PTE_R | PTE_W); // 将计算出的虚拟地址保存到进程结构中 p-\u0026gt;kstack = va; } // 初始化虚拟内存管理相关的硬件设置 kvminithart(); } alloc a page for each kernel stack with a guard page\nsetup user address space allocproc(): allocates empty top-level page table // 在进程表中查找一个 UNUSED 状态的进程。 // 如果找到，初始化所需的状态以在内核中运行，并返回时持有 p-\u0026gt;lock。 // 如果没有空闲的进程，或内存分配失败，返回 0。 static struct proc* allocproc(void) { struct proc *p; // 遍历进程表中的每个进程 for(p = proc; p \u0026lt; \u0026amp;proc[NPROC]; p++) { acquire(\u0026amp;p-\u0026gt;lock); // 获取进程的锁以安全访问其状态 if(p-\u0026gt;state == UNUSED) { // 检查进程状态是否为 UNUSED goto found; // 找到空闲进程，跳转到初始化部分 } else { release(\u0026amp;p-\u0026gt;lock); // 如果不是 UNUSED，释放锁并继续下一个进程 } } // 如果没有找到空闲进程，返回 0 return 0; found: // 分配一个新的进程 ID p-\u0026gt;pid = allocpid(); // 为进程分配一个 trapframe 页面，用于处理系统调用和中断 if((p-\u0026gt;trapframe = (struct trapframe *)kalloc()) == 0) { release(\u0026amp;p-\u0026gt;lock); // 分配失败，释放锁 return 0; // 返回 0 表示失败 } // 创建一个空的用户页面表 p-\u0026gt;pagetable = proc_pagetable(p); if(p-\u0026gt;pagetable == 0) { // 检查页面表分配是否成功 freeproc(p); // 如果分配失败，释放进程资源 release(\u0026amp;p-\u0026gt;lock); // 释放锁 return 0; // 返回 0 表示失败 } // 设置新的上下文，以在 forkret 处开始执行， // forkret 会返回到用户空间。 memset(\u0026amp;p-\u0026gt;context, 0, sizeof(p-\u0026gt;context)); // 清零上下文结构 p-\u0026gt;context.ra = (uint64)forkret; // 设置返回地址为 forkret 函数 p-\u0026gt;context.sp = p-\u0026gt;kstack + PGSIZE; // 设置堆栈指针到内核栈的顶部 return p; // 返回分配和初始化的进程 } fork(): uvmcopy()\n// 根据父进程的页表，将其内存复制到子进程的页表。 // 复制页表和物理内存。 // 成功返回 0，失败返回 -1。 // 在失败时释放已分配的页面。 int uvmcopy(pagetable_t old, pagetable_t new, uint64 sz) { pte_t *pte; // 页表条目的指针 uint64 pa, i; // 物理地址和循环变量 uint flags; // 页表条目的标志位 // 遍历从 0 到 sz 的所有页面 for(i = 0; i \u0026lt; sz; i += PGSIZE){ // 获取旧页表中对应虚拟地址的页表条目 if((pte = walk(old, i, 0)) == 0) panic(\u0026#34;uvmcopy: pte should exist\u0026#34;); // 如果未找到页表条目，触发错误 // 检查页表条目是否有效 if((*pte \u0026amp; PTE_V) == 0) panic(\u0026#34;uvmcopy: page not present\u0026#34;); // 如果页面不存在，触发错误 // 获取物理地址 pa = PTE2PA(*pte); // 清除写权限标志，以便进行写时复制（Copy-On-Write） *pte \u0026amp;= (~PTE_W); // 清除 PTE_W *pte |= (PTE_C); // 设置 PTE_C，标记此页面为 Copy-On-Write // 获取当前页表条目的其他标志 flags = PTE_FLAGS(*pte); // 在新页表中映射原来的物理地址 if (mappages(new, i, PGSIZE, pa, flags) != 0) { goto err; // 如果映射失败，跳转到错误处理 } // 增加物理页面的引用计数 kincre((void *)pa); } return 0; // 成功完成复制，返回 0 err: // 释放在新页表中已分配的页面 uvmunmap(new, 0, i / PGSIZE, 1); return -1; // 返回 -1 表示失败 } exec(): replace proc\u0026rsquo;s page table with a new one\n// 执行指定路径的程序，设置新的用户栈并准备参数。 // 成功返回程序的参数个数，失败返回 -1。 int exec(char *path, char **argv) { char *s, *last; // 字符串指针，用于处理路径 int i, off; // 循环变量和偏移量 uint64 argc, sz = 0, sp, ustack[MAXARG+1], stackbase; // 参数计数、内存大小、栈指针、用户栈数组和栈基地址 struct elfhdr elf; // ELF 头结构 struct inode *ip; // 文件节点指针 struct proghdr ph; // 程序头结构 pagetable_t pagetable = 0, oldpagetable; // 新旧页表 struct proc *p = myproc(); // 获取当前进程结构 begin_op(); // 开始文件操作 // 查找程序路径对应的 inode if((ip = namei(path)) == 0){ end_op(); // 结束文件操作 return -1; // 找不到文件，返回 -1 } ilock(ip); // 锁定 inode // 检查 ELF 头 if(readi(ip, 0, (uint64)\u0026amp;elf, 0, sizeof(elf)) != sizeof(elf)) goto bad; // 读取 ELF 头失败，跳转到错误处理 if(elf.magic != ELF_MAGIC) goto bad; // 检查 ELF 魔法数，若不匹配则跳转到错误处理 // 获取当前进程的页表 if((pagetable = proc_pagetable(p)) == 0) goto bad; // 获取页表失败，跳转到错误处理 // 从 ELF 文件加载程序到内存 for(i = 0, off = elf.phoff; i \u0026lt; elf.phnum; i++, off += sizeof(ph)){ // 读取程序头 if(readi(ip, 0, (uint64)\u0026amp;ph, off, sizeof(ph)) != sizeof(ph)) goto bad; // 读取失败，跳转到错误处理 if(ph.type != ELF_PROG_LOAD) continue; // 仅处理加载类型的程序头 if(ph.memsz \u0026lt; ph.filesz) goto bad; // 内存大小小于文件大小，跳转到错误处理 if(ph.vaddr + ph.memsz \u0026lt; ph.vaddr) goto bad; // 地址溢出，跳转到错误处理 uint64 sz1; // 为加载的段分配内存 if((sz1 = uvmalloc(pagetable, sz, ph.vaddr + ph.memsz)) == 0) goto bad; // 内存分配失败，跳转到错误处理 sz = sz1; // 更新分配大小 // 检查段的虚拟地址是否对齐 if(ph.vaddr % PGSIZE != 0) goto bad; // 虚拟地址未对齐，跳转到错误处理 // 从文件中加载段到内存 if(loadseg(pagetable, ph.vaddr, ip, ph.off, ph.filesz) \u0026lt; 0) goto bad; // 加载段失败，跳转到错误处理 } iunlockput(ip); // 解锁并释放 inode end_op(); // 结束文件操作 ip = 0; // 清空 inode 指针 p = myproc(); // 再次获取当前进程结构 uint64 oldsz = p-\u0026gt;sz; // 保存旧的程序大小 // 在下一个页边界分配两个页面 // 使用第二个页面作为用户栈 sz = PGROUNDUP(sz); // 将大小向上对齐到页边界 uint64 sz1; if((sz1 = uvmalloc(pagetable, sz, sz + 2*PGSIZE)) == 0) goto bad; // 内存分配失败，跳转到错误处理 sz = sz1; // 更新分配大小 uvmclear(pagetable, sz - 2 * PGSIZE); // 清除栈底的页面内容 sp = sz; // 设置栈指针 stackbase = sp - PGSIZE; // 设置栈基地址 // 将参数字符串推入栈，并准备栈的其他部分 for(argc = 0; argv[argc]; argc++) { if(argc \u0026gt;= MAXARG) goto bad; // 超过最大参数数量，跳转到错误处理 sp -= strlen(argv[argc]) + 1; // 为参数字符串分配空间 sp -= sp % 16; // 确保栈指针是 16 字节对齐 if(sp \u0026lt; stackbase) goto bad; // 栈指针超出栈基，跳转到错误处理 if(copyout(pagetable, sp, argv[argc], strlen(argv[argc]) + 1) \u0026lt; 0) goto bad; // 将参数字符串复制到用户栈失败，跳转到错误处理 ustack[argc] = sp; // 保存参数字符串的地址 } ustack[argc] = 0; // 以 0 结束参数数组 // 将 argv[] 指针数组推入栈 sp -= (argc + 1) * sizeof(uint64); // 为 argv 指针数组分配空间 sp -= sp % 16; // 确保栈指针是 16 字节对齐 if(sp \u0026lt; stackbase) goto bad; // 栈指针超出栈基，跳转到错误处理 if(copyout(pagetable, sp, (char *)ustack, (argc + 1) * sizeof(uint64)) \u0026lt; 0) goto bad; // 复制 argv 指针数组失败，跳转到错误处理 // 准备用户主函数的参数 (argc, argv) // argc 将通过系统调用返回值放入 a0 中 p-\u0026gt;trapframe-\u0026gt;a1 = sp; // 将栈指针赋值给 trapframe // 保存程序名称以便调试 for(last = s = path; *s; s++) if(*s == \u0026#39;/\u0026#39;) last = s + 1; // 找到路径中的最后一个斜杠 safestrcpy(p-\u0026gt;name, last, sizeof(p-\u0026gt;name)); // 复制程序名称 // 提交用户映像 oldpagetable = p-\u0026gt;pagetable; // 保存旧的页表 p-\u0026gt;pagetable = pagetable; // 更新当前进程的页表 p-\u0026gt;sz = sz; // 更新进程的内存大小 p-\u0026gt;trapframe-\u0026gt;epc = elf.entry; // 设置初始程序计数器为 ELF 入口点 p-\u0026gt;trapframe-\u0026gt;sp = sp; // 设置初始栈指针 proc_freepagetable(oldpagetable, oldsz); // 释放旧的页表 return argc; // 返回参数个数，放入 a0，作为 main(argc, argv) 的第一个参数 bad: // 错误处理部分 if(pagetable) proc_freepagetable(pagetable, sz); // 释放已分配的页表 if(ip){ iunlockput(ip); // 解锁并释放 inode end_op(); // 结束文件操作 } return -1; // 返回 -1 表示失败 } uvmalloc()\nloadseg()\n// 将程序段加载到指定的页表中，虚拟地址为 va。 // va 必须是页对齐的，且从 va 到 va+sz 的页必须已经映射。 // 成功时返回 0，失败时返回 -1。 static int loadseg(pagetable_t pagetable, uint64 va, struct inode *ip, uint offset, uint sz) { uint i, n; // 循环变量 i 和每页要读取的字节数 n uint64 pa; // 映射到的物理地址 // 检查虚拟地址是否是页对齐的 if((va % PGSIZE) != 0) panic(\u0026#34;loadseg: va must be page aligned\u0026#34;); // 遍历每个页，从虚拟地址 va 开始，直到加载的大小 sz for(i = 0; i \u0026lt; sz; i += PGSIZE){ // 获取当前虚拟地址对应的物理地址 pa = walkaddr(pagetable, va + i); // 如果物理地址为 0，表示对应的页不存在，触发 panic if(pa == 0) panic(\u0026#34;loadseg: address should exist\u0026#34;); // 确定要读取的字节数 if(sz - i \u0026lt; PGSIZE) n = sz - i; // 如果剩余的字节数小于一页，则只读取剩余的字节 else n = PGSIZE; // 否则读取一整页 // 从 inode 中读取数据到物理内存中 if(readi(ip, 0, (uint64)pa, offset+i, n) != n) return -1; // 如果读取的字节数不等于 n，返回 -1 表示失败 } return 0; // 成功加载所有页，返回 0 } print user page table for sh\nQ: what is entry 2?\na process calls sbrk(n) to ask for n more bytes of heap memory user/umalloc.c calls sbrk() to get memory for the allocator each process has a size kernel adds new memory at process\u0026rsquo;s end, increases size sbrk() allocates physical memory (RAM) maps it into the process\u0026rsquo;s page table returns the starting address of the new memory\ngrowproc() in proc.c // 增加或减少用户内存 n 字节。 // 成功时返回 0，失败时返回 -1。 int growproc(int n) { uint sz; // 当前进程的内存大小 struct proc *p = myproc(); // 获取当前进程结构 sz = p-\u0026gt;sz; // 获取当前进程的内存大小 if(n \u0026gt; 0){ // 如果 n 为正，表示增加内存 // 尝试分配新的内存空间 if((sz = uvmalloc(p-\u0026gt;pagetable, sz, sz + n)) == 0) { // 如果内存分配失败，返回 -1 return -1; } } else if(n \u0026lt; 0){ // 如果 n 为负，表示减少内存 // 尝试释放内存 sz = uvmdealloc(p-\u0026gt;pagetable, sz, sz + n); // 注意：此处没有检查 uvmdealloc 的返回值，假设其成功 } p-\u0026gt;sz = sz; // 更新当前进程的内存大小 return 0; // 返回 0 表示成功 } proc-\u0026gt;sz is the process\u0026rsquo;s current size uvmalloc() does most of the work when switching to user space satp will be loaded with updated page table\nuvmalloc() in vm.c // 为进程分配页表项和物理内存，将进程从 oldsz 扩展到 newsz。 // newsz 不需要页对齐。成功时返回新大小，失败时返回 0。 uint64 uvmalloc(pagetable_t pagetable, uint64 oldsz, uint64 newsz) { char *mem; // 用于存储分配的内存指针 uint64 a; // 循环变量，用于遍历分配的内存地址 // 如果新的大小小于旧的大小，直接返回旧的大小 if(newsz \u0026lt; oldsz) return oldsz; // 将旧大小向上对齐到下一个页边界 oldsz = PGROUNDUP(oldsz); // 从旧大小开始，逐页分配内存直到新的大小 for(a = oldsz; a \u0026lt; newsz; a += PGSIZE){ // 分配一页物理内存 mem = kalloc(); if(mem == 0){ // 如果内存分配失败，释放已经分配的内存并返回 0 uvmdealloc(pagetable, a, oldsz); return 0; } // 将分配的内存初始化为 0 memset(mem, 0, PGSIZE); // 将分配的物理内存映射到进程的虚拟地址空间 if(mappages(pagetable, a, PGSIZE, (uint64)mem, PTE_W|PTE_X|PTE_R|PTE_U) != 0){ // 如果映射失败，释放物理内存并释放已分配的内存 kfree(mem); uvmdealloc(pagetable, a, oldsz); return 0; } } // 如果所有的内存都成功分配和映射，返回新的大小 return newsz; } why PGROUNDUP? arguments to mappages()\u0026hellip;\nLab: page tables Print a page table (easy) Define a function called vmprint(). It should take a pagetable_t argument, and print that pagetable in the format described below. Insert if(p-\u0026gt;pid==1) vmprint(p-\u0026gt;pagetable) in exec.c just before the return argc, to print the first process\u0026rsquo;s page table. You receive full credit for this assignment if you pass the pte printout test of make grade.\nvoid vmprint_rec(pagetable_t pagetable, int level) { for (int i = 0; i \u0026lt; 512; i++) { pte_t pte = pagetable[i]; if (pte \u0026amp; PTE_V) { uint64 pa = PTE2PA(pte); for (int j = 0; j \u0026lt;= level; j++) { if(j \u0026gt; 0){ printf(\u0026#34; \u0026#34;); } printf(\u0026#34;..\u0026#34;); } printf(\u0026#34;%d: pte %p pa %p\\n\u0026#34;, i, pte, pa); if ((pte \u0026amp; (PTE_R | PTE_W | PTE_X)) == 0) { // Recursively print next level page table vmprint_rec((pagetable_t)pa, level + 1); } } } } void vmprint(pagetable_t pagetable) { printf(\u0026#34;page table %p\\n\u0026#34;, pagetable); vmprint_rec(pagetable, 0); } pid = 1代表init进程，即第一个启动的用户级进程，它负责派生其他进程并为系统提供基本服务。\nA kernel page table per process (hard) proc.h proc.c vm.c defs.h Simplify copyin/copyinstr (hard) defs.h vm.c Q \u0026amp; A ","permalink":"https://kennems.github.io/posts/tech/mit6.s0814-virtual-memory/","summary":"MIT6.S081(4)-Virtual Memory Plan: Address spaces Paging hardware xv6 VM code Virtual memory overview Today\u0026rsquo;s problem: [user/kernel diagram] [memory view: diagram with user processes and kernel in memory] Suppose the shell has a bug: sometimes it writes to a random memory address how can we keep it from wrecking the kernel? and from wrecking other processes? we want isolated address spaces each process has its own memory it can read and","title":"MIT6.S081(4)-Virtual Memory"},{"content":"股票 股票：股票是股份公司在筹集资本时向出资人公开或私下发行的、用以证明出资人的股本身份和权力，并根据持有人所持有的股份数享有权益和承担义务的凭证。\n收益 ： 差价和分红\n股票软件；\n同花顺 东方财富 通达信 指南针 股市交易时间： 周一到周五 非节假日 9：30~11：30 13：00~15：00 交易费用：佣金 印花税 过户费 交易规则： 集合竞价：9：15~9：25 最大成交量的价格 该如何挂单 9：15~9：20 可撤单 20之后不能撤单 连续竞价 价格优先，时间优先 T+1交易规则： 当地买进 当日不能卖出 次日才能卖出\n变相T+0，做T\n正向T\n600/1 上证主板\n000 深圳主板\n300 创业板\n688 科创板\n换手率 表示股市的活跃度，活跃的一般在3~4%左右\n成交量: 代表了多空双方看法的分歧程度\n量价齐升，量增价稳，量缩价涨（量价背离）等等\n均线MA 趋势交易法\n股票技术分析 技术分析 和 基本面分析\nK线分析 红涨绿跌\n常用K线： 形态分析 用一连串的K线组合在一起形成各种不同的形态或者形状，并加以分析。 切线分析 指标分析 RSI（Relative Strength Index，相对强弱指数）指标能够反映市场强弱，成交量能够反映市场能量。\n任何技术指标都是对当前或过去市场走势的滞后特征反应\n均线系统 移动平均线指标\n均线系统就是计算过去某一段时间的平均收盘价，然后连接起来\n均线的本质是反应过去一段时间市场整体的持仓成本，是很重要的支撑和阻力指标 道氏理论 波浪理论 江恩理论 技术分析的三大前提条件和四个分析要素 三大前提 1、市场行为包容和消化一切信息 股价的波动和涨跌是一切影响股价的因素和集中体现 这些因素包括公司经营状况，行业甚至政治，心理等 影响股价变动的根本原因是基本面因素 2、价格以趋势的方式演变 股价的趋势变化是技术分析的核心\n价格波动要么上涨趋势，要么下跌趋势，要么横盘震荡\n技术分析的意义在于尽早地判断出趋势转折点，买进卖出\n趋势一旦确立，不会轻易改变或者终止\n通过技术分析工具找到市场趋势，然后“顺势而为”\n3、历史会重演 各种“图标”给出的涨跌信号总会不断重演\n同样的技术分析信号，过去有效，将来一样会有效\n人性的贪婪和恐慌不变，“历史”将不断重演\n“图标”给出的技术信号不会完全雷同，但会非常相似\n中国股市中相邻的两个顶部或相邻两个底部，形态非常类似，相隔时间越长，形态差别越大\n四个分析要素 价格 价格应该是我们研究技术分析的首要因素 价格是指股票过去和当前的成交价，具体的还有开盘价，收盘价，最高价和最低价。 收盘价最重要： 每一天日内价格波动是市场所有多空双方的博弈结果，它直接反映在当日收盘价上。 股价连续三天收盘价突破重要关口，才算是真的突破了。 成交量 成交量是反映市场人气和动力的指标，和价格之间存在一定的推理关系\n量价齐升，量价背离，缩量上涨，放量下跌\n上涨需要放量，否则持久不了；下跌则不需要， 可以缩量下跌\n通常先看到成交量的变化，然后再看到价格的变动\n时间 时间指的是时间周期\n牛市和熊市是存在周期性的交替\n股价存在周期性变化，因为股价反应经济，经济本身是存在周期性\n按周期K线图可分为日线，周线，月线，10分钟，30分钟，小时图等\n研究时间的目的在于寻找市场的趋势转折点\n江恩认为时间才是市场允许的最重要因素，甚至超过价格\n空间 空间就是股价上下波动范围 预测价格就是预测股价波动的时间范围，要精确预测很难 以时间换空间是指股价上的空间和时间相互转化 单根K线分析以及操作意义 大阳线 光头光脚大阳线说明当天的开盘价就是最低价，收盘价就是最高价，后市继续看好\n大阴线说明当天几乎最高点开盘，然后最低点收盘，说明空方力量明显占优\n小阳线表示上涨幅度不大，多方略微占优\n小阴线意味着跌幅不大，空头稍微占优\n一般出现在多空力量相当的情况，如震荡市行情\n中阴线和中阳线：比小阳线和小阴线实体更大一点的就是中阳线和中阴线\n一般涨跌幅度小于$3%$被称为小阳线和小阴线；超过$3%$小于$6%$被称之为中阳线和中阴线\n超过$6%$就是大阳线和大阴线\n长影K线\n长上影K线说明当天多方一度占优较大，但因空方打压或利空消息而在尾盘有所回落\n长上影K线技术信号不明确，后市不一定看跌\n长上影K线在特定阶段被称为“仙人指路”\n下影线越长，下方支持越强；上影线越长，上方阻力越大\n连续几天出现长下影K线，是看多信号，后市更加看好\n高位的长下影K线更可能是空头试探的打压行为\n十字星：\n高位和低位十字星都是行情逆转的信号 行情中途出现的十字星一般是调整或反弹结束的信号 震荡行情中出现十字星就是要突破震荡市的信号 T字形和倒T形\nT字形K线对后市多方有利 T字形K线出现在股价的相对低位，是明显的看多信号 倒T形K线说明股价冲高回落，收盘价和开盘价一样，是明显的看空信号 一字型：\n一字涨停是突然出现利好消息，买也买不到；一字跌停是突然出现利空消息，卖也卖不掉 常用、重要的K线组合 三阳开泰 连续出现三根中阳或大阳线，股价在短时间内快读爆发上涨，呈现加速上涨态势 股价连续三天大涨，股价上涨动力很大，是强烈的看多信号 下跌趋势结束，上升趋势开始 三个白武士 K线收盘价一天比一天高 每天的开盘价在昨天阳线的实体之内 三根阳线的上下影线比较短，收盘价几乎是当天最高价 通常出现在见底回升的初期 三个白武士的三根阳线很大部分是重叠在一起的 三只乌鸦 三只乌鸦指连续出现三根中阴线或者大阴线 三只乌鸦是强烈的看空信号 容易出现在市场头部或者高位，尤其是从牛转熊的过程 出水芙蓉 出水芙蓉是K线和均线组合的技术图形\n股价经过一段时间的横盘整理 均价系统最后也粘合在一起 一根大阳线放量突破所有的均线系统 上涨行情就此展开 断头铡刀 断头铡刀和出水芙蓉相反，是高位放量阴线跌破均线系统 断头铡刀容易出现在市场头部和高位横盘 如果三天之内不能收复这根大阴线，最好卖出，因为反弹之后是更大的下跌 旭日东升 孕育线 孕育线预示着上涨或者下跌力量已经衰竭，股价即将要转势 孕育线对趋势转折的信号并不强烈，还需通过其他技术指标来确认 乌云盖顶 处在上涨行情 出现一根中阳线或者大阳线之后 第二天收到一根中阴线或大阴线，形成阴盖阳走势 是经典的看空K线组合，预示着空头的猛烈反击 多方炮和空方炮 多方炮\n多方炮指的是底部反复盘整，具有筑底功能，以夯实底部 上涨行情中途也可能出现，是多方为了继续向上发动行情进行中途震荡洗盘 是较强的看涨信号 空方炮\n空方炮的出现显示空头力量越来越强，而且坚决不退让，后市不看好 早晨之星 第一天 ： 一根大阴线 第二天：跳空下行的小阴线或小阳线 第三天：一根大阳线，股价收复第一天的大部分失地 黄昏之星 价格形态的基本操作要领 价格形态是指股价在一段时间内形成的各种”几何图形“\n价格形态也被称为技术形态\n价格形态是经验总结，不断重复出现，而且有规律，在操作方面具有指导意义\n反转形态 头肩顶形态 头肩底 双重顶 双重底 三重顶 多出现在多头行情的末端 周线图中就容易出现三重顶 向下跌破颈线位置后的调整时间比较长 三重底 V 型反转 股价走势呈现出V字形或倒V，所以也被称为尖顶或者尖底\n必要条件是市场出现猛烈的上涨或下跌，上涨或者下跌的空间足够大\n圆弧顶 圆弧顶的成交量不太规则 圆弧左侧成交量明显大于右侧时，圆顶形成概率很高。 跌破颈线位置$3%$时，就需要卖出股票或者做空操作 圆弧底 整理（持续）形态 三角形形态 上升和下降三角形 按照概率，三角形形态大多数是股价的中途整理 扩散三角形 旗形和三角旗形形态 矩形形态 趋势和趋势线 ","permalink":"https://kennems.github.io/posts/read/%E8%82%A1%E7%A5%A8/","summary":"股票 股票：股票是股份公司在筹集资本时向出资人公开或私下发行的、用以证明出资人的股本身份和权力，并根据持有人所持有的股份数享有权益和承担义务的","title":"股票"},{"content":"MIT6.S081(1)-O/S overview Class Page Overview 6.S081 goals Understand operating system (O/S) design and implementation Hands-on experience extending a small O/S Hands-on experience writing systems software What is the purpose of an O/S? Abstract the hardware for convenience and portability Multiplex the hardware among many applications Isolate applications in order to contain bugs Allow sharing among cooperating applications Control sharing for security Don\u0026rsquo;t get in the way of high performance Support a wide range of applications Organization: layered picture user applications: vi, gcc, DB, \u0026amp;c kernel services h/w: CPU, RAM, disk, net, \u0026amp;c we care a lot about the interfaces and internal kernel structure What services does an O/S kernel typically provide? process (a running program) memory allocation file contents file names, directories access control (security) many others: users, IPC（Inter-Process Communication）, network, time, terminals What\u0026rsquo;s the application / kernel interface? \u0026ldquo;System calls\u0026rdquo;\nExamples, in C, from UNIX (e.g. Linux, macOS, FreeBSD):\nfd = open(\u0026#34;out\u0026#34;, 1); write(fd, \u0026#34;hello\\n\u0026#34;, 6); pid = fork(); These look like function calls but they aren\u0026rsquo;t\nSystem Calls 函数名 功能描述 int fork() 创建一个进程，返回子进程的 PID。 int exit(int status) 终止当前进程，status 返回给 wait()，不返回。 int wait(int *status) 等待子进程退出，退出状态存入 *status，返回子进程的 PID。 int kill(int pid) 终止进程 PID。返回 0 或 -1（表示错误）。 int getpid() 返回当前进程的 PID。 int sleep(int n) 暂停 n 个时钟周期。 int exec(char *file, char *argv[]) 加载并执行文件 file，传入参数 argv[]，仅在发生错误时返回。 char *sbrk(int n) 增加 n 字节的进程内存，返回新内存的起始地址。 int open(char *file, int flags) 打开文件，flags 指示读/写模式，返回文件描述符。 int write(int fd, char *buf, int n) 从 buf 中向文件描述符 fd 写入 n 字节，返回写入的字节数。 int read(int fd, char *buf, int n) 从文件描述符 fd 中读取 n 字节到 buf，返回读取的字节数或 0（文件结束）。 int close(int fd) 关闭文件描述符 fd。 int dup(int fd) 返回一个新的文件描述符，指向与 fd 相同的文件。 int pipe(int p[]) 创建一个管道，将读/写文件描述符放入 p[0] 和 p[1]。 int chdir(char *dir) 更改当前目录为 dir。 int mkdir(char *dir) 创建一个新目录 dir。 int mknod(char *file, int, int) 创建一个设备文件。 int fstat(int fd, struct stat *st) 将关于打开文件的信息放入 *st。 int stat(char *file, struct stat *st) 将关于文件 file 的信息放入 *st。 int link(char *file1, char *file2) 为文件 file1 创建另一个名称 file2。 int unlink(char *file) 删除文件 file。 Why is O/S design + implementation hard and interesting? unforgiving environment: quirky h/w, hard to debug\nmany design tensions:\nefficient vs abstract / portable / general-purpose powerful vs simple interfaces flexible vs secure features interact: fd = open(); fork()\nuses are varied: laptops, smart-phones, cloud, virtual machines, embedded\nevolving hardware: NVRAM, multi-core, fast networks\nYou\u0026rsquo;ll be glad you took this course if you\u0026hellip;\ncare about what goes on under the hood like infrastructure need to track down bugs or security problems care about high performance Class structure Online course information: https://pdos.csail.mit.edu/6.S081/2020 \u0026ndash; schedule, assignments, labs Piazza \u0026ndash; announcements, discussion, lab help\nLectures\nO/S ideas case study of xv6, a small O/S, via code and xv6 book lab background O/S papers submit a question about each reading, before lecture. Labs: The point: hands-on experience Mostly one week each. Three kinds: Systems programming (due next week\u0026hellip;) O/S primitives, e.g. thread switching. O/S kernel extensions to xv6, e.g. network. Use piazza to ask/answer lab questions. Discussion is great, but please do not look at others\u0026rsquo; solutions!\nGrading: 70% labs, based on tests (the same tests you run). 20% lab check-off meetings: we\u0026rsquo;ll ask you about randomly-selected labs. 10% home-work and class/piazza discussion. No exams, no quizzes. Note that most of the grade is from labs. Start them early!\nIntroduction to UNIX system calls I\u0026rsquo;ll show some examples, and run them on xv6. xv6 has similar structure to UNIX systems such as Linux. but much simpler \u0026ndash; you\u0026rsquo;ll be able to digest all of xv6 accompanying book explains how xv6 works, and why Why UNIX? open source, well documented, clean design, widely used studying xv6 will help if you ever need to look inside Linux xv6 has two roles in 6.S081: example of core functions: virtual memory, multi-core, interrupts, \u0026amp;c starting point for most of the labs xv6 runs on RISC-V, as in current 6.004 you\u0026rsquo;ll run xv6 under the qemu machine emulator\nExample: copy.c, copy input to output read bytes from input, write them to the output\n$ copy copy.c is written in C Kernighan and Ritchie (K\u0026amp;R) book is good for learning C you can find these example programs via the schedule on the web site\ncopy.c // copy.c: 复制输入到输出 #include \u0026#34;kernel/types.h\u0026#34; // 包含系统调用相关的类型定义 #include \u0026#34;user/user.h\u0026#34; // 包含用户态函数的声明（如 read, write, exit） int main() { char buf[64]; // 定义一个缓冲区，用于存储读取的数据 // 无限循环，直到读取到文件结束标志或出现错误 while(1){ // 从标准输入（文件描述符 0）中读取数据到 buf 中 int n = read(0, buf, sizeof(buf)); // 如果读取到的数据量小于等于 0，则表示输入结束或发生了错误 if(n \u0026lt;= 0) break; // 退出循环 // 将读取的数据写入标准输出（文件描述符 1） write(1, buf, n); } // 正常退出程序 exit(0); } read() and write() are system calls first read()/write() argument is a \u0026quot;file descriptor\u0026quot; (fd) passed to kernel to tell it which \u0026ldquo;open file\u0026rdquo; to read/write must previously have been opened\nan FD connects to a file/device/socket/\u0026amp;c a process can open many files, have many FDs\nUNIX convention: fd 0 is \u0026ldquo;standard input\u0026rdquo;, 1 is \u0026ldquo;standard output\u0026rdquo;\nsecond read() argument is a pointer to some memory into which to read\nthird argument is the maximum number of bytes to read read() may read less, but not more return value: number of bytes actually read, or -1 for error\nnote: copy.c does not care about the format of the data UNIX I/O is 8-bit bytes interpretation is application-specific, e.g. database records, C source, \u0026amp;c\nWhere do file descriptors come from? example: open.c, create a file\n$ open $ cat output.txt open() creates a file, returns a file descriptor (or -1 for error) FD is a small integer FD indexes into a per-process table maintained by kernel [user/kernel diagram] different processes have different FD name-spaces i.e. FD 1 often means different things to different processes these examples ignore errors \u0026ndash; don\u0026rsquo;t be this sloppy! Figure 1.2 in the xv6 book lists system call arguments/return or look at UNIX man pages, e.g. \u0026ldquo;man 2 open\u0026rdquo;\nWhat happens when a program calls a system call like open()? looks like a function call, but it\u0026rsquo;s actually a special instruction hardware saves some user registers hardware increases privilege level hardware jumps to a known \u0026ldquo;entry point\u0026rdquo; in the kernel now running C code in the kernel kernel calls system call implementation open() looks up name in file system it might wait for the disk it updates kernel data structures (cache, FD table) restore user registers reduce privilege level jump back to calling point in the program, which resumes we\u0026rsquo;ll see more detail later in the course\nI\u0026rsquo;ve been typing to UNIX\u0026rsquo;s command-line interface, the shell. the shell prints the \u0026ldquo;$\u0026rdquo; prompts. the shell lets you run UNIX command-line utilities useful for system management, messing with files, development, scripting\n$ ls $ ls \u0026gt; out $ grep x \u0026lt; out UNIX supports other styles of interaction too window systems, GUIs, servers, routers, \u0026amp;c. but time-sharing via the shell was the original focus of UNIX. we can exercise many system calls via the shell.\nexample: fork.c, create a new process\n​\tthe shell creates a new process for each command you type, e.g. for\n$ echo hello the fork() system call creates a new process\n$ fork the kernel makes a copy of the calling process instructions, data, registers, file descriptors, current directory \u0026ldquo;parent\u0026rdquo; and \u0026ldquo;child\u0026rdquo; processes only difference: fork() returns a pid in parent, 0 in child a pid (process ID) is an integer, kernel gives each process a different pid thus: fork.c\u0026rsquo;s \u0026ldquo;fork() returned\u0026rdquo; executes in both processes the \u0026ldquo;if(pid == 0)\u0026rdquo; allows code to distinguish ok, fork lets us create a new process how can we run a program in that process?\nexample: exec.c, replace calling process with an executable file how does the shell run a program, e.g.\n$ echo a b c a program is stored in a file: instructions and initial memory created by the compiler and linker so there\u0026rsquo;s a file called echo, containing instructions\n$ exec exec() replaces current process with an executable file discards instruction and data memory loads instructions and memory from the file preserves file descriptors exec(filename, argument-array) argument-array holds command-line arguments; exec passes to main() cat user/echo.c echo.c shows how a program looks at its command-line arguments\nexample: forkexec.c, fork() a new process, exec() a program\n$ forkexec forkexec.c contains a common UNIX idiom: fork() : a child process exec() : a command in the child parent wait()s for child to finish the shell does fork/exec/wait for every command you type after wait(), the shell prints the next prompt to run in the background \u0026ndash; \u0026amp; \u0026ndash; the shell skips the wait() exit(status) -\u0026gt; wait(\u0026amp;status) status convention: 0 = success, 1 = command encountered an error note: the fork() copies, but exec() discards the copied memory this may seem wasteful you\u0026rsquo;ll transparently eliminate the copy in the \u0026ldquo;copy-on-write\u0026rdquo; lab\nfork 和 exec 的区别 fork 用于创建新进程，父子进程并发执行。\nexec 用于在现有进程中加载并运行新程序。\nfork 系统调用 功能：fork 用于创建一个新进程，称为子进程。子进程是通过复制当前进程（父进程）的地址空间创建的，因此子进程和父进程几乎完全相同，拥有相同的代码、数据和打开的文件描述符。 执行结果： 父进程调用 fork 后，返回值是子进程的 PID。 子进程从 fork 返回时，返回值是 0。 特点： 子进程是父进程的几乎精确副本，包括文件描述符、变量、代码段等，但其 PID（进程 ID）不同。 并发执行：fork 之后，父进程和子进程可以并发执行各自的代码。 多次返回：fork 会返回两次，一次在父进程中，一次在子进程中。 exec 系统调用 功能：exec 用于替换当前进程的代码和数据段，加载一个新程序并执行该程序。当 exec 被调用时，当前进程的所有内容（如代码、数据、堆栈）都被新程序替换，但进程的 PID 不变。 执行结果： exec 不返回，除非调用失败。成功调用 exec 后，旧的程序代码完全被新程序替换。 文件描述符不会被关闭（除非设置了 close-on-exec 标志）。 特点： exec 只会改变进程的执行代码，不会创建新的进程。 新程序继承了调用进程的 PID 和文件描述符，但原有的内存数据、堆栈、代码等都会被新程序替换掉。 example: redirect.c, redirect the output of a command what does the shell do for this?\n$ echo hello \u0026gt; out answer: fork, change FD 1 in child, exec echo\n$ redirect $ cat output.txt note: open() always chooses lowest unused FD; 1 due to close(1). fork, FDs, and exec interact nicely to implement I/O redirection separate fork-then-exec give child a chance to change FDs before exec FDs provide indirection commands just use FDs 0 and 1, don\u0026rsquo;t have to know where they go exec preserves the FDs that sh set up thus: only sh has to know about I/O redirection, not each program\nIt\u0026rsquo;s worth asking \u0026ldquo;why\u0026rdquo; about design decisions: Why these I/O and process abstractions? Why not something else? Why provide a file system? Why not let programs use the disk their own way? Why FDs? Why not pass a filename to write()? Why are files streams of bytes, not disk blocks or formatted records? Why not combine fork() and exec()? The UNIX design works well, but we will see other designs!\nexample: pipe1.c, communicate through a pipe how does the shell implement\n$ ls | grep x $ pipe1 an FD can refer to a \u0026ldquo;pipe\u0026rdquo;, as well as a file the pipe() system call creates two FDs read from the first FD write to the second FD the kernel maintains a buffer for each pipe [u/k diagram] write() appends to the buffer read() waits until there is data\nexample: pipe2.c, communicate between processes pipes combine well with fork() to implement ls | grep x shell creates a pipe, then forks (twice), then connects ls\u0026rsquo;s FD 1 to pipe\u0026rsquo;s write FD, and grep\u0026rsquo;s FD 0 to the pipe [diagram]\n$ pipe2 -- a simplified version pipes are a separate abstraction, but combine well w/ fork()\nexample: list.c, list files in a directory how does ls get a list of the files in a directory? you can open a directory and read it -\u0026gt; file names \u0026ldquo;.\u0026rdquo; is a pseudo-name for a process\u0026rsquo;s current directory see ls.c for more details\nSummary We\u0026rsquo;ve looked at UNIX\u0026rsquo;s I/O, file system, and process abstractions. The interfaces are simple \u0026ndash; just integers and I/O buffers. The abstractions combine well, e.g. for I/O redirection. You\u0026rsquo;ll use these system calls in the first lab, due next week.\nCode Pipes int pipeFd[2]; // 管道文件描述符数组，pipeFd[0]为读取端，pipeFd[1]为写入端 char *arguments[2]; // 存储传递给exec的参数 int main() { // 设置要执行的命令和参数 arguments[0] = \u0026#34;wc\u0026#34;; // 将 \u0026#34;wc\u0026#34; 命令作为参数传递给exec，用于统计输入的行、单词和字符数 arguments[1] = 0; // 以NULL表示参数结束 // 创建管道 pipe(pipeFd); // pipeFd[0]用于读取，pipeFd[1]用于写入 // 创建子进程 if(fork() == 0) { // 子进程代码，fork()返回0表示当前是子进程 close(0); // 关闭标准输入（文件描述符0） dup(pipeFd[0]); // 将管道的读取端复制到文件描述符0，使标准输入重定向到管道的读取端 close(pipeFd[0]); // 关闭管道的读取端，已重定向到标准输入，不再需要 close(pipeFd[1]); // 关闭管道的写入端，子进程不负责写入数据 exec(\u0026#34;/bin/wc\u0026#34;, arguments); // 执行wc命令，读取标准输入（从管道中读取），计算行、单词和字符数 } else { // 父进程代码 close(pipeFd[0]); // 关闭管道的读取端，父进程不负责读取数据 // 向管道写入数据 write(pipeFd[1], \u0026#34;hello world\\n\u0026#34;, 12); // 将 \u0026#34;hello world\\n\u0026#34; 写入管道，供子进程读取 close(pipeFd[1]); // 关闭管道的写入端，表示数据写入完成 } return 0; } cat.c #include \u0026#34;kernel/types.h\u0026#34; // 包含系统调用相关的类型定义 #include \u0026#34;kernel/stat.h\u0026#34; // 包含文件状态相关的定义 #include \u0026#34;user/user.h\u0026#34; // 包含用户态函数的声明（如 read, write, open, close, fprintf, exit） char buf[512]; // 定义一个缓冲区，用于存储读取的数据 // 函数：cat // 参数：int fd - 文件描述符 // 功能：从文件描述符 fd 中读取数据，并将其写入标准输出（文件描述符 1） void cat(int fd) { int n; // 从文件描述符 fd 中读取数据到 buf 中，读取的字节数存储在 n 中 while((n = read(fd, buf, sizeof(buf))) \u0026gt; 0) { // 将读取的数据写入标准输出 if (write(1, buf, n) != n) { // 如果写入的字节数不等于读取的字节数，报告写入错误 fprintf(2, \u0026#34;cat: write error\\n\u0026#34;); exit(1); } } // 如果读取过程中出现错误，报告读取错误并退出 if(n \u0026lt; 0){ fprintf(2, \u0026#34;cat: read error\\n\u0026#34;); exit(1); } } // 主函数 int main(int argc, char *argv[]) { int fd, i; // 如果没有提供文件参数，默认读取标准输入（文件描述符 0） if(argc \u0026lt;= 1){ cat(0); exit(0); } // 遍历命令行参数中的文件名 for(i = 1; i \u0026lt; argc; i++){ // 打开文件，获取文件描述符 if((fd = open(argv[i], 0)) \u0026lt; 0){ // 如果文件无法打开，报告错误并退出 fprintf(2, \u0026#34;cat: cannot open %s\\n\u0026#34;, argv[i]); exit(1); } // 调用 cat 函数，将文件内容输出到标准输出 cat(fd); // 关闭文件描述符 close(fd); } // 正常退出 exit(0); } echo.c #include \u0026#34;kernel/types.h\u0026#34; // 包含系统调用相关的类型定义 #include \u0026#34;kernel/stat.h\u0026#34; // 包含文件状态相关的定义 #include \u0026#34;user/user.h\u0026#34; // 包含用户态函数的声明（如 write, exit, strlen） int main(int argc, char *argv[]) { int i; // 遍历命令行参数，从第一个参数（argv[1]）开始 for(i = 1; i \u0026lt; argc; i++){ // 将当前参数 argv[i] 写入标准输出（文件描述符 1） write(1, argv[i], strlen(argv[i])); // 如果不是最后一个参数，在其后写入一个空格 if(i + 1 \u0026lt; argc){ write(1, \u0026#34; \u0026#34;, 1); } else { // 如果是最后一个参数，在其后写入一个换行符 write(1, \u0026#34;\\n\u0026#34;, 1); } } // 正常退出程序 exit(0); } forktest.c // 测试 fork 是否能在进程表满时优雅地失败。 // 这个程序是一个小的可执行文件，用于填充进程表以测试 fork 的行为。 #include \u0026#34;kernel/types.h\u0026#34; // 包含系统调用相关的类型定义 #include \u0026#34;kernel/stat.h\u0026#34; // 包含文件状态相关的定义 #include \u0026#34;user/user.h\u0026#34; // 包含用户态函数的声明（如 write, exit, fork, wait, strlen） #define N 1000 // 定义测试的 fork 最大次数 // 函数：print // 参数：const char *s - 要输出的字符串 // 功能：将字符串 s 写入标准输出（文件描述符 1） void print(const char *s) { write(1, s, strlen(s)); // 使用 write 系统调用将字符串写入标准输出 } // 函数：forktest // 功能：测试 fork 系统调用的行为，特别是在进程表满时 void forktest(void) { int n, pid; // 输出开始测试的信息 print(\u0026#34;fork test\\n\u0026#34;); // 循环尝试创建 N 个子进程 for(n = 0; n \u0026lt; N; n++){ pid = fork(); // 创建一个子进程 if(pid \u0026lt; 0) break; // 如果 fork 失败，退出循环 if(pid == 0) exit(0); // 子进程退出 } // 如果成功创建了 N 个子进程，表示 fork 行为异常 if(n == N){ print(\u0026#34;fork claimed to work N times!\\n\u0026#34;); exit(1); } // 等待所有子进程结束 for(; n \u0026gt; 0; n--){ if(wait(0) \u0026lt; 0){ // 等待子进程结束 print(\u0026#34;wait stopped early\\n\u0026#34;); exit(1); // 如果 wait 失败，报告错误并退出 } } // 如果 wait 没有返回 -1，表示还有多余的子进程 if(wait(0) != -1){ print(\u0026#34;wait got too many\\n\u0026#34;); exit(1); } // 输出测试成功的信息 print(\u0026#34;fork test OK\\n\u0026#34;); } // 主函数 int main(void) { forktest(); // 执行 fork 测试 exit(0); // 正常退出程序 } stressfs.c // Demonstrate that moving the \u0026#34;acquire\u0026#34; in iderw after the loop that // appends to the idequeue results in a race. // For this to work, you should also add a spin within iderw\u0026#39;s // idequeue traversal loop. Adding the following demonstrated a panic // after about 5 runs of stressfs in QEMU on a 2.1GHz CPU: // for (i = 0; i \u0026lt; 40000; i++) // asm volatile(\u0026#34;\u0026#34;); #include \u0026#34;kernel/types.h\u0026#34; #include \u0026#34;kernel/stat.h\u0026#34; #include \u0026#34;user/user.h\u0026#34; #include \u0026#34;kernel/fs.h\u0026#34; #include \u0026#34;kernel/fcntl.h\u0026#34; int main(int argc, char *argv[]) { int fd, i; char path[] = \u0026#34;stressfs0\u0026#34;; char data[512]; printf(\u0026#34;stressfs starting\\n\u0026#34;); memset(data, \u0026#39;a\u0026#39;, sizeof(data)); for(i = 0; i \u0026lt; 4; i++) if(fork() \u0026gt; 0) break; printf(\u0026#34;write %d\\n\u0026#34;, i); path[8] += i; fd = open(path, O_CREATE | O_RDWR); for(i = 0; i \u0026lt; 20; i++) // printf(fd, \u0026#34;%d\\n\u0026#34;, i); write(fd, data, sizeof(data)); close(fd); printf(\u0026#34;read\\n\u0026#34;); fd = open(path, O_RDONLY); for (i = 0; i \u0026lt; 20; i++) read(fd, data, sizeof(data)); close(fd); wait(0); exit(0); } Lab - Util sleep (easy) #include \u0026#34;kernel/types.h\u0026#34; #include \u0026#34;kernel/stat.h\u0026#34; #include \u0026#34;user/user.h\u0026#34; int main(int argc, char *argv[]) { if(argc != 2){ fprintf(2, \u0026#34;Usage: sleep [the times of ticks]...\\n\u0026#34;); exit(1); } int times = atoi(argv[1]); sleep(times); exit(0); } pingpong (easy) #include \u0026#34;kernel/types.h\u0026#34; #include \u0026#34;kernel/stat.h\u0026#34; #include \u0026#34;user/user.h\u0026#34; int main(int argc, char *argv[]) { if (argc \u0026gt; 1) { fprintf(2, \u0026#34;Usage: pingpong (without any parameters)\\n\u0026#34;); exit(1); } int pipe_fd[2]; if (pipe(pipe_fd) \u0026lt; 0) { fprintf(2, \u0026#34;pipe error\\n\u0026#34;); exit(1); } int pid = fork(); if (pid \u0026gt; 0) { // 父进程关闭管道的写端 close(pipe_fd[1]); // 父进程等待子进程的信号 char buf[1]; read(pipe_fd[0], buf, 1); pid = wait((int *)0); printf(\u0026#34;%d: received pong\\n\u0026#34;, getpid()); // 父进程关闭管道的读端 close(pipe_fd[0]); } else if (pid == 0) { // 子进程关闭管道的读端 close(pipe_fd[0]); printf(\u0026#34;%d: received ping\\n\u0026#34;, getpid()); // 子进程通过管道向父进程发送信号 write(pipe_fd[1], \u0026#34;x\u0026#34;, 1); // 子进程关闭管道的写端 close(pipe_fd[1]); exit(0); } else { printf(\u0026#34;fork error\\n\u0026#34;); exit(1); } exit(0); } primes (moderate)/(hard) #include \u0026#34;kernel/types.h\u0026#34; #include \u0026#34;kernel/stat.h\u0026#34; #include \u0026#34;user/user.h\u0026#34; void sieve(int p_left) { int p_right[2]; int prime; // 从左侧管道读取第一个数字 if (read(p_left, \u0026amp;prime, sizeof(int)) == 0) { close(p_left); exit(0); } // 输出该素数 printf(\u0026#34;prime %d\\n\u0026#34;, prime); // 创建一个新的管道 if (pipe(p_right) \u0026lt; 0) { fprintf(2, \u0026#34;pipe error\\n\u0026#34;); exit(1); } if (fork() == 0) { // 子进程递归处理 close(p_right[1]); sieve(p_right[0]); } else { // 父进程继续读取并筛选 close(p_right[0]); int num; while (read(p_left, \u0026amp;num, sizeof(int)) != 0) { if (num % prime != 0) { write(p_right[1], \u0026amp;num, sizeof(int)); } } // 关闭管道，等待子进程结束 close(p_left); close(p_right[1]); wait(0); exit(0); } } int main(int argc, char *argv[]) { int p[2]; if (pipe(p) \u0026lt; 0) { fprintf(2, \u0026#34;pipe error\\n\u0026#34;); exit(1); } if (fork() == 0) { close(p[1]); sieve(p[0]); } else { close(p[0]); // 将 2 到 35 的数字写入管道 for (int i = 2; i \u0026lt;= 35; i++) { write(p[1], \u0026amp;i, sizeof(int)); } close(p[1]); wait(0); exit(0); } return 0; } find (moderate) #include \u0026#34;kernel/types.h\u0026#34; #include \u0026#34;kernel/stat.h\u0026#34; #include \u0026#34;user/user.h\u0026#34; #include \u0026#34;kernel/fs.h\u0026#34; #include \u0026#34;kernel/fcntl.h\u0026#34; #define MAXBUF 512 // 定义缓冲区大小 /** * find - 递归查找目录树中与指定文件名匹配的文件。 * @path: 要搜索的目录路径。 * @filename: 要查找的文件名。 * * 该函数通过递归遍历目录树，打印出与指定文件名匹配的文件的路径。 * 它会忽略特殊目录项 `.` 和 `..` 以避免递归回到当前或父目录。 */ void find(char *path, char *filename) { char buf[512], *p; int fd; struct dirent de; struct stat st; // 打开指定的目录路径 if ((fd = open(path, 0)) \u0026lt; 0) { fprintf(2, \u0026#34;find: cannot open %s\\n\u0026#34;, path); return; } // 获取文件状态（例如确定是文件还是目录） if (fstat(fd, \u0026amp;st) \u0026lt; 0) { fprintf(2, \u0026#34;find: cannot stat %s\\n\u0026#34;, path); close(fd); return; } // 判断文件类型，处理不同的情况 switch (st.type) { case T_FILE: // 如果是普通文件 // 检查文件名是否与目标文件名匹配 if (strcmp(path + strlen(path) - strlen(filename), filename) == 0) { // 如果匹配，打印文件路径 printf(\u0026#34;%s\\n\u0026#34;, path); // 注意这里每个匹配的文件都应该在新行打印 } break; case T_DIR: // 如果是目录 // 检查路径长度是否超出缓冲区大小 if (strlen(path) + 1 + DIRSIZ + 1 \u0026gt; sizeof(buf)) { printf(\u0026#34;find: path too long\\n\u0026#34;); break; } // 将当前路径复制到缓冲区中 strcpy(buf, path); p = buf + strlen(buf); *p++ = \u0026#39;/\u0026#39;; // 读取目录中的每个目录项 while (read(fd, \u0026amp;de, sizeof(de)) == sizeof(de)) { if (de.inum == 0) continue; // 跳过无效的目录项 // 将目录项名称复制到路径缓冲区 memmove(p, de.name, DIRSIZ); p[DIRSIZ] = 0; // 忽略特殊目录项 `.` 和 `..` if (strcmp(de.name, \u0026#34;.\u0026#34;) == 0 || strcmp(de.name, \u0026#34;..\u0026#34;) == 0) continue; // 递归调用 find 函数处理子目录或文件 find(buf, filename); } break; } // 关闭文件描述符以释放资源 close(fd); } /** * main - 程序的入口点，解析命令行参数并调用 find 函数。 * @argc: 参数个数。 * @argv: 参数值数组。 * * 该函数验证参数的正确性，并调用 find 函数开始递归查找。 */ int main(int argc, char *argv[]) { // 检查命令行参数是否正确 if (argc \u0026lt; 3) { // 如果参数不足，打印使用说明并退出 fprintf(2, \u0026#34;Usage: find \u0026lt;directory\u0026gt; \u0026lt;filename\u0026gt;\\n\u0026#34;); exit(1); } // 调用 find 函数，开始查找文件 find(argv[1], argv[2]); exit(0); } xargs (moderate) #include \u0026#34;kernel/types.h\u0026#34; #include \u0026#34;kernel/stat.h\u0026#34; #include \u0026#34;user/user.h\u0026#34; #define MAXARG 32 // 最大参数数量 #define MAXBUF 1024 // 最大输入缓冲区大小 // 从标准输入读取一行 int read_line(char *buf, int size) { int i = 0; // 当前字符索引 char c; // 存储读取的字符 // 从标准输入逐字符读取，直到遇到换行符或缓冲区已满 while (i \u0026lt; size - 1) { if (read(0, \u0026amp;c, 1) != 1) { return i; // 到达输入结束或发生错误 } if (c == \u0026#39;\\n\u0026#39;) { break; // 遇到换行符，停止读取 } buf[i++] = c; // 将读取的字符存入缓冲区 } buf[i] = \u0026#39;\\0\u0026#39;; // 在字符串末尾添加 null 终止符 return i; } int main(int argc, char *argv[]) { if (argc \u0026lt; 2) { fprintf(2, \u0026#34;Usage: xargs command [initial-args]\\n\u0026#34;); // 如果没有提供命令参数，输出用法提示 exit(1); // 退出程序 } char buf[MAXBUF]; // 用于存储输入行的缓冲区 // 从标准输入读取每一行 while (read_line(buf, sizeof(buf)) \u0026gt; 0) { // 创建命令行参数数组 char *cmd_argv[MAXARG + 2]; // +2: 一个存放命令名，一个存放拼接后的参数 cmd_argv[0] = argv[1]; // 命令名称 int i; // 复制用户提供的初始参数（如果有） for (i = 1; i \u0026lt; argc - 1 \u0026amp;\u0026amp; i \u0026lt; MAXARG; i++) { cmd_argv[i] = argv[i + 1]; } // 将读取的行作为最后一个参数 cmd_argv[i++] = buf; cmd_argv[i] = 0; // 参数列表以 null 终止 int pid = fork(); // 创建子进程 if (pid \u0026lt; 0) { fprintf(2, \u0026#34;xargs: fork failed\\n\u0026#34;); // 如果创建子进程失败，输出错误信息 exit(1); // 退出程序 } else if (pid == 0) { exec(cmd_argv[0], cmd_argv); // 执行命令 fprintf(2, \u0026#34;xargs: exec failed\\n\u0026#34;); // 如果执行命令失败，输出错误信息 exit(1); // 退出子进程 } else { // 父进程中 wait(0); // 等待子进程完成 } } exit(0); // 正常退出程序 } ","permalink":"https://kennems.github.io/posts/tech/mit6.s0811-os-overview/","summary":"MIT6.S081(1)-O/S overview Class Page Overview 6.S081 goals Understand operating system (O/S) design and implementation Hands-on experience extending a small O/S Hands-on experience writing systems software What is the purpose of an O/S? Abstract the hardware for convenience and portability Multiplex the hardware among many applications Isolate applications in order to contain bugs Allow sharing among cooperating applications Control sharing for security Don\u0026rsquo;t get in the way of high performance Support","title":"MIT6.S081(1)-O/S overview"},{"content":"MIT6.S081(3)-OS organization Lecture Topic: OS design ​ system calls ​ micro/monolithic kernel First system call in xv6\nOS picture apps: sh, echo, \u0026hellip; system call interface (open, close,\u0026hellip;) OS\nGoal of OS run multiple applications isolate them multiplex them share\nStrawman design: No OS Application directly interacts with hardware CPU cores \u0026amp; registers DRAM chips Disk blocks \u0026hellip; OS library perhaps abstracts some of it\nStrawman design not conducive to multiplexing each app periodically must give up hardware BUT, weak isolation app forgets to give up, no other app runs apps has end-less loop, no other app runs you cannot even kill the badly app from another app but used by real-time OSes \u0026ldquo;cooperative scheduling\u0026rdquo;\nStrawman design not conducive to memory isolation all apps share physical memory one app can overwrites another apps memory one app can overwrite OS library\nUnix interface conducive to OS goals abstracts the hardware in way that achieves goals processes (instead of cores): fork OS transparently allocates cores to processes Saves and restore registers Enforces that processes give them up Periodically re-allocates cores memory (instead of physical memory): exec Each process has its \u0026ldquo;own\u0026rdquo; memory OS can decide where to place app in memory OS can enforce isolation between memory of different apps OS allows storing image in file system files (instead of disk blocks) OS can provide convenient names OS can allow sharing of files between processes/users pipes (instead of shared physical mem) OS can stop sender/receiver\nOS must be defensive an application shouldn\u0026rsquo;t be able to crash OS an application shouldn\u0026rsquo;t be able to break out of its isolation =\u0026gt; need strong isolation between apps and OS approach: hardware support\nuser/kernel mode virtual memory Processors provide user/kernel mode kernel mode: can execute \u0026ldquo;privileged\u0026rdquo; instructions e.g., setting kernel/user bit e.g., reprogramming timer chip user mode: cannot execute privileged instructions Run OS in kernel mode, applications in user mode [RISC-V has also an M mode, which we mostly ignore]\nProcessors provide virtual memory Hardware provides page tables that translate virtual address to physical Define what physical memory an application can access OS sets up page tables so that each application can access only its memory\nApps must be able to communicate with kernel Write to storage device, which is shared =\u0026gt; must be protected =\u0026gt; in kernel Exit app \u0026hellip;\nSolution: add instruction to change mode in controlled way ecall enters kernel mode at a pre-agreed entry point\nModify OS picture user / kernel (redline) app -\u0026gt; printf() -\u0026gt; write() -\u0026gt; SYSTEM CALL -\u0026gt; sys_write() -\u0026gt; \u0026hellip; user-level libraries are app\u0026rsquo;s private business kernel internal functions are not callable by user\nother way of drawing picture: syscall 1 -\u0026gt; system call stub -\u0026gt; kernel entry -\u0026gt; syscall -\u0026gt; fs syscall 2 -\u0026gt; proc\nsystem call stub executes special instruction to enter kernel hardware switches to kernel mode but only at an entry point specified by the kernel\nsyscall need some way to get at arguments of syscall\n[syscalls the topic of this week\u0026rsquo;s lab]\nKernel is the Trusted Computing Base (TCB) Kernel must be \u0026ldquo;correct\u0026rdquo; Bugs in kernel could allow user apps to circumvent kernel/user Happens often in practice, because kernels are complex See CVEs Kernel must treat user apps as suspect User app may trick kernel to do the wrong thing Kernel must check arguments carefully Setup user/kernel correctly Etc. Kernel in charge of separating applications too One app may try to read/write another app\u0026rsquo;s memory =\u0026gt; Requires a security mindset Any bug in kernel may be a security exploit\nAside: can one have process isolation WITHOUT h/w-supported kernel/user mode and virtual memory? yes! use a strongly-typed programming language\nFor example, see Singularity O/S the compiler is then the trust computing base (TCB) but h/w user/kernel mode is the most popular plan Monolothic kernel OS runs in kernel space Xv6 does this. Linux etc. too. kernel interface == system call interface one big program with file system, drivers, \u0026amp;c\ngood: easy for subsystems to cooperate one cache shared by file system and virtual memory bad: interactions are complex leads to bugs no isolation within Microkernel design many OS services run as ordinary user programs file system in a file server kernel implements minimal mechanism to run services in user space processes with memory inter-process communication (IPC) kernel interface != system call interface\ngood: more isolation bad: may be hard to get good performance both monolithic and microkernel designs widely used Xv6 case study Monolithic kernel Unix system calls == kernel interface Source code reflects OS organization (by convention) user/ apps in user mode kernel/ code in kernel mode Kernel has several parts kernel/defs.h proc fs .. Goal: read source code and understand it (without consulting book)\nUsing xv6 Makefile builds kernel program user programs mkfs $ make qemu runs xv6 on qemu emulates a RISC-V computer\nBuilding kernel\n.c -\u0026gt; gcc -\u0026gt; .s -\u0026gt; .o \\\r.... ld -\u0026gt; a.out\r.c -\u0026gt; gcc -\u0026gt; .s -\u0026gt; .o / makefile keeps .asm file around for binary see for example, kernel/kernel.asm\nThe RISC-V computer A very simple board (e.g., no display)\nRISC-V processor with 4 cores RAM (128 MB) support for interrupts (PLIC, CLINT) support for UART allows xv6 to talk to console allows xv6 to read from keyboard support for e1000 network card (through PCIe) Development using Qemu More convenient than using the real hardware Qemu emulates several RISC-V computers\nwe use the \u0026ldquo;virt\u0026rdquo; one https://github.com/riscv/riscv-qemu/wiki close to the SiFive board (https://www.sifive.com/boards) but with virtio for disk What is \u0026ldquo;to emulate\u0026rdquo;? Qemu is a C program that faithfully implements a RISC-V processor\nfor (;;) {\rread next instructions\rdecode instruction\rexecute instruction (updating processor state)\r} [big idea: software = hardware]\nBoot xv6 (under gdb)\n$ make CPUS=1 qemu-gdb ​ runs xv6 under gdb (with 1 core) Qemu starts xv6 in kernel/entry.S (see kernel/kernel.ld) ​ set breakpoint at _entry ​ look at instruction ​ info reg ​ set breakpoint at main ​ Walk through main ​ single step into userinit ​ Walk through userinit ​ show proc.h ​ show allocproc() ​ show initcode.S/initcode.asm ​ break forkret() ​ walk to userret ​ break syscall ​ print num ​ syscalls[num] ​ exec \u0026ldquo;/init\u0026rdquo;\nOperating system organization 文件名 描述 bio.c 文件系统的磁盘块缓存。 console.c 连接用户键盘和屏幕。 entry.S 最早的引导指令。 exec.c exec() 系统调用。 file.c 文件描述符支持。 fs.c 文件系统。 kalloc.c 物理页面分配器。 kernelvec.S 处理来自内核的陷阱和定时器中断。 log.c 文件系统日志和崩溃恢复。 main.c 控制启动时其他模块的初始化。 pipe.c 管道。 plic.c RISC-V 中断控制器。 printf.c 格式化输出到控制台。 proc.c 进程和调度。 sleeplock.c 让出 CPU 的锁。 spinlock.c 不让出 CPU 的锁。 start.c 机器模式的早期引导代码。 string.c C 字符串和字节数组库。 swtch.S 线程切换。 syscall.c 将系统调用分派给处理函数。 sysfile.c 与文件相关的系统调用。 sysproc.c 与进程相关的系统调用。 trampoline.S 用户和内核之间切换的汇编代码。 trap.c 处理并返回陷阱和中断的 C 代码。 uart.c 串行端口控制台设备驱动程序。 virtio_disk.c 磁盘设备驱动程序。 vm.c 管理页表和地址空间。 Lab: system calls System call tracing (moderate) /home/topeet/project/xv6-labs-2020/Makefile $U/_wc\\ $U/_zombie\\ $U/_trace\\ /home/topeet/project/xv6-labs-2020/user/usys.pl entry(\u0026#34;trace\u0026#34;); ~/project/xv6-labs-2020/kernel/proc.c 在fork()函数内部添加如下代码：\n// copy saved user registers. *(np-\u0026gt;trapframe) = *(p-\u0026gt;trapframe); np-\u0026gt;tracemask = p-\u0026gt;tracemask; // Cause fork to return 0 in the child. np-\u0026gt;trapframe-\u0026gt;a0 = 0; ~/project/xv6-labs-2020/kernel/proc.h 在结构体proc中添加tracemask属性\nchar name[16]; // Process name (debugging) int tracemask; // Trace Mask }; ~/project/xv6-labs-2020/kernel/syscall.c 处理系统调用（system call)的核心代码， 主要作用是实现系统调用的参数提取，处理和结果返回。\n[SYS_mkdir] sys_mkdir, [SYS_close] sys_close, [SYS_trace] sys_trace}; 按照参数顺序保存每个系统调用的名称，便于调试和输出。\nchar *sys_name[] = { \u0026#34;fork\u0026#34;, \u0026#34;exit\u0026#34;, \u0026#34;wait\u0026#34;, \u0026#34;pipe\u0026#34;, \u0026#34;read\u0026#34;, \u0026#34;kill\u0026#34;, \u0026#34;exec\u0026#34;, \u0026#34;fstat\u0026#34;, \u0026#34;chdir\u0026#34;, \u0026#34;dup\u0026#34;, \u0026#34;getpid\u0026#34;, \u0026#34;sbrk\u0026#34;, \u0026#34;sleep\u0026#34;, \u0026#34;uptime\u0026#34;, \u0026#34;open\u0026#34;, \u0026#34;write\u0026#34;, \u0026#34;mknod\u0026#34;, \u0026#34;unlink\u0026#34;, \u0026#34;link\u0026#34;, \u0026#34;mkdir\u0026#34;, \u0026#34;close\u0026#34;, \u0026#34;trace\u0026#34;}; 在syscall函数中添加对应的逻辑：如果tracemask参数对应需要输出对应的system call， 则在调用之后根据tracemask打印输出。\nif (num \u0026gt; 0 \u0026amp;\u0026amp; num \u0026lt; NELEM(syscalls) \u0026amp;\u0026amp; syscalls[num]) { p-\u0026gt;trapframe-\u0026gt;a0 = syscalls[num](); if (p-\u0026gt;tracemask \u0026gt;\u0026gt; (num) \u0026amp; 0x01 == 1) { printf(\u0026#34;%d: syscall %s -\u0026gt; %d\\n\u0026#34;, p-\u0026gt;pid, sys_name[num - 1], p-\u0026gt;trapframe-\u0026gt;a0); } } ~/project/xv6-labs-2020/kernel/syscall.h #define SYS_mkdir 20 #define SYS_close 21 #define SYS_trace 22 ~/project/xv6-labs-2020/kernel/sysproc.c 当命令行输入命令后执行此函数\nuint64 sys_trace(void) { int n; argint(0, \u0026amp;n); myproc()-\u0026gt;tracemask = n; return 0; } ~/project/xv6-labs-2020/user/user.h int sleep(int); int uptime(void); int trace(int); Sysinfo (moderate) 实现sysinfo，同时重构上面的 trace\n~/project/xv6-labs-2020/Makefile $U/_sysinfotest\\ ~/project/xv6-labs-2020/kernel/defs.h // sysinfo.c int process_number(); int amount_free_memory(void); ~/project/xv6-labs-2020/kernel/kalloc.c // get free memory int amount_free_memory(void){ struct run *r; r = kmem.freelist; int cnt = 0; for (; r; r = r-\u0026gt;next) { cnt++; } return cnt*PGSIZE; } ~/project/xv6-labs-2020/kernel/proc.c #include \u0026#34;sysinfo.h\u0026#34; ~/project/xv6-labs-2020/kernel/proc.h char name[16]; // Process name (debugging) int tracemask; // Trace memory }; struct sysinfo; int trace(int mask); void gather_sysinfo(struct sysinfo *info); ~/project/xv6-labs-2020/kernel/syscall.c [SYS_trace] sys_trace, [SYS_sysinfo] sys_sysinfo }; \u0026#34;close\u0026#34;, \u0026#34;trace\u0026#34;, \u0026#34;sysinfo\u0026#34; }; extern uint64 sys_uptime(void); extern uint64 sys_trace(void); extern uint64 sys_sysinfo(void); ~/project/xv6-labs-2020/kernel/syscall.h #define SYS_close 21 #define SYS_trace 22 #define SYS_sysinfo 23 ~/project/xv6-labs-2020/kernel/sysproc.c #include \u0026#34;sysinfo.h\u0026#34; ~/project/xv6-labs-2020/user/user.h struct rtcdate; struct sysinfo; ~/project/xv6-labs-2020/user/usys.pl entry(\u0026#34;uptime\u0026#34;); entry(\u0026#34;trace\u0026#34;); entry(\u0026#34;sysinfo\u0026#34;); ","permalink":"https://kennems.github.io/posts/tech/mit6.s0813-os-organization/","summary":"MIT6.S081(3)-OS organization Lecture Topic: OS design ​ system calls ​ micro/monolithic kernel First system call in xv6 OS picture apps: sh, echo, \u0026hellip; system call interface (open, close,\u0026hellip;) OS Goal of OS run multiple applications isolate them multiplex them share Strawman design: No OS Application directly interacts with hardware CPU cores \u0026amp; registers DRAM chips Disk blocks \u0026hellip; OS library perhaps abstracts some of it Strawman design not conducive to","title":"MIT6.S081(3)-OS organization"},{"content":"Kotlin协程(4) Kotlin实践部分\nFlow与文件下载应用 DownloadFragment.kt // DownloadFragment 是一个 Fragment 类，用于处理文件下载任务 class DownloadFragment : Fragment() { // 定义下载文件的 URL 地址，这是一个静态的常量 val URL = \u0026#34;https://ts1.cn.mm.bing.net/th/id/R-C.56ab5704680b6574c1b3c0a52643d8b5?rik=P8OAzrJEZS%2biuw\u0026amp;riu=http%3a%2f%2fjourneyz.co%2fwp-content%2fuploads%2f2019%2f09%2fGolden-Gate-Bridge.jpg\u0026amp;ehk=WX9eb2rUUjWBLLrsG2MQZLOMk2wtreV%2bT1Qq1tARk4s%3d\u0026amp;risl=\u0026amp;pid=ImgRaw\u0026amp;r=0\u0026#34; // 延迟初始化 mBinding，这是一个 FragmentDownloadBinding 对象，用于绑定 XML 布局文件 private val mBinding: FragmentDownloadBinding by lazy { FragmentDownloadBinding.inflate(layoutInflater) } // 重写 onCreateView 方法，在 Fragment 创建视图时调用 override fun onCreateView( inflater: LayoutInflater, container: ViewGroup?, savedInstanceState: Bundle? ): View? { // 返回绑定的根视图作为 Fragment 的界面 return mBinding.root } // 重写 onActivityCreated 方法，当与 Fragment 相关的活动的 onCreate 方法完成时调用 @RequiresApi(Build.VERSION_CODES.UPSIDE_DOWN_CAKE) override fun onActivityCreated(savedInstanceState: Bundle?) { super.onActivityCreated(savedInstanceState) // 使用 lifecycleScope 启动协程，当 Fragment 的生命周期处于 Created 状态时执行 lifecycleScope.launchWhenCreated { // 获取上下文并执行下载操作 context?.apply { // 指定下载文件的存储位置，保存在应用的外部文件目录下 val file = File(getExternalFilesDir(null)?.path, \u0026#34;pic.jpg\u0026#34;) // 开始下载文件，并收集下载状态 DownloadManager.download(URL, file).collect { status -\u0026gt; when (status) { // 如果下载过程中有进度更新 is DownloadStatus.Progress -\u0026gt; { mBinding.apply { // 更新进度条和进度文本 progressBar.progress = status.value tvProgress.text = \u0026#34;${status.value}%\u0026#34; } } // 如果下载过程中出现错误 is DownloadStatus.Error -\u0026gt; { Toast.makeText(context, \u0026#34;下载错误\u0026#34;, Toast.LENGTH_SHORT).show() } // 如果下载完成 is DownloadStatus.Done -\u0026gt; { mBinding.apply { // 设置进度条到 100%，并更新文本为 100% progressBar.progress = 100 tvProgress.text = \u0026#34;100%\u0026#34; } Toast.makeText(context, \u0026#34;下载完成\u0026#34;, Toast.LENGTH_SHORT).show() } // 处理其他可能的下载状态 else -\u0026gt; { Log.d(\u0026#34;Kennem\u0026#34;, \u0026#34;下载失败\u0026#34;) } } } } } } } DownloadManager.kt object DownloadManager { /** * 下载指定的文件并返回下载状态的流（Flow）。 * * @param url 文件下载的 URL 地址。 * @param file 下载后保存的本地文件。 * @return 下载状态的 Flow，包含下载进度、完成状态或错误信息。 */ @RequiresApi(Build.VERSION_CODES.UPSIDE_DOWN_CAKE) fun download(url: String, file: File): Flow\u0026lt;DownloadStatus\u0026gt; { return flow { // 构建 HTTP 请求对象 val request = Request.Builder().url(url).get().build() // 执行 HTTP 请求，获取响应 val response = OkHttpClient.Builder().build().newCall(request).execute() // 检查响应是否成功 if (response.isSuccessful) { response.body()!!.let { body -\u0026gt; // 获取内容的总长度（字节数） val total = body.contentLength() // 使用输出流将下载的数据写入本地文件 file.outputStream().use { output -\u0026gt; val input = body.byteStream() // 获取输入流 var emittedProgress = 0L // 记录已发出的进度 // 将输入流中的数据复制到输出流，同时跟踪复制的字节数 input.copyTo(output) { bytesCopied -\u0026gt; // 计算当前进度百分比 val progress = bytesCopied * 100 / total // 每当进度比上次更新多5%以上时，发出进度更新 if (progress - emittedProgress \u0026gt; 5) { delay(100) // 模拟网络延迟（可选） emit(DownloadStatus.Progress(progress.toInt())) // 发出进度状态 emittedProgress = progress // 更新已发出的进度 } } } } // 下载完成，发出完成状态 emit(DownloadStatus.Done(file)) } else { // 如果响应失败，抛出异常 throw IOException(response.toString()) } }.catch { // 如果发生错误，删除部分下载的文件并发出错误状态 file.delete() emit(DownloadStatus.Error(it)) }.flowOn(Dispatchers.IO) // 在 IO 线程上运行下载流程 } } DownloadStatus.kt /** * 封闭类，用于表示下载过程中的不同状态。 * 封闭类允许定义一个有限的类型集合，在使用 `when` 表达式时提供全面的类型检查。 */ sealed class DownloadStatus { /** * 表示初始状态，即尚未开始下载。 * 可以用于初始化或重置状态。 */ object None : DownloadStatus() /** * 表示正在进行的下载的进度。 * @param value 一个整数，表示当前的进度百分比（0-100）。 */ data class Progress(val value: Int) : DownloadStatus() /** * 表示下载过程中发生的错误。 * @param throwable 引发失败的异常或错误。 */ data class Error(val throwable: Throwable) : DownloadStatus() /** * 表示下载成功完成。 * @param file 下载完成的文件。 */ data class Done(val file: File) : DownloadStatus() } Flow与Room的应用 UserFragment.kt /** * `UserViewModel` 继承自 `AndroidViewModel`，用于管理用户数据的视图模型。 * `AndroidViewModel` 提供了对应用程序上下文的访问。 * * @param app 应用程序上下文。 */ class UserViewModel(app: Application) : AndroidViewModel(app) { /** * 插入一个新的用户到数据库中。 * 这个方法会在 `viewModelScope` 中异步执行。 * `viewModelScope` 是 `ViewModel` 提供的协程作用域，可以自动取消任务。 * * @param uid 用户 ID。 * @param firstName 用户的名字。 * @param lastName 用户的姓氏。 */ fun insert(uid: String, firstName: String, lastName: String) { viewModelScope.launch { // 获取应用数据库实例并执行插入操作 AppDatabase.getInstance(getApplication()) .userDao() .insert(User(uid.toInt(), firstName, lastName)) // 打印日志，便于调试 Log.d(\u0026#34;Kennem\u0026#34;, \u0026#34;insert user: $uid\u0026#34;) } } /** * 获取所有用户的流。 * 返回一个 `Flow` 对象，它允许异步地获取数据并观察数据变化。 * * @return 返回一个 `Flow` 对象，其中包含用户列表。 */ fun getAll(): Flow\u0026lt;List\u0026lt;User\u0026gt;\u0026gt; { return AppDatabase.getInstance(getApplication()) .userDao() .getAll() .catch { e -\u0026gt; // 捕获并打印流中的异常 e.printStackTrace() } .flowOn(Dispatchers.IO) // 在 IO 线程中执行数据库操作 } } User.kt @Entity(tableName = \u0026#34;user\u0026#34;) data class User( @PrimaryKey(autoGenerate = true) val uid: Int = 0, @ColumnInfo(name = \u0026#34;first_name\u0026#34;) val firstName: String, @ColumnInfo(name = \u0026#34;last_name\u0026#34;) val lastName: String ) UserDao.kt @Dao interface UserDao{ @Insert(onConflict = OnConflictStrategy.REPLACE) suspend fun insert(user: User) @Query(\u0026#34;SELECT * FROM user\u0026#34;) fun getAll(): Flow\u0026lt;List\u0026lt;User\u0026gt;\u0026gt; } AppDatabase.kt /** * Room 数据库类，用于定义数据库及其版本。 * Room 是 Android 的持久性库，它提供了一个抽象层，方便使用 SQLite 数据库。 * * @param entities 数据库中的实体类。这里定义了 `User` 实体类。 * @param version 数据库的版本号。当实体类结构发生变化时，版本号需要递增。 * @param exportSchema 是否导出数据库模式到一个 JSON 文件。这里设置为 false，表示不导出。 */ @Database(entities = [User::class], version = 1, exportSchema = false) abstract class AppDatabase : RoomDatabase() { /** * 获取 UserDao 的实例。 * DAO（数据访问对象）用于定义对数据库的操作。 * * @return UserDao 实例，用于执行数据库操作。 */ abstract fun userDao(): UserDao companion object { @Volatile private var instance: AppDatabase? = null /** * 获取数据库实例的方法。 * 如果实例不存在，则同步创建一个新实例，并进行初始化。 * * @param context 应用程序上下文，用于创建数据库。 * @return AppDatabase 的单例实例。 */ fun getInstance(context: Context): AppDatabase { // 检查现有的实例 return instance ?: synchronized(this) { // 双重检查锁定（Double-Checked Locking） val newInstance = Room.databaseBuilder( context.applicationContext, AppDatabase::class.java, \u0026#34;app_database\u0026#34; ).build() instance = newInstance newInstance } } } } UserAdapter.kt // UserAdapter 是一个继承自 RecyclerView.Adapter 的适配器类，用于在 RecyclerView 中显示 User 数据。 class UserAdapter(private val context: Context) : RecyclerView.Adapter\u0026lt;BindingViewHolder\u0026gt;() { // data 用于存储要显示的 User 数据的 ArrayList。 private val data = ArrayList\u0026lt;User\u0026gt;() /** * 用于更新适配器的数据。 * @param data 要设置的新数据列表。 */ @SuppressLint(\u0026#34;NotifyDataSetChanged\u0026#34;) fun setData(data: List\u0026lt;User\u0026gt;) { // 打印日志以查看 setData 方法调用时传递的数据。 Log.d(\u0026#34;Kennem\u0026#34;, \u0026#34;setData called with data: $data\u0026#34;) // 清空当前数据并添加新的数据。 this.data.clear() this.data.addAll(data) // 通知适配器数据已更改，刷新视图。 notifyDataSetChanged() } /** * 创建新的 ViewHolder 对象。 * @param parent ViewGroup 父视图，用于在其中添加新视图。 * @param viewType 视图类型。 * @return 返回一个新的 BindingViewHolder 对象。 */ override fun onCreateViewHolder(parent: ViewGroup, viewType: Int): BindingViewHolder { // 使用指定的上下文对象通过布局解析器加载布局并绑定到 ViewHolder。 val binding = ItemUserBinding.inflate(LayoutInflater.from(context), parent, false) return BindingViewHolder(binding = binding) } /** * 返回 RecyclerView 中数据项的总数。 * @return 数据项的总数。 */ override fun getItemCount() = data.size /** * 绑定 ViewHolder 中的视图数据。 * @param holder BindingViewHolder 当前 ViewHolder。 * @param position 当前数据项的位置。 */ @SuppressLint(\u0026#34;SetTextI18n\u0026#34;) override fun onBindViewHolder(holder: BindingViewHolder, position: Int) { // 根据当前的 position 获取对应的 User 对象。 val item = data[position] // 将 ViewHolder 的绑定对象转换为 ItemUserBinding 类型。 val binding = holder.binding as ItemUserBinding // 设置文本视图，显示用户的 id、名字和姓氏。 binding.text.text = \u0026#34;id: ${item.uid}, Name: ${item.firstName}, ${item.lastName}\u0026#34; } } Flow与Retrofit的应用 ArticleFragment.kt class ArticleFragment : Fragment() { // 使用 viewModels 委托属性获取 ArticleViewModel 实例 private val viewModel by viewModels\u0026lt;ArticleViewModel\u0026gt;() // 延迟初始化 FragmentArticleBinding 实例，用于绑定布局 private val mBinding: FragmentArticleBinding by lazy { FragmentArticleBinding.inflate(layoutInflater) } // 创建视图时返回绑定的根视图 override fun onCreateView( inflater: LayoutInflater, container: ViewGroup?, savedInstanceState: Bundle? ): View? { return mBinding.root } // 扩展函数：为 TextView 创建一个 Flow 以响应文本变化 private fun TextView.textWatcherFlow(): Flow\u0026lt;String\u0026gt; = callbackFlow { // 创建一个 TextWatcher 对象以监听文本变化 val textWatcher = object : TextWatcher { override fun beforeTextChanged( s: CharSequence?, start: Int, count: Int, after: Int ) { // 在文本变化之前的回调，这里无需处理 } override fun onTextChanged(s: CharSequence?, start: Int, before: Int, count: Int) { // 在文本变化时的回调，这里无需处理 } override fun afterTextChanged(s: Editable?) { // 在文本变化后发送新文本到 Flow this@callbackFlow.trySend(s.toString()).isSuccess } } // 将 TextWatcher 添加到 TextView addTextChangedListener(textWatcher) // 当 Flow 关闭时，移除 TextWatcher awaitClose { removeTextChangedListener(textWatcher) } } // 在 Activity 创建时执行的操作 override fun onActivityCreated(savedInstanceState: Bundle?) { super.onActivityCreated(savedInstanceState) // 启动一个协程来收集文本变化并搜索文章 lifecycleScope.launchWhenCreated { mBinding.etSearch.textWatcherFlow().collect { Log.d(\u0026#34;Kennem\u0026#34;, \u0026#34;onActivityCreated: 收到文本变化：$it\u0026#34;) viewModel.searchArticles(it) } } // 配置 RecyclerView 适配器和布局管理器 context?.let { val adapter = ArticleAdapter(it) mBinding.recyclerView.adapter = adapter mBinding.recyclerView.layoutManager = LinearLayoutManager(context) // 观察文章列表变化并更新适配器的数据 viewModel.articles.observe(viewLifecycleOwner) { articles -\u0026gt; adapter.setData(articles) } } } } ArticleViewModel.kt /** * `ArticleViewModel` 继承自 `AndroidViewModel`，用于管理与文章相关的视图模型。 * `AndroidViewModel` 提供了对应用程序上下文的访问。 * * @param app 应用程序上下文。 */ class ArticleViewModel(app: Application) : AndroidViewModel(app) { /** * 使用 `MutableLiveData` 来保存和观察文章数据。 * `MutableLiveData` 允许对数据进行修改，并通知观察者数据变化。 */ val articles = MutableLiveData\u0026lt;ResponseBody\u0026gt;() /** * 根据给定的关键字搜索文章。 * 使用协程和流来进行异步网络请求并处理结果。 * * @param key 搜索关键字。 */ fun searchArticles(key: String) { viewModelScope.launch { flow { // 发起网络请求获取文章数据 val list = RetrofitClient.articleApi.searchArticles(key) // 将获取的结果发射到流中 emit(list) } .flowOn(Dispatchers.IO) // 在 IO 线程中执行网络请求 .catch { e -\u0026gt; // 捕获并打印流中的异常 e.printStackTrace() } .collect { // 更新 LiveData 的值，以便 UI 可以观察到变化 articles.value = it } } } } RetrofitClient.kt object RetrofitClient { private val instance: Retrofit by lazy { Retrofit .Builder() .client(OkHttpClient.Builder().build()) .baseUrl(\u0026#34;https://www.bing.com/\u0026#34;) .build() } val articleApi: ArticleApi by lazy { instance.create(ArticleApi::class.java) } } ArticleApi.kt interface ArticleApi { @GET(\u0026#34;search\u0026#34;) suspend fun searchArticles( @Query(\u0026#34;q\u0026#34;) key : String ): ResponseBody } ArticleAdapter.kt class ArticleAdapter(private val context: Context) : RecyclerView.Adapter\u0026lt;BindingViewHolder\u0026gt;() { // 用于存储 ResponseBody 对象列表 private val data = ArrayList\u0026lt;String\u0026gt;() // 设置数据时，将 ResponseBody 转换为字符串 @SuppressLint(\u0026#34;NotifyDataSetChanged\u0026#34;) fun setData(responseBody: ResponseBody) { Log.d(\u0026#34;Kennem\u0026#34;, \u0026#34;setData called with data: $responseBody\u0026#34;) this.data.clear() // 将 ResponseBody 转换为字符串并添加到数据列表中 this.data.add(responseBody.string()) notifyDataSetChanged() } override fun onCreateViewHolder(parent: ViewGroup, viewType: Int): BindingViewHolder { val binding = ItemUserBinding.inflate(LayoutInflater.from(context), parent, false) return BindingViewHolder(binding = binding) } override fun getItemCount() = data.size @SuppressLint(\u0026#34;SetTextI18n\u0026#34;) override fun onBindViewHolder(holder: BindingViewHolder, position: Int) { val item = data[position] val binding = holder.binding as ItemUserBinding // 将字符串形式的原始响应内容显示在 TextView 中 binding.text.text = item } } StateFlow 类似LiveData, 具有LiveDat的属性又有Flow的支持\nclass NumberFragment : Fragment() { // 使用 viewModels 委托属性获取 ArticleViewModel 实例 private val viewModel by viewModels\u0026lt;NumberViewModel\u0026gt;() // 延迟初始化 FragmentArticleBinding 实例，用于绑定布局 private val mBinding: FragmentNumberBinding by lazy { FragmentNumberBinding.inflate(layoutInflater) } // Fragment的布局生成和视图创建 override fun onCreateView( inflater: LayoutInflater, container: ViewGroup?, savedInstanceState: Bundle? ): View? { // 返回绑定的根视图 return mBinding.root } // 在Activity创建后调用，用于初始化视图和数据 override fun onActivityCreated(savedInstanceState: Bundle?) { super.onActivityCreated(savedInstanceState) // 使用apply作用域函数来简化代码 mBinding.apply { // 为增加按钮设置点击事件监听器 btnAdd.setOnClickListener{ // 调用ViewModel的increment函数，增加计数值 viewModel.increment() } // 为减少按钮设置点击事件监听器 btnMinus.setOnClickListener{ // 调用ViewModel的decrement函数，减少计数值 viewModel.decrement() } } // 使用lifecycleScope来确保在视图创建时收集数据流 lifecycleScope.launchWhenCreated { // 收集ViewModel中number的状态流，并在UI中显示 viewModel.number.collect { value -\u0026gt; // 将当前的数值更新到TextView中 mBinding.tvNumber.text = \u0026#34;$value\u0026#34; } } } } ShareFlow ShareFlow为热流，一直发送，可以在多个位置接受到发送的流\nLocalEventBus.kt object LocalEventBus { val events = MutableSharedFlow\u0026lt;Event\u0026gt;() suspend fun postEvent(event: Event){ events.emit(event) } } data class Event(val timestamp: Long) SharedFlowViewModel.kt class SharedFlowViewModel : ViewModel() { private var job: Job? = null fun startRefresh() { // 检查是否已有正在运行的 Job if (job?.isActive == true) { return // 如果已存在，直接返回 } // 启动新的 Job job = viewModelScope.launch(Dispatchers.IO) { while (isActive) { LocalEventBus.postEvent(Event(System.currentTimeMillis())) } } } fun stopRefresh() { job?.cancel() // 取消当前的 Job job = null // 将 job 置为空，表示没有运行的 Job } } SharedFlowFragment.kt class SharedFlowFragment : Fragment() { private val viewModel by viewModels\u0026lt;SharedFlowViewModel\u0026gt;() private val mBinding: FragmentSharedFlowBinding by lazy { FragmentSharedFlowBinding.inflate(layoutInflater) } override fun onCreateView( inflater: LayoutInflater, container: ViewGroup?, savedInstanceState: Bundle? ): View? { return mBinding.root } override fun onActivityCreated(savedInstanceState: Bundle?) { super.onActivityCreated(savedInstanceState) mBinding.apply { btnStart.setOnClickListener { viewModel.startRefresh() } btnEnd.setOnClickListener { viewModel.stopRefresh() } } } } Flow与Jetpack Paging3 Paging3 加载数据流程 PageConfig pageSize: 每页显示的数据的大小 prefetchDistance，预刷新的距离，距离最后一个item多远时加载数据，默认为pageSize。 initialLoadSize，初始化加载数量，默认位pageSize * 3 Paging3部分 MoviePagingSource.kt // MoviePagingSource 继承自 PagingSource，用于定义如何从数据源加载分页数据 class MoviePagingSource : PagingSource\u0026lt;Int, Movie\u0026gt;() { // 用于获取刷新数据时的键值 override fun getRefreshKey(state: PagingState\u0026lt;Int, Movie\u0026gt;): Int? { // 获取当前锚定位置的索引，如果不存在则返回 null val anchorPosition = state.anchorPosition ?: return null // 获取与锚定位置最近的一页 val anchorPage = state.closestPageToPosition(anchorPosition) // 如果锚定页存在且前一页的 key 存在，则返回前一页的 key 加 1 // 否则，如果下一页的 key 存在，则返回下一页的 key 减 1 return anchorPage?.prevKey?.plus(1) ?: anchorPage?.nextKey?.minus(1) } // 定义如何加载数据 override suspend fun load(params: LoadParams\u0026lt;Int\u0026gt;): LoadResult\u0026lt;Int, Movie\u0026gt; { // 当前要加载的页码，如果为 null 则加载第一页 val currentPage = params.key ?: 1 // 需要加载的项目数 val pageSize = params.loadSize return try { // 使用 Retrofit 发送网络请求获取电影数据，传入当前页码和每页加载的数量 val response = RetrofitClient.createApi(MovieApi::class.java) .getMovies(currentPage, pageSize) // 打印日志，显示加载的页码和获取的电影数量 Log.d(\u0026#34;PagingSource\u0026#34;, \u0026#34;Loaded page $currentPage with ${response.movieList.size} items\u0026#34;) // 获取电影列表，如果为空则返回空列表 val movies = response.movieList ?: emptyList() // 如果当前页是第一页，则前一页的 key 为 null，否则为当前页码减 1 val prevKey = if (currentPage == 1) null else currentPage - 1 // 如果还有更多数据，则下一页的 key 为当前页码加 1，否则为 null val nextKey = if (response.hasMore) currentPage + 1 else null // 返回加载的结果，包括数据、前一页的 key 和下一页的 key LoadResult.Page( data = movies, prevKey = prevKey, nextKey = nextKey ) } catch (e: Exception) { // 捕获异常并打印错误日志 Log.e(\u0026#34;PagingSource\u0026#34;, \u0026#34;Error loading page $currentPage\u0026#34;, e) // 返回错误结果，传递异常信息 return LoadResult.Error(e) } } } MovieViewModel.kt 负责分页的配置以及分页的加载\n// MovieViewModel 继承自 ViewModel，负责管理 UI 相关的数据 class MovieViewModel : ViewModel() { // 定义 movies 变量，使用 lazy 初始化，即在首次访问时才会初始化 // Pager 是 Paging 库中用于分页加载数据的核心组件 private val movies by lazy { Pager( config = PagingConfig( pageSize = 8, // 每页加载的数据量大小 prefetchDistance = 1, // 提前预加载下一页数据的触发距离 initialLoadSize = 8 // 首次加载时加载的数据量大小 ), // 定义数据源工厂，创建 MoviePagingSource 实例，用于从数据源加载数据 pagingSourceFactory = { MoviePagingSource() } ) // flow 是一种异步数据流，cachedIn(viewModelScope) 将流数据缓存到 ViewModel 的作用域中 // 这样即使屏幕旋转，数据也能保留，不需要重新加载 .flow.cachedIn(viewModelScope) } // 暴露一个公共方法用于加载电影数据，并返回 Flow\u0026lt;PagingData\u0026lt;Movie\u0026gt;\u0026gt; 类型的流 fun loadMovie(): Flow\u0026lt;PagingData\u0026lt;Movie\u0026gt;\u0026gt; = movies } NetWrok部分 RetrofitClient.kt object RetrofitClient { private val instance: Retrofit by lazy { val interceptor = HttpLoggingInterceptor { Log.d(\u0026#34;Kennem\u0026#34;, \u0026#34;$it\u0026#34;) } interceptor.level = HttpLoggingInterceptor.Level.BODY Retrofit.Builder() .client(OkHttpClient.Builder().addInterceptor(interceptor).build()) .baseUrl(\u0026#34;https://apifoxmock.com/m1/4944163-4601795-default/\u0026#34;) .addConverterFactory(GsonConverterFactory.create()) .build() } fun \u0026lt;T\u0026gt; createApi(clazz: Class\u0026lt;T\u0026gt;): T { // 调用实例的 create 方法，传入 clazz 参数以创建接口的实例 return instance.create(clazz) as T } } ","permalink":"https://kennems.github.io/posts/tech/kotlin%E5%8D%8F%E7%A8%8B4/","summary":"Kotlin协程(4) Kotlin实践部分 Flow与文件下载应用 DownloadFragment.kt // DownloadFragment 是一个 Fragment 类，用于处理文件下载任务 class DownloadFragment : Fragment() { // 定义下载文件的 URL 地址，这是","title":"Kotlin协程(4)"},{"content":"20240823 星期五 青岛市区 Created: 2024/8/25/17:49 Tags: Daily, Personal\n美好的一天！\n今天上午去修电脑， 键盘出了些问题，心里没有底，又送去看了看，时间还早，还没到十二点，正好带了学生证，打算玩玩再回去。\n小青岛——琴女\n","permalink":"https://kennems.github.io/posts/life/20240823-%E6%98%9F%E6%9C%9F%E4%BA%94-%E9%9D%92%E5%B2%9B%E5%B8%82%E5%8C%BA/","summary":"20240823 星期五 青岛市区 Created: 2024/8/25/17:49 Tags: Daily, Personal 美好的一天！ 今天上午去修电脑， 键盘出了些问题，心里没有底，又送去看了看，时间还早，还没到十二点，正好带了学生证，打","title":"20240823 星期五 青岛市区"},{"content":"Git git 由 linus 开发。\nGit流程图 clone（克隆)）： 从远程仓库中克隆代码到本地仓库 checkout（检出）：从本地仓库中检出一个仓库分支然后进行修订 add（添加）：在提交前先将代码提交到暂存区 commit（提交）：提交到本地仓库，本地仓库中保存修改的各个历史版本 fetch（抓取）：从远程库，抓取到本地仓库，不进行任何的合并动作，一般操作比较少。 pull（拉取）：从远程库拉到本地库，自动进行合并（merge），然后放到工作区，相当于fetch + merge push（推送）：修改完成后，需要和团队成员共享代码时，将代码推送到远程仓库 Git基本配置 git config --global user.name \u0026#34;xxx\u0026#34; git config --global user.email \u0026#34;xxx@gmail.com\u0026#34; git config --global user.name git config --global user.email 给一些长命令起别名：\n在 ~/.bashrc 中添加：\nalias git-log=\u0026#39;git log --pretty=oneline --all --graph --abbrev-commit\u0026#39; alias ll=\u0026#39;ls -al\u0026#39; 之后 source ~/.bashrc 使其生效。\n版本切换： git reset --hard commitId 查看所有日志：\ngit reflog 分支 查看本地分支\ngit branch 创建本地分支\ngit branch 分支名 切换分支\ngit checkout 分支名 切换并创建分支\ngit checkout -b 分支名 合并分支 git merge 删除分支 删除分支时，需要做各种检查\ngit branch -d b1 不做任何检查，强制删除\ngit branch -D b1 解决冲突 git merge 需要合并的工作区 远程仓库 git push -f --set-upstream [远端名称[本地分支名][:远端分支名]] git remote add origin 源 查看源\ngit remote -v 只查看 origin 的 URL\ngit remote get-url origin 更换源\ngit remote set-url origin 新的仓库地址 设置本地分支与远端分支绑定 git push --set-upstream origin main 设置好之后，直接\ngit push 克隆 git clone 地址 从远程仓库抓取和拉取 抓取，将仓库里的更新都抓取到本地，但不会进行合并\ngit fetch [remote name] [branch name] 拉取，就是将远端仓库的修改拉到本地并自动进行合并，等同于 fetch + merge\ngit pull [remote name] [branch name] 解决合并冲突 恢复 1. 恢复到特定提交 如果你想将分支恢复到某个特定的提交（如 abc1234），可以使用以下命令：\ngit reset --hard abc1234 这将重置当前分支到该提交，并且会丢失该提交之后的所有更改。\n2. 还原最近的提交（但保留更改） 如果你想撤销最近的提交，但保留工作区的更改，可以使用：\ngit reset --soft HEAD~1 这会将 HEAD 移动到上一个提交，同时保留你的更改在暂存区。\n3. 恢复被删除的提交 如果你需要恢复一个已经被删除的提交，可以使用 git reflog 查找并恢复它：\ngit reflog 找到需要恢复的提交哈希（如 abc1234），然后使用：\ngit checkout abc1234 或者，如果你想将当前分支移动到该提交：\ngit reset --hard abc1234 4. 撤销最近的提交（保持更改） 如果你想撤销最近的提交，但想保留更改在工作目录中，可以使用：\ngit revert HEAD 这将创建一个新的提交，撤销最后一次提交的更改。\n修改 commit 的 message 1. 修改最近一次的 commit message 使用 --amend：\ngit commit --amend -m \u0026#34;新的提交信息\u0026#34; 这条命令会替换最近一次的 commit message。\n2. 修改更早的 commit message 如果需要修改更早的 commit message，可以使用 rebase 命令：\n启动交互式 rebase：\ngit rebase -i HEAD~n 其中 n 是你想要回溯的提交数量。\n在打开的文本编辑器中找到要修改的 commit，将 pick 改为 reword（或 r）。\n保存并退出编辑器，接着会弹出一个新的编辑器窗口，你可以在这里修改 commit message。\n保存并关闭编辑器，完成后 Git 将会应用修改。\n","permalink":"https://kennems.github.io/posts/tech/git/","summary":"Git git 由 linus 开发。 Git流程图 clone（克隆)）： 从远程仓库中克隆代码到本地仓库 checkout（检出）：从本地仓库中检出一个仓库分支然后进行","title":"Git"},{"content":"Kotlin协程(3) 操作符 过渡流操作符 可以使用操作符转换符，就像使用集合与序列一样 过渡操作符应用于上游流，并返回下游流。 这些操作符也是冷操作符，就像流一样。这类操作符本身不是挂起函数。 它运行的速度很快，返回新的转换流的定义。 transform() // 定义一个挂起函数，模拟发送请求并返回响应 suspend fun performRequest(request: Int): String { delay(1000) // 模拟网络延迟，延迟 1000 毫秒（1 秒） return \u0026#34;response $request\u0026#34; // 返回一个响应字符串 } // 测试函数，使用 JUnit 测试框架 @Test fun `test transform flow operator`() = runBlocking { // 将整数范围转换为 Flow (1..3).asFlow() .transform { request -\u0026gt; // 使用 transform 运算符转换流的元素 emit(\u0026#34;Making request $request\u0026#34;) // 发射一个字符串，表示正在发送请求 emit(performRequest(request)) // 发射 performRequest 的返回值 } .collect { v -\u0026gt; // 收集流的元素 println(v) // 打印收集到的元素 } } take() // 定义一个简单的 Flow，产生 Int 类型的值 fun numbers() = flow\u0026lt;Int\u0026gt; { try { emit(1) // 发射第一个整数 1 emit(2) // 发射第二个整数 2 println(\u0026#34;This line will not execute\u0026#34;) // 这一行代码不会被执行，因为 collect 操作会提前中止 Flow emit(3) // 发射第三个整数 3（不会执行） } finally { // 在 Flow 被收集完成或取消时执行 println(\u0026#34;Finally in numbers\u0026#34;) // 打印 \u0026#34;Finally in numbers\u0026#34;，表示 finally 块的执行 } } // 测试函数，使用 JUnit 测试框架 @Test fun `test limit length operator`() = runBlocking { // 调用 numbers 函数，限制收集的元素数量为 2 numbers() .take(2) // 使用 take 运算符，只收集前 2 个元素 .collect { v -\u0026gt; // 收集 Flow 中的元素 println(v) // 打印每个收集到的元素 } } 末端操作符 末端操作符是在流上用于启动流收集的挂起函数。collect是最基础的末端操作符，但是还有另外一些更方便使用的末端操作符 转化为各种集合，例如toList和toSet 获取第一个（first）值与确保流发射单个（single）值的操作符 使用reduce与fold将流规约到单个值 组合多个流 就像Kotlin标准库中的Sequence.zip拓展函数一样，流拥有一个zip操作符用于组合两个流中的相关值 @Test fun `test zip2`() = runBlocking { // 创建一个整数流，发射 1 到 3 的数字，每个数字发射之间延迟 300 毫秒 val numbs = (1..3).asFlow().onEach { delay(300) // 模拟延迟 } // 创建一个字符串流，发射 \u0026#34;one\u0026#34;、\u0026#34;two\u0026#34; 和 \u0026#34;three\u0026#34; 的字符串，每个字符串发射之间延迟 400 毫秒 val strs = flowOf(\u0026#34;one\u0026#34;, \u0026#34;two\u0026#34;, \u0026#34;three\u0026#34;).onEach { delay(400) // 模拟延迟 } // 记录测试开始时间 val startTime = System.currentTimeMillis() // 使用 zip 操作符将两个流的元素配对 numbs.zip(strs) { a, b -\u0026gt; \u0026#34;$a -\u0026gt; $b\u0026#34; } // 将 numbs 和 strs 的每对元素组合成字符串 .collect { v -\u0026gt; // 收集配对后的元素 // 打印配对后的元素和从测试开始到当前时间的时间差 println(\u0026#34;$v, consume time : ${System.currentTimeMillis() - startTime} ms \u0026#34;) } } 展平流 流表示异步接收的值序列，所以很容易遇到这样的情况：每个值都会触发对另一个值序列的请求，然而，由于流具有异步的性质，因此需要不同的展平模式，为此，存在一系列的流展平操作符： flatMapConcat 连接模式 flatMapMerge 合并模式 flatMapLatest 最新展平模式 // 使用 flatMapConcat 操作符的测试函数 @Test fun `test flatMapConcat`() = runBlocking\u0026lt;Unit\u0026gt; { val startTime = System.currentTimeMillis() // 记录开始时间 // 创建一个流，包含数字 1 到 3 (1..3) .asFlow() // 将数字转换为流 .onEach { delay(100) } // 在每个元素上施加 100 毫秒的延迟 // 使用 flatMapConcat 将每个元素转换为新的流并串联 .flatMapConcat { requestFlow(it) } .collect { v -\u0026gt; // 收集并打印每个元素的值以及从开始到现在的消耗时间 println(\u0026#34;$v, consume time : ${System.currentTimeMillis() - startTime} ms \u0026#34;) } } // 使用 flatMapMerge 操作符的测试函数 @Test fun `test flatMapMerge`() = runBlocking\u0026lt;Unit\u0026gt; { val startTime = System.currentTimeMillis() // 记录开始时间 // 创建一个流，包含数字 1 到 3 (1..3) .asFlow() // 将数字转换为流 .onEach { delay(100) } // 在每个元素上施加 100 毫秒的延迟 // 使用 flatMapMerge 将每个元素转换为新的流并并发执行 .flatMapMerge { requestFlow(it) } .collect { v -\u0026gt; // 收集并打印每个元素的值以及从开始到现在的消耗时间 println(\u0026#34;$v, consume time : ${System.currentTimeMillis() - startTime} ms \u0026#34;) } } // 使用 flatMapLatest 操作符的测试函数 @Test fun `test flatMapLatest`() = runBlocking\u0026lt;Unit\u0026gt; { val startTime = System.currentTimeMillis() // 记录开始时间 // 创建一个流，包含数字 1 到 3 (1..3) .asFlow() // 将数字转换为流 .onEach { delay(100) } // 在每个元素上施加 100 毫秒的延迟 // 使用 flatMapLatest 将每个元素转换为新的流，仅保留最新流 .flatMapLatest { requestFlow(it) } .collect { v -\u0026gt; // 收集并打印每个元素的值以及从开始到现在的消耗时间 println(\u0026#34;$v, consume time : ${System.currentTimeMillis() - startTime} ms \u0026#34;) } } 流的异常处理 当运算符中的发射器或代码抛出异常时，有几种处理异常的方法： try/catch块 catch函数 /** * 测试用例 `test exception1`： * 使用 runBlocking 启动协程，收集 simpleFlow 的值。 * 如果值大于 1，则抛出异常并捕获。 */ @Test fun `test exception1`() = runBlocking\u0026lt;Unit\u0026gt; { try { simpleFlow().collect { v -\u0026gt; println(v) check(v \u0026lt;= 1) { \u0026#34;Collected $v\u0026#34; } } } catch (e: Throwable) { println(\u0026#34;Caught $e\u0026#34;) } } /** * 测试用例 `test exception2`： * 创建一个流，发射一个值后抛出异常。 * 使用 catch 操作符处理异常。 */ @Test fun `test exception2`() = runBlocking\u0026lt;Unit\u0026gt; { flow { emit(1) throw ArithmeticException(\u0026#34;Div 0\u0026#34;) } .catch { e: Throwable -\u0026gt; println(\u0026#34;Caught: $e\u0026#34;) } .flowOn(Dispatchers.IO) .collect { println(it) } } 流的完成 当流收集完成时（普通情况或异常情况），它可能需要执行一个动作 命令是finally块 onCompletion声明式处理 // 定义一个函数，返回1到3的值作为 Flow fun simpleFlow2() = (1..3).asFlow() @Test // 测试在 finally 块中完成流的处理 fun `test flow complete in finally`() = runBlocking { try { // 收集 simpleFlow2 流中的每个值 simpleFlow2().collect { println(it) } } finally { // 无论流的收集过程是否成功，这条消息都会在最后打印 println(\u0026#34;Done!\u0026#34;) } } // 定义一个函数，返回一个 Flow\u0026lt;Int\u0026gt; 类型的流 fun simpleFlow3() = flow\u0026lt;Int\u0026gt; { // 发射（emit）第一个值 emit(1) // 发射一个异常来中断流 throw RuntimeException() } @Test // 测试使用 onCompletion 操作符处理流完成 fun `test flow complete in onCompletion`() = runBlocking { simpleFlow3() // 在流完成时调用的操作符 .onCompletion { exception -\u0026gt; if (exception != null) { // 如果有异常，打印流以异常方式完成 println(\u0026#34;Flow completed exceptionally\u0026#34;) } } // 捕获流中的异常 .catch { exception -\u0026gt; println(\u0026#34;Caught $exception\u0026#34;) } // 收集 simpleFlow3 流中的每个值 .collect { println(it) } } 通道-多路复用-并发安全 Channel Channel是一个并发安全的队列，它可以用来连接协程，实现不同协程的通信。 @Test fun `test know channel`() = runBlocking\u0026lt;Unit\u0026gt; { // 创建一个整数类型的通道，用于在不同的协程之间传递数据 val channel = Channel\u0026lt;Int\u0026gt;() // 在全局范围内启动一个生产者协程，负责向通道发送数据 val producer = GlobalScope.launch { var i = 0 while (true) { // 每次发送前暂停1秒钟 delay(1000) // 递增计数器并将值发送到通道 channel.send(++i) println(\u0026#34;send $i\u0026#34;) } } // 在全局范围内启动一个消费者协程，负责从通道接收数据 val consumer = GlobalScope.launch { while (true) { // 接收通道中的数据 val element = channel.receive() println(\u0026#34;receive $element\u0026#34;) } } // 等待生产者和消费者协程结束 joinAll(producer, consumer) } Channel的容量 Channel实际上就是一个队列，队列中一定存在缓冲区，一旦这个缓冲区满了，并且一直没有人调用receive并取走函数，send就需要挂起。故意让接收端的节奏放慢，发现send总是会挂起，直到receive之后才会继续往下执行。 迭代channel produce 与 actor 构造生产者与消费者的便捷方法 可以通过produce方法启动一个生产者协程，并返回一个ReceiveChannel， 其他协程就可以用这个Channel来接收数据了。反之，可以用actor启动一个消费者协程。 @OptIn(DelicateCoroutinesApi::class) @Test fun `test fast consumer channel`() = runBlocking { // 创建一个发送通道，它通过actor协程进行数据接收和处理 val sendChannel: SendChannel\u0026lt;Int\u0026gt; = GlobalScope.actor { while (true) { // 接收并处理通道中的数据 val element = receive() println(element) } } // 在全局范围内启动一个生产者协程，负责向通道发送数据 val producer = GlobalScope.launch { for (i in 0..3) { // 向通道发送数据 sendChannel.send(i) } } // 等待生产者协程完成 producer.join() } Channel的关闭 produce和actor返回的Channel都会随着对应的协程执行完毕而关闭，也正是这样，Channel才被称为热数据流。 对于Channel，如果我们调用了它的close方法，它会立即停止接收新元素，也就是说这是它的isClosedForSend会立即返回true。而由于Channel缓冲区的存在，这时候可能还有一些元素没有被处理完，因此要等所有的元素都被读取之后isClosedForSend才会返回true。 Channel的生命周期最好由主导方来维护，建议由主导的一方实现关闭。 @Test fun `test close channel`() = runBlocking { // 创建一个无界限的整数类型的通道，用于在不同的协程之间传递数据 val channel = Channel\u0026lt;Int\u0026gt;(Channel.UNLIMITED) // 在全局范围内启动一个生产者协程，负责向通道发送数据 val producer = GlobalScope.launch { List(3) { channel.send(it) println(\u0026#34;send $it\u0026#34;) } // 发送完成后关闭通道 channel.close() // 打印通道的关闭状态 println( \u0026#34;\u0026#34;\u0026#34;close channel. | -ClosedForSend : ${channel.isClosedForSend} | -ClosedForReceive: ${channel.isClosedForReceive} \u0026#34;\u0026#34;\u0026#34;.trimMargin() ) } // 在全局范围内启动一个消费者协程，负责从通道接收数据 val consumer = GlobalScope.launch { for (element in channel) { println(\u0026#34;receive $element\u0026#34;) delay(1000) } // 消费完成后打印通道的关闭状态 println( \u0026#34;\u0026#34;\u0026#34;close channel. | -ClosedForSend : ${channel.isClosedForSend} | -ClosedForReceive: ${channel.isClosedForReceive} \u0026#34;\u0026#34;\u0026#34;.trimMargin() ) } // 等待生产者和消费者协程结束 joinAll(producer, consumer) } BroadcastChannel 发送端和接收端在Channel中存在一对多的情形，从数据处理本身来讲，虽然有多个接收端，但是同一个元素只会被一个接收端读到。广播则不然，多个接收端不存在互斥行为。\n// 选择使用过时和精细的协程 API @OptIn(ObsoleteCoroutinesApi::class, DelicateCoroutinesApi::class) @Test fun `test broadcastChannel`() = runBlocking\u0026lt;Unit\u0026gt; { // 创建一个新的通道，使用无限缓冲区容量 val channel = Channel\u0026lt;Int\u0026gt;() // 将通道转换为广播通道，可以有多个订阅者 val broadcastChannel = channel.broadcast(3) // 生产者协程，将一系列整数发送到广播通道 val producer = GlobalScope.launch { // 发送 3 个整数到广播通道，每次发送之间有延迟 List(3) { delay(100) broadcastChannel.send(it) } // 在发送完所有整数后关闭广播通道 broadcastChannel.close() } // 启动 3 个协程，每个协程订阅广播通道 List(3) { index: Int -\u0026gt; GlobalScope.launch { // 每个协程打开广播通道的一个订阅 val receiveChannel = broadcastChannel.openSubscription() // 迭代接收的广播通道中的值 for (i in receiveChannel) { println(\u0026#34;[#$index] received : $i\u0026#34;) } } }.joinAll() // 等待所有协程完成 } 多路复用 数据通信系统或计算机网络系统中，传输媒体的带宽或容量往往会大于传输单一信号的需求，为了有效地利用通信线路，希望一个信道同时传输多路信号，这就是多路复用技术（Multiplexing） 复用多个await 两个API分别从网络和本地缓存获取数据，期望哪个先返回就先用哪个做展示 @Test fun `test select channel`() = runBlocking\u0026lt;Unit\u0026gt; { // 创建一个包含两个整型通道的列表 val channels = listOf(Channel\u0026lt;Int\u0026gt;(), Channel\u0026lt;Int\u0026gt;()) // 第一个全局协程，在延迟100毫秒后向第一个通道发送200 GlobalScope.launch { delay(100) channels[0].send(200) } // 第二个全局协程，在延迟50毫秒后向第二个通道发送100 GlobalScope.launch { delay(50) channels[1].send(100) } // 使用select表达式从通道中接收一个值 val result = select\u0026lt;Int?\u0026gt; { // 对每个通道应用onReceive子句 channels.forEach { channel -\u0026gt; channel.onReceive { value -\u0026gt; value // 返回接收到的值 } } } // 打印从通道中接收到的值 println(result) } SelectClause SelectClause0 : 对应事件没有返回值，例如 join 没有返回值，那么onJoin就是SelectClauseN类型。使用时，onJoin的参数是一个无参函数。\nSelectClause1：对应事件有返回值，前面的onAwait和onReceive都是此类情况。\nSelectClause2：对应事件有返回值，此外还需要一个额外的参数，例如Channel.onSend有两个参数，第一个是Channel数据类型的值，表示即将发送的值，第二个是发送成功时的回调参数。\n如果想要确认挂起函数是否支持select，只需要查看其是否存在对应的SelectClauseN类型可回调即可。\n使用Flow实现多路复用 @Test fun `test select flow`() = runBlocking\u0026lt;Unit\u0026gt; { // 定义用户名 val name = \u0026#34;guest\u0026#34; // 在协程作用域内运行 coroutineScope { // 创建一个包含两个函数引用的列表 listOf(::getUserFromLocal, ::getUserFromRemote) .map { function -\u0026gt; // 调用每个函数，传入用户名和当前协程作用域 function.call(name, this) } .map { deferred -\u0026gt; // 将每个 Deferred 转换为 Flow，并发射其结果 flow { emit(deferred.await()) } } // 合并所有的 Flow .merge() // 收集结果并打印每个用户对象 .collect { user -\u0026gt; println(user) } } } 协程的并发工具 除了在线程中常用的解决并发问题的手段之外，协程框架也提供了一些安全的工具，包括： Channel：并发安全的消息通道 Mutex：轻量级锁，它的lock和unlock从语义上与线程锁比较类似，之所以轻量是因为它在获取不到锁时不会阻塞线程，而是挂起等待锁的释放 Semaphore：轻量级信号量，信号量可以有多个，协程在获取到信号量后即可执行并发操作。当Semaphore的参数为1时，效果等价于Mutex。 @Test fun `test not concurrent tools`() = runBlocking { // 初始化计数器 var count = 0 // 初始化一个互斥锁 var mutex = Mutex() // 创建 1000 个协程，每个协程都尝试增加计数器 List(1000) { GlobalScope.launch { // 在互斥锁保护下增加计数器，确保线程安全 mutex.withLock { count += 1 } } }.joinAll() // 等待所有协程完成 // 打印计数器的最终值 println(count) } @Test fun `test not concurrent tools2`() = runBlocking { // 初始化计数器 var count = 0 // 初始化一个信号量，允许同时只有一个协程进入临界区 var semaphore = Semaphore(1) // 创建 1000 个协程，每个协程都尝试增加计数器 List(1000) { GlobalScope.launch { // 在信号量保护下增加计数器，确保线程安全 semaphore.withPermit { count += 1 } } }.joinAll() // 等待所有协程完成 // 打印计数器的最终值 println(count) } 避免访问外部可变状态 编写函数时要求它不得访问外部状态，只能基于参数做运算，通过返回值提供运算结果 @Test fun `test avoid access outer variable`() = runBlocking { var count = 0 var result = count + List(1000){ GlobalScope.async { 1 } }.map { it.await() }.sum() println(result) } ","permalink":"https://kennems.github.io/posts/tech/kotlin%E5%8D%8F%E7%A8%8B3/","summary":"Kotlin协程(3) 操作符 过渡流操作符 可以使用操作符转换符，就像使用集合与序列一样 过渡操作符应用于上游流，并返回下游流。 这些操作符也是冷操","title":"Kotlin协程(3)"},{"content":"Kotlin协程(2) 异常处理的必要性 @OptIn(ExperimentalStdlibApi::class) // 标记该代码使用了实验性标准库 API @Test // 表示这是一个测试函数 fun `test CoroutineContext extend2`() = runBlocking { // 使用 runBlocking 启动协程 // 创建一个协程异常处理器，用于捕获协程中的异常 val coroutineExceptionHandler = CoroutineExceptionHandler { _, exception -\u0026gt; println(\u0026#34;Caught : $exception\u0026#34;) // 打印捕获到的异常 } // 创建一个协程作用域，包含一个 Job，使用主线程调度器和异常处理器 val scope = CoroutineScope( Job() + Dispatchers.Main + coroutineExceptionHandler // Job() 用于管理协程的生命周期 ) // 在 IO 线程上启动一个新的协程 val job = scope.launch(Dispatchers.IO) { // 获取当前协程上下文中的调度器 val dispatcher = coroutineContext[CoroutineDispatcher] // 打印当前使用的调度器 println(\u0026#34;Current dispatcher: $dispatcher\u0026#34;) } // 等待协程完成 job.join() // 确保主协程在子协程完成后再继续 } 异常的传播 协程构建器有两种形式：1、自动传播异常（launch与actor）2、向用户暴露异常（async与produce）， 当这些构建器用于创建一个根协程时（该协程不是另一个协程的子协程），前者这类构建器，异常会在它发生的第一时间被抛出，而后者则依赖用户来最终消费异常，例如通过await或receive。 // 根协程 @Test @OptIn(DelicateCoroutinesApi::class) fun `test exception propagation`() = runBlocking\u0026lt;Unit\u0026gt; { // 在 GlobalScope 中启动一个新协程，返回一个 Job 对象 val job = GlobalScope.launch { try { // 在协程中抛出一个 IndexOutOfBoundsException throw IndexOutOfBoundsException() } catch (e: Exception) { // 捕获异常并打印一条消息，指示捕获了 IndexOutOfBoundsException println(\u0026#34;IndexOutOfBoundsException\u0026#34;) // 如果需要可以选择打印堆栈轨迹 // e.printStackTrace() } } // 等待协程完成 job.join() // 在 GlobalScope 中启动一个新协程，并返回一个 Deferred 对象 val deffer = GlobalScope.async { // 在协程中抛出一个 ArithmeticException throw ArithmeticException() } try { // 等待异步任务完成并获取结果，如果任务抛出异常，这里会重新抛出异常 deffer.await() } catch (e: Exception) { // 捕获异常并打印一条消息，指示捕获了 ArithmeticException println(\u0026#34;ArithmeticException\u0026#34;) // 如果需要可以选择打印堆栈轨迹 // e.printStackTrace() } } 非根协程的异常 其他协程所创建的协程中，产生的异常总是会被传播 /* 非根协程，job是scope内的子协程，所以会直接消费掉异常 */ @Test fun `test exception propagation2`() = runBlocking { // 创建一个新的 CoroutineScope，使用 Job 作为其上下文元素 val scope = CoroutineScope(Job()) // 在 scope 中启动一个新协程，返回一个 Job 对象 val job = scope.launch { // 在协程中启动一个异步任务 async { // 在异步任务中抛出一个 IllegalArgumentException throw IllegalArgumentException() } } // 等待 launch 启动的协程完成 job.join() } 异常的传播特性 当一个协程由于一个异常而运行失败时，它会传播这个异常并传递给它的父级。接下来，父级会进行下面几步操作： 取消它自己的子级 取消它自己 将异常传播并传递给它的父级 SupervisorJob 使用SupervisorJob时，一个子协程的运行失败不会影响其他子协程，SupervisorJob不会传播异常给它的父级，它会让子协程自己处理异常。 需求：在作用域内定义作业的UI组件，如果任何一个UI的子作业执行失败了，它并不总是有必要取消整个UI组件，但是如果UI组件被销毁了，由于它的结果不再被需要了，它就有必要使所有的子作业执行失败。 @Test fun `test supervisorJob`() = runBlocking\u0026lt;Unit\u0026gt; { // 创建一个新的 CoroutineScope，使用 SupervisorJob 作为其上下文元素 val supervisor = CoroutineScope(SupervisorJob()) // 如果使用普通的 Job，注释掉上一行并启用以下行 // val supervisor = CoroutineScope(Job()) // 在 supervisor 作用域中启动第一个子协程，返回一个 Job 对象 val job1 = supervisor.launch { // 延迟 100 毫秒以模拟一些工作 delay(100) println(\u0026#34;child 1\u0026#34;) // 在第一个子协程中抛出一个 IllegalArgumentException throw IllegalArgumentException() } // 在 supervisor 作用域中启动第二个子协程，返回一个 Job 对象 val job2 = supervisor.launch { try { // 无限延迟以模拟长时间运行的任务 delay(Long.MAX_VALUE) } finally { // 当协程取消时，最终会打印 \u0026#34;child 2 finished\u0026#34; println(\u0026#34;child 2 finished\u0026#34;) } } // 以下是可选部分，如果需要，可以取消注释 // 延迟 200 毫秒后取消 supervisor 作用域内的所有协程 // delay(200) // supervisor.cancel() // 等待 job1 和 job2 都完成 joinAll(job1, job2) } SupervisorScope 当作业自身执行失败的时候，所以子作业将会被全部取消 @Test fun `test supervisorScope`() = runBlocking\u0026lt;Unit\u0026gt; { // 使用 supervisorScope 启动一个新的协程作用域 supervisorScope { // 在 supervisorScope 中启动一个子协程，返回一个 Job 对象 launch { // 延迟 100 毫秒以模拟一些工作 delay(100) // 输出 \u0026#34;child 1\u0026#34;，表示子协程已完成其任务 println(\u0026#34;child 1\u0026#34;) // 在协程中抛出一个 IllegalArgumentException，以测试异常传播 throw IllegalArgumentException() } // 在 supervisorScope 中启动另一个协程 try { // 延迟一个非常长的时间，模拟长时间运行的任务 delay(Long.MAX_VALUE) } finally { // 当 supervisorScope 被取消时（由于异常），最终会打印 \u0026#34;child 2 finished.\u0026#34; println(\u0026#34;child 2 finished.\u0026#34;) } } } @Test fun `test supervisorScope2`() = runBlocking\u0026lt;Unit\u0026gt; { // 使用 supervisorScope 来启动一个协程作用域 supervisorScope { // 在 supervisorScope 中启动一个子协程 val child = launch { try { // 输出 \u0026#34;The child is sleeping\u0026#34; 表示子协程进入睡眠状态 println(\u0026#34;The child is sleeping\u0026#34;) // 延迟无限长的时间，模拟长时间运行的任务 delay(Long.MAX_VALUE) } finally { // 当子协程被取消时，最终会打印 \u0026#34;The child is cancelled\u0026#34; println(\u0026#34;The child is cancelled\u0026#34;) } } // 让出线程以确保子协程启动并进入延迟状态 yield() // 在 supervisorScope 中抛出一个异常 println(\u0026#34;Throwing an exception from the scope\u0026#34;) throw AssertionError() // 抛出一个断言错误，用于测试作用域的异常处理 } } 异常的捕获 使用CoroutineExcepitonHandler对协程的异常进行捕获 以下的条件被满足时，异常就会被捕获： 时机：异常是被自动抛出异常的协程所抛出的（使用launch，而不是async时）； 位置：在CoroutineScope的CoroutineContext中或在一个根协程（CoroutineScope或者supervisorScope的直接子协程）中。 Android中全局异常处理 全局异常处理器可以获取到所有协程未处理的未捕获异常，不过它并不能对异常进行捕获，虽然不能阻止程序崩溃，全局异常处理器在程序调试和异常上报等场景中仍然有非常大的用处。 我们需要在classpath下面创建META-INF/services目录，并在其中创建一个名为kotlinx.coroutines.CoroutineExceptionHandler的文件，文件内容就是我们的全局异常处理器的全类名。 取消与异常 取消与异常紧密相关，协程内部使用CancellationExcepiton来进行取消，这个异常会被忽略。 当子协程被取消时，不会取消它的父协程 如果一个协程遇到了CancellationExcepiton以外的异常，它将使用该异常取消它的父协程。当父协程的所有子协程都结束后，异常才会被父协程处理。 @Test fun `test cancel and exception`() = runBlocking\u0026lt;Unit\u0026gt; { // 启动一个协程作为父协程 val job = launch { // 在父协程中启动一个子协程 val child = launch { try { // 子协程尝试延迟执行，模拟长时间运行的任务 delay(Long.MAX_VALUE) } finally { // 当子协程被取消时，执行此块 println(\u0026#34;Child is cancelled\u0026#34;) } } // 让父协程暂时让出线程，给其他协程执行的机会 yield() println(\u0026#34;Cancelling child\u0026#34;) // 取消子协程，并等待其执行完 finally 块 child.cancelAndJoin() // 再次让出线程 yield() println(\u0026#34;Parent is not cancelled\u0026#34;) } // 等待父协程完成执行 job.join() } @Test fun `test cancel and exception2`() = runBlocking\u0026lt;Unit\u0026gt; { // 定义一个 CoroutineExceptionHandler 来处理未捕获的异常 val handler = CoroutineExceptionHandler { _, exception -\u0026gt; println(\u0026#34;Caught: $exception\u0026#34;) } // 使用 GlobalScope 启动一个顶层协程，并应用异常处理器 val job = GlobalScope.launch(handler) { // 第一个子协程，模拟一个需要很长时间的任务 launch { try { // 使用一个很长的延迟来模拟长时间运行的任务 delay(Long.MAX_VALUE) } finally { // 确保在协程被取消时，执行以下代码 withContext(NonCancellable) { println(\u0026#34;Children are cancelled, but exceptions are not handled\u0026#34;) delay(100) // 确保输出语句有机会执行 println(\u0026#34;The first child finished its non cancellable block\u0026#34;) } } } // 第二个子协程，在短暂延迟后抛出一个异常 launch { delay(10) println(\u0026#34;Second child throws an exception\u0026#34;) throw ArithmeticException() // 抛出一个异常来测试异常处理 } } // 等待父协程完成 job.join() } 异常聚合 当协程的多个子协程因为异常而失败时，一般情况下取第一个异常进行处理。在第一异常之后发生的所有其他异常，都将绑定到第一个异常之上。 @Test fun `test exception aggregation`() = runBlocking\u0026lt;Unit\u0026gt; { // 定义一个 CoroutineExceptionHandler 来处理未捕获的异常 val handler = CoroutineExceptionHandler { _, exception -\u0026gt; // 输出被捕获的主异常和抑制的异常（如果有） println(\u0026#34;Caught: $exception, Suppressed: ${exception.suppressed.contentToString()}\u0026#34;) } // 使用 GlobalScope 启动一个顶层协程，并应用异常处理器 val job = GlobalScope.launch(handler) { // 第一个子协程 launch { try { // 模拟长时间运行的任务 delay(Long.MAX_VALUE) } finally { // 在取消时抛出 ArithmeticException throw ArithmeticException() } } // 第二个子协程 launch { try { // 进行短暂的延迟 delay(100) } finally { // 在取消时抛出 IOException throw IOException() } } // 第三个子协程 launch { try { // 进行更短暂的延迟 delay(10) } finally { // 在取消时抛出 IndexOutOfBoundsException throw IndexOutOfBoundsException() } } } // 等待父协程完成，确保所有子协程的异常都被处理 job.join() } Flow-异步流 // 定义一个名为 simpleFlow 的挂起函数，返回一个 Flow\u0026lt;Int\u0026gt; suspend fun simpleFlow() = flow\u0026lt;Int\u0026gt; { // 使用 for 循环遍历从 1 到 100 的整数 for (i in 1..100) { delay(1000) // 延迟 1 秒钟，模拟异步任务的延迟 emit(i) // 向下游发射当前整数 } } // 这是一个测试函数，演示了异步、非阻塞式的行为 @Test fun `test multiple values3`() = runBlocking\u0026lt;Unit\u0026gt; { // 启动一个新的协程，不阻塞主线程 launch { // 使用 for 循环打印信息，展示主线程没有被阻塞 for (k in 1..3) { println(\u0026#34;I am not blocked $k\u0026#34;) delay(1500) // 延迟 1.5 秒钟 } } // 收集 simpleFlow() 发射的值 simpleFlow().collect { value -\u0026gt; println(value) // 打印每个收集到的值 } } 冷流 Flow是一种类似于序列的冷流，flow构建器中的代码直到流被收集的时候才运行 // 测试函数，演示 Flow 是冷流的概念 @Test fun `test flow is cold`() = runBlocking { // 创建一个新的 Flow 实例 val flow = simpleFlow2() // 首次调用 collect，开始收集 Flow 发射的值 println(\u0026#34;Calling collect...\u0026#34;) flow.collect { value -\u0026gt; println(value) // 打印每个收集到的值 } // 再次调用 collect，重新收集 Flow 发射的值 println(\u0026#34;Calling collect again...\u0026#34;) flow.collect { value -\u0026gt; println(value) // 打印每个收集到的值 } } 流的连续性 流的每次单独收集都是按顺序执行的，除非使用特殊操作符 从上游到下游每个过渡操作符都会处理每个发射出的值，然后再交给末端操作符。 // 测试函数，演示流的连续操作 @Test fun `test flow continuation`() = runBlocking { // 将 1 到 5 的整数转换成流 (1..5).asFlow() // 过滤流，只保留偶数 .filter { it % 2 == 0 } // 将每个整数转换为字符串 .map { \u0026#34;String $it\u0026#34; } // 收集流中的每个元素 .collect { value -\u0026gt; println(\u0026#34;Collect $value\u0026#34;) // 打印收集到的每个元素 } } 流构建器 flowOf构建器定义了一个发射固定值集的流。 @Test fun `test flow continuation`() = runBlocking { // 将 1 到 5 的整数转换成流 (1..5).asFlow() // 过滤流，只保留偶数 .filter { it % 2 == 0 } // 将每个整数转换为字符串 .map { \u0026#34;String $it\u0026#34; } // 收集流中的每个元素 .collect { value -\u0026gt; println(\u0026#34;Collect $value\u0026#34;) // 打印收集到的每个元素 } } 使用.asFlow()扩展函数，可以将各种集合与序列转换为流。 @Test fun `test flow builder2`() = runBlocking\u0026lt;Unit\u0026gt; { // 创建一个包含三个字符串元素的 Flow：\u0026#34;one\u0026#34;、\u0026#34;two\u0026#34; 和 \u0026#34;three\u0026#34; flowOf(\u0026#34;one\u0026#34;, \u0026#34;two\u0026#34;, \u0026#34;three\u0026#34;) // 对 Flow 中的每个元素，应用 1000 毫秒（1 秒）的延迟 .onEach { delay(1000) } // 收集 Flow 中的每个元素，并将其打印到控制台 .collect { v -\u0026gt; println(v) } // 将整数范围从 1 到 3 转换为 Flow 并收集每个元素 (1..3).asFlow() .collect { println(it) // 将每个收集到的整数打印到控制台 } } 流的上下文 流的收集总是在调用协程的上下文中发生，流的该属性称为上下文保存 flow{...}构建器中的代码必须遵循上下文保存属性，并且不允许从其他上下文中发射（emit） flowOn操作符，该函数用于更改流发射的上下文。 // 定义一个简单的 Flow，返回 Int 类型的值 fun simpleFlow5() = flow\u0026lt;Int\u0026gt; { // 打印当前线程的名称，表明 Flow 开始执行 println(\u0026#34;Flow started ${Thread.currentThread().name}\u0026#34;) // 生成从 1 到 3 的整数 for (i in 1..3) { // 延迟 1000 毫秒（1 秒）模拟耗时操作 delay(1000) // 发射（emit）当前整数 emit(i) } // 设置 Flow 在默认的调度器（Dispatcher）上运行 }.flowOn(Dispatchers.Default) // 测试函数，使用 JUnit 测试框架 @Test fun `test flow context3`() = runBlocking\u0026lt;Unit\u0026gt; { // 收集 Flow 中发射的值 simpleFlow5().collect { v -\u0026gt; // 打印当前线程的名称和收集到的值 println(\u0026#34;Collected $v ${Thread.currentThread().name}\u0026#34;) } } 启动流 使用launchIn替换collect，可以在单独的协程中启动流的收集\n// 定义一个 Flow，产生整数 1 到 3 fun events() = (1..3) .asFlow() // 将整数范围转换为 Flow .onEach { delay(100) } // 对于每个元素，延迟 100 毫秒 .flowOn(Dispatchers.Default) // 在默认的调度器（Dispatcher）上执行上述操作 // 测试函数，使用 JUnit 测试框架 @Test fun `test flow launch`() = runBlocking { // 使用 `launchIn` 在新的协程中收集 Flow events() .onEach { event -\u0026gt; // 打印当前收到的元素 println(event) } .launchIn(CoroutineScope(Dispatchers.IO)) // 在 IO 调度器上启动协程来收集 Flow .join() // 等待协程完成 } 流的取消 流采用与协程同样的协作取消。像往常一样，流的收集可以是当流在一个可取消的挂起函数（例如delay）中挂起的时候取消 fun simpleFlow6() = flow\u0026lt;Int\u0026gt; { // 生成从 1 到 3 的整数 for (i in 1..3) { delay(1000) // 延迟 1000 毫秒（1 秒），模拟耗时操作 emit(i) // 发射（emit）当前整数 println(\u0026#34;Emitting $i\u0026#34;) // 打印当前发射的值，显示发射过程 } } // 测试函数，使用 JUnit 测试框架 @Test fun `test cancel flow`() = runBlocking\u0026lt;Unit\u0026gt; { // 使用 withTimeoutOrNull 来取消协程，在超时后返回 null withTimeoutOrNull(2500) { // 收集 Flow 中发射的值 simpleFlow6().collect { v -\u0026gt; println(v) // 打印收集到的值 } } // 打印 \u0026#34;Done\u0026#34; 表示协程已取消或正常完成 println(\u0026#34;Done!\u0026#34;) } 流的取消检测 为方便起见，流构建器对每个发射值执行附加的ensureActive检测以进行取消，这意味着从flow{...}发出的繁忙循环是可以取消的。 出于性能原因，大多数其他流操作不会自动执行其他取消检测，在协程处于繁忙循环的情况下，必须明确检测是否取消。 通过cancellable操作符来执行此操作 fun simpleFlow7() = flow\u0026lt;Int\u0026gt; { for (i in 1..5) { emit(i) println(\u0026#34;Emitting $i\u0026#34;) } } @Test fun `test cancel flow check`() = runBlocking\u0026lt;Unit\u0026gt; { // 取消成功，因为emit会suspend函数，有ensureActive检测，所以cancel后会取消 simpleFlow7().collect { v -\u0026gt; println(v) if (v == 3) { cancel() // 当值等于3时，取消收集过程 println(\u0026#34;cancelled\u0026#34;) // 打印 \u0026#34;cancelled\u0026#34; 表示流已取消 } } // 取消失败，其他流没有取消检测 // (1..5).asFlow().collect { v -\u0026gt; // println(v) // if (v == 3) { // cancel() // 当值等于3时，取消收集过程 // } // } // 取消成功，因为添加了.cancellable() // 使用 cancellable() 方法允许流在收集过程中被取消 (1..5) .asFlow() .cancellable() .collect { v -\u0026gt; println(v) // 打印当前收集到的值 if (v == 3) { cancel() // 当值等于3时，取消收集过程 } } // simpleFlow7() // .cancellable() // .collect { v -\u0026gt; // println(v) // 打印当前收集到的值 // if (v == 3) { // cancel() // 当值等于3时，取消收集过程 // println(\u0026#34;cancelled\u0026#34;) // 打印 \u0026#34;cancelled\u0026#34; 表示流已取消 // } // } } 背压 buffer()，并发运行流中发射元素的代码。\nconflate()，合并发射项目，不对每个值进行处理\ncollectLatest()，取消并重新发射最后一个值\n当必须更改CoroutineDispatcher时，flowOn操作符使用了相同的缓冲机制，但是buffer函数显式地请求缓冲而不改变执行上下文。\n@Test fun `test flow back pressure`() = runBlocking { // 使用 measureTimeMillis 计算流的收集时间 val time = measureTimeMillis { simpleFlow8() // 调用定义的简单流 // .flowOn(Dispatchers.Default) // （可选）使用 Default 调度器在后台线程上执行流 // .buffer(100) // （可选）使用缓冲策略以在生产者和消费者之间提供 100 个值的缓冲区 // .conflate() // （可选）在下游繁忙时合并流的值，只处理最新的值 .collectLatest { v -\u0026gt; // 使用 collectLatest 收集流的最新值 delay(300) // 模拟耗时操作，延迟 300 毫秒 println(\u0026#34;Collected $v ${Thread.currentThread().name}\u0026#34;) // 打印收集到的值和线程名称 } } println(\u0026#34;Collected in $time ms\u0026#34;) // 打印总共花费的时间 } ","permalink":"https://kennems.github.io/posts/tech/kotlin%E5%8D%8F%E7%A8%8B2/","summary":"Kotlin协程(2) 异常处理的必要性 @OptIn(ExperimentalStdlibApi::class) // 标记该代码使用了实验性标准库 API @Test // 表示这是一个测试函数 fun `test CoroutineContext extend2`() = runBlocking { // 使用 runBlocking 启动协程 // 创建一个协程","title":"Kotlin协程(2)"},{"content":"Kotlin协程(1) 看明白，讲清楚。\n协程处理的问题：\n处理耗时任务， 这种任务常常会阻塞主线程 保证主线程安全，即确保安全的从主线程调用任何suspend函数 异步任务 协程让异步逻辑同步化，杜绝回调地狱 协程最核心的点就是：函数或一段程序能够被挂起，稍后再在挂起的位置恢复 协程的挂起与恢复 常规函数基础操作包括 ： invoke(call) 和 return, 协程新增了 suspend 和 resume ； suspend —— 也称为挂起或暂停，用于暂停执行当前协程，并保存所有局部变量 resume——用于让已暂停的协程从其暂停处继续执行 挂起函数 使用suspend关键字修饰的函数叫做挂起函数 挂起函数只能在协程体内或其他挂起函数内调用 Kotlin协程的两部分 基础设施层次，标准库的协程API， 主要对协程提供了概念和语义上最基本的支持 业务框架层，协程的上层框架支持 调度器 所有协程必须在调度器中运行，即使它们在主线程上运行也是如此。\nDispatchers.Main Android上的主线程，用来处理UI交互和一些轻量级任务\n调用suspend函数 调用UI函数 更新LiveData Dispatchers.IO 专为磁盘和网络IO进行了优化\n数据库 文件读写 网络处理 Dispatchers.Default 非主线程，专为CPU密集型任务进行了优化\n数组排序 JSON数据解析 处理差异判断 任务泄漏 类似内存泄漏\n结构化并发：\n取消任务：当某项任务不再需要时取消它\n追踪任务，当任务正在执行时，追踪它 发出错误信号，当协程失败时， 发出错误信号表明有错误发生 Coroutine Scope 定义协程必须指定其CoroutineScope， 它会跟踪所有协程，同样它还可以取消由它启动的所有协程\n重用的相关API有：\nGlobalScope：生命周期是process级别的，即使Activity， Fragment 已经被销毁，协程仍然在执行 MainScope，在Activity中使用，可以在onDestroy()中取消协程 viewModelScope，只能在ViewModel中使用，绑定ViewModel的声明周期 lifecycleScope，只能在Activity，Fragment中使用，会绑定Activity 和 Fragment的生命周期 协程使用 retrofit API // 定义 UserServiceApi 接口，用于声明与用户相关的API请求 interface UserServiceApi { // 声明一个 GET 请求，用于加载指定名称的用户信息 // @Query 注解表示请求中的查询参数 \u0026#34;name\u0026#34;，会附加到URL中 // 返回类型是 Call\u0026lt;User\u0026gt;，表示一个异步的 HTTP 请求，可以通过 enqueue 方法执行 @GET(\u0026#34;user\u0026#34;) fun loadUser(@Query(\u0026#34;name\u0026#34;) name: String): Call\u0026lt;User\u0026gt; // 声明一个 GET 请求，使用 Kotlin 的协程机制 // suspend 关键字表示这是一个挂起函数，可以在协程中被调用 // 返回类型是 User，表示直接返回解析后的用户对象 @GET(\u0026#34;user\u0026#34;) suspend fun getUser(@Query(\u0026#34;name\u0026#34;) name: String): User } // 创建一个懒加载的 userServiceApi 实例，使用 Retrofit 构建器 val userServiceApi: UserServiceApi by lazy { // 使用 Retrofit.Builder 构建 Retrofit 实例 val retrofit = retrofit2.Retrofit.Builder() // 设置 API 请求的基础 URL .baseUrl(\u0026#34;https://apifoxmock.com/m1/4944163-4601795-default/kotlinstudyserver/\u0026#34;) // 添加一个转换工厂，这里使用 MoshiConverterFactory 来解析 JSON 数据 .addConverterFactory(MoshiConverterFactory.create()) // 构建 Retrofit 实例 .build() // 创建并返回 UserServiceApi 的具体实现 retrofit.create(UserServiceApi::class.java) } User data class User(val name: String, val address: String) UserRepository.kt class UserRepository { // 声明一个挂起函数 getUser，用于获取用户信息 // 该函数在协程中执行 suspend fun getUser(name: String): User { // 调用 userServiceApi 的 getUser 方法，传递用户名称作为参数 // userServiceApi 是一个 API 接口实例，返回的 User 对象表示用户信息 return userServiceApi.getUser(name) } } MainViewModel.kt // MainViewModel 继承自 ViewModel，用于管理与用户相关的 UI 数据和业务逻辑 class MainViewModel : ViewModel() { // MutableLiveData 用于存储和观察用户数据的 LiveData // 可以在 UI 组件中观察 userLiveData，当数据发生变化时更新 UI val userLiveData = MutableLiveData\u0026lt;User\u0026gt;() // 创建 UserRepository 实例，用于获取用户数据 private val userRepository = UserRepository() // getUser 函数用于从 UserRepository 获取用户数据，并将其存储到 userLiveData 中 fun getUser(name: String) { // 使用 viewModelScope 启动协程，viewModelScope 是一个与 ViewModel 生命周期相关联的协程范围 viewModelScope.launch { // 调用 UserRepository 的 getUser 方法，获取用户信息 // 将获取的用户信息设置到 userLiveData 中，触发观察者更新 UI userLiveData.value = userRepository.getUser(name) } } } Activity // MainActivity7 继承自 AppCompatActivity，用于显示主界面 class MainActivity7 : AppCompatActivity() { // 使用 viewModels 委托来获取 MainViewModel 实例 private val mainViewModel: MainViewModel by viewModels() // 存储对 TextView 的引用（可选，后续可以用来更新 UI） private var nameTextView: TextView? = null // 创建一个 MainScope 实例，用于管理协程生命周期 // 工厂设计模式实例化 MainScope private val mainScope = MainScope() @SuppressLint(\u0026#34;StaticFieldLeak\u0026#34;) // SuppressLint 注解用于忽略静态字段泄漏警告 override fun onCreate(savedInstanceState: Bundle?) { super.onCreate(savedInstanceState) // 启用边缘到边缘模式，以使布局填充整个屏幕 enableEdgeToEdge() // 设置活动的布局 setContentView(R.layout.activity_main7) // 使用 ViewCompat 和 WindowInsetsCompat 处理系统窗口的内边距 ViewCompat.setOnApplyWindowInsetsListener(findViewById(R.id.main)) { v, insets -\u0026gt; // 获取系统窗口的内边距 val systemBars = insets.getInsets(WindowInsetsCompat.Type.systemBars()) // 设置视图的内边距，避免被系统窗口遮挡 v.setPadding(systemBars.left, systemBars.top, systemBars.right, systemBars.bottom) // 返回处理后的 insets insets } // 使用 DataBindingUtil 绑定布局文件与视图模型 val binding = DataBindingUtil.setContentView\u0026lt;ActivityMain7Binding\u0026gt;(this, R.layout.activity_main7) // 将 ViewModel 绑定到布局 binding.viewModel = mainViewModel // 设置生命周期所有者，使数据绑定可以观察 LiveData binding.lifecycleOwner = this // 设置提交按钮的点击监听器 binding.submitButton.setOnClickListener(View.OnClickListener { // 当按钮被点击时，调用 ViewModel 的 getUser 方法 // 这里使用 \u0026#34;ken\u0026#34; 作为查询参数 mainViewModel.getUser(\u0026#34;ken\u0026#34;) }) } // 活动销毁时取消协程，释放资源 override fun onDestroy() { super.onDestroy() // 取消所有在 MainScope 中启动的协程 mainScope.cancel() } } 协程构建器 launch与async构建器都用来启动新协程 launch，返回 Job 并且不附带任何结果值 async，返回一个Deferred，Deferred也是一个Job，可以使用.await()在一个延期的值上得到它的最终结果 等待一个作业 join和await 组合并发 协程的启动模式 DEFAULT：协程创建后，立即开始调度，在调度前如果协程被取消，其将直接进入取消响应的状态 ATOMIC：协程创建后，立即开始调度，协程执行到第一个挂起点之前不响应取消 LAZY：只有协程被需要时，包括主动调用协程的start，join或者await等函数时才会开始调度，如果调度前就被取消，那么该协程将直接进入异常结束状态 UNDISPATCHED：协程创建后立即在当前函数调用栈中执行，直到遇到第一个真正挂起的点 coroutineScope 与 runBlocking runBlocking是常规函数，而coroutineScope是挂起函数 它们都会等待其协程体以及所有子协程结束，主要区别在于runBlocking方法会阻塞当前线程来等待，而coroutineScope只是挂起，会释放底层线程用于其他用途 区别：\ncoroutineScope：一个协程失败了，所有其他兄弟协程也会被取消 supervisorScope：一个协程失败了，不会影响其他兄弟协程 Job对象 对于每一个创建的协程（通过launch或者async），会返回一个Job实例，该实例是协程的唯一标识，并且负责管理协程的生命周期 一个任务可以包含一系列状态，新创建（New）、活跃（Active）、完成中（Completing）、已完成（Completed）、取消中（Cancelling）和已取消（Cancelled）。可以访问Job的属性：isActive，isCancelled和isCompleted。 Job的生命周期 如果协程处于活跃状态，协程运行出错或者调用 job.cancel() 都会将当前任务置为取消中（Cancelling）状态（isActive = false, isCancelled = true）。当所有的子协程都完成后，协程会进入已取消（Cancelled）。\n@Test fun `test scope cancel`() = runBlocking\u0026lt;Unit\u0026gt; { // 创建一个 CoroutineScope，指定使用 Default 调度器 val scope = CoroutineScope(Dispatchers.Default) // 启动第一个协程，延迟 1000 毫秒后打印 \u0026#34;job 1\u0026#34; scope.launch { delay(1000) println(\u0026#34;job 1\u0026#34;) } // 启动第二个协程，延迟 1000 毫秒后打印 \u0026#34;job 2\u0026#34; scope.launch { delay(1000) println(\u0026#34;job 2\u0026#34;) } // 延迟 100 毫秒，确保前面两个协程有时间启动 // delay(100) // 取消 scope 中的所有协程 // scope.cancel() // 两个均不打印 // 延迟 1500 毫秒，确保可以看到协程的输出（如果它们没有被取消的话） delay(1500) // 两个可以正常打印 } @Test fun `test brother cancel`() = runBlocking\u0026lt;Unit\u0026gt; { // 创建一个 CoroutineScope，指定使用 Default 调度器 val scope = CoroutineScope(Dispatchers.Default) // 启动第一个协程，延迟 1000 毫秒后打印 \u0026#34;job 1\u0026#34; val job1 = scope.launch { delay(1000) println(\u0026#34;job 1\u0026#34;) } // 启动第二个协程，延迟 1000 毫秒后打印 \u0026#34;job 2\u0026#34; val job2 = scope.launch { delay(1000) println(\u0026#34;job 2\u0026#34;) } // 延迟 100 毫秒，确保前面两个协程有时间启动 delay(100) // 取消 job1，但不取消 job2 job1.cancel() // 延迟 1500 毫秒，确保可以看到 job2 的输出 delay(1500) } 取消协程 在cancel()后保证协程被取消\n@Test fun `test cancel cpu task by isActive`() = runBlocking\u0026lt;Unit\u0026gt; { // 获取当前时间的毫秒数，用于计算任务执行的时间点 val startTime = System.currentTimeMillis() // 启动一个协程，运行在默认调度器上（通常是后台线程） val job = launch(Dispatchers.Default) { var nextPrintTime = startTime // 下次打印信息的时间 var i = 0 // 计数器，用于限制任务执行次数 // 循环执行，直到达到5次或协程被取消 while (i \u0026lt; 5 \u0026amp;\u0026amp; isActive) { // 检查是否到达下一个打印时间点 if (System.currentTimeMillis() \u0026gt;= nextPrintTime) { // 打印当前状态和计数器 println(\u0026#34;job: I\u0026#39;m sleeping ${i++}\u0026#34;) nextPrintTime += 500 // 更新下次打印的时间 } } } // 延迟 1300 毫秒，模拟主线程的等待时间 delay(1300) // 主线程输出，表示等待的时间结束 println(\u0026#34;main : I\u0026#39;m tired of waiting\u0026#34;) // 取消 job 协程并等待其完全结束 job.cancelAndJoin() // 主线程输出，表示可以退出了 println(\u0026#34;main : Now I can quit.\u0026#34;) } @Test fun `test cancel cpu task by ensureActive`() = runBlocking\u0026lt;Unit\u0026gt; { // 获取当前时间的毫秒数，用于计算任务执行的时间点 val startTime = System.currentTimeMillis() // 启动一个协程，运行在默认调度器上（通常是后台线程） val job = launch(Dispatchers.Default) { var nextPrintTime = startTime // 下次打印信息的时间 var i = 0 // 计数器，用于限制任务执行次数 // 循环执行，直到达到5次 while (i \u0026lt; 5) { // 确保协程处于活跃状态，如果协程已取消则会抛出 CancellationException ensureActive() // 检查是否到达下一个打印时间点 if (System.currentTimeMillis() \u0026gt;= nextPrintTime) { // 打印当前状态和计数器 println(\u0026#34;job: I\u0026#39;m sleeping ${i++}\u0026#34;) nextPrintTime += 500 // 更新下次打印的时间 } } } // 延迟 1300 毫秒，模拟主线程的等待时间 delay(1300) // 主线程输出，表示等待的时间结束 println(\u0026#34;main : I\u0026#39;m tired of waiting\u0026#34;) // 取消 job 协程并等待其完全结束 job.cancelAndJoin() // 主线程输出，表示可以退出了 println(\u0026#34;main : Now I can quit.\u0026#34;) } CPU密集型任务取消 isActive是一个可以被使用在CoroutineScope中的扩展属性，检查Job是否处于活跃状态\nensureActive()， 如果job处于非活跃状态，这个方法会立即抛出异常\nyield函数会检查所在协程的状态，如果已经取消，则抛出CancellationExcepiton予以相应。此外，它还会尝试让出线程的执行权，给其他协程提供执行机会。\n协程取消的副作用 在finally中释放资源。\n@Test fun `test release resources`() = runBlocking\u0026lt;Unit\u0026gt; { val job = launch { try { repeat(1000){ it-\u0026gt; println(\u0026#34;job : I\u0026#39;m sleeping $it ...\u0026#34;) delay(500L) } } catch (e: Exception) { println(\u0026#34;Job: I\u0026#39;m running finally\u0026#34;) // 释放资源 } } delay(1300) println(\u0026#34;main : I\u0026#39;m tired of waiting\u0026#34;) job.cancelAndJoin() println(\u0026#34;main : Now I can quit.\u0026#34;) } use函数：该函数只能被实现了Closeable的对象使用，程序结束的时候会自动调用close方法，适合文件对象。\n@Test fun `test use function`() = runBlocking\u0026lt;Unit\u0026gt; { // 使用 use 函数自动管理资源 // use 函数会自动关闭资源，无需手动调用 close BufferedReader(FileReader(\u0026#34;D:\\\\test\\\\test.txt\u0026#34;)).use { var line: String? // 无限循环读取文件内容，直到文件末尾 while (true) { // 读取一行内容，如果为 null（文件末尾），则退出循环 line = it.readLine() ?: break println(line) // 打印每一行内容 } } } 不能被取消的任务 @Test fun `test cancel with NonCancellable`() = runBlocking\u0026lt;Unit\u0026gt; { // 启动一个新的协程 val job = launch { try { // 在协程中重复执行任务1000次 repeat(1000) { it -\u0026gt; println(\u0026#34;job : I\u0026#39;m sleeping $it ...\u0026#34;) // 打印当前任务的状态 delay(500L) // 暂停500毫秒 } } finally { // 这里的代码块在协程取消时执行 // 使用 NonCancellable 上下文，确保这个代码块中的任务不会被取消 withContext(NonCancellable) { println(\u0026#34;job: I\u0026#39;m running finally\u0026#34;) // 打印消息，表示进入了 finally 部分 delay(1000L) // 这里的延迟不会被取消，即使协程已经被取消 println(\u0026#34;job: And I\u0026#39;ve just delayed for 1 sec \u0026#34;) // 打印延迟后的消息 } } } // 主协程延迟1300毫秒，给子协程足够的时间运行 delay(1300) println(\u0026#34;main: I\u0026#39;m tired of waiting!\u0026#34;) // 打印主协程等待的消息 // 取消子协程并等待它完成 job.cancelAndJoin() println(\u0026#34;main: Now I can quit.\u0026#34;) // 打印主协程完成后的消息 } 超时任务 取消协程的理由是有可能超时 withTimeoutOrNull 通过返回null来进行超时操作，从而替代抛出一个异常 @Test fun `test deal with timeout`() = runBlocking { // 使用 withTimeout 函数设置超时时间 withTimeout(1300L) { // 设置最大执行时间为1300毫秒 repeat(1000) { i -\u0026gt; // 计划执行1000次任务 println(\u0026#34;job: I\u0026#39;m sleeping $i ...\u0026#34;) // 打印当前任务的状态 delay(500L) // 每个任务暂停500毫秒 } } } @Test fun `test deal with timeout return null`() = runBlocking { // 使用 withTimeoutOrNull 函数设置超时时间并处理超时返回 null val result = withTimeoutOrNull(1300L) { // 设置最大执行时间为1300毫秒 repeat(1000) { i -\u0026gt; // 计划执行1000次任务 println(\u0026#34;job: I\u0026#39;m sleeping $i ...\u0026#34;) // 打印当前任务的状态 delay(500L) // 每个任务暂停500毫秒 } \u0026#34;Done\u0026#34; // 如果在1300毫秒内完成所有任务，将返回 \u0026#34;Done\u0026#34; } // 打印 result 结果，如果任务在超时时间内完成，则 result 为 \u0026#34;Done\u0026#34;，否则为 null println(\u0026#34;Result is $result\u0026#34;) } 协程上下文 CoroutineContext是一组用于定义协程行为的元素，它由如下几项构成：\nJob：控制协程的生命周期 CoroutineDispatcher：向合适的线程分发任务 CoroutineName：协程的名称，调试的时候很有用 CoroutineExceptionHandler：处理未被捕捉的异常 组合上下文中的元素 有时我们需要在协程上下文中定义多个元素。可以使用 + 操作符来实现。 @Test fun `test CoroutineContext`() = runBlocking\u0026lt;Unit\u0026gt; { launch(Dispatchers.Default + CoroutineName(\u0026#34;test\u0026#34;)) { println(\u0026#34;I\u0026#39;m working in thread ${Thread.currentThread().name}\u0026#34;) } } 协程上下文的继承 协程的上下文 = 默认值 + 继承的CoroutineContext + 参数\n","permalink":"https://kennems.github.io/posts/tech/kotlin%E5%8D%8F%E7%A8%8B1/","summary":"Kotlin协程(1) 看明白，讲清楚。 协程处理的问题： 处理耗时任务， 这种任务常常会阻塞主线程 保证主线程安全，即确保安全的从主线程调用任何su","title":"Kotlin协程(1)"},{"content":"Kotlin协程(5) Binding 视图绑定\nView Binding: 通过View Binding， Android 会为每个XML布局文件自动生成一个绑定类。在这个类中，每个View都有一个直接对应的属性，可以避免findViewById的使用，从而减少了手动查找视图和类型转换的工作。提高代码的安全性和可读性。 val binding = ActivityMainBinding.inflate(layoutInflater) setContentView(binding.root) binding.textView.text = \u0026#34;Hello World\u0026#34; Data Binding: 功能比View Binding 更为强大，允许在布局文件中直接绑定UI组件到数据源（如ViewModel），这样，数据的变化会自动更新UI \u0026lt;data\u0026gt; \u0026lt;variable name=\u0026#34;user\u0026#34; type=\u0026#34;com.example.User\u0026#34;/\u0026gt; \u0026lt;/data\u0026gt; \u0026lt;TextView android:text=\u0026#34;@{user.name}\u0026#34;/\u0026gt; Activity中：\nval binding: ActivityMainBinding = DataBindingUtil.setContentView(this, R.layout.activity_main) binding.user = userObject Holder Holder通常指的是ViewHolder，用于在RecyclerView中复用视图的一种设计模式。ViewHolder主要用于存储视图引用，从而避免频繁调用findViewById，提高RecyclerView的性能。\nViewHolder的作用 缓存视图：在 ViewHolder中缓存了每个子项的视图引用，减少不必要的视图查找。 服用视图：通过复用 ViewHolder对象，避免在滚动时重复创建和销毁视图，提高性能。 class MyViewHolder(itemView: View) : RecyclerView.ViewHolder(itemView) { val textView: TextView = itemView.findViewById(R.id.text_view) } override fun onBindViewHolder(holder: MyViewHolder, position: Int) { holder.textView.text = data[position] } 在RecyclerView中，当一个新的子项需要显示时，系统会使用已经创建好的ViewHolder，并通过onBindViewHolder方法绑定数据到视图上，从而避免重复创建视图。\nHilt 负责托管对象与对象之间的注入关系\n注解 @HiltAndroidApp：触发 Hilt 的代码生成。 @AndroidEntryPoint：创建一个依赖容器，该容器遵循 Android 类的生命周期。 @Module：告诉 Hilt 如何提供不同类型的实例。 @InstallIn：Install 用来告诉 Hilt 这个模块会被装配到哪个组件上。 @Provides：告诉 Hilt 如何获得具体实例。 @Singleton：单例。 @ViewModelInject：通过构造函数，给 ViewModel 注入实例。 Data Mapper 使用Data Mapper 分离数据源的Model和页面显示的Model， 不要因为数据源的增加，修改或者删除，导致上层页面也要跟着一起修改。\nCoil Coil 是一个用于 Android 的图像加载库，具有以下特点：\n性能优越：在性能上表现出色。 体积较小：与 Picasso 相比，体积小，且低于 Glide 和 Fresco。 简单易用：与 Kotlin 兼容，API 简单直观。 技术先进：基于 Coroutine、OkHttp、Okio 等现代技术，确保技术的先进性。 丰富功能：支持缓存管理（内存和磁盘缓存）、动态图像采样等，提升图像加载效率。 Coil 旨在提供高效的图像加载解决方案，特别适合 Kotlin 开发者。\nLoadType PagingState pages: List\u0026lt;Page\u0026lt;Key, Value\u0026raquo; 返回的上一页的数据，主要用于获取上一页最后一条数据作为下一页的开始位置。 config：PagingConfig返回的初始化位置的PagingConfig包含了pageSize，prefetchDistance， initialLoadSize等等。 MediatorResult 请求出现错误，返回MediatorResult.Error(e) 请求成功且有数据，返回MediatorResult.Success(endOfPaginationReached = true)。 请求成功但是没有数据，返回MediatorResult.Success(endOfPaginationReached = false)。 CarBrandRemoteMediator.kt @OptIn(ExperimentalPagingApi::class) class CarBrandRemoteMediator( private val api: CarBrandService, // 依赖注入的API服务，用于请求网络数据 private val database: AppDatabase // 依赖注入的数据库实例，用于数据存储 ) : RemoteMediator\u0026lt;Int, CarBrandEntity\u0026gt;() { // 负责加载分页数据的核心方法 override suspend fun load( loadType: LoadType, // 加载类型，可能是REFRESH、PREPEND或APPEND state: PagingState\u0026lt;Int, CarBrandEntity\u0026gt; // 用于获取当前分页状态 ): MediatorResult { try { Log.d(\u0026#34;Kennem\u0026#34;, \u0026#34;loadType = ${loadType}\u0026#34;) // 确定当前请求的页码 val pageKey = when (loadType) { // 首次加载或手动刷新时，不需要页码，设为null LoadType.REFRESH -\u0026gt; null // 向前加载数据时，直接返回，不继续请求，标记为分页结束 LoadType.PREPEND -\u0026gt; return MediatorResult.Success(endOfPaginationReached = true) // 向后加载更多数据时，获取最后一项的数据页码作为新的页码 LoadType.APPEND -\u0026gt; { val lastItem: CarBrandEntity = state.lastItemOrNull() ?: return MediatorResult.Success(endOfPaginationReached = true) lastItem.page } } // 无网络，加载本地数据 if (!AppHelper.mContext.isConnectedNetWork()){ MediatorResult.Success(endOfPaginationReached = true) } // 请求网络分页数据，pageKey为null时默认请求第一页数据 val page = pageKey ?: 0 val result = api.fetchCarBrandList( page * state.config.pageSize, // 根据页码和页面大小计算请求的偏移量 state.config.pageSize // 页面大小 ) // 将网络数据映射为数据库实体 val item = result.map { CarBrandEntity( id = it.id, name = it.name, icon = it.icon, page = page + 1 // 将页码加一，标记为下一次请求的页码 ) } // 判断是否到达分页末端 val endOfPaginationReached = result.isEmpty() // 获取DAO操作对象 val carBrandDao = database.carBrandDao() // 使用事务插入数据，保证数据一致性 database.withTransaction { if (loadType == LoadType.REFRESH) { // 如果是刷新操作，清空已有的数据 carBrandDao.clearCarBrand() } // 插入新数据 carBrandDao.insertCarBrand(item) } // 返回加载结果，标记是否到达分页末端 return MediatorResult.Success(endOfPaginationReached = endOfPaginationReached) } catch (e: Exception) { e.printStackTrace() // 捕获异常，返回错误结果 return MediatorResult.Error(e) } } } App Startup App Startup 是 Android Jetpack 最新成员，提供了在App启动时初始化组件简单、高效的方法，无论是library开发人员还是App开发人员都可以使用App Startup显式的设置初始化顺序。 /** * AppInitializer 是一个自定义的应用初始化类，用于在应用启动时进行必要的初始化操作。 * 它实现了 androidx.startup.Initializer 接口。 */ class AppInitializer : Initializer\u0026lt;Unit\u0026gt; { /** * create 方法在应用启动时被调用，用于执行初始化逻辑。 * * @param context 应用程序的上下文，用于初始化操作 */ override fun create(context: Context) { // 调用 AppHelper 的 init 方法进行初始化操作 AppHelper.init(context) } /** * dependencies 方法用于声明当前 Initializer 所依赖的其他 Initializer。 * 这里返回一个空的列表，表示没有依赖项。 * * @return MutableList\u0026lt;Class\u0026lt;out Initializer\u0026lt;*\u0026gt;\u0026gt;\u0026gt; 当前初始化器的依赖项列表 */ override fun dependencies(): MutableList\u0026lt;Class\u0026lt;out Initializer\u0026lt;*\u0026gt;\u0026gt;\u0026gt; = mutableListOf() } AndroidManifest.xml 添加provider部分\n\u0026lt;provider android:name=\u0026#34;androidx.startup.InitializationProvider\u0026#34; android:authorities=\u0026#34;${applicationId}.androidx-startup\u0026#34; android:exported=\u0026#34;false\u0026#34; tools:node=\u0026#34;merge\u0026#34;\u0026gt; \u0026lt;meta-data android:name=\u0026#34;com.show.carhome.init.AppInitializer\u0026#34; android:value=\u0026#34;androidx.startup\u0026#34; /\u0026gt; \u0026lt;/provider\u0026gt; ","permalink":"https://kennems.github.io/posts/tech/kotlin%E5%8D%8F%E7%A8%8B5/","summary":"Kotlin协程(5) Binding 视图绑定 View Binding: 通过View Binding， Android 会为每个XML布局文件自动生成一个绑定类。在这个类中，每个View都有一个","title":"Kotlin协程(5)"},{"content":"Hugo配置与使用 下载PaperMod主题：\ngit clone https://github.com/adityatelange/hugo-PaperMod themes/PaperMod --depth=1 生成public内容时清空文件夹\nhugo -F --cleanDestinationDir 新建post\nhugo new content posts/my-first-post.md 完成Git push流程\necho \u0026#34;# showguan.github.io\u0026#34; \u0026gt;\u0026gt; README.md git init git add README.md git commit -m \u0026#34;first commit\u0026#34; git branch -M main git remote add origin https://github.com/showguan/showguan.github.io.git git push -u origin main git remote add origin https://github.com/showguan/showguan.github.io.git git branch -M main git push -u origin main 强制push到仓库\ngit push -f -u origin main git remote add origin \u0026lt;远程代码库的URL\u0026gt; 第六步：在上面创建的github文件中，放入要上传的代码，然后按照上面的指令开始操作，执行指令 1、git init （建立本地仓库） 2、git add * (将代码添加到本地仓库，《*是添加全部代码，代码全部更新》) 3、git commit -m \u0026#34;first commit\u0026#34; (提交到本地缓冲，《引号里说明提交了什么东西，说白了就是注释》） Git代理管理 //http || https git config --global http.proxy 127.0.0.1:10809 git config --global https.proxy 127.0.0.1:10809 //sock5代理 git config --global http.proxy socks5 127.0.0.1:10808 git config --global https.proxy socks5 127.0.0.1:10808 git config --global --unset http.proxy git config --global --unset https.proxy 最终的原因： 它控制着在提交和检出文件时是否自动地将行结束符转换为不同的格式。\ngit config --global core.autocrlf false Front Matter --- title: \u0026#34;我的第一篇文章\u0026#34; subtitle: \u0026#34;\u0026#34; date: 2020-03-04T15:58:26+08:00 lastmod: 2020-03-04T15:58:26+08:00 draft: true author: \u0026#34;\u0026#34; authorLink: \u0026#34;\u0026#34; description: \u0026#34;\u0026#34; license: \u0026#34;\u0026#34; tags: [] categories: [] hiddenFromHomePage: false featured_image: \u0026#34;\u0026#34; featured_image_preview: \u0026#34;\u0026#34; toc: false autoCollapseToc: true math: true mapbox: accessToken: \u0026#34;\u0026#34; lightStyle: \u0026#34;\u0026#34; darkStyle: \u0026#34;\u0026#34; navigation: true geolocate: true scale: true fullscreen: true lightgallery: true linkToMarkdown: true share: enable: true comment: true --- --- title: \u0026#34;My 1st post\u0026#34; date: 2020-09-15T11:30:03+00:00 # weight: 1 # aliases: [\u0026#34;/first\u0026#34;] tags: [\u0026#34;first\u0026#34;] author: \u0026#34;Me\u0026#34; # author: [\u0026#34;Me\u0026#34;, \u0026#34;You\u0026#34;] # multiple authors showToc: true TocOpen: false draft: false hidemeta: false comments: false description: \u0026#34;Desc Text.\u0026#34; canonicalURL: \u0026#34;https://canonical.url/to/page\u0026#34; disableHLJS: true # to disable highlightjs disableShare: false disableHLJS: false hideSummary: false searchHidden: true ShowReadingTime: true ShowBreadCrumbs: true ShowPostNavLinks: true ShowWordCount: true ShowRssButtonInSectionTermList: true UseHugoToc: true cover: image: \u0026#34;\u0026lt;image path/url\u0026gt;\u0026#34; # image path/url alt: \u0026#34;\u0026lt;alt text\u0026gt;\u0026#34; # alt text caption: \u0026#34;\u0026lt;text\u0026gt;\u0026#34; # display caption under cover relative: false # when using page bundles set this to true hidden: true # only hide on current single page editPost: URL: \u0026#34;https://github.com/\u0026lt;path_to_repo\u0026gt;/content\u0026#34; Text: \u0026#34;Suggest Changes\u0026#34; # edit text appendFilePath: true # to append file path to Edit link --- 不蒜子流量统计 \u0026lt;script async src=\u0026#34;https://cdn.dusays.com/bsz.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt;\r本文总阅读量 \u0026lt;span id=\u0026#34;busuanzi_value_page_pv\u0026#34;\u0026gt;\u0026lt;/span\u0026gt; 次\r本文总访客量 \u0026lt;span id=\u0026#34;busuanzi_value_page_uv\u0026#34;\u0026gt;\u0026lt;/span\u0026gt; 人\r本站总访问量 \u0026lt;span id=\u0026#34;busuanzi_value_site_pv\u0026#34;\u0026gt;\u0026lt;/span\u0026gt; 次\r本站总访客数 \u0026lt;span id=\u0026#34;busuanzi_value_site_uv\u0026#34;\u0026gt;\u0026lt;/span\u0026gt; 人 config.yaml baseURL: https://kyxie.github.io/ languageCode: en-ca # zh-cn title: Kunyang\u0026#39;s Blog theme: PaperMod enableInlineShortcodes: true enableEmoji: true # allowing using emoji enableRobotsTXT: true hasCJKLanguage: true buildDrafts: false buildFuture: false buildExpired: false #googleAnalytics: UA-123-45 paginate: 15 # articles per page minify: disableXML: true # minifyOutput: true permalinks: post: \u0026#34;/:title/\u0026#34; # post: \u0026#34;/:year/:month/:day/:title/\u0026#34; defaultContentLanguage: en # prefer language defaultContentLanguageInSubdir: true languages: en: languageName: \u0026#34;English🇨🇦\u0026#34; contentDir: content/English weight: 1 profileMode: enabled: true title: Kyrie Xie subtitle: \u0026#34;Welcome to my site!\u0026#34; # imageUrl: \u0026#34;Avatar.png\u0026#34; imageUrl: \u0026#34;Selfie.png\u0026#34; imageTitle: Selfie imageWidth: 150 imageHeight: 150 buttons: - name: About url: about - name: Project url: projects - name: Resume url: resume.pdf menu: main: - identifier: About name: About url: about weight: 1 - identifier: Projects name: Project url: projects weight: 2 - identifier: Resume name: Resume url: resume.pdf weight: 3 - identifier: Blog name: Blogs url: blog weight: 4 - identifier: Search name: Search url: search weight: 5 zh: languageName: \u0026#34;中文🇨🇳\u0026#34; contentDir: content/Chinese weight: 2 profileMode: enabled: true title: 谢坤洋 subtitle: \u0026#34;欢迎来到我的网站！\u0026#34; # imageUrl: \u0026#34;Avatar.png\u0026#34; imageUrl: \u0026#34;Selfie.png\u0026#34; imageTitle: Selfie imageWidth: 150 imageHeight: 150 buttons: - name: 关于 url: about - name: 博客 url: blog - name: 简历 url: resume.pdf menu: main: - identifier: About name: 关于 url: about weight: 1 - identifier: Projects name: 项目 url: projects weight: 2 - identifier: Resume name: 简历 url: resume.pdf weight: 3 - identifier: Blog name: 博客 url: blog weight: 4 - identifier: Comments name: 留言板 url: comment/comments weight: 5 - identifier: Links name: 友链 url: links weight: 6 - identifier: Search name: 搜索 url: search weight: 7 outputs: home: - HTML - RSS - JSON params: env: production # to enable google analytics, opengraph, twitter-cards and schema. title: Kyrie author: Kyrie defaultTheme: dark # defaultTheme: light or dark disableThemeToggle: false DateFormat: \u0026#34;2006-01-02\u0026#34; ShowShareButtons: true ShowReadingTime: true # disableSpecialistPost: true disableScrollToTop: false displayFullLangName: true ShowPostNavLinks: true ShowBreadCrumbs: true ShowCodeCopyButtons: true hideFooter: false # hide foot ShowWordCounts: true VisitCount: true ShowLastMod: true ShowToc: true TocOpen: true comments: true socialIcons: - name: instagram url: \u0026#34;https://www.instagram.com/_kyxie/\u0026#34; - name: github url: \u0026#34;https://github.com/kyxie\u0026#34; - name: linkedin url: \u0026#34;https://www.linkedin.com/in/kunyang-kyrie-xie-557270194/\u0026#34; # - name: qq # url: \u0026#34;qq.jpg\u0026#34; - name: wechat url: \u0026#34;wechat.jpg\u0026#34; - name: weibo url: \u0026#34;https://weibo.com/u/5687393723\u0026#34; - name: bilibili url: \u0026#34;https://space.bilibili.com/156752850?spm_id_from=333.1007.0.0\u0026#34; - name: strava url: \u0026#34;https://www.strava.com/athletes/62343657\u0026#34; - name: email url: \u0026#34;mailto:kyriexie@outlook.com\u0026#34; assets: favicon: \u0026#34;k-48.png\u0026#34; favicon16x16: \u0026#34;k-48.png\u0026#34; favicon32x32: \u0026#34;k-48.png\u0026#34; apple_touch_icon: \u0026#34;k-48.png\u0026#34; safari_pinned_tab: \u0026#34;k-48.png\u0026#34; label: text: \u0026#34;Home\u0026#34; fuseOpts: isCaseSensitive: false shouldSort: true location: 0 distance: 1000 threshold: 1 minMatchCharLength: 0 keys: [\u0026#34;title\u0026#34;, \u0026#34;permalink\u0026#34;, \u0026#34;summary\u0026#34;] twikoo: version: 1.4.11 taxonomies: category: categories tag: tags series: series markup: goldmark: renderer: unsafe: true highlight: # anchorLineNos: true codeFences: true guessSyntax: true lineNos: true # noClasses: false style: monokai lineNos: false privacy: vimeo: disabled: false simple: true twitter: disabled: false enableDNT: true simple: true instagram: disabled: false simple: true youtube: disabled: false privacyEnhanced: true services: instagram: disableInlineCSS: true twitter: disableInlineCSS: true languages: en: languageName: \u0026#34;English\u0026#34; # contentDir: content/english weight: 1 profileMode: enabled: true title: (〃\u0026#39;▽\u0026#39;〃) subtitle: \u0026#34;🧨学而时习之，不亦说乎？有朋自远方来，不亦乐乎？\u0026lt;br/\u0026gt;👏🏼欢迎光临素履(Sulv)的博客\u0026lt;br/\u0026gt;👇联系方式\u0026#34; imageUrl: \u0026#34;img/Q.gif\u0026#34; #图片放在static/img/Q.gif imageTitle: imageWidth: 150 imageHeight: 150 buttons: - name: 👨🏻‍💻技术 url: posts/tech - name: 📕阅读 url: posts/read - name: 🏖生活 url: posts/life menu: main: - identifier: search name: 🔍搜索 url: search weight: 1 - identifier: home name: 🏠主页 url: / weight: 2 - identifier: posts name: 📚文章 url: posts weight: 3 - identifier: archives name: ⏱时间轴 url: archives/ weight: 20 - identifier: tags name: 🔖标签 url: tags weight: 40 - identifier: about name: 🙋🏻‍♂️关于 url: about weight: 50 - identifier: links name: 🤝友链 url: links weight: 60 enableInlineShortcodes: true #允许内联短码 enableEmoji: true # 允许使用 Emoji 表情，建议 true enableRobotsTXT: true # 允许爬虫抓取到搜索引擎，建议 true hasCJKLanguage: true # 自动检测是否包含 中文日文韩文 如果文章中使用了很多中文引号的话可以开启 buildDrafts: false buildFuture: false buildExpired: false #googleAnalytics: UA-123-45 # 谷歌统计 # Copyright: Sulv paginate: 15 # 每页显示的文章数 minify: disableXML: true # minifyOutput: true permalinks: #浏览器链接显示方式 post: \u0026#34;/:title/\u0026#34; # post: \u0026#34;/:year/:month/:day/:title/\u0026#34; defaultContentLanguage: en # 最顶部首先展示的语言页面 defaultContentLanguageInSubdir: true outputs: home: - HTML - RSS - JSON params: env: production # to enable google analytics, opengraph, twitter-cards and schema. # description: \u0026#34;这是一个纯粹的博客......\u0026#34; author: Sulv # author: [\u0026#34;Me\u0026#34;, \u0026#34;You\u0026#34;] # multiple authors defaultTheme: auto # defaultTheme: light or dark disableThemeToggle: false DateFormat: \u0026#34;2006-01-02\u0026#34; ShowShareButtons: true ShowReadingTime: true # disableSpecialistPost: true displayFullLangName: true ShowPostNavLinks: true ShowBreadCrumbs: true ShowCodeCopyButtons: true hideFooter: false # 隐藏页脚 ShowWordCounts: true VisitCount: true ShowLastMod: true #显示文章更新时间 ShowToc: true # 显示目录 TocOpen: true # 自动展开目录 comments: true socialIcons: - name: github url: \u0026#34;https://github.com/xyming108\u0026#34; - name: twitter url: \u0026#34;img/twitter.png\u0026#34; - name: facebook url: \u0026#34;https://www.facebook.com/profile.php?id=100027782410997\u0026#34; - name: instagram url: \u0026#34;img/instagram.png\u0026#34; - name: QQ url: \u0026#34;img/qq.png\u0026#34; - name: WeChat url: \u0026#34;img/wechat.png\u0026#34; - name: email url: \u0026#34;mailto:1931559710@qq.com\u0026#34; - name: RSS url: \u0026#34;index.xml\u0026#34; # editPost: # URL: \u0026#34;https://github.com/adityatelange/hugo-PaperMod/tree/exampleSite/content\u0026#34; # Text: \u0026#34;Suggest Changes\u0026#34; # edit text # appendFilePath: true # to append file path to Edit link label: text: \u0026#34;Sulv\u0026#39;s Blog\u0026#34; #icon: \u0026#34;img/Q.gif\u0026#34; icon: \u0026#34;https://www.sulvblog.cn/Q.gif\u0026#34; iconHeight: 35 # analytics: #谷歌分析 # google: # SiteVerificationTag: \u0026#34;XYZabc\u0026#34; assets: favicon: \u0026#34;img/Q.gif\u0026#34; favicon16x16: \u0026#34;img/Q.gif\u0026#34; favicon32x32: \u0026#34;img/Q.gif\u0026#34; apple_touch_icon: \u0026#34;Q.gif\u0026#34; safari_pinned_tab: \u0026#34;Q.gif\u0026#34; # cover: # hidden: true # hide everywhere but not in structured data # hiddenInList: true # hide on list pages and home # hiddenInSingle: true # hide on single page fuseOpts: isCaseSensitive: false shouldSort: true location: 0 distance: 1000 threshold: 1 minMatchCharLength: 0 keys: [\u0026#34;title\u0026#34;, \u0026#34;permalink\u0026#34;, \u0026#34;summary\u0026#34;] twikoo: version: 1.4.11 taxonomies: category: categories tag: tags series: series markup: goldmark: renderer: unsafe: true # HUGO 默认转义 Markdown 文件中的 HTML 代码，如需开启的话 highlight: # anchorLineNos: true codeFences: true guessSyntax: true lineNos: true # noClasses: false # style: monokai style: darcula # codeFences：代码围栏功能，这个功能一般都要设为 true 的，不然很难看，就是干巴巴的-代码文字，没有颜色。 # guessSyntax：猜测语法，这个功能建议设置为 true, 如果你没有设置要显示的语言则会自动匹配。 # hl_Lines：高亮的行号，一般这个不设置，因为每个代码块我们可能希望让高亮的地方不一样。 # lineNoStart：行号从编号几开始，一般从 1 开始。 # lineNos：是否显示行号，我比较喜欢显示，所以我设置的为 true. # lineNumbersInTable：使用表来格式化行号和代码,而不是 标签。这个属性一般设置为 true. # noClasses：使用 class 标签，而不是内嵌的内联样式 privacy: vimeo: disabled: false simple: true twitter: disabled: false enableDNT: true simple: true instagram: disabled: false simple: true youtube: disabled: false privacyEnhanced: true services: instagram: disableInlineCSS: true twitter: disableInlineCSS: true 完整发布流程 hugo -F --cleanDestinationDir 将备份文件夹内的文件复制到发布文件夹内\nCopy-Item -Path AddFile -Destination ../kennems/public -Recurse 将备份文件复制到发布文件夹内：\nCopy-Item -Path \u0026#34;AddFile\\*\u0026#34; -Destination \u0026#34;.\u0026#34; -Recurse post文件夹 这里是 主页 -》📚文章 下面的分类\n自定义CSS 这个文件夹放置各种自定义CSS样式，分开放不会有优先级问题。\n配置封面图 cover: image: img/cat.jpg # 设置图片的小标题 alt: \u0026#34;图片\u0026#34; #caption: \u0026#34;图片\u0026#34; hidden: true # 文章页面隐藏封面图片 自定义底部categories ","permalink":"https://kennems.github.io/posts/tech/hugo/","summary":"Hugo配置与使用 下载PaperMod主题： git clone https://github.com/adityatelange/hugo-PaperMod themes/PaperMod --depth=1 生成public内容时清空文件夹 hugo -F --cleanDestinationDir 新建post hugo new content posts/my-first-post.md 完成Git push流程 echo \u0026#34;# showguan.github.io\u0026#34;","title":"Hugo配置与使用"},{"content":"Kotlin基础 val \u0026amp; var const 编译时常量只能在函数之外定义，因为编译时常量必须在编译时赋值， 而函数都是在运行时才调用， 函数内的变量也是在运行时赋值，编译时常量要在这些变量赋值前就已经存在。 函数参数 fun main(){ println(doSomething(1, false)) println(fix(\u0026#34;Jack\u0026#34;)) println(fix(age=10, name=\u0026#34;Rose\u0026#34;)) } private fun doSomething(age:Int, flag:Boolean):String{ return \u0026#34;result\u0026#34; } fun fix(name:String, age:Int = 2){ println(name + \u0026#34; \u0026#34; + age) } 函数没有返回类型时默认返回Unit\n匿名函数 定义时不取名字的函数，称之为匿名函数， 匿名函数通常整体传递给其他函数， 或者从其他函数返回。 匿名函数对Kotlin来说很重要，可以根据需要指定特殊规则，轻松定制标准库里面的内置函数。 val blessingFunction:()-\u0026gt;String blessingFunction = { val holiday = \u0026#34;New Year.\u0026#34; \u0026#34;Happy $holiday\u0026#34; // 隐式返回：默认返回最后一句 } println(blessingFunction()) val blessingFunction:(String)-\u0026gt;String = { name -\u0026gt; val holiday = \u0026#34;New Year.\u0026#34; \u0026#34;$name, Happy $holiday\u0026#34; } println(blessingFunction(\u0026#34;Jack\u0026#34;)) it关键字 定义只有一个参数的匿名函数时， 可以使用it关键字来标识参数名。当需要传入两个值参， it关键字就不能用了\n定义参数是函数的函数 fun main(){ val getDiscountWords = { goodsName:String, hour:Int -\u0026gt; val currentYear = 2024 \u0026#34;${currentYear}年， 双11${goodsName}促销倒计时：$hour 小时\u0026#34; } showOnBoard(\u0026#34;卫生纸\u0026#34;, getDiscountWords) } fun showOnBoard(goodsName:String, getDiscountWords:(String, Int) -\u0026gt; String){ val hour = (1..24).random() println(getDiscountWords(goodsName, hour)) } fun main() { showOnBoard(\u0026#34;卫生纸\u0026#34;) { goodsName: String, hour: Int -\u0026gt; val currentYear = 2024 \u0026#34;${currentYear}年， 双11${goodsName}促销倒计时：$hour 小时\u0026#34; } } private fun showOnBoard(goodsName: String, getDiscountWords: (String, Int) -\u0026gt; String) { val hour = (1..24).random() println(getDiscountWords(goodsName, hour)) } 函数内联 添加inline， 避免多个lambda表达式的内存消耗\n闭包 在Kotlin中，匿名函数能修改并引用定义在自己的作用域之外的变量， 匿名函数引用着定义自身的函数里的变量，Kotlin的lambda就是闭包。 能接收函数或者返回函数的函数又叫做高级函数， 高级函数广泛应用于函数式编程当中。 类型推断 var str:String? = \u0026#34;strawberry\u0026#34; // 可空类型 str = null 使用带let的安全调用 var str: String? = \u0026#34;strawberry\u0026#34; // 可空类型 str = str?.let { // let返回最后一行执行的结果 if (it.isNotBlank()) { it.capitalize() } else { \u0026#34;strawberry\u0026#34; } } println(str) 使用非空断言操作符 !!又称为感叹号操作符， 当变量值为null时， 会抛出KotlinNullPointerException 空合并操作符 字符串操作 subString val index = NAME.indexOf(\u0026#39;\\\u0026#39;\u0026#39;) val str = NAME.substring(0 until index) println(str) split const val NAMES = \u0026#34;Jack, jacky, jason\u0026#34; val (origin, dest, proxy) = NAMES.split(\u0026#34;,\u0026#34;) println(origin) println(dest) println(proxy) replace val str1 = \u0026#34;The United states of American\u0026#34; val str2 = str1.replace(Regex(\u0026#34;[aeiou]\u0026#34;)) { when (it.value) { \u0026#34;a\u0026#34; -\u0026gt; \u0026#34;8\u0026#34; \u0026#34;e\u0026#34; -\u0026gt; \u0026#34;6\u0026#34; \u0026#34;i\u0026#34; -\u0026gt; \u0026#34;9\u0026#34; \u0026#34;o\u0026#34; -\u0026gt; \u0026#34;1\u0026#34; \u0026#34;u\u0026#34; -\u0026gt; \u0026#34;3\u0026#34; else -\u0026gt; it.value } } println(str1) println(str2) 字符串比较 val str1 = \u0026#34;Jason\u0026#34; val str2 = \u0026#34;jason\u0026#34;.capitalize() println(str1 == str2) // 内容 println(str1 === str2) // 是否是同一个引用 字符串遍历 \u0026#34;The people\u0026#39;s Reputation of the Jones\u0026#34;.forEach { print(\u0026#34;$it \u0026#34;) } 数字类型 // val number1:Int = \u0026#34;8.98\u0026#34;.toInt() val number1: Int? = \u0026#34;8.98\u0026#34;.toIntOrNull() println(number1) println(8.63413423.toInt()) println(8.63413423.roundToInt()) println(\u0026#34;%.4f\u0026#34;.format(8.63413423)) apply val file1 = File(\u0026#34;D://test//test.txt\u0026#34;) file1.setReadable(true) file1.setWritable(true) file1.setExecutable(true) val file2 = File(\u0026#34;D://test//test.txt\u0026#34;).apply { setReadable(true) setWritable(true) setExecutable(true) } run fun main() { val file = File(\u0026#34;d://test//test.txt\u0026#34;) val result = file.run { readText().contains(\u0026#34;has\u0026#34;) // 返回执行结果， 并且包含 file.readText() 这样的隐式调用 } println(result) val result2 = \u0026#34;The quick brown fox jumps over the lazy dog\u0026#34; .run(::isLong) .run(::showMessage) // 链式调用， 将上一个返回的结果做为输入 .run(::println) } fun isLong(name:String) = name.length \u0026gt;= 10 fun showMessage(isLong: Boolean):String{ return if(isLong){ \u0026#34;Name is not suitable\u0026#34; }else{ \u0026#34;Name is suitable\u0026#34; } } with val result1 = \u0026#34;The people of world\u0026#34;.run { length \u0026gt;= 10 } val result2 = with(\u0026#34;The people of world\u0026#34;) { length \u0026gt;= 10 } val result3 = with(\u0026#34;The people of world\u0026#34;) { length \u0026gt;= 100 } println(result1) println(result2) println(result3) also val fileConents:List\u0026lt;String\u0026gt; File(\u0026#34;D:\\\\test\\\\test.txt\u0026#34;) .also { println(it.name) // 把接收者作为值参传给lambda， 返回接收者对象 } .also { fileConents = it.readLines() println(fileConents) } takeIf val result = File(\u0026#34;D:\\\\test\\\\test.txt\u0026#34;) .takeIf { it.exists() \u0026amp;\u0026amp; it.canRead() }?.readText() println(result) takeUnless val result = File(\u0026#34;D:\\\\test\\\\test.txt\u0026#34;) .takeUnless { it.isHidden }?.readText() println(result) 集合类型 list val list = listOf(\u0026#34;Jason\u0026#34;, \u0026#34;Jack\u0026#34;, \u0026#34;Jacky\u0026#34;) println(list.getOrElse(3){\u0026#34;what?\u0026#34;}) println(list.getOrNull(3)?: \u0026#34;it is null\u0026#34;) mutableListOf可变列表 val mutableList = mutableListOf(\u0026#34;Java\u0026#34;,\u0026#34;Kotlin\u0026#34;,\u0026#34;C**\u0026#34;) mutableList.add(\u0026#34;Go\u0026#34;) mutableList.remove(\u0026#34;Kotlin\u0026#34;) println(mutableList) val toMutableList = listOf(\u0026#34;Java\u0026#34;, \u0026#34;Kotlin\u0026#34;, \u0026#34;C**\u0026#34;).toMutableList() val toList = mutableListOf(\u0026#34;Java\u0026#34;, \u0026#34;Python\u0026#34;, \u0026#34;ls\u0026#34;).toList() mutator函数 // mutator函数 mutableList += \u0026#34;Jimmy\u0026#34; println(mutableList) mutableList -= \u0026#34;Jimmy\u0026#34; println(mutableList) mutableList.removeIf{ it.contains(\u0026#34;Jack\u0026#34;) } println(mutableList) 遍历 val list = listOf(\u0026#34;Java\u0026#34;, \u0026#34;Kotlin\u0026#34;, \u0026#34;C**\u0026#34;, \u0026#34;Jack\u0026#34;, \u0026#34;Jacky\u0026#34;) for (s in list) { println(s) } list.forEach { println(it) } list.forEachIndexed{ index, item -\u0026gt; println(\u0026#34;$index $item\u0026#34;) } Set \u0026amp; mutableSet val set = setOf(\u0026#34;Jason\u0026#34;, \u0026#34;Jack\u0026#34;, \u0026#34;Jacky\u0026#34;, \u0026#34;Jimmy\u0026#34;) println(set.elementAt(2)) println(set.elementAt(3)) val mutableSet = mutableSetOf(\u0026#34;Jason\u0026#34;, \u0026#34;Java\u0026#34;, \u0026#34;Kotlin\u0026#34;) mutableSet += \u0026#34;Jimmy\u0026#34; mutableSet -= \u0026#34;Jason\u0026#34; println(mutableSet) 数组类型 Kotlin提供各种Array， 虽然是引用类型，但可以编译成Java基本数据类型。\nval intArrayOf = intArrayOf(10, 20, 30) val toIntArray = listOf(10, 20, 30).toIntArray() arrayOf(File(\u0026#34;xxx\u0026#34;), File(\u0026#34;yyy\u0026#34;)) Map集合 val map = mapOf(\u0026#34;Jack\u0026#34; to 20, 1 to \u0026#34;bag\u0026#34;) println(map[\u0026#34;1\u0026#34;]) println(map.get(\u0026#34;Jack\u0026#34;)) println(map.getOrElse(\u0026#34;Rose\u0026#34;) { \u0026#34;Unknown key\u0026#34; }) println(map.getOrDefault(\u0026#34;Rost\u0026#34;, 0)) map.forEach { println(\u0026#34;${it.key} -\u0026gt; ${it.value}\u0026#34;) } map.forEach { t, u -\u0026gt; println(\u0026#34;$t -\u0026gt; $u\u0026#34;) } 类 class Player{ var name = \u0026#34;jack\u0026#34; get() = field.capitalize() set(value){ field = value.trim() } } fun main() { var p = Player() p.name = \u0026#34;rose\u0026#34; // setName println(p.name) } 类的初始化 构造函数的使用\nclass Player ( // 只用一次的变量用下划线开头 _name:String, _age:Int, _isNormal:Boolean ){ var name = _name get() = field.capitalize() set(value){ field = value.trim() } var age = _age get() = field.absoluteValue set(value){ field = value.absoluteValue } var isNormal = _isNormal override fun toString(): String { return \u0026#34;Player(isNormal=$isNormal, age=$age, name=\u0026#39;$name\u0026#39;)\u0026#34; } } fun main() { val p = Player(\u0026#34;Jack\u0026#34;, 10, false) p.name = \u0026#34;Rose\u0026#34; println(p.toString()) } 构造函数：声明时即初始化 class Player2 ( // 只用一次的变量用下划线开头 _name:String, var age:Int, var isNormal:Boolean ){ var name = _name get() = field.capitalize() set(value){ field = value.trim() } override fun toString(): String { return \u0026#34;Player2(age=$age, isNormal=$isNormal, name=\u0026#39;$name\u0026#39;)\u0026#34; } } fun main() { val p = Player(\u0026#34;Jack\u0026#34;, 10, false) p.name = \u0026#34;Rose\u0026#34; println(p.toString()) } 次构造函数 class Player2 ( // 只用一次的变量用下划线开头 _name:String, var age:Int, var isNormal:Boolean ){ var name = _name get() = field.capitalize() set(value){ field = value.trim() } override fun toString(): String { return \u0026#34;Player2(age=$age, isNormal=$isNormal, name=\u0026#39;$name\u0026#39;)\u0026#34; } // 次构造函数， 可以定义多个次构造函数来配置不同的参数组合 constructor(name:String):this(name,0,false) constructor(name:String, age:Int):this(name,0,false){ this.name = name.toUpperCase() } } fun main() { val p = Player(\u0026#34;Jack\u0026#34;, 10, false) p.name = \u0026#34;Rose\u0026#34; println(p.toString()) //Player(isNormal=false, age=10, name=\u0026#39;Rose\u0026#39;) val player2 = Player2(\u0026#34;Rose\u0026#34;) println(player2.toString()) //Player2(age=0, isNormal=false, name=\u0026#39;Rose\u0026#39;) val player3 = Player2(\u0026#34;Rose\u0026#34;, 10) println(player3.toString()) //Player2(age=0, isNormal=false, name=\u0026#39;ROSE\u0026#39;) } 初始化块 init{ require(age \u0026gt; 10){ \u0026#34;age must greater than 10!\u0026#34; } require(name.isNotBlank()){ \u0026#34;name must not blank!\u0026#34; } } 初始化顺序 主构造函数里声明的属性 类级别的属性赋值 init初始化块里的属性赋值和函数调用 次构造函数里的属性赋值和函数调用 延迟初始化 lazy class Player5 ( _name:String ){ var name = _name val config by lazy { // 延迟初始化 loadConfig() } private fun loadConfig():String{ println(\u0026#34;loading...\u0026#34;) return \u0026#34;xxx\u0026#34; } } fun main() { val p = Player5(\u0026#34;test\u0026#34;) Thread.sleep(1000) println(p.config) } 继承 类默认都是封闭的， 要让某个类开放继承，必须使用open关键字修改它。 open class Product( val name: String ) { fun description() = \u0026#34;Product : $name\\n\u0026#34; open fun load() = \u0026#34;Nothing\u0026#34; } class LuxuryProduct : Product( \u0026#34;Luxury product name\u0026#34; ) { override fun load() = \u0026#34;Luxury product load\u0026#34; fun special() = \u0026#34;LuxuryProduct special function\u0026#34; } kotlin超类Any\nprintln(p is Any) 对象 对象声明 open class Player{ open fun load() = \u0026#34;load nothing...\u0026#34; } fun main() { val p = object : Player(){ override fun load(): String { return \u0026#34;anonymous nothing...\u0026#34; } } println(p.load()) } 伴生对象 open class ConfigMap { // 伴生对象 companion object{ private const val PATH = \u0026#34;path.txt\u0026#34; fun load() = File(PATH).readBytes() } } fun main() { // static // 不调用不会实例化，一旦调用则实例化，并且仅实例化一次 ConfigMap.load() } 嵌套类 class Player2{ // 内部类 class Equipment(var name:String){ fun show() = println(\u0026#34;Equipment : ${name}\u0026#34;) } fun battle(){ } } fun main() { val p = Player2() p.battle() Player2.Equipment(\u0026#34;Sharp knife\u0026#34;).show() } 数据类 用data声明的类，会重写 equals 和 hashCode 方法\ndata class Coordinate( var x: Int = 10, var y: Int = 1 ) { val isInBounds = x \u0026gt; 0 \u0026amp;\u0026amp; y \u0026gt; 0 } fun main() { println(Coordinate(1, 2).isInBounds) println(Coordinate(10, 20) == Coordinate(10, 20)) println(Coordinate(10, 20) === Coordinate(10, 20)) } copy data class Student( var _name: String, val age: Int ) { var name = _name var score = 0 private val hobby = \u0026#34;music\u0026#34; val subject: String init { println(\u0026#34;initializing Student $name\u0026#34;) subject = \u0026#34;math\u0026#34; } constructor(_name: String) : this(_name, 10) { score = 10 } override fun toString(): String { return \u0026#34;Student(age=$age, name=\u0026#39;$name\u0026#39;, score=$score, hobby=\u0026#39;$hobby\u0026#39;, subject=\u0026#39;$subject\u0026#39;)\u0026#34; } } fun main() { val student = Student(\u0026#34;John\u0026#34;) val copy = student.copy(\u0026#34;Rose\u0026#34;) println(student) // Student(age=10, name=\u0026#39;John\u0026#39;, score=10, hobby=\u0026#39;music\u0026#39;, subject=\u0026#39;math\u0026#39;) println(copy) // Student(age=10, name=\u0026#39;Rose\u0026#39;, score=0, hobby=\u0026#39;music\u0026#39;, subject=\u0026#39;math\u0026#39;) } 解构声明 class PlayerScore( val experience:Int, val level:Int ){ operator fun component1():Int = experience operator fun component2():Int = level } fun main() { // 数据类天然支持component1, component2 val (x, y) = PlayerScore(10, 20) println(\u0026#34;${x}, $y\u0026#34;) } 运算符重载 如果要将内置运算符应用在自定义类身上， 必须重写运算符函数，告诉编译器该如何操作自定义类。 data class Coordinate2( var x: Int = 10, var y: Int = 1 ) { val isInBounds = x \u0026gt; 0 \u0026amp;\u0026amp; y \u0026gt; 0 operator fun plus(coordinate: Coordinate2): Coordinate2 = Coordinate2(x + coordinate.x, y + coordinate.y) } fun main() { var c1 = Coordinate2(1, 2) val c2 = Coordinate2(3, 4) c1 += c2 println(c1) // Coordinate2(x=4, y=6) } 枚举类 enum class Direction(){ EAST, WEST, SOUTH, NORTH } fun main(){ println(Direction.NORTH) //NORTH println(Direction.EAST is Direction) //true } 密封类 对于更复杂的ADT， 可以使用Kotlin的密封类（sealed class）来实现复杂的定义，密封类可以用来定义一个类似于枚举类的ADT // 密封类 sealed class LicenseStatus2 { // object 单例对象，只有一个实例 object UNQUALIFIED : LicenseStatus2() object LEARNING : LicenseStatus2() class QUALIFIED(val licenseId: String) : LicenseStatus2() } private class Driver2(var status: LicenseStatus2) { fun checkLicense(): String { return when (status) { is LicenseStatus2.UNQUALIFIED -\u0026gt; \u0026#34;没资格\u0026#34; is LicenseStatus2.LEARNING -\u0026gt; \u0026#34;在学\u0026#34; is LicenseStatus2.QUALIFIED -\u0026gt; \u0026#34;有资格, 驾驶证编号： ${(this.status as LicenseStatus2.QUALIFIED).licenseId}\u0026#34; } } } fun main() { println(Driver2(LicenseStatus2.QUALIFIED(\u0026#34;100\u0026#34;)).run { checkLicense() }) } 接口 interface Movable { var maxSpeed: Int var wheels: Int fun move(movable: Movable): String } class Car( _name: String, override var wheels: Int = 4 ) : Movable { override var maxSpeed: Int get() = TODO(\u0026#34;Not yet implemented\u0026#34;) set(value) { 1 } override fun move(movable: Movable): String { TODO(\u0026#34;Not yet implemented\u0026#34;) } } fun main() { } 抽象类 abstract class Gun(val range:Int){ abstract fun pullTrigger():String } class AK47(val price:Int):Gun(range = 100){ override fun pullTrigger(): String { return \u0026#34;Shot\u0026#34; } } fun main() { } 定义泛型类 T (type)\nclass MagicBox\u0026lt;T\u0026gt;(item:T) { private var subject: T = item } class Boy(val name: String, val age: Int) class Dog(val weight: Int) fun main() { val box1 = MagicBox(Boy(\u0026#34;Cute dog\u0026#34;, 1)) val box2 = MagicBox(Dog(1)) } 泛型约束类 class MagicBox\u0026lt;T:Human\u0026gt;(item: T) { var available = false var subject: T = item fun fetch(): T? { return subject.takeIf { available } } // 把元素进行修改 // 魔盒里面是男孩，编程男人 fun \u0026lt;R\u0026gt; fetch(subjectModFunction: (T) -\u0026gt; R): R? { return subjectModFunction(subject).takeIf { available } } } open class Human(val age:Int) class Boy(val name: String, age: Int):Human(age) class Man(private val name: String, age: Int):Human(age) { override fun toString(): String { return \u0026#34;Man(name=\u0026#39;$name\u0026#39;, age=$age)\u0026#34; } } class Dog(val weight: Int) fun main() { val box1 = MagicBox(Boy(\u0026#34;Cute Boy\u0026#34;, 1)) // val box2 = MagicBox(Dog(1)) // box2.available = false // box2.fetch()?.run { // println(\u0026#34;Your find it\u0026#34;) // } box1.available = true box1.fetch()?.run { println(\u0026#34;you find $name\u0026#34;) } val man = box1.fetch { Man(it.name, it.age.plus(10)) } println(man) } vararg关键字与get函数 MagicBox能存放任何类型的Human类型， 但一次只能一个。 class MagicBox\u0026lt;T : Human\u0026gt;(vararg item: T) { var available = false // itme是可变参数, 有多个 // 泛型是可变参数， 必须写out var subject: Array\u0026lt;out T\u0026gt; = item fun fetch(index: Int): T? { return subject[index].takeIf { available } } // 把元素进行修改 // 魔盒里面是男孩，编程男人 fun \u0026lt;R\u0026gt; fetch(index: Int, subjectModFunction: (T) -\u0026gt; R): R? { return subjectModFunction(subject[index]).takeIf { available } } // 可变参数 fun a(vararg a: Int) { } operator fun get(index: Int): T? = subject[index] } open class Human(val age: Int) class Boy(val name: String, age: Int) : Human(age) class Man(private val name: String, age: Int) : Human(age) { override fun toString(): String { return \u0026#34;Man(name=\u0026#39;$name\u0026#39;, age=$age)\u0026#34; } } class Dog(val weight: Int) fun main() { val box1 = MagicBox( Boy(\u0026#34;Cute Boy\u0026#34;, 1), Boy(\u0026#34;Kennem\u0026#34;, 10) ) box1.available = true; box1.fetch(1)?.run { println(\u0026#34;Your find $name\u0026#34;) } val man = box1.fetch(0) { Man(it.name, it.age.plus(10)) } } out out（协变），如果泛型类只将泛型类作为函数的返回（输出）， 那么使用out， 可以称之为生产类/接口，因为它主要用来生产（produce）指定的泛型对象\n子类泛型的对象可以赋值给父类泛型的对象， 用out in（逆变）， 如果泛型类只将泛型类型作为函数的入参（输入），那么使用in，可以称之为消费者类/接口，因为它主要是用来消费（consume）指定的泛型对象。\n父类泛型对象可以赋值给子类泛型对象，用in invariant（不变），如果泛型类既将泛型类型作为函数参数，又将泛型类型作为函数的输出，那么既不用out也不用in。\n//out interface Production\u0026lt;out T\u0026gt; { fun product(): T } //in interface Consumer\u0026lt;in T\u0026gt; { fun consume(item: T) } // 不变 interface ProductionConsumer\u0026lt;T\u0026gt; { fun produce(item: T) fun consume(item: T) } open class Food open class FastFood : Food() class Burger : FastFood() class FoodStore : Production\u0026lt;Food\u0026gt; { override fun product(): Food { println(\u0026#34;Produce food.\u0026#34;) return Food() } } class FastFoodStore : Production\u0026lt;FastFood\u0026gt; { override fun product(): FastFood { println(\u0026#34;Produce FastFood.\u0026#34;) return FastFood() } } class BurgerStore : Production\u0026lt;Burger\u0026gt; { override fun product(): Burger { println(\u0026#34;Produce FastFood.\u0026#34;) return Burger() } } // 消费者 class Everybody : Consumer\u0026lt;Food\u0026gt; { override fun consume(item: Food) { println(\u0026#34;Eat food.\u0026#34;) } } class ModernPeople : Consumer\u0026lt;FastFood\u0026gt; { override fun consume(item: FastFood) { println(\u0026#34;Eat fastFood.\u0026#34;) } } class American : Consumer\u0026lt;Burger\u0026gt; { override fun consume(item: Burger) { println(\u0026#34;Eat burger food.\u0026#34;) } } fun main() { // 子类泛型的对象可以赋值给父类泛型的对象， 用out val production1: Production\u0026lt;Food\u0026gt; = FoodStore() val production2: Production\u0026lt;Food\u0026gt; = FastFoodStore() val production3: Production\u0026lt;Food\u0026gt; = BurgerStore() // 父类泛型对象可以赋值给子类泛型对象，用in val consumer1: Consumer\u0026lt;Burger\u0026gt; = Everybody() // 这里Everybody : Consumer\u0026lt;Food\u0026gt; 可以赋值为 Consumer\u0026lt;Burger\u0026gt; consumer1.consume(Burger()) val consumer2: Consumer\u0026lt;Burger\u0026gt; = ModernPeople() val consumer3: Consumer\u0026lt;Burger\u0026gt; = American() } reified reified关键字能够检查泛型参数类型 class MagicBox\u0026lt;T : Human\u0026gt;(vararg item: T) { // 随机产生一个对象，如果不是指定类型的对象，就通过backup函数生成一个指定类型的对象 // fun \u0026lt;T\u0026gt; randomOrBackup(backup: () -\u0026gt; T): T { // val items = listOf( // Boy(\u0026#34;Jack\u0026#34;, 20), // Man(\u0026#34;John\u0026#34;, 20) // ) // val random = items.shuffled().first() // return if(random is T){ // random // }else{ // backup() // } // } inline fun \u0026lt;reified T\u0026gt; randomOrBackup(backup: () -\u0026gt; T): T { val items = listOf( Boy(\u0026#34;Jack\u0026#34;, 20), Man(\u0026#34;John\u0026#34;, 20) ) val random = items.shuffled().first() return if(random is T){ println(random) random }else{ backup() } } } open class Human(val age: Int) class Boy(val name: String, age: Int) : Human(age){ override fun toString(): String { return \u0026#34;Boy(name=\u0026#39;$name\u0026#39;)\u0026#34; } } class Man(private val name: String, age: Int) : Human(age) { override fun toString(): String { return \u0026#34;Man(name=\u0026#39;$name\u0026#39;, age=$age)\u0026#34; } } class Dog(val weight: Int) fun main() { val box1 = MagicBox\u0026lt;Human\u0026gt;() // 由backup函数推断出T的类型 val subject = box1.randomOrBackup { Boy(\u0026#34;Jimmy\u0026#34;, 29) } println(subject) } 扩展函数 定义扩展函数 扩展可以在不直接修改类定义的情况下增加类功能， 扩展可以用于自定义类，也可以用于如List， String， 以及Kotlin标准库里的其他类。 fun String.addExt(amount:Int = 1) = this + \u0026#34;!\u0026#34;.repeat(amount) fun String.easyPrint():String{ println(this) return this } fun main() { println(\u0026#34;abc\u0026#34;.addExt(10)) //abc!!!!!!!!!! \u0026#34;abc\u0026#34;.easyPrint() \u0026#34;abc\u0026#34;.easyPrint().addExt(3).easyPrint() } 泛型扩展函数 fun String.addExt(amount: Int = 1) = this + \u0026#34;!\u0026#34;.repeat(amount) fun \u0026lt;T\u0026gt; T.easyPrint(): T { println(this) return this } fun main() { println(\u0026#34;abc\u0026#34;.addExt(10)) //abc!!!!!!!!!! \u0026#34;abc\u0026#34;.easyPrint() \u0026#34;abc\u0026#34;.easyPrint().addExt(3).easyPrint() 3.14.easyPrint() } 扩展属性 给String添加一个统计元音字母个数的属性\nval String.numVowels get() = count{ \u0026#34;aeiou\u0026#34;.contains(it) } private fun \u0026lt;T\u0026gt; T.easyPrint():T{ println(this) return this } fun main() { println(\u0026#34;The people\u0026#39;s Republic of China\u0026#34;.numVowels) } 可空类扩展 fun String?.printWithDefault(default:String) = print(this ?: default) fun main() { // val nullableString:String? = null val nullableString:String? = \u0026#34;null\u0026#34; nullableString.printWithDefault(\u0026#34;xxx\u0026#34;) } infix关键字 infix fun String?.printWithDefault(default:String) = print(this ?: default) fun main() { val nullableString:String? = \u0026#34;null\u0026#34; nullableString printWithDefault(\u0026#34;xxx\u0026#34;) // 实现效果 \u0026#34;jack\u0026#34;.to(18) \u0026#34;jack\u0026#34; to 10 } 扩展文件 fun \u0026lt;T\u0026gt; Iterable\u0026lt;T\u0026gt;.randomTake(): T = this.shuffled().first() 在其他文件中可以使用这个扩展文件内的函数，并且可以起别名\nimport com.showguan.extension.randomTake as randomizer fun main() { val list = listOf(\u0026#34;Jason\u0026#34;, \u0026#34;Jack\u0026#34;, \u0026#34;Tom\u0026#34;) val set = list.toSet() println(list.randomizer()) } 带接收者的函数字面量 apply 实现\n@kotlin.internal.InlineOnly public inline fun \u0026lt;T\u0026gt; T.apply(block: T.() -\u0026gt; Unit): T { contract { callsInPlace(block, InvocationKind.EXACTLY_ONCE) } block() return this } public inline fun File.apply(block: File.() -\u0026gt; Unit): File { block() return this } fun main() { val file = File(\u0026#34;xx\u0026#34;).apply { setReadable(true) setWritable(true) } // 详细实现过程 fun File.ext(): Unit { setReadable(true) } val block = File::ext File(\u0026#34;xx\u0026#34;).apply(block) } DSL（Domain-Specific Language，领域特定语言） interface Element class HTML { private val elements = mutableListOf\u0026lt;Element\u0026gt;() fun body(init: Body.() -\u0026gt; Unit) { val body = Body() body.init() elements.add(body) } override fun toString(): String { return elements.joinToString(\u0026#34;\u0026#34;) } } class TextElement(val tag: String, val text: String) : Element { override fun toString() = \u0026#34;\u0026lt;$tag\u0026gt;$text\u0026lt;/$tag\u0026gt;\u0026#34; } class Body : Element { private val elements = mutableListOf\u0026lt;Element\u0026gt;() fun h1(text: String) { elements.add(TextElement(\u0026#34;h1\u0026#34;, text)) } fun h2(text: String) { elements.add(TextElement(\u0026#34;h2\u0026#34;, text)) } fun h3(text: String) { elements.add(TextElement(\u0026#34;h2\u0026#34;, text)) } fun p(text: String) { elements.add(TextElement(\u0026#34;p\u0026#34;, text)) } override fun toString(): String { return TextElement(\u0026#34;body\u0026#34;, elements.joinToString(\u0026#34;\u0026#34;)).toString() // return \u0026#34;\u0026lt;body\u0026gt;${elements.joinToString(\u0026#34;\u0026#34;)}\u0026lt;/body\u0026gt;\u0026#34; } } fun html(init: HTML.() -\u0026gt; Unit): HTML { val html = HTML() html.init() return html } fun main() { // 使用DSL创建HTML结构 // val document = html { // body { // h1(\u0026#34;Kotlin DSL\u0026#34;) // p(\u0026#34;This is a paragraph.\u0026#34;) // } // } val document = html { body { h1(\u0026#34;这里是一级标题\u0026#34;) h2(\u0026#34;这里是二级标题\u0026#34;) p(\u0026#34;这里是第一段\u0026#34;) p(\u0026#34;这里是第二段\u0026#34;) } } println(document) } 函数式编程 编程范式\n一个函数式应用通常由三大类函数构成：变换transform, 过滤filter, 合并combine。每类函数都针对集合数据类型，目标是产生一个最终结果。\n函数式编程范式支持的设计理念就是不可变数据的副本在链上的函数间传递\nmap fun main() { val animals = listOf(\u0026#34;zebra\u0026#34;, \u0026#34;pig\u0026#34;, \u0026#34;tiger\u0026#34;, \u0026#34;giraffe\u0026#34;, \u0026#34;rat\u0026#34;, \u0026#34;cat\u0026#34;) val map = animals .map { animal -\u0026gt; \u0026#34;A baby $animal\u0026#34; } .map { baby -\u0026gt; \u0026#34;$baby, with the cutest little tail ever!\u0026#34; } var animalsLength = animals.map { it.length } println(animals) println(map) println(animalsLength) } flatMap fun main() { val list = listOf(listOf(1, 2, 3), listOf(4, 5, 6), listOf(7, 8, 9)).flatMap { it } println(list) //[1, 2, 3, 4, 5, 6, 7, 8, 9] } filter fun main() { val list = List(100) { Random.nextInt(0, 1001) } println(list) val primes = list.filter { number -\u0026gt; (2 until number).map { number % it } .none { it == 0 } // 没有一个结果是等于0的 } println(primes) } zip 合并函数来合并两个集合， 返回一个包含键值对的新集合\nfun main() { val employees = listOf(\u0026#34;Jack\u0026#34;, \u0026#34;Jason\u0026#34;, \u0026#34;Tommy\u0026#34;) val shirtSize = listOf(\u0026#34;large\u0026#34;, \u0026#34;xl-large\u0026#34;, \u0026#34;medium\u0026#34;) val employeesSizes = employees.zip(shirtSize).toMap() println(employeesSizes) } fold 接收一个初始累加器值，随后会根据匿名函数的结果更新\nfun main() { val employees = listOf(\u0026#34;Jack\u0026#34;, \u0026#34;Jason\u0026#34;, \u0026#34;Tommy\u0026#34;) val shirtSize = listOf(\u0026#34;large\u0026#34;, \u0026#34;xl-large\u0026#34;, \u0026#34;medium\u0026#34;) val fold = listOf(1, 2, 34, 4).fold(0) { accumulator, number -\u0026gt; println(\u0026#34;Accumulator value : \u0026#34; + accumulator) accumulator + (number * 3) } /** * Accumulator value : 0 * Accumulator value : 3 * Accumulator value : 9 * Accumulator value : 111 */ println(\u0026#34;Final value : \u0026#34; + fold) //Final value : 123 } 函数式编程的优点：\n累加变量都是隐式定义的 函数运算结果会自动赋值给累加变量，降低了代码出错的机会 执行新任务的函数很容易添加到函数调用链上，因为他们都兼容Iterable类型 序列 Kotlin内有一个内置惰性集合类型叫序列（Sequence）， 序列不会索引排序它的内容，也不记录元素数目，在使用一个序列时，序列里的值可能有无限多，因为某个数据源能产生无限多个元素。\nfun Int.isPrime():Boolean{ (2 until this).map { if(this % it == 0){ return false } } return true } fun main() { val filter = (2..10000).toList().filter { it.isPrime() }.take(1000) println(filter) val take = generateSequence(2) { value -\u0026gt; value + 1 }.filter { it.isPrime() }.take(1000) println(take.toList()) } 互操作性与可空性 Java文件 Jhava.java public class Jhava { public String utterGreeting(){ return \u0026#34;HELLO!\u0026#34;; } @Nullable public String determineFriendshipLevel(){ return null; } } Hello.kt fun main() { val adversary = Jhava() println((adversary.utterGreeting())) val level = adversary.determineFriendshipLevel() // 防止为空 println(level?.toLowerCase()) } 类型映射 代码运行时，所有的映射类型都会重新映射回对应的Java类型\n用kotlin获取java中变量的类型\njava:\npublic Integer x = 100; kotlin:\nprintln(adversary.x.javaClass) //class java.lang.Integer 属性访问 直接访问即可，实际上使用的还是get/set方法\n@JvmName 通过 @file:JvmName(name = \u0026quot;Hero\u0026quot;)来自定义需要引用的名称\nkotlin:\n@file:JvmName(name = \u0026#34;Hero\u0026#34;) // 顶部 fun makeProclamation() = \u0026#34;Greeting, beast!\u0026#34; java：\nSystem.out.println(Hero.makeProclamation()); @JvmField kotlin:\nclass Spellbook { @JvmField val spells = listOf(\u0026#34;Magic Ms. L\u0026#34;, \u0026#34;Lay on Hans\u0026#34;) } Java:\nSpellbook spellbook = new Spellbook(); System.out.println(spellbook); //com.showguan.Spellbook@4edde6e5 for (String spell : spellbook.spells) { System.out.println(spell); } /* Magic Ms. L Lay on Hans */ @JvmOverloads 自动重载\n@JvmOverloads fun handOverFood(leftHand:String = \u0026#34;berries\u0026#34;, rightHand:String = \u0026#34;beef\u0026#34;){ println(\u0026#34;Your right hand is ${rightHand}, left hand is $leftHand\u0026#34;) } Hero.handOverFood(\u0026#34;apple\u0026#34;); Hero.handOverFood(\u0026#34;apple\u0026#34;, \u0026#34;banana\u0026#34;); @JvmStatic class Spellbook { @JvmField val spells = listOf(\u0026#34;Magic Ms. L\u0026#34;, \u0026#34;Lay on Hans\u0026#34;) companion object { @JvmField val MAX_SPELL_COUNT = 5 @JvmStatic fun getSpellbookGreeting() = \u0026#34;I am the Great Grimoire\u0026#34; } } // int maxSpellCount = Spellbook.Companion.getMAX_SPELL_COUNT(); //静态调用 int maxSpellCount = Spellbook.MAX_SPELL_COUNT; // String spellbookGreeting = Spellbook.Companion.getSpellbookGreeting(); //静态调用 String spellbookGreeting = Spellbook.getSpellbookGreeting(); @Throws kotlin中抛出异常\n@Throws(IOException::class) fun acceptApology(){ throw IOException() } Java中处理异常\ntry { Hero.acceptApology(); } catch (IOException e) { System.out.println(\u0026#34;Caught!\u0026#34;); } 函数类型操作 kotlin:\nval translator = { utterance:String -\u0026gt; println(utterance.toLowerCase().capitalize()) } Java:\nFunction1\u0026lt;String, Unit\u0026gt; translator = Hero.getTranslator(); translator.invoke(\u0026#34;true\u0026#34;); Function1 代表有1个参数， 同理Function2代表有2个参数。\n","permalink":"https://kennems.github.io/posts/tech/kotlin%E5%9F%BA%E7%A1%80/","summary":"Kotlin基础 val \u0026amp; var const 编译时常量只能在函数之外定义，因为编译时常量必须在编译时赋值， 而函数都是在运行时才调用， 函数内的变量也是在运行时赋值","title":"Kotlin基础"},{"content":"第十二天笔记 SW 屏幕适配\nHandler实现通信。\n代码可维护，精简\n","permalink":"https://kennems.github.io/posts/tech/%E7%AC%AC%E5%8D%81%E4%BA%8C%E5%A4%A9%E7%AC%94%E8%AE%B0/","summary":"第十二天笔记 SW 屏幕适配 Handler实现通信。 代码可维护，精简","title":"训练营第十二天笔记"},{"content":"第十一天笔记 Kotlin 讲义总结 1. 包的定义与导入 1) 包的声明\n包的声明在代码文件的开头，格式为 package 包名。 包名是工程根目录下的子目录，如 com.jetbrains。 在根目录下创建 com.jetbrains 包，并在此包下创建 Demo1.kt 文件，文件第一行声明包名：package com.jetbrains。 2) 包的导入\n包的导入格式为 import 资源全名。 在 Demo1.kt 文件中添加 demo1 函数，函数全名为 com.jetbrains.demo1。 在 Main.kt 文件中导入并使用 com.jetbrains.demo1： import com.jetbrains.demo1 fun main(args: Array\u0026lt;String\u0026gt;) { demo1() } Kotlin 默认导入一些包，无需手动导入： kotlin.* kotlin.annotation.* kotlin.collections.* kotlin.comparisons.* kotlin.io.* kotlin.ranges.* kotlin.sequences.* kotlin.text.* 2. 程序入口 每个 Kotlin 程序都有一个执行入口，在每个 Kotlin 文件中，main 函数是执行入口： fun main() { println(\u0026#34;Hello world!\u0026#34;) } main 函数可以接收可变数量的字符串参数： fun main(args: Array\u0026lt;String\u0026gt;) { println(args.contentToString()) } 在命令行中运行程序并传递参数： $ kotlin MainKt a b c 在 IDEA 中直接运行时可以在输出目录下找到编译后的 MainKt.class 文件，并手动执行。 3. 标准输入输出 标准输出\nprint 打印内容到标准输出，不换行。 println 打印内容到标准输出并换行。 print(\u0026#34;Hello, \u0026#34;) print(\u0026#34;World!\u0026#34;) println(\u0026#34;Hello, World!\u0026#34;) println(123) println(3.14) 标准输入\nreadln() 读取一行输入，返回 String 类型。 val value = readln() 使用 toInt() 等方法将输入转换为其他基本数据类型： val intValue = readln().toInt() val longValue = readln().toLong() val doubleValue = readln().toDouble() 如果使用 Kotlin 1.6 之前的版本，需使用 readLine()!!： val value = readLine()!! 使用 split 方法读取多个输入数据，例如空格分割： val (a, b) = readln().split(\u0026#34; \u0026#34;) 4. 函数 函数定义\n使用关键字 fun 定义函数： fun sum(a: Int, b: Int): Int { return a + b } Kotlin 支持函数的表达式形式，返回值可以自动推断： fun sum(a: Int, b: Int) = a + b 返回 Unit 类型\n如果函数不返回任何有意义的值，可以用 Unit 关键字： fun printSum(a: Int, b: Int): Unit { println(\u0026#34;$a 与 $b 的和为: ${a + b}\u0026#34;) } Unit 类型可以省略： fun printSum(a: Int, b: Int) { println(\u0026#34;$a 与 $b 的和为: ${a + b}\u0026#34;) } 参数默认值\n函数参数可以有默认值： fun sum(a: Int, b: Int = 0): Int { return a + b } 4. 函数 函数调用\n可以在其他函数中调用函数，例如在 main 函数中调用 sum 函数：\nfun main() { val res = sum(1, 2) println(res) } 区别不同函数可以使用函数名和参数列表来确定：\nfun sum(a: Int): Int { return a } fun sum(a: Int, b: Int): Int { return a + b } fun printSum(a: Int, b: Int): Unit { println(a + b) } 函数调用示例：\nfun main() { val a = sum(1) println(a) val b = sum(1, 2) println(b) printSum(1, 2) } 函数的调用会涉及到入栈、出栈操作，遵循先入后出的原则。\n5. 变量 使用 val 关键字定义只读变量\n只读变量赋值后不可更改，但可以延迟初始化：\nfun main() { val a: Int = 1 // 立即赋值 val b = 2 // 自动推断类型 val c: Int // 提供初始值前，先声明类型 c = 3 // 延后初始化 println(\u0026#34;a = $a, b = $b, c = $c\u0026#34;) } 使用 var 关键字定义可变变量\n可变变量可以重新赋值：\nfun main() { var a = 1 a = 2 println(\u0026#34;a = $a\u0026#34;) } val 等价于 Java 的 private final 变量，var 等价于 private 变量。\n官方推荐优先使用 val 定义变量，避免副作用。\n6. 基本数据类型 数值类型 (Number)\nKotlin 的数值类型分为两种：整数类型 (Integer types) 和浮点类型 (Floating-point types)。 类型 大小 最小值 最大值 Byte 8bits(1Byte) -128 127 Short 16bits(2Byte) -32768 32767 Int 32bits(4Byte) -2,147,483,648 (-2^31) 2,147,483,647 (2^31-1) Long 64bits(8Byte) -9,223,372,036,854,775,808 (-2^63) 9,223,372,036,854,775,807 (2^63-1) 浮点类型 Kotlin 提供两种浮点类型：Float 和 Double。\n类型 大小 有效位 指数位 小数位数 Float 32bits(4Byte) 24 8 6-7 Double 64bits(8Byte) 53 11 15-16 这些类型都继承自 Number 类。\n整数类型 在 Kotlin 中，整数类型的变量初始化时，如果显式指定数据类型，编译器会自动推断：\n如果值在 Int 类型范围内，默认为 Int 类型。 如果超过 Int 类型范围，自动转换为 Long 类型。 例如：\nval int = 1 // Int类型 val long = 2147483648 // Long类型 println(long is Long) // true 可以通过添加后缀 L 显式指定 Long 类型：\nval long = 2147483648L // Long类型 默认情况下，变量类型为 Int，可以通过显式声明指定其他类型：\nval byte: Byte = 1 // Byte类型 如果变量值超出类型限制，编译器会报错。\n无符号整型 Kotlin 提供了无符号整数类型：\n类型 数据范围 UByte 0-255 UShort 0-65535 UInt 0-2^32-1 ULong 0-2^64-1 浮点型变量 初始化浮点型变量时，未显式指定类型默认为 Double。可以通过添加后缀 F 指定为 Float：\nval double = 1.0 // Double类型 val float = 1.0f // Float类型 如果显式指定浮点类型却赋值为整数，编译器会报错。\nJVM 中的数字表示 在 Kotlin 中，== 用于比较数值，=== 用于比较对象引用。\n对于可空的数字引用：\nval a = 128 val b: Int? = a val c: Int? = a println(b == c) // true println(b === c) // false 当值在 -128 到 127 范围内时，对象引用相同：\nval a = 127 val b: Int? = a val c: Int? = a println(b === c) // true 类型转换 Kotlin 提供类型转换函数如 toInt(), toDouble() 等，如 sqrt() 函数需要传入浮点型：\nval num = 16.toDouble() println(sqrt(num)) 2. 布尔类型 布尔类型的值只有 true 和 false 两种，布尔值可以为空。\nval a: Boolean = true val b = false val c: Boolean? = null println(a \u0026amp;\u0026amp; b) // false println(a || b) // true 3. 字符类型 与 Java 不同，Kotlin 中字符类型不属于数值类型，不能与数字进行操作。\nval a: Char = \u0026#39;a\u0026#39; val b = \u0026#39;b\u0026#39; val c = \u0026#39;\\n\u0026#39; print(a) print(c) print(b) 可以通过 code 属性获取字符的 ASCII 编码。\nval a = \u0026#39;a\u0026#39; println(a.code) // 97 4. 字符串类型 字符串类型用 \u0026quot;\u0026quot; 表示。\nval s: String = \u0026#34;I\u0026#39;m a coder\u0026#34; println(s) 可以用 in 关键字判断字符是否出现在字符串中，也可以通过该关键字遍历字符串。\nval c = \u0026#39;I\u0026#39; val s: String = \u0026#34;I\u0026#39;m a coder\u0026#34; println(c in s) // true for (c in s) { println(c) } 可以通过 uppercase() 方法将字符串全转换为大写。\nprintln(\u0026#34;abcd\u0026#34;.uppercase()) // ABCD 可以通过 + 来连接字符串。\nval a = \u0026#34;abc\u0026#34; val b = a + \u0026#34;def\u0026#34; println(b) 可以通过 \u0026quot;\u0026quot;\u0026quot; \u0026quot;\u0026quot;\u0026quot; 来使用原始字符串，它不会处理转义符，可以包含换行符和任意字符，可以通过 trimMargin() 去掉前导空格。\nval s = \u0026#34;\u0026#34;\u0026#34; #include \u0026lt;iostream\u0026gt; using namespace std; int main() { cout \u0026lt;\u0026lt; \u0026#34;Hello, World!\u0026#34; } \u0026#34;\u0026#34;\u0026#34;.trimMargin() println(s) 字符串模板：\nval i = 1 println(\u0026#34;i = $i\u0026#34;) // i = 1 val s = \u0026#34;abc\u0026#34; println(\u0026#34;s.length = ${s.length}\u0026#34;) // s.length = 3 5. 数组类型 在 Kotlin 中，数组由 Array 类表示。\n数组的定义可以通过 arrayOf() 或者 Array 构造函数方式。\nval a: Array\u0026lt;String\u0026gt; = arrayOf(\u0026#34;a\u0026#34;, \u0026#34;b\u0026#34;, \u0026#34;c\u0026#34;) val b: Array\u0026lt;Int\u0026gt; = arrayOf(1, 2, 3) 可以通过 forEach() 方法遍历数组。\na.forEach { println(it) } 数组类有 size 属性，可以通过它得到数组的长度。\n6. 任意类型 Kotlin 中的 Any 类是所有非空类型的超类，与 Java 中的 Object 类相似。\n7. 类型的检查和强制转换 类型检查：使用 is 关键字进行类型检查。\nval s = \u0026#34;Hello\u0026#34; println(s is String) // true 不安全类型转换：使用 as 关键字进行强制转换，如果转换失败会抛出异常。\nval y = null val x: String = y as String // 抛出异常 安全类型转换：使用 as? 关键字进行安全类型转换，转换失败时返回 null 而不会抛出异常。\nval y = null val x: String? = y as? String println(x) // null 8. 条件判断、循环语句 if 判断条件 基本形式：\nval a = 1 val b = 2 var max = a if (a \u0026gt; b) { max = a } else { max = b } 表达式形式：\nval a = 1 val b = 2 val max = if (a \u0026gt; b) a else b 块中的表达式：\nval a = 1 val b = 2 val max = if (a \u0026gt; b) { println(a) a } else { println(b) b } 与 in 关键字搭配使用：\nif (1 in 1..10) { println(\u0026#34;Yes\u0026#34;) } else { println(\u0026#34;No\u0026#34;) } when 表达式 基本用法：类似于 switch，但功能更强大。\nval x: Int = 1 when (x) { 1 -\u0026gt; println(1) 2 -\u0026gt; println(2) else -\u0026gt; println(\u0026#34;No condition matched\u0026#34;) } 多值匹配：\nwhen (x) { 0, 1 -\u0026gt; println(\u0026#34;x is 0 or 1\u0026#34;) else -\u0026gt; println(\u0026#34;x is neither 0 nor 1\u0026#34;) } when 表达式 简单匹配：\nval x: Int = 1 when (x) { 1, 2 -\u0026gt; println(\u0026#34;1 or 2\u0026#34;) else -\u0026gt; println(\u0026#34;No conditions matched\u0026#34;) } 传入函数，匹配函数的返回值：\nfun getNum(x: Int) = x * 2 fun main() { when (getNum(2)) { 2 -\u0026gt; println(2) 4 -\u0026gt; println(4) } } 使用 is 和 in 关键字：\nfun getNum(x: Int) = x * 2 fun main() { when (getNum(2)) { in 1..2 -\u0026gt; println(\u0026#34;1..2\u0026#34;) } } 循环语句 for 循环：\nfor (i in 1..10) { println(i) // 1 到 10 } for (i in 0..6 step 2) { println(i) // 0, 2, 4, 6 } for (i in 6 downTo 0 step 2) { println(i) // 6, 4, 2, 0 } 遍历 Array 对象：\nval array: Array\u0026lt;Int\u0026gt; = arrayOf(1, 2, 3, 4) for (i in array) { println(i) } 通过索引遍历：\nval array: Array\u0026lt;Int\u0026gt; = arrayOf(1, 2, 3, 4) for (i in array.indices) { println(array[i]) } 使用 withIndex：\nval array: Array\u0026lt;Int\u0026gt; = arrayOf(1, 2, 3, 4) for ((index, value) in array.withIndex()) { println(\u0026#34;index: $index, value: $value\u0026#34;) } 使用 break 和 continue：\nfor (i in array.withIndex()) { if (i == 2) break // 终止循环 if (i == 1) continue // 跳过本次循环 } while 循环 基本用法：\nvar x = 3 while (x \u0026gt; 0) { println(x) x-- } var y = 3 do { println(y) y-- } while (y \u0026gt; 0) 面向对象 特殊语法糖 class DetailActivity : AppCompatActivity() { companion object { const val EXTRA_POSITION = \u0026#34;position\u0026#34; } override fun onCreate(savedInstanceState: Bundle?) { super.onCreate(savedInstanceState) setContentView(R.layout.activity_detail) val pos = intent.getIntExtra(EXTRA_POSITION, -1) val textView = findViewById\u0026lt;TextView\u0026gt;(R.id.text) val imageView = findViewById\u0026lt;ImageView\u0026gt;(R.id.image) val likeView = findViewById\u0026lt;View\u0026gt;(R.id.like) when (val item = ItemDataManager.items[pos]) { is Item.TextItem -\u0026gt; { textView.text = item.text textView.visibility = View.VISIBLE imageView.visibility = View.GONE likeView.run { isSelected = item.like setOnClickListener { item.like = !item.like isSelected = item.like } } } is Item.ImageItem -\u0026gt; { imageView.setImageResource(item.imageResId) imageView.visibility = View.VISIBLE textView.visibility = View.GONE likeView.run { isSelected = item.like setOnClickListener { item.like = !item.like isSelected = item.like } } } } } } class MyAdapter( private val items: List\u0026lt;Item\u0026gt;, private val onClick: (Int) -\u0026gt; Unit ) : RecyclerView.Adapter\u0026lt;RecyclerView.ViewHolder\u0026gt;() { class TextViewHolder(itemView: View) : RecyclerView.ViewHolder(itemView) { val textView: TextView? = itemView.findViewById(R.id.text) val likeView: View? = itemView.findViewById(R.id.like) } class ImageViewHolder(itemView: View) : RecyclerView.ViewHolder(itemView) { val imageView: ImageView? = itemView.findViewById(R.id.image) val likeView: View? = itemView.findViewById(R.id.like) } override fun onCreateViewHolder(parent: ViewGroup, viewType: Int): RecyclerView.ViewHolder { return when (viewType) { TEXT_TYPE -\u0026gt; { val view = LayoutInflater.from(parent.context).inflate(R.layout.item_text, parent, false) TextViewHolder(view) } IMAGE_TYPE -\u0026gt; { val view = LayoutInflater.from(parent.context).inflate(R.layout.item_image, parent, false) ImageViewHolder(view) } else -\u0026gt; { val view = LayoutInflater.from(parent.context).inflate(R.layout.item_text, parent, false) TextViewHolder(view) } } } override fun onBindViewHolder(holder: RecyclerView.ViewHolder, position: Int) { holder.itemView.setOnClickListener { onClick(position) } when (val item = items[position]) { is Item.TextItem -\u0026gt; { val textHolder = holder as TextViewHolder textHolder.textView?.text = item.text textHolder.likeView?.run { isSelected = item.like setOnClickListener { item.like = !item.like isSelected = item.like } } } is Item.ImageItem -\u0026gt; { val imageHolder = holder as ImageViewHolder imageHolder.imageView?.setImageResource(item.imageResId) imageHolder.likeView?.run { isSelected = item.like setOnClickListener { item.like = !item.like isSelected = item.like } } } } } override fun getItemCount() = items.size override fun getItemViewType(position: Int) = when (items[position]) { is Item.TextItem -\u0026gt; TEXT_TYPE is Item.ImageItem -\u0026gt; IMAGE_TYPE } companion object { private const val TEXT_TYPE = 1 private const val IMAGE_TYPE = 2 } } ","permalink":"https://kennems.github.io/posts/tech/%E7%AC%AC%E5%8D%81%E4%B8%80%E5%A4%A9%E7%AC%94%E8%AE%B0/","summary":"第十一天笔记 Kotlin 讲义总结 1. 包的定义与导入 1) 包的声明 包的声明在代码文件的开头，格式为 package 包名。 包名是工程根目录下的子目录，如 com.jetbrai","title":"训练营第十一天笔记"},{"content":"第十天笔记 内存泄漏 1. Java垃圾回收机制 1.1 什么是垃圾回收 垃圾回收（GC）是由Java虚拟机（JVM）垃圾回收器提供的一种内存回收机制。 当内存空间或内存占用过高时，系统会回收那些没有引用的对象。 JVM内存模型 运行时数据区域：包括方法区、堆、栈、本地方法栈和程序计数器等。 堆内存： 新生代（Young Generation）：分为Eden区和两个Survivor区（S0、S1）。 老年代（Old Generation）。 方法区（MetaSpace）：存储类元数据、方法信息等。 1.2 判断对象是否是垃圾的算法 1.2.1 引用计数算法 对象被创建后，系统为其初始化引用计数器。 每当对象被引用时，计数器加1，引用失效时，计数器减1。 当计数器为0时，对象不再被引用，可以进行回收。 优点：判断简单，效率高。 缺点：无法避免循环引用。 1.2.2 可达性分析法 从GC Roots出发，逐步遍历到所有可达的对象。 这些对象称为可达对象，不可达的对象则被标记为垃圾，需要回收。 GC Roots包括的对象： 虚拟机栈中引用的对象（栈帧中的本地变量表）。 方法区中类静态属性引用的对象。 方法区中常量引用的对象。 本地方法栈中JNI（Native方法）引用的对象。 Java中的对象引用 Java中的对象引用主要分为四种类型：\n1. 强引用 (Strong Reference) 定义: 例如 Object obj = new Object()，这是Java程序中最常见的引用类型。 特点: 强引用是不可回收的资源，垃圾回收器不会回收它。当内存空间不足时，JVM宁愿抛出 OutOfMemoryError 错误，也不会回收强引用的对象。 2. 软引用 (Soft Reference) 定义: 软引用是一种相对强引用有所弱化的引用。 特点: 可以让对象避免一些垃圾收集。只有当JVM认为内存不足时，才会尝试回收软引用指向的对象。在抛出 OutOfMemoryError 之前，JVM会确保回收软引用的对象。软引用通常用于实现内存敏感的缓存，如果有足够内存，软引用对象会被保留。 3. 弱引用 (Weak Reference) 定义: 弱引用的强度比软引用更弱。 特点: 无论内存是否充足，当JVM进行垃圾回收时，都会回收被弱引用关联的对象。 4. 虚引用 (Phantom Reference) 定义: 虚引用也称为幽灵引用或幻象引用，是最弱的一种引用关系。 特点: 虚引用的存在不会对对象的生命周期构成影响，无法通过虚引用获得对象实例。唯一的目的是在对象被垃圾回收器回收时收到系统通知。 图示总结 强引用: 只有在没有空闲内存时才会被回收。 软引用: 在内存不足时会被回收。 弱引用: 在垃圾回收检测时立即回收。 虚引用: 不会直接影响对象生命周期，但能在对象被回收时收到通知。 这个图示展示了不同引用类型如何与垃圾回收器交互，以及在垃圾回收后的结果。\n初识ANR 主线程执行耗时操作 当主线程执行耗时操作（如大量计算、循环、递归、IO操作等）会导致ANR。\n示例代码:\nmBind.textView.setOnClickListener(new View.OnClickListener() { @Override public void onClick(View v) { while (true) { Log.i(\u0026#34;TAG\u0026#34;, \u0026#34;主线程执行耗时操作\u0026#34;); try { // 执行耗时操作 Thread.sleep(500); } catch (Exception e) { e.printStackTrace(); } } } }); 死锁 当对象锁被其他线程持有，主线程长时间无法获取当前对象锁，会导致ANR。\n示例代码:\npublic class MainThreadAnrActivity extends BaseActivity\u0026lt;ActivityHandlerBinding\u0026gt; { private final Object object = new Object(); private final String TAG = MainThreadAnrActivity.class.getSimpleName(); private boolean taskComplete = false; @Override protected void bindListener() { super.bindListener(); mBind.textView.setOnClickListener(new View.OnClickListener() { @Override public void onClick(View v) { // 需要使用子线程执行的结果 synchronized (object) { Log.i(TAG, \u0026#34;死锁导致ANR \u0026#34; + taskComplete); } } }); new Thread(new Runnable() { @Override public void run() { synchronized (object) { try { Thread.sleep(30 * 1000); taskComplete = true; } catch (Exception e) { e.printStackTrace(); } } } }).start(); } } 解决方法 使用ReentrantLock代替synchronized，同时tryLock()增加最大等待时间，超过最大等待时间主动释放锁，避免出现ANR。 示例代码:\nReentrantLock lock = new ReentrantLock(); lock.tryLock(3000, TimeUnit.MICROSECONDS); android长生命周期：application， service content provider\n作业 ","permalink":"https://kennems.github.io/posts/tech/%E7%AC%AC%E5%8D%81%E5%A4%A9%E7%AC%94%E8%AE%B0/","summary":"第十天笔记 内存泄漏 1. Java垃圾回收机制 1.1 什么是垃圾回收 垃圾回收（GC）是由Java虚拟机（JVM）垃圾回收器提供的一种内存回收机制。 当内存","title":"训练营第十天笔记"},{"content":"第九天笔记 权限与网络请求课程预习 1. 有哪些权限，具体权限的介绍 普通权限 网络权限：允许设备访问网络\n\u0026lt;uses-permission android:name=\u0026#34;android.permission.INTERNET\u0026#34; /\u0026gt; 获取网络的状态：如是否有网\n\u0026lt;uses-permission android:name=\u0026#34;android.permission.ACCESS_NETWORK_STATE\u0026#34; /\u0026gt; 读取手机状态：如IMEI等信息\n\u0026lt;uses-permission android:name=\u0026#34;android.permission.READ_PHONE_STATE\u0026#34; /\u0026gt; 获取WiFi的状态\n\u0026lt;uses-permission android:name=\u0026#34;android.permission.ACCESS_WIFI_STATE\u0026#34; /\u0026gt; 敏感权限 写入SDK权限：文件下载、图片下载\n\u0026lt;uses-permission android:name=\u0026#34;android.permission.WRITE_EXTERNAL_STORAGE\u0026#34; /\u0026gt; 读取SDK的权限：读取相册、文件\n\u0026lt;uses-permission android:name=\u0026#34;android.permission.READ_EXTERNAL_STORAGE\u0026#34; /\u0026gt; 拍摄照片和视频\n\u0026lt;uses-permission android:name=\u0026#34;android.permission.CAMERA\u0026#34; /\u0026gt; 录音\n\u0026lt;uses-permission android:name=\u0026#34;android.permission.RECORD_AUDIO\u0026#34; /\u0026gt; 拨打电话\n\u0026lt;uses-permission android:name=\u0026#34;android.permission.CALL_PHONE\u0026#34; /\u0026gt; 读取手机联系人\n\u0026lt;uses-permission android:name=\u0026#34;android.permission.READ_CONTACTS\u0026#34; /\u0026gt; 往手机写入联系人\n\u0026lt;uses-permission android:name=\u0026#34;android.permission.WRITE_CONTACTS\u0026#34; /\u0026gt; 权限与网络请求课程预习笔记 1. 权限申请方法 检查是否授权 // 检查是否授权 checkSelfPermission(Manifest.permission.WRITE_EXTERNAL_STORAGE); ContextCompat.checkSelfPermission(this, Manifest.permission.WRITE_EXTERNAL_STORAGE); 权限申请 requestPermissions(new String[]{Manifest.permission.CAMERA}, 200); 权限申请结果处理 public void onRequestPermissionsResult(int requestCode, @NonNull String[] permissions, @NonNull int[] grantResults) { // 处理权限申请结果 } 2. OkHttp介绍 OkHttp 是 Square 公司开源的，专注于连接效率的 HTTP 客户端。OkHttp 提供了对 HTTP/2 和 SPDY 的支持，并提供了连接池、GZIP 压缩和 HTTP 响应缓存功能。\n使用 OkHttp 进行同步请求 implementation(\u0026#34;com.squareup.okhttp3:okhttp:4.12.0\u0026#34;); // 1. 创建 OkHttpClient private final OkHttpClient okHttpClient = new OkHttpClient.Builder().build(); // 2. 创建 Request Request request = new Request.Builder() .get() .url(\u0026#34;https://hotfix-service-prod.g.mi.com/quick-game/game/109\u0026#34;) .build(); // 3. 同步请求 Response response = okHttpClient.newCall(request).execute(); 通过以上步骤可以实现 OkHttp 的同步请求，分别创建 OkHttpClient 实例和 Request 实例，然后通过 newCall 方法执行请求。\n异步请求与Handler 1. 使用 OkHttp 进行异步请求 以下是使用 OkHttp 进行异步请求的步骤：\n// 1. 创建 Request Request request = new Request.Builder() .get() .url(\u0026#34;https://hotfix-service-prod.g.mi.com/quick-game/game/109\u0026#34;) .build(); // 2. 异步请求 okHttpClient.newCall(request).enqueue(new Callback() { @Override public void onFailure(@NonNull Call call, @NonNull IOException e) { Log.i(TAG, \u0026#34;网络请求失败\u0026#34;); } @Override public void onResponse(@NonNull Call call, @NonNull Response response) throws IOException { Log.i(TAG, \u0026#34;网络请求成功, code \u0026#34; + response.code()); } }); 创建 Request 对象，指定请求方式和URL。\n使用\nenqueue 方法进行异步请求，并实现\nCallback 接口处理请求结果。\nonFailure 方法处理请求失败情况。 onResponse 方法处理请求成功情况。 2. 什么是 Handler Handler 是 Android 中的消息传递机制，主要用于线程间通信。其主要功能包括：\n在子线程通过 Handler 将更新 UI 的操作传递给主线程，从而完成 UI 刷新。 在多线程应用场景中，将工作线程中需更新 UI 的操作信息传递到 UI 主线程，从而实现工作线程对 UI 的更新处理，最终实现异步消息的处理。 Handler 的主要方法 方法名称 说明 sendMessage() 系列 发送普通消息、延迟消息，最终调用 queue.enqueueMessage() 方法将消息存入消息队列。 post() 系列 提交普通/延迟 Runnable，随后封装成 Message，调用 sendMessage() 方法将消息存入消息队列。 dispatchMessage(Message msg) 分发消息，优先执行 msg.callback（也就是 runnable），其次调用 handleMessage()。 通过这些方法，Handler 可以在不同线程之间传递消息和操作，实现异步任务的处理和 UI 更新。\nHandler 示例 不在主线程中绘制UI的原因；避免不同线程混乱。\nUI线程 ： 主线程。\n以下是一个详细的 Handler 示例，涵盖了如何在 Android 中使用 Handler 进行线程间通信，更新 UI 元素，以及处理延迟任务等。\nHandler实现信息倒计时60s 1. 创建 Handler 首先，我们需要在主线程中创建一个 Handler 实例。\npublic class MainActivity extends AppCompatActivity { private TextView textView; private Handler handler; @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); textView = findViewById(R.id.textView); // 创建 Handler 实例，并重写 handleMessage 方法 handler = new Handler(Looper.getMainLooper()) { @Override public void handleMessage(@NonNull Message msg) { super.handleMessage(msg); // 处理消息 switch (msg.what) { case 1: textView.setText(\u0026#34;Message received: \u0026#34; + msg.obj); break; case 2: textView.setText(\u0026#34;Delayed message received: \u0026#34; + msg.obj); break; default: break; } } }; // 启动一个后台线程 new Thread(new Runnable() { @Override public void run() { // 模拟一些耗时操作 try { Thread.sleep(2000); } catch (InterruptedException e) { e.printStackTrace(); } // 发送消息到主线程 Message msg = handler.obtainMessage(1, \u0026#34;Hello from background thread\u0026#34;); handler.sendMessage(msg); // 发送延迟消息 Message delayedMsg = handler.obtainMessage(2, \u0026#34;This message is delayed\u0026#34;); handler.sendMessageDelayed(delayedMsg, 3000); } }).start(); } } 2. 发送和处理消息 在上面的代码中，Handler 被用来在主线程中处理来自后台线程的消息。\nhandler.obtainMessage(int what, Object obj)：创建一个消息实例。 handler.sendMessage(Message msg)：立即发送消息。 handler.sendMessageDelayed(Message msg, long delayMillis)：延迟发送消息。 3. 使用 post() 方法 除了发送消息，Handler 还可以直接执行 Runnable 对象。\n@Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); textView = findViewById(R.id.textView); handler = new Handler(Looper.getMainLooper()); // 使用 post 方法在主线程中执行 Runnable handler.post(new Runnable() { @Override public void run() { textView.setText(\u0026#34;Runnable executed immediately\u0026#34;); } }); // 使用 postDelayed 方法延迟执行 Runnable handler.postDelayed(new Runnable() { @Override public void run() { textView.setText(\u0026#34;Runnable executed after delay\u0026#34;); } }, 2000); } 4. 使用 sendMessageAtTime() 方法 可以指定一个绝对时间来发送消息。\n@Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); textView = findViewById(R.id.textView); handler = new Handler(Looper.getMainLooper()); // 发送定时消息 long uptimeMillis = SystemClock.uptimeMillis() + 5000; // 5秒后执行 Message msg = handler.obtainMessage(3, \u0026#34;Message at specific time\u0026#34;); handler.sendMessageAtTime(msg, uptimeMillis); } 5. 使用 removeCallbacksAndMessages() 可以移除所有的回调和消息。\n@Override protected void onDestroy() { super.onDestroy(); // 移除 Handler 中所有的回调和消息 handler.removeCallbacksAndMessages(null); } 总结 通过 Handler，可以实现以下功能：\n线程间通信：从子线程发送消息到主线程。 UI 更新：在主线程中更新 UI 元素。 延迟任务：延迟执行任务。 定时任务：在指定时间点执行任务。 移除任务：清除未执行的任务和消息。 这些功能使得 Handler 成为 Android 开发中处理线程和任务调度的强大工具。\nRetrofit 简介及工作流程 1. 什么是 Retrofit Retrofit 是一种流行的网络请求框架，可以理解为 OkHttp 的增强版。 底层封装了 OkHttp，实际是一个 RESTful 的 HTTP 网络请求框架的封装。 Retrofit 主要负责网络请求接口的封装，而网络请求的实际工作由 OkHttp 完成。 2. 工作流程 App 应用程序 通过 Retrofit 进行网络请求。 Retrofit 接口层封装请求参数、Header、URL 等信息，然后交给 OkHttp 继续完成请求工作。 服务端返回数据后，OkHttp 将原始数据交给 Retrofit。 Retrofit 根据用户需求解析数据。 3. 总结 Retrofit 简化了网络请求的接口定义和调用，增强了 OkHttp 的功能。 高效、简洁地处理网络请求和响应数据的解析。 通过这一流程，开发者可以更加便捷、高效地进行网络请求操作。\nRetrofit网络请求: https://hotfix-service-prod.g.mi.com/quick-game/game/{id} 参数: id=109\nhttps://hotfix-service-prod.g.mi.com/quick-game/api/auth/sendCode 参数: phone\n110室\n这个图片展示了两个Retrofit网络请求的URL和参数信息。第一个请求URL包含一个ID参数,第二个请求URL包含一个phone参数。这些信息可能是用于在Android应用程序中访问一些游戏相关的服务接口。\nRetrofit 示例 以下是一个详细的 Retrofit 示例，展示了如何在 Android 应用中使用 Retrofit 进行网络请求，包括接口定义、请求参数、响应解析等。\n1. 添加依赖 首先，在你的 build.gradle 文件中添加 Retrofit 和 OkHttp 的依赖：\ndependencies { implementation \u0026#39;com.squareup.retrofit2:retrofit:2.9.0\u0026#39; implementation \u0026#39;com.squareup.retrofit2:converter-gson:2.9.0\u0026#39; implementation \u0026#39;com.squareup.okhttp3:logging-interceptor:4.9.0\u0026#39; } 2. 创建数据模型 假设我们要请求一个用户信息接口，返回一个用户对象。首先定义用户数据模型：\npublic class User { private int id; private String name; private String email; // Getters and setters public int getId() { return id; } public void setId(int id) { this.id = id; } public String getName() { return name; } public void setName(String name) { this.name = name; } public String getEmail() { return email; } public void setEmail(String email) { this.email = email; } } 3. 定义 API 接口 使用 Retrofit 的注解来定义 API 接口：\npublic interface ApiService { @GET(\u0026#34;users/{id}\u0026#34;) Call\u0026lt;User\u0026gt; getUserById(@Path(\u0026#34;id\u0026#34;) int id); @POST(\u0026#34;users\u0026#34;) Call\u0026lt;User\u0026gt; createUser(@Body User user); @PUT(\u0026#34;users/{id}\u0026#34;) Call\u0026lt;User\u0026gt; updateUser(@Path(\u0026#34;id\u0026#34;) int id, @Body User user); @DELETE(\u0026#34;users/{id}\u0026#34;) Call\u0026lt;Void\u0026gt; deleteUser(@Path(\u0026#34;id\u0026#34;) int id); } 4. 创建 Retrofit 实例 在应用中创建一个 Retrofit 实例，并配置 OkHttp 和 Gson 转换器：\nimport retrofit2.Retrofit; import retrofit2.converter.gson.GsonConverterFactory; import okhttp3.OkHttpClient; import okhttp3.logging.HttpLoggingInterceptor; public class RetrofitClient { private static final String BASE_URL = \u0026#34;https://api.example.com/\u0026#34;; private static Retrofit retrofit; public static Retrofit getRetrofitInstance() { if (retrofit == null) { HttpLoggingInterceptor logging = new HttpLoggingInterceptor(); logging.setLevel(HttpLoggingInterceptor.Level.BODY); OkHttpClient client = new OkHttpClient.Builder() .addInterceptor(logging) .build(); retrofit = new Retrofit.Builder() .baseUrl(BASE_URL) .client(client) .addConverterFactory(GsonConverterFactory.create()) .build(); } return retrofit; } } 5. 使用 Retrofit 进行网络请求 在你的 Activity 或 Fragment 中调用 Retrofit 接口：\npublic class MainActivity extends AppCompatActivity { private ApiService apiService; @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); Retrofit retrofit = RetrofitClient.getRetrofitInstance(); apiService = retrofit.create(ApiService.class); getUserById(1); createUser(new User()); updateUser(1, new User()); deleteUser(1); } private void getUserById(int id) { Call\u0026lt;User\u0026gt; call = apiService.getUserById(id); call.enqueue(new Callback\u0026lt;User\u0026gt;() { @Override public void onResponse(Call\u0026lt;User\u0026gt; call, Response\u0026lt;User\u0026gt; response) { if (response.isSuccessful()) { User user = response.body(); // 处理用户对象 } } @Override public void onFailure(Call\u0026lt;User\u0026gt; call, Throwable t) { t.printStackTrace(); } }); } private void createUser(User user) { user.setName(\u0026#34;John Doe\u0026#34;); user.setEmail(\u0026#34;john@example.com\u0026#34;); Call\u0026lt;User\u0026gt; call = apiService.createUser(user); call.enqueue(new Callback\u0026lt;User\u0026gt;() { @Override public void onResponse(Call\u0026lt;User\u0026gt; call, Response\u0026lt;User\u0026gt; response) { if (response.isSuccessful()) { User createdUser = response.body(); // 处理创建的用户对象 } } @Override public void onFailure(Call\u0026lt;User\u0026gt; call, Throwable t) { t.printStackTrace(); } }); } private void updateUser(int id, User user) { user.setName(\u0026#34;Jane Doe\u0026#34;); user.setEmail(\u0026#34;jane@example.com\u0026#34;); Call\u0026lt;User\u0026gt; call = apiService.updateUser(id, user); call.enqueue(new Callback\u0026lt;User\u0026gt;() { @Override public void onResponse(Call\u0026lt;User\u0026gt; call, Response\u0026lt;User\u0026gt; response) { if (response.isSuccessful()) { User updatedUser = response.body(); // 处理更新的用户对象 } } @Override public void onFailure(Call\u0026lt;User\u0026gt; call, Throwable t) { t.printStackTrace(); } }); } private void deleteUser(int id) { Call\u0026lt;Void\u0026gt; call = apiService.deleteUser(id); call.enqueue(new Callback\u0026lt;Void\u0026gt;() { @Override public void onResponse(Call\u0026lt;Void\u0026gt; call, Response\u0026lt;Void\u0026gt; response) { if (response.isSuccessful()) { // 处理删除成功 } } @Override public void onFailure(Call\u0026lt;Void\u0026gt; call, Throwable t) { t.printStackTrace(); } }); } } package com.showguan.study_day09; import android.os.Bundle; import android.util.Log; import android.view.View; import android.widget.Button; import android.widget.TextView; import androidx.appcompat.app.AppCompatActivity; import com.google.gson.Gson; import com.showguan.study_day09.Bean.GameBean; import com.showguan.study_day09.Bean.HttpBean; import okhttp3.MediaType; import okhttp3.RequestBody; import retrofit2.Call; import retrofit2.Callback; import retrofit2.Response; public class RetrofitActivity extends AppCompatActivity { private static final String TAG = \u0026#34;RetrofitActivity\u0026#34;; private Gson mGson = new Gson(); private ApiServiceModule apiService; private TextView tvMsg; private Button btnSendId; private Button btnSendPhone; @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.activity_retrofit); tvMsg = findViewById(R.id.tv_msg); btnSendId = findViewById(R.id.btn_send_id); btnSendPhone = findViewById(R.id.btn_send_phone); btnSendId.setOnClickListener(v -\u0026gt; sendRequestById()); btnSendPhone.setOnClickListener(v -\u0026gt; sendRequestByPhone(\u0026#34;15610456605\u0026#34;)); } private void sendRequestById() { ApiServiceModule.getInstance().getGameService().queryGame(\u0026#34;109\u0026#34;).enqueue(new Callback\u0026lt;HttpBean\u0026lt;GameBean\u0026gt;\u0026gt;() { @Override public void onResponse(Call\u0026lt;HttpBean\u0026lt;GameBean\u0026gt;\u0026gt; call, Response\u0026lt;HttpBean\u0026lt;GameBean\u0026gt;\u0026gt; response) { if (response.isSuccessful() \u0026amp;\u0026amp; response.body() != null) { Log.i(TAG, \u0026#34;http success: \u0026#34; + response.body().getMsg()); Log.i(TAG, \u0026#34;result: \u0026#34; + mGson.toJson(response.body())); tvMsg.setText(\u0026#34;Result (ID): \u0026#34; + mGson.toJson(response.body())); } // else { // Log.i(TAG, \u0026#34;http failed: \u0026#34; + response.errorBody()); // tvMsg.setText(\u0026#34;Request failed (ID)\u0026#34;); // } } @Override public void onFailure(Call\u0026lt;HttpBean\u0026lt;GameBean\u0026gt;\u0026gt; call, Throwable t) { Log.i(TAG, \u0026#34;http failure\u0026#34;, t); tvMsg.setText(\u0026#34;Request failed (ID)\u0026#34;); } }); } private void sendRequestByPhone(String phone) { // 示例：创建 RequestBody 并发送 POST 请求 RequestBody requestBody = RequestBody.create(MediaType.parse(\u0026#34;application/json\u0026#34;), \u0026#34;{\\\u0026#34;phone\\\u0026#34;:\\\u0026#34;\u0026#34; + phone + \u0026#34;\\\u0026#34;}\u0026#34;); ApiServiceModule.getInstance().getGameService().sendCode(requestBody).enqueue(new Callback\u0026lt;HttpBean\u0026lt;String\u0026gt;\u0026gt;() { @Override public void onResponse(Call\u0026lt;HttpBean\u0026lt;String\u0026gt;\u0026gt; call, Response\u0026lt;HttpBean\u0026lt;String\u0026gt;\u0026gt; response) { if (response.isSuccessful() \u0026amp;\u0026amp; response.body() != null) { Log.i(TAG, \u0026#34;http success: \u0026#34; + response.body().getMsg()); Log.i(TAG, \u0026#34;result: \u0026#34; + mGson.toJson(response.body())); tvMsg.setText(\u0026#34;Result (Phone): \u0026#34; + mGson.toJson(response.body())); } else { Log.i(TAG, \u0026#34;http failed: \u0026#34; + response.errorBody()); tvMsg.setText(\u0026#34;Request failed (Phone)\u0026#34;); } } @Override public void onFailure(Call\u0026lt;HttpBean\u0026lt;String\u0026gt;\u0026gt; call, Throwable t) { Log.i(TAG, \u0026#34;http failure\u0026#34;, t); tvMsg.setText(\u0026#34;Request failed (Phone)\u0026#34;); } }); } } 总结 通过以上示例，我们展示了如何使用 Retrofit 进行网络请求，并实现了 GET、POST、PUT 和 DELETE 请求。Retrofit 的优势在于简化了网络请求的接口定义和调用，并且与 OkHttp 结合使用，增强了功能和灵活性。\n流程\nMMKV 使用测试URL\n火柴人\rhttps://hotfix-service-prod.g.mi.com/quick-game/game/search?search=%E7%81%AB%E6%9F%B4%E4%BA%BA\u0026amp;current=2 上拉刷新：\n使用RecyclerView， 不改变数量， 但改变顺序\n下拉加载，首先\nIntent 线程通信\nEventbus 第三方库， 消息传递，线程切换， 本进程， 其中线程切换同样使用了Handler\nHandler 线程切换， 在本进程中使用\n","permalink":"https://kennems.github.io/posts/tech/%E7%AC%AC%E4%B9%9D%E5%A4%A9%E7%AC%94%E8%AE%B0/","summary":"第九天笔记 权限与网络请求课程预习 1. 有哪些权限，具体权限的介绍 普通权限 网络权限：允许设备访问网络 \u0026lt;uses-permission android:name=\u0026#34;android.permission.INTERNET\u0026#34; /\u0026gt; 获取网络的状态：如是否有网 \u0026lt;uses-permission android:name=\u0026#34;android.permission.ACCESS_NETWORK_STATE\u0026#34; /\u0026gt; 读取手机","title":"训练营第九天笔记"},{"content":"第八天笔记 自定义控件的实现 View 绘制过程 Activity 和 View 的关系 Window 类：负责在 Activity 中展示内容（具体实现为 PhoneWindow 类） DecorView：Window 创建出根布局 DecorView（继承自 FrameLayout） 单个 View 的绘制步骤 系统根据布局树完成界面绘制，单个 View 需要经过三个步骤：\n计算 View 的宽高：measure 计算 View 的位置：layout 绘制 View 的内容：draw 布局树逐级向下调用 布局树的绘制过程从上到下逐级调用，具体步骤如下：\n测量： performMeasure() measure() onMeasure() 布局： performLayout() layout() onLayout() 绘制： performDraw() draw() onDraw() 视图树调用流程图 位置的描述依赖坐标系 Android 的坐标系定义为： 屏幕的左上角为坐标原点 向右为 x 轴增大方向 向下为 y 轴增大方向 自定义 View draw 函数 作用：绘制内容在给定的 Canvas 上\n调用时机：要保证 layout 之后再调用这个方法\n注意事项：自定义 View 时考虑优先重写 onDraw 方法而不是这个方法\n继承关系：如果一定要重写 draw 方法，要记得调用父类方法\n实现步骤：有 7 个绘制步骤：\n绘制背景 其余步骤依次类推 位置的描述依赖坐标系 Android 的坐标系定义为： 屏幕的左上角为坐标原点 向右为 x 轴增大方向 向下为 y 轴增大方向 draw 函数 作用：绘制内容在给定的 Canvas 上。\n调用时机：要保证 layout 之后再调用这个方法。\n注意事项：自定义 View 时考虑优先重写 onDraw 方法而不是这个方法。\n继承关系：如果一定要重写 draw 方法，要记得调用父类方法。\n实现步骤：有 7 个绘制步骤：\n绘制背景 如有必要，保存画布图层以准备淡入淡出动画 绘制内容 绘制子 View（即调用 childView.draw） 如有必要，绘制淡入淡出并恢复图层 绘制装饰（例如滚动条） 如有必要，绘制默认焦点高亮 /** * Manually render this view (and all of its children) to the given Canvas. * The view must have already done a full layout before this function is * called. When implementing a view, implement * {@link #onDraw(android.graphics.Canvas)} instead of overriding this method. * If you do need to override this method, call the superclass version. * * @param canvas The Canvas to which the View is rendered. */ @CallSuper public void draw(Canvas canvas) { final int privateFlags = mPrivateFlags; mPrivateFlags = (privateFlags \u0026amp; ~PFLAG_DIRTY_MASK) | PFLAG_DRAWN; /* * Draw traversal performs several drawing steps which must be executed * in the appropriate order: * * 1. Draw the background * 2. If necessary, save the canvas\u0026#39; layers to prepare for fading * 3. Draw view\u0026#39;s content * 4. Draw children * 5. If necessary, draw the fading edges and restore layers * 6. Draw decorations (scrollbars for instance) * 7. If necessary, draw the default focus highlight */ } onDraw 函数 调用时机：在 7 个绘制步骤中的第三步。 实现：绘制内容。 protected void onDraw(Canvas canvas) { // Step 1, draw the background, if needed int saveCount; drawBackground(canvas); // skip step 2 \u0026amp; 5 if possible (common case) final int viewFlags = mViewFlags; boolean horizontalEdges = (viewFlags \u0026amp; FADING_EDGE_HORIZONTAL) != 0; boolean verticalEdges = (viewFlags \u0026amp; FADING_EDGE_VERTICAL) != 0; if (!verticalEdges \u0026amp;\u0026amp; !horizontalEdges) { // Step 3, draw the content onDraw(canvas); } } 绘制内容在给定的 Canvas 上 Canvas 类：Android 中用于绘制图形的重要类。它包含了许多绘图方法，主要可以分为以下几类：\n绘制基本的几何形状，如矩形、圆形、椭圆等 使用路径（Path）定义复杂的图形 drawRect(RectF rect, Paint paint) drawPath(Path path, Paint paint) drawCircle(float cx, float cy, float radius, Paint paint) drawOval(RectF oval, Paint paint) 用于在画布上绘制文本 绘制位图图像 drawText(String text, float x, float y, Paint paint) drawBitmap(Bitmap bitmap, float left, float top, Paint paint) 设置绘制的颜色和样式 drawColor(int color): 设置绘制的颜色 drawPaint(Paint paint): 设置绘制的样式 对画布进行变换 translate(float dx, float dy): 平移变换 rotate(float degrees): 旋转变换 在画布上创建和操作图层，实现图层效果 save(): 保存当前画布的状态 restore(): 恢复之前保存的画布状态 Paint 类配合提供绘制参数 Paint paint = new Paint(); paint.setColor(Color.RED); // 设置颜色 paint.setTextSize(24); // 设置文字大小 paint.setTypeface(Typeface.create(Typeface.DEFAULT, Typeface.BOLD)); // 设置字体样式 paint.setStrokeWidth(2); // 设置绘制线条宽度 paint.setAntiAlias(true); // 启用抗锯齿 Path 类配合描述复杂图形 Path path = new Path(); path.moveTo(x: 100, y: 200); // 从当前位置移动到指定位置（不画线） path.lineTo(x: 100, y: 200); // 从前点绘制一条线到指定点 RectF oval = new RectF(left: 100, top: 100, right: 300, bottom: 600); // 绘制圆线 path.arcTo(oval, startAngle: 100, sweepAngle: 180, forceMoveTo: true); // 绘制弧线 path.close(); // 连接当前点和起始点 自定义 ViewGroup measure 函数 作用: 计算 View 的宽高 调用 onMeasure 完成真正的计算工作，且子类应该重写 onMeasure final 修饰该方法，不可重写 public final void measure(int widthMeasureSpec, int heightMeasureSpec) { boolean optical = isLayoutModeOptical() != this; if (optical != isLayoutModeOptical(mParent)) { // ... 相关代码 } } onMeasure 函数\n作用: 计算 View 的宽高，应由子类重写，以提供对其内容的准确有效的测量。 约定: 重写此方法时，必须调用 setMeasuredDimension(width, height) 来存储测量好的宽度和高度。 没有 final 修饰符，可重写 protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) { setMeasuredDimension(getDefaultSize(getSuggestedMinimumWidth(), widthMeasureSpec), getDefaultSize(getSuggestedMinimumHeight(), heightMeasureSpec)); } MeasureSpec 类 MeasureSpec 包含两部分信息：\n低 30 位为 SpecSize，即尺寸 高 2 位为 SpecMode，即测量模式 @Override protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) { int widthSpecMode = MeasureSpec.getMode(widthMeasureSpec); int widthSpecSize = MeasureSpec.getSize(widthMeasureSpec); int heightSpecMode = MeasureSpec.getMode(heightMeasureSpec); int heightSpecSize = MeasureSpec.getSize(heightMeasureSpec); int newWidthSpec = MeasureSpec.makeMeasureSpec(1, MeasureSpec.AT_MOST); } MeasureSpec 高 2 位为 SpecMode，即测量模式 测量模式 说明 UNSPECIFIED 父 View 对子 View 的大小不做限制 EXACTLY 父 View 计算好了子 View 具体的宽高，子 View 的最终大小就是 SpecSize 指定的值 AT_MOST 父 View 指定了一个可用大小 SpecSize，子 View 的大小不能大于这个值 onMeasure 函数\n作用: 计算 View 的宽高，应由子类重写，以提供对其内容的准确有效的测量。 约定: 重写此方法时，必须调用 setMeasuredDimension(width, height) 来存储测量好的宽度和高度。 没有 final 修饰符，可重写 protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) { setMeasuredDimension(getDefaultSize(getSuggestedMinimumWidth(), widthMeasureSpec), getDefaultSize(getSuggestedMinimumHeight(), heightMeasureSpec)); } MeasureSpec 类 MeasureSpec 包含两部分信息：\n低 30 位为 SpecSize，即尺寸 高 2 位为 SpecMode，即测量模式 @Override protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) { int widthSpecMode = MeasureSpec.getMode(widthMeasureSpec); int widthSpecSize = MeasureSpec.getSize(widthMeasureSpec); int heightSpecMode = MeasureSpec.getMode(heightMeasureSpec); int heightSpecSize = MeasureSpec.getSize(heightMeasureSpec); int newWidthSpec = MeasureSpec.makeMeasureSpec(1, MeasureSpec.AT_MOST); } MeasureSpec 高 2 位为 SpecMode，即测量模式 测量模式 说明 UNSPECIFIED 父 View 对子 View 的大小不做限制 EXACTLY 父 View 计算好了子 View 具体的宽高，子 View 的最终大小就是 SpecSize 指定的值 AT_MOST 父 View 指定了一个可用大小 SpecSize，子 View 的大小不能大于这个值 ViewGroup 中 MeasureSpec 计算公式 子 View 的布局参数（通过 childView.getLayoutParams() 获取） + 父 View 的测量要求 = 子 View 的 MeasureSpec\n测量模式 精确值 MATCH_PARENT WRAP_CONTENT EXACTLY SpecSize: View Group SizeSpecMode: EXACTLY SpecSize: View Group SizeSpecMode: EXACTLY SpecSize: View Group SizeSpecMode: AT_MOST AT_MOST SpecSize: View Group SizeSpecMode: AT_MOST SpecSize: View Group SizeSpecMode: AT_MOST SpecSize: View Group SizeSpecMode: AT_MOST UNSPECIFIED SpecSize: 0SpecMode: UNSPECIFIED SpecSize: 0SpecMode: UNSPECIFIED SpecSize: 0SpecMode: UNSPECIFIED onMeasure 函数实现 父 View 测量要求（MeasureSpec）作为 onMeasure 的入参传入：UNSPECIFIED, EXACTLY, AT_MOST 实现： 根据公式：子 View 布局参数（+ 父 View 测量要求）= 子 View 测量要求 将子 View 测量要求作为参数，调用子 View 的 measure 方法 根据当前 ViewGroup 布局策略计算自己的宽高 调用 setMeasuredDimension(int, int) 保存计算好的宽高 layout 函数 布局机制的第二阶段（第一阶段是测量） 作用: 给所有子 View 分配位置 实现: 在这个阶段，每个父 View 调用其所有子 View 的 layout 方法来确定它们的位置。 派生类不应覆盖此方法，子 View 的派生类应覆盖 onLayout 方法。 public void layout(int l, int t, int r, int b) { if ((mPrivateFlags \u0026amp; PFLAG3_MEASURE_NEEDED_BEFORE_LAYOUT) != 0) { onMeasure(mOldWidthMeasureSpec, mOldHeightMeasureSpec); mPrivateFlags3 \u0026amp;= ~PFLAG3_MEASURE_NEEDED_BEFORE_LAYOUT; } ... } onLayout 函数 被 layout 方法调用 作用: 为该 View 的子 View 分配位置 有子 View 的派生类应重写该方法，并对每个子 View 调用 layout 方法，通常是使用在测量过程中存储的子 View 尺寸来完成的。 . onLayout 方法 定义：在 layout 被调用时，分配每个子 View 的位置和尺寸。 参数： changed：此视图的尺寸或位置是否发生变化。 left：相对于父视图的左边位置。 top：相对于父视图的顶部位置。 right：相对于父视图的右边位置。 bottom：相对于父视图的底部位置。 2. 使用在测量过程中存储的子 View 尺寸来完成布局 在 onLayout 方法中调用子视图的 layout 方法，使用 getMeasuredWidth 和 getMeasuredHeight 获取子视图的宽度和高度。 3. getMeasuredHeight 和 getHeight 的区别 getMeasuredWidth / getMeasuredHeight： 作用：获取 View 测量的宽高。 赋值时机：measure 过程中。 赋值方法：setMeasuredDimension。 值大小：一般情况下二者获取的宽高值相等。 getWidth / getHeight：gtcg 作用：获取 View 最终的宽高。 赋值时机：layout 过程中。 赋值方法：layout 中传递的 4 个参数之间的运算。 4. 如何定义标签间距？ 自定义属性：\n在 res/values/ 新建 attrs.xml 文件，定义标签间距的属性。\n示例代码：\n\u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;utf-8\u0026#34;?\u0026gt; \u0026lt;resources\u0026gt; \u0026lt;declare-styleable name=\u0026#34;TagCloud\u0026#34;\u0026gt; \u0026lt;attr name=\u0026#34;hMargin\u0026#34; format=\u0026#34;dimension\u0026#34;/\u0026gt; \u0026lt;attr name=\u0026#34;vMargin\u0026#34; format=\u0026#34;dimension\u0026#34;/\u0026gt; \u0026lt;/declare-styleable\u0026gt; \u0026lt;/resources\u0026gt; 1. 自定义属性与标签间距 定义自定义属性 gravity：\n\u0026lt;attr name=\u0026#34;gravity\u0026#34;\u0026gt; \u0026lt;flag name=\u0026#34;top\u0026#34; value=\u0026#34;0x30\u0026#34; /\u0026gt; \u0026lt;flag name=\u0026#34;bottom\u0026#34; value=\u0026#34;0x50\u0026#34; /\u0026gt; \u0026lt;flag name=\u0026#34;left\u0026#34; value=\u0026#34;0x03\u0026#34; /\u0026gt; \u0026lt;flag name=\u0026#34;right\u0026#34; value=\u0026#34;0x05\u0026#34; /\u0026gt; \u0026lt;flag name=\u0026#34;center_vertical\u0026#34; value=\u0026#34;0x10\u0026#34; /\u0026gt; \u0026lt;/attr\u0026gt; 定义混合类型属性 background：\n\u0026lt;attr name=\u0026#34;background\u0026#34; format=\u0026#34;reference|color\u0026#34; /\u0026gt; 2. 在 XML 中使用属性 示例代码：\n\u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;utf-8\u0026#34;?\u0026gt; \u0026lt;LinearLayout xmlns:android=\u0026#34;http://schemas.android.com/apk/res/android\u0026#34; android:id=\u0026#34;@+id/parent\u0026#34; android:layout_width=\u0026#34;match_parent\u0026#34; android:layout_height=\u0026#34;match_parent\u0026#34;\u0026gt; \u0026lt;com.xiaomi.customview.TagCloud xmlns:app=\u0026#34;http://schemas.android.com/apk/res-auto\u0026#34; android:id=\u0026#34;@+id/cloud\u0026#34; android:layout_width=\u0026#34;match_parent\u0026#34; android:layout_height=\u0026#34;match_parent\u0026#34; app:hMargin=\u0026#34;40dp\u0026#34; app:vMargin=\u0026#34;20dp\u0026#34; /\u0026gt; \u0026lt;/LinearLayout\u0026gt; 在 Java 代码中获取属性：\npublic TagCloud(@NonNull Context context, @Nullable AttributeSet attrs) { super(context, attrs); TypedArray a = context.obtainStyledAttributes(attrs, R.styleable.TagCloud); horizontalMargin = a.getDimension(R.styleable.TagCloud_hMargin, 20); verticalMargin = a.getDimension(R.styleable.TagCloud_vMargin, 10); a.recycle(); } 3. 响应手势操作 MotionEvent 类（运动事件）包含：ACTION（事件类型）+ 事件位置\nonInterceptTouchEvent:\n**用途:**当先分发给子View处理,且子View的dispatchTouchEvent返回true(子View表示会消费这个事件),当前ViewGroup依然有捕获的能力\n场景:支持滑动的ViewGroup中的子View做了事件消费,第一个事件action_down发生在该子View范围内,该子View的dispatchTouchEvent方法返回true\n第二个事件是action_move,此时当前ViewGroup判断为滑动手势,由自己开始消费(onInterceptTouchEvent返回true控制这事件),并且给子View分发action_cancel事件(帮助子View结束此组手势)\n事件类型：\nACTION_DOWN：按下 ACTION_POINTER_DOWN：第 n 个手指按下 ACTION_MOVE：移动 ACTION_UP：抬起 ACTION_POINTER_UP：多指按下的前提下，抬起一个手指 ACTION_CANCEL：取消 事件位置：\n(x, y) 坐标 示例代码：\n@Override public boolean onTouchEvent(MotionEvent event) { switch (event.getAction()) { case MotionEvent.ACTION_DOWN: // 处理按下事件 break; case MotionEvent.ACTION_MOVE: // 处理移动事件 break; case MotionEvent.ACTION_UP: // 处理抬起事件 break; case MotionEvent.ACTION_CANCEL: // 处理取消事件 break; } return true; } 用户的真实有意义的手势是由多个 MotionEvent（运动事件）组合而成\n例如：\n用户滑动手势： DOWN事件 MOVE事件（若干个） UP事件 进入另一个视图时的CANCEL事件 示例流程图：\nrequirementDiagram\rrequirement test_req {\rid: 1\rtext: the test text.\rrisk: high\rverifymethod: test\r}\relement test_entity {\rtype: simulation\r}\rtest_entity - satisfies -\u0026gt; test_req GestureDetector 类及其回调方法 onDown(MotionEvent e): 用户按下屏幕时调用，表示屏幕已经被触摸。 返回 false。 onShowPress(MotionEvent e): 用户按下屏幕一段时间后，但未完成其他手势时调用。 无返回值。 onSingleTapUp(MotionEvent e): 用户轻触屏幕时调用，且未发生滑动或长按。 返回 false。 onScroll(MotionEvent e1, MotionEvent e2, float distanceX, float distanceY): 用户在屏幕上滑动时调用，提供起始事件和当前事件之间的滑动距离。 返回 false。 onLongPress(MotionEvent e): 用户长按屏幕时调用，用于处理长按事件。 无返回值。 onFling(MotionEvent e1, MotionEvent e2, float velocityX, float velocityY): 用户快速滑动后松开时调用，提供起始事件、当前事件以及滑动速度。 返回 false。 MotionEvent 事件类型 ACTION_UP: 抬起 ACTION_POINTER_UP: 多指按下的前提下，抬起一个手指 ACTION_CANCEL: 取消 事件位置 事件位置为 (x, y) 坐标系。 手势的组合 用户的真实手势是由多个 MotionEvent（运动事件）组合而成。例如：\nDOWN事件 -\u0026gt; MOVE事件 -\u0026gt; UP事件 -\u0026gt; CANCEL事件 常见手势的事件组合 点击: down + up 长按: down（持续一段时间没有 move 和 up 事件） 滑动: down + move + up 双击: down + up + down + up 双指放大/缩小: down + pointer_down + move + pointer_up + up 长按拖动: down + move + up（满足触发长按的阈值） 边缘滑动: down + move + up（区别在于事件位置在边缘） GestureDetector 类 作用: 提供封装好的手势判断结果。 使用 onTouchEvent 方法或 onTouchListener 处理手势 通过重写 onTouchEvent 方法或注册 onTouchListener，可以将 MotionEvent 交给 GestureDetector 进行处理。\n重写 onTouchEvent 方法: @Override public boolean onTouchEvent(MotionEvent event) { return mDetector.onTouchEvent(event); } 注册 onTouchListener: findViewById(R.id.parent).setOnTouchListener(new View.OnTouchListener() { @Override public boolean onTouch(View v, MotionEvent event) { return mDetector.onTouchEvent(event); } }); 手势分发及响应过程：View 处理流程 流程图: 开始 └── View.dispatchTouchEvent()（分发事件） ├── 是否注册了Touch事件监听 │ ├── true：View.onTouch() │ │ ├── true：事件消费，不再向下分发 │ │ └── false：事件无法消费，继续向下分发 │ └── false：onTouchEvent() │ ├── 是否注册了点击事件 │ │ ├── true：performClick() -\u0026gt; onClick() │ │ └── false：事件结束 └── 结果 事件处理: 如果我们认为一个有意义的手势是由 ACTION_DOWN 开始的一组 MotionEvent 事件组成，所以如果需要响应手势，第一个 ACTION_DOWN 就应该开始消费，即 onTouch 返回 true（且整个手势都应该持续返回 true）。如果返回 false，那么后续父 View 将不会把该组事件分发到当前 View。 手势分发及响应过程：ViewGroup 处理流程 流程图: 开始 └── ViewGroup.dispatchTouchEvent()（接收传递的事件） ├── ViewGroup.onInterceptTouchEvent()（拦截事件） │ ├── true：不允许事件继续向子View传递 │ │ └── ViewGroup交给dispatchTouchEvent()（即View.dispatchTouchEvent()） │ │ ├── 自己处理该事件 -\u0026gt; onTouchEvent() -\u0026gt; performClick() -\u0026gt; onClick() │ └── false：允许事件继续向子View传递 │ ├── 找到被点击的子View（遍历所有子View） │ │ ├── 找到被点击的子View │ │ │ └── 调用子View的dispatchTouchEvent()（实现了事件传递：ViewGroup -\u0026gt; View） │ │ └── 找不到被点击的子View（如点击了空白处） └── 结果 事件处理: ViewGroup 通过 dispatchTouchEvent() 分发事件，事件分发到子 View 时，会调用 onInterceptTouchEvent() 判断是否拦截事件。 如果拦截事件，ViewGroup 自己处理事件；如果不拦截，继续向子 View 传递，找到被点击的子 View 并调用其 dispatchTouchEvent() 进行事件传递和处理。 onInterceptTouchEvent 作用: 即使事件是无分发给子 View 处理，且子 View 的 dispatchTouchEvent 返回 true（子 View 表示会消费这个事件），当前 ViewGroup 依然有拦截的能力。 场景: 支持该功能的 ViewGroup 中的子 View 做了事件消费，第一个事件 action_down 发生在该子 View 范围内，该子 View 的 dispatchTouchEvent 方法返回 true。第二个事件是 action_move，此时当前 ViewGroup 判断为滑动手势，由自己开始消费（onInterceptTouchEvent 返回 true 拦截该事件），并且给子 View 分发 action_cancel 事件（帮助子 View 结束此组手势响应）。 扩展内容 GestureDetector#OnDoubleTapListener\n作用: 检测双击手势。 使用: 使用方式同 GestureDetector。 ScaleGestureDetector 类\n作用: 检测双指缩放手势。 使用: 使用方式同 GestureDetector。 ViewDragHelper / DragShadowBuilder 类\n相同的作用: 都是帮助实现拖拽逻辑的辅助类。\n不同的能力和场景:\nViewDragHelper DragShadowBuilder 场景 针对 ViewGroup 中拖拽子 View 的场景 适用于更多场景，甚至支持跨进程拖动传递数据 使用难易 简单 复杂 课后阅读 Android 开发者指南: 自定义视图组件 j\n","permalink":"https://kennems.github.io/posts/tech/%E7%AC%AC%E5%85%AB%E5%A4%A9%E7%AC%94%E8%AE%B0/","summary":"第八天笔记 自定义控件的实现 View 绘制过程 Activity 和 View 的关系 Window 类：负责在 Activity 中展示内容（具体实现为 PhoneWindow 类） DecorView：Window 创建出根布局 Dec","title":"训练营第八天笔记"},{"content":"第七天笔记 Android 动画 帧动画 作用对象 视图控件 (View) 例如 Android 的 TextView、Button 等等 不可作用于 View 组件的属性，如：颜色、背景、长度等等 使用 资源文件方式 代码方式 资源文件方式 基本信息介绍 资源文件方式使用，需要先定义动画的 XML 文件，这种动画的 XML 文件一般放在 res/drawable/ 目录下。示例 XML 内容：\n\u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;utf-8\u0026#34;?\u0026gt; \u0026lt;animation-list xmlns:android=\u0026#34;http://schemas.android.com/apk/res/android\u0026#34; android:oneshot=\u0026#34;true\u0026#34;\u0026gt; \u0026lt;item android:drawable=\u0026#34;@drawable/run1\u0026#34; android:duration=\u0026#34;100\u0026#34;/\u0026gt; \u0026lt;item android:drawable=\u0026#34;@drawable/run2\u0026#34; android:duration=\u0026#34;100\u0026#34;/\u0026gt; \u0026lt;item android:drawable=\u0026#34;@drawable/run3\u0026#34; android:duration=\u0026#34;100\u0026#34;/\u0026gt; \u0026lt;item android:drawable=\u0026#34;@drawable/run4\u0026#34; android:duration=\u0026#34;100\u0026#34;/\u0026gt; \u0026lt;item android:drawable=\u0026#34;@drawable/run5\u0026#34; android:duration=\u0026#34;100\u0026#34;/\u0026gt; \u0026lt;item android:drawable=\u0026#34;@drawable/run6\u0026#34; android:duration=\u0026#34;100\u0026#34;/\u0026gt; \u0026lt;item android:drawable=\u0026#34;@drawable/run7\u0026#34; android:duration=\u0026#34;100\u0026#34;/\u0026gt; \u0026lt;/animation-list\u0026gt; 使用 XML 展示动画 新建 Activity 布局文件：\n\u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;utf-8\u0026#34;?\u0026gt; \u0026lt;FrameLayout xmlns:android=\u0026#34;http://schemas.android.com/apk/res/android\u0026#34; xmlns:tools=\u0026#34;http://schemas.android.com/tools\u0026#34; android:layout_width=\u0026#34;match_parent\u0026#34; android:layout_height=\u0026#34;match_parent\u0026#34; tools:context=\u0026#34;.frameanim.FrameAnimXmlSampleLetActivity\u0026#34;\u0026gt; \u0026lt;ImageView android:id=\u0026#34;@+id/iv_run_anim\u0026#34; android:layout_width=\u0026#34;90dp\u0026#34; android:layout_height=\u0026#34;160dp\u0026#34; android:layout_gravity=\u0026#34;center\u0026#34;/\u0026gt; \u0026lt;/FrameLayout\u0026gt; 帧动画 作用对象 视图控件 (View) 例如 Android 的 TextView、Button 等等 不可作用于 View 组件的属性，如：颜色、背景、长度等等 使用 资源文件方式 代码方式 资源文件方式 基本信息介绍 资源文件方式使用，需要先定义动画的 XML 文件，这种动画的 XML 文件一般放在 res/drawable/ 目录下。示例 XML 内容：\n\u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;utf-8\u0026#34;?\u0026gt; \u0026lt;animation-list xmlns:android=\u0026#34;http://schemas.android.com/apk/res/android\u0026#34; android:oneshot=\u0026#34;true\u0026#34;\u0026gt; \u0026lt;item android:drawable=\u0026#34;@drawable/run1\u0026#34; android:duration=\u0026#34;100\u0026#34;/\u0026gt; \u0026lt;item android:drawable=\u0026#34;@drawable/run2\u0026#34; android:duration=\u0026#34;100\u0026#34;/\u0026gt; \u0026lt;item android:drawable=\u0026#34;@drawable/run3\u0026#34; android:duration=\u0026#34;100\u0026#34;/\u0026gt; \u0026lt;item android:drawable=\u0026#34;@drawable/run4\u0026#34; android:duration=\u0026#34;100\u0026#34;/\u0026gt; \u0026lt;item android:drawable=\u0026#34;@drawable/run5\u0026#34; android:duration=\u0026#34;100\u0026#34;/\u0026gt; \u0026lt;item android:drawable=\u0026#34;@drawable/run6\u0026#34; android:duration=\u0026#34;100\u0026#34;/\u0026gt; \u0026lt;item android:drawable=\u0026#34;@drawable/run7\u0026#34; android:duration=\u0026#34;100\u0026#34;/\u0026gt; \u0026lt;/animation-list\u0026gt; 使用 XML 展示动画 新建 Activity 布局文件：\n\u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;utf-8\u0026#34;?\u0026gt; \u0026lt;FrameLayout xmlns:android=\u0026#34;http://schemas.android.com/apk/res/android\u0026#34; xmlns:tools=\u0026#34;http://schemas.android.com/tools\u0026#34; android:layout_width=\u0026#34;match_parent\u0026#34; android:layout_height=\u0026#34;match_parent\u0026#34; tools:context=\u0026#34;.frameanim.FrameAnimXmlSampleLetActivity\u0026#34;\u0026gt; \u0026lt;ImageView android:id=\u0026#34;@+id/iv_run_anim\u0026#34; android:layout_width=\u0026#34;90dp\u0026#34; android:layout_height=\u0026#34;160dp\u0026#34; android:layout_gravity=\u0026#34;center\u0026#34;/\u0026gt; \u0026lt;/FrameLayout\u0026gt; 代码方式 基础信息介绍 在代码中使用我们刚才定义好的动画 XML 文件：\npackage com.xiaomi.anim.animationsample.frameanim; import ... public class FrameAnimXmlSampleLetActivity extends AppCompatActivity { @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.activity_frame_anim_xml_sample); ImageView runImageView = findViewById(R.id.iv_run_anim); runImageView.setImageResource(R.drawable.drawable_run_anim); AnimationDrawable animationDrawable = (AnimationDrawable) runImageView.getDrawable(); animationDrawable.start(); } } 资源文件方式 基本信息介绍 资源文件方式使用，需要先定义动画的 XML 文件，这种动画的 XML 文件一般放在 res/drawable/ 目录下。示例 XML 内容：\n\u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;utf-8\u0026#34;?\u0026gt; \u0026lt;animation-list xmlns:android=\u0026#34;http://schemas.android.com/apk/res/android\u0026#34; android:oneshot=\u0026#34;true\u0026#34;\u0026gt; \u0026lt;item android:drawable=\u0026#34;@drawable/run1\u0026#34; android:duration=\u0026#34;100\u0026#34;/\u0026gt; \u0026lt;item android:drawable=\u0026#34;@drawable/run2\u0026#34; android:duration=\u0026#34;100\u0026#34;/\u0026gt; \u0026lt;item android:drawable=\u0026#34;@drawable/run3\u0026#34; android:duration=\u0026#34;100\u0026#34;/\u0026gt; \u0026lt;item android:drawable=\u0026#34;@drawable/run4\u0026#34; android:duration=\u0026#34;100\u0026#34;/\u0026gt; \u0026lt;item android:drawable=\u0026#34;@drawable/run5\u0026#34; android:duration=\u0026#34;100\u0026#34;/\u0026gt; \u0026lt;item android:drawable=\u0026#34;@drawable/run6\u0026#34; android:duration=\u0026#34;100\u0026#34;/\u0026gt; \u0026lt;item android:drawable=\u0026#34;@drawable/run7\u0026#34; android:duration=\u0026#34;100\u0026#34;/\u0026gt; \u0026lt;/animation-list\u0026gt; 使用 XML 展示动画 新建 Activity 布局文件：\n\u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;utf-8\u0026#34;?\u0026gt; \u0026lt;FrameLayout xmlns:android=\u0026#34;http://schemas.android.com/apk/res/android\u0026#34; xmlns:tools=\u0026#34;http://schemas.android.com/tools\u0026#34; android:layout_width=\u0026#34;match_parent\u0026#34; android:layout_height=\u0026#34;match_parent\u0026#34; tools:context=\u0026#34;.frameanim.FrameAnimXmlSampleLetActivity\u0026#34;\u0026gt; \u0026lt;ImageView android:id=\u0026#34;@+id/iv_run_anim\u0026#34; android:layout_width=\u0026#34;90dp\u0026#34; android:layout_height=\u0026#34;160dp\u0026#34; android:layout_gravity=\u0026#34;center\u0026#34;/\u0026gt; \u0026lt;/FrameLayout\u0026gt; 代码方式 基础信息介绍 在代码中使用我们刚才定义好的动画 XML 文件：\npackage com.xiaomi.anim.animationsample.frameanim; import android.graphics.drawable.AnimationDrawable; import android.os.Bundle; import android.widget.ImageView; import androidx.appcompat.app.AppCompatActivity; import androidx.core.content.ContextCompat; public class FrameAnimCodeSampleActivity extends AppCompatActivity { @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.activity_frame_anim_code_sample); ImageView runImageView = findViewById(R.id.iv_run_anim); AnimationDrawable animationDrawable = new AnimationDrawable(); animationDrawable.setOneShot(false); animationDrawable.addFrame(ContextCompat.getDrawable(this, R.drawable.run1), 100); animationDrawable.addFrame(ContextCompat.getDrawable(this, R.drawable.run2), 100); animationDrawable.addFrame(ContextCompat.getDrawable(this, R.drawable.run3), 100); animationDrawable.addFrame(ContextCompat.getDrawable(this, R.drawable.run4), 100); animationDrawable.addFrame(ContextCompat.getDrawable(this, R.drawable.run5), 100); animationDrawable.addFrame(ContextCompat.getDrawable(this, R.drawable.run6), 100); animationDrawable.addFrame(ContextCompat.getDrawable(this, R.drawable.run7), 100); runImageView.setImageDrawable(animationDrawable); animationDrawable.start(); } } 补间动画 动画类型 平移动画 (Translate) 缩放动画 (Scale) 旋转动画 (Rotate) 透明度动画 (Alpha) 基本使用 补间动画可以通过 XML 或 Android 代码两种方式使用，一般情况建议使用 XML 文件定义，因为它更具可读性、可重用性。XML 放在 res/anim/ 目录下。\n基础标签和类 XML 标签 \u0026lt;translate\u0026gt; 标签：表示平移动画 \u0026lt;scale\u0026gt; 标签：表示缩放动画 \u0026lt;rotate\u0026gt; 标签：表示旋转动画 \u0026lt;alpha\u0026gt; 标签：表示透明度动画 \u0026lt;set\u0026gt; 标签：表示组合动画 动画效果 从当前 View 左上角移动到宽高的 50%，持续 1000ms。\nXML 方式实现 在 res/anim/ 目录下创建 anim_translate.xml 文件：\n\u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;utf-8\u0026#34;?\u0026gt; \u0026lt;translate xmlns:android=\u0026#34;http://schemas.android.com/apk/res/android\u0026#34; android:duration=\u0026#34;1000\u0026#34; android:fromXDelta=\u0026#34;0%\u0026#34; android:fromYDelta=\u0026#34;0%\u0026#34; android:toXDelta=\u0026#34;50%\u0026#34; android:toYDelta=\u0026#34;50%\u0026#34;\u0026gt; \u0026lt;/translate\u0026gt; 在 Activity 中使用 XML 动画 在 Activity 中加载并应用动画：\npackage com.xiaomi.anim.animationsample.tweenanim; import android.os.Bundle; import android.view.animation.Animation; import android.view.animation.AnimationUtils; import android.widget.ImageView; import androidx.appcompat.app.AppCompatActivity; public class TweenAnimTranslateXmlActivity extends AppCompatActivity { @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.activity_tween_anim_translate_xml); ImageView robotImageView = findViewById(R.id.iv_robot); Animation animation = AnimationUtils.loadAnimation(this, R.anim.anim_translate); robotImageView.startAnimation(animation); } } 缩放动画 (Scale) 动画效果 基于当前 View 中心点扩大 1.2 倍，持续 1000ms。\nXML 方式实现 在 res/anim/ 目录下创建 anim_scale.xml 文件：\n\u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;utf-8\u0026#34;?\u0026gt; \u0026lt;scale xmlns:android=\u0026#34;http://schemas.android.com/apk/res/android\u0026#34; android:duration=\u0026#34;1000\u0026#34; android:fromXScale=\u0026#34;1.0\u0026#34; android:fromYScale=\u0026#34;1.0\u0026#34; android:toXScale=\u0026#34;1.2\u0026#34; android:toYScale=\u0026#34;1.2\u0026#34; android:pivotX=\u0026#34;50%\u0026#34; android:pivotY=\u0026#34;50%\u0026#34;\u0026gt; \u0026lt;/scale\u0026gt; 在 Activity 中使用 XML 动画 在 Activity 中加载并应用动画：\npackage com.xiaomi.anim.animationsample.tweenanim; import android.os.Bundle; import android.view.animation.Animation; import android.view.animation.AnimationUtils; import android.widget.ImageView; import androidx.appcompat.app.AppCompatActivity; public class TweenAnimScaleXmlActivity extends AppCompatActivity { @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.activity_tween_anim_scale_xml); ImageView robotImageView = findViewById(R.id.iv_robot); Animation animation = AnimationUtils.loadAnimation(this, R.anim.anim_scale); robotImageView.startAnimation(animation); } } 代码方式实现 通过代码实现缩放动画：\npackage com.xiaomi.anim.animationsample.tweenanim; import android.os.Bundle; import android.view.animation.ScaleAnimation; import android.widget.ImageView; import androidx.appcompat.app.AppCompatActivity; public class TweenAnimScaleCodeActivity extends AppCompatActivity { @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.activity_tween_anim_scale_code); ImageView robotImageView = findViewById(R.id.iv_robot); ScaleAnimation animation = new ScaleAnimation( 1f, 1.2f, // fromX, toX 1f, 1.2f, // fromY, toY Animation.RELATIVE_TO_SELF, 0.5f, // pivotX Animation.RELATIVE_TO_SELF, 0.5f // pivotY ); animation.setDuration(1000); robotImageView.startAnimation(animation); } } 旋转动画 (Rotate) 动画效果 基于当前 View 中心点顺时针旋转180度，持续1000ms。\nXML 方式实现 在 res/anim/ 目录下创建 anim_rotation.xml 文件：\n\u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;utf-8\u0026#34;?\u0026gt; \u0026lt;rotate xmlns:android=\u0026#34;http://schemas.android.com/apk/res/android\u0026#34; android:duration=\u0026#34;1000\u0026#34; android:fromDegrees=\u0026#34;0\u0026#34; android:toDegrees=\u0026#34;180\u0026#34; android:pivotX=\u0026#34;50%\u0026#34; android:pivotY=\u0026#34;50%\u0026#34;\u0026gt; \u0026lt;/rotate\u0026gt; 在 Activity 中使用 XML 动画 在 Activity 中加载并应用动画：\npackage com.xiaomi.anim.animationsample.tweenanim; import android.os.Bundle; import android.view.animation.Animation; import android.view.animation.AnimationUtils; import android.widget.ImageView; import androidx.appcompat.app.AppCompatActivity; public class TweenAnimRotationXmlActivity extends AppCompatActivity { @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.activity_tween_anim_rotation_xml); ImageView robotImageView = findViewById(R.id.iv_robot); Animation animation = AnimationUtils.loadAnimation(this, R.anim.anim_rotation); robotImageView.startAnimation(animation); } } 透明度动画 (Alpha) 动画效果 当前 View 从不透明变为透明，持续1000ms。\nXML 方式实现 在 res/anim/ 目录下创建 anim_alpha.xml 文件：\n\u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;utf-8\u0026#34;?\u0026gt; \u0026lt;alpha xmlns:android=\u0026#34;http://schemas.android.com/apk/res/android\u0026#34; android:duration=\u0026#34;@integer/anim_1000\u0026#34; android:fromAlpha=\u0026#34;1\u0026#34; android:toAlpha=\u0026#34;0\u0026#34;\u0026gt; \u0026lt;/alpha\u0026gt; 在 Activity 中使用 XML 动画 在 Activity 中加载并应用透明度动画：\npackage com.xiaomi.anim.animationsample.tweenanim; import android.os.Bundle; import android.view.animation.Animation; import android.view.animation.AnimationUtils; import android.widget.ImageView; import androidx.appcompat.app.AppCompatActivity; public class TweenAnimAlphaXmlActivity extends AppCompatActivity { @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.activity_tween_anim_alpha_xml); ImageView robotImageView = findViewById(R.id.iv_robot); Animation animation = AnimationUtils.loadAnimation(this, R.anim.anim_alpha); robotImageView.startAnimation(animation); } } 1. 动画的 XML 实现方式 代码示例\npublic class TweenAnimSetXmlActivity extends AppCompatActivity { @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.activity_tween_anim_set_xml); ImageView robotImageView = findViewById(R.id.iv_robot); Animation animation = AnimationUtils.loadAnimation(this, R.anim.anim_set); robotImageView.startAnimation(animation); } } 2. 动画的代码实现方式 代码示例\npublic class TweenAnimSetCodeActivity extends AppCompatActivity { @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.activity_tween_anim_set_code); ImageView robotImageView = findViewById(R.id.iv_robot); AnimationSet animationSet = new AnimationSet(true); ScaleAnimation scaleAnimation = new ScaleAnimation(1f, 1.2f, 1f, 1.2f, Animation.RELATIVE_TO_SELF, 0.5f, Animation.RELATIVE_TO_SELF, 0.5f); RotateAnimation rotateAnimation = new RotateAnimation(0f, 180f, Animation.RELATIVE_TO_SELF, 0.5f, Animation.RELATIVE_TO_SELF, 0.5f); AlphaAnimation alphaAnimation = new AlphaAnimation(1f, 0f); animationSet.addAnimation(scaleAnimation); animationSet.addAnimation(rotateAnimation); animationSet.addAnimation(alphaAnimation); animationSet.setDuration(1000); robotImageView.startAnimation(animationSet); } } 3. 动画监听 概述\nAnimation 类可以通过设置动画监听器来监听动画的开始、结束和重复时刻，以执行一系列操作。 代码示例\nanimation.setAnimationListener(new Animation.AnimationListener() { @Override public void onAnimationStart(Animation animation) { // 动画开始时回调 } @Override public void onAnimationEnd(Animation animation) { // 动画结束时回调 } @Override public void onAnimationRepeat(Animation animation) { // 动画重复执行时回调 } }); 属性动画 作业， 课堂表现， 大作业项目。\n现在开头还算中等， 坚持下去有机会。\n自定义Interpolator 自定义View ","permalink":"https://kennems.github.io/posts/tech/%E7%AC%AC%E4%B8%83%E5%A4%A9%E7%AC%94%E8%AE%B0/","summary":"第七天笔记 Android 动画 帧动画 作用对象 视图控件 (View) 例如 Android 的 TextView、Button 等等 不可作用于 View 组件的属性，如：颜色、背景、长度等等 使用 资源文","title":"训练营第七天笔记"},{"content":"第六天笔记 组件库笔记 1. 组件库依赖、发布和使用 依赖方式对比 2.x版本 3.x版本 说明 apk runtimeOnly apk 功能同 runtimeOnly。只在生成 apk 时参与打包，编译时不会参与。Gradle 只会将依赖项添加到构建输出，以便在运行时使用。 provided compileOnly provided 功能同 compileOnly。只在编译时有效，不会参与打包至 apk。 compile api compile 功能同 api。该依赖方式会传递所依赖的库，当其他 module 依赖了该 module 时，可以使用该 module 下使用 api 依赖的库。 - implementation 该依赖方式所依赖的库不会传递，只会在当前 module 中生效。 格式介绍 格式 介绍 差异 AAR AAR 文件包含了 Android 库项目的代码、资源文件和清单文件等信息，可以被其他 Android 应用程序引用和使用。 Android 特有的归档文件格式，主要用于打包 Android 库项目。 JAR JAR 文件包含了 Java 类文件、资源文件和清单文件等信息，可以被其他 Java 应用程序引用和使用。 Java 中常用的归档文件格式，用于打包 Java 类库和应用程序。 依赖添加方式 本地依赖\n将 Jar 文件放置在项目的 libs 目录下，并在项目的 build.gradle 文件中添加以下依赖：\ndependencies { implementation files(\u0026#39;libs/library_name.jar\u0026#39;) } 其中，library_name.jar 是 Jar 文件的名称。\n仓库依赖\nJar 文件发布到 Maven 仓库或 JCenter 等公共仓库中，并在项目的 build.gradle 文件中添加以下依赖：\ndependencies { implementation \u0026#39;group_id:artifact_id:version\u0026#39; } 其中，group_id 是 Jar 文件所属的组织或公司的 ID，artifact_id 是 Jar 文件的名称，version 是 Jar 文件的版本号。\nMaven 仓库地址: https://repo.maven.apache.org/maven2/ JCenter 仓库: https://jcenter.bintray.com/ 3. 自定义仓库 a. 配置 mavenDeployer { // 本地 maven 仓库的路径 repository(url: uri(\u0026#34;$rootDir/maven\u0026#34;)) // 生成 maven 依赖的组名 pom.groupId = \u0026#39;com.xiaomi.lib\u0026#39; // 生成 maven 依赖的模块名称 pom.artifactId = \u0026#39;image\u0026#39; // 生成 maven 依赖的版本号 pom.version = \u0026#39;1.0.0\u0026#39; } b. 发布 在 Android Studio 中 Gradle 面板工程的根目录找到功能菜单:\nCircleImageLib -\u0026gt; Task -\u0026gt; upload -\u0026gt; uploadArchives 双击 uploadArchives 开始打包发布或在 Terminal 命令行中执行:\n./gradlew uploadArchives c. 引用 在工程根目录的中的\nrepositories 中添加仓库地址:\nmaven { url uri(\u0026#34;$rootDir/maven\u0026#34;) } 在 App Module 目录的 build.gradle 中添加依赖。\n2. 基础组件库 2.1 图片库 图片库 Glide 组件源码地址: https://github.com/bumptech/glide Glide Transformations 源码地址: https://github.com/wasabeef/glide-transformations Glide 图片原理 更多组件 Glide 图片加载缓存机制 2.2 事件传递库 a. EventBus 集成使用 项目地址: https://github.com/greenrobot/EventBus\n依赖集成:\nimplementation(\u0026#34;org.greenrobot:eventbus:3.3.1\u0026#34;) b. EventBus原理 2.3 适配器组件库 a. BaseRecyclerViewAdapterHelper使用 项目地址: https://github.com/CymChad/BaseRecyclerViewAdapterHelper\n依赖集成:\nimplementation \u0026#34;io.github.cymchad:BaseRecyclerViewAdapterHelper:2.9.50\u0026#34; 项目根目录的中添加:\nmaven { url \u0026#34;https://jitpack.io\u0026#34; } b. BaseRecyclerViewAdapterHelper基本原理 2.4 刷新库 SwipeRefreshLayout组件使用 源码地址: https://developer.android.google.cn/reference/androidx/swiperefreshlayout/widget/SwipeRefreshLayout PullToRefresh组件原理解析 2.5 更多组件库 UI组件 描述 UI组件 描述 SmartRefreshLayout 支持下拉刷新、上拉加载 BaseRecyclerViewAdapterHelper 灵活的RecyclerAdapter TwinklingRefreshLayout 支持下拉刷新和上拉加载 Android-PickerView 选择器 SwipeBackLayout 支持手滑滑动返回 TitleBar 标题栏框架 CoordinatorTabLayout 配合TabLayout折叠控件 ToastUtils 各种聚集杂项 FlowLayout Android Android流式布局 Toasty 自定义Toast库 ShimmerRecyclerView 数据加载闪烁效果 banner 轮播图 动画 动画库 描述 lottie json动画库 AVLoadingIndicatorView load动画库 数据库 数据库库 描述 greendao 将对象映射的SQLite的ORM解决方案库 litepal 对象关系映射 (ORM) 模型 afinal 开源的android的Orm和Ioc应用开发框架，小巧灵活，代码优雅 objectbox 基于IoT为嵌入和移动设备打造出的非常快速的面向对象的数据库库 Room Google推出的官方数据库框架 realm 移动端数据库，替代SQLite \u0026amp; ORMs 事件传递 事件传递库 描述 eventbus 在activities, fragments, threads, services之间传递消息 rxbus 简易的非反射的事件总线库 网络请求 网络请求库 描述 okhttp 安卓端最火热的网络请求库，使用简单，功能完备 volley 网络请求库，适合数据量不大，通信频繁的网络操作 retrofit 基于okhttp封装的网络库 JSON解析 JSON解析库 描述 fastjson Java语言编写的高性能功能完善的JSON库 gson Java序列化反序列化库用于JSON和Java对象转化 moshi 面向Android, Java 和Kotlin的现代JSON库 Jackson Java JSON库 热修复 热修复库 描述 tinker 腾讯热修复解决方案库 robust 美团热修复框架 注解框架 注解框架库 描述 butterknife View, Resource注入框架 dagger 依赖注入库 性能优化 性能优化库 描述 leakcanary 内存泄漏检测库 blockcanary 卡顿检测 arca 应用崩溃报告 组件化 组件化库 描述 arouter App进行组件化改造的路由框架 响应式 响应式库 描述 rxjava 响应式编程，创建基于事件的异步操作库 rxandroid RxJava的Android绑定 动画 问: Lottie 动画库的优点是什么？它是如何工作的？\n答: Lottie 是一个强大的动画库，支持在 Android、iOS 和 Web 上渲染 Adobe After Effects 动画。它的主要优点包括： 跨平台支持: 一次创建，随处使用。 高性能: 通过 JSON 文件渲染动画，比传统帧动画更高效。 易于使用: 只需几行代码即可加载并播放动画。 Lottie 工作原理是通过解析由 Bodymovin 导出的 JSON 文件，并将其转换为原生的动画效果。 问: 如何在 Android 项目中集成 AVLoadingIndicatorView？\n答: 在 Android 项目中集成 AVLoadingIndicatorView 可以按照以下步骤进行：\n在项目的\n文件中添加依赖：\nimplementation \u0026#39;com.wang.avi:library:2.1.3\u0026#39; 在布局文件中添加 AVLoadingIndicatorView：\n\u0026lt;com.wang.avi.AVLoadingIndicatorView android:id=\u0026#34;@+id/avi\u0026#34; android:layout_width=\u0026#34;wrap_content\u0026#34; android:layout_height=\u0026#34;wrap_content\u0026#34; app:indicatorName=\u0026#34;BallPulseIndicator\u0026#34;/\u0026gt; 在代码中启动或停止动画：\nAVLoadingIndicatorView avi = findViewById(R.id.avi); avi.show(); // To start animation avi.hide(); // To stop animation 数据库 问: Room 数据库有哪些主要特性？ 答: Room 是 Google 推出的官方数据库库，主要特性包括： 简单易用: 使用注解来定义数据库表和查询。 编译时验证: Room 在编译时验证 SQL 查询语句的正确性。 与 LiveData 和 RxJava 集成: 支持与 LiveData 和 RxJava 集成，实现数据的异步处理和响应式编程。 迁移支持: 提供了方便的数据库迁移机制。 问: 对比 SQLite、Realm 和 ObjectBox，有哪些不同点？ 答: SQLite: 原生支持，轻量级，广泛应用，但需要手动管理数据库和查询。 Realm: 高性能，简单易用，支持实时更新，但库体积较大，使用时需要注意许可证问题。 ObjectBox: 高性能，简易的对象关系映射，适用于物联网和移动设备，但相对较新，社区支持可能不如前两者。 事件传递 问: EventBus 和 RxBus 有什么区别？ 答: EventBus: 简单易用，基于发布-订阅模式，适用于组件间的简单通信。 RxBus: 基于 RxJava 实现的事件总线，支持复杂的事件流处理和异步操作，适合需要响应式编程的场景。 网络请求 问: Retrofit 是如何简化网络请求的？ 答: Retrofit 是一个基于 OkHttp 的网络请求库，通过注解和接口定义 API，简化了网络请求的处理。主要优点包括： 类型安全: 自动将 JSON 响应解析为指定的 Java 对象。 简洁的 API 定义: 通过注解定义请求方法和参数。 与 OkHttp 集成: 支持 OkHttp 的所有特性，如拦截器和缓存。 扩展性强: 支持自定义转换器和适配器，如 Gson、Moshi 和 RxJava。 JSON解析 问: Gson 和 Moshi 有什么区别？ 答: Gson: 由 Google 开发，稳定且广泛使用，支持复杂的数据结构和自定义序列化/反序列化。 Moshi: 由 Square 开发，现代化设计，支持 Kotlin 特性（如 Kotlin 类型和不可变数据类），性能更高，错误处理更友好。 性能优化 问: LeakCanary 是如何帮助检测内存泄漏的？ 答: LeakCanary 是一个内存泄漏检测库，通过监控对象的生命周期来检测内存泄漏。当检测到内存泄漏时，会生成详细的泄漏路径报告，帮助开发者快速定位和修复内存泄漏问题。 响应式 问: RxJava 的核心思想是什么？如何在 Android 中使用 RxJava？\n答: RxJava 的核心思想是响应式编程，通过 Observable 和 Observer 进行事件流处理。它允许开发者以声明性方式处理异步事件和数据流。使用 RxJava 可以简化异步操作，避免回调地狱。在 Android 中使用 RxJava，可以通过以下步骤：\n添加依赖：\nimplementation \u0026#39;io.reactivex.rxjava3:rxjava:3.0.0\u0026#39;\rimplementation \u0026#39;io.reactivex.rxjava3:rxandroid:3.0.0\u0026#39; 创建 Observable 和 Observer：\nObservable\u0026lt;String\u0026gt; observable = Observable.just(\u0026#34;Hello, RxJava\u0026#34;); Observer\u0026lt;String\u0026gt; observer = new Observer\u0026lt;String\u0026gt;() { @Override public void onSubscribe(Disposable d) {} @Override public void onNext(String s) { Log.d(\u0026#34;RxJava\u0026#34;, s); } @Override public void onError(Throwable e) {} @Override public void onComplete() {} }; observable.subscribe(observer); v\n对方正在输入… 2024/7/11 14:43:38\rimplementation \u0026#39;io.github.cymchad:BaseRecyclerViewAdapterHelper:3.0.14\u0026#39;\r对方正在输入… 2024/7/11 15:52:47\rimplementation(\u0026#34;androidx.swiperefreshlayout:swiperefreshlayout:1.0.0\u0026#34;)\r对方正在输入… 2024/7/11 16:55:18\rBaseMultiItemQuickAdapter\r对方正在输入… 2024/7/11 16:55:33\rSwipeRefreshLayout\r对方正在输入… 2024/7/11 16:56:01\rEventBus.getDefault().post\r对方正在输入… 2024/7/11 16:56:14\rGlide.with ","permalink":"https://kennems.github.io/posts/tech/%E7%AC%AC%E5%85%AD%E5%A4%A9%E7%AC%94%E8%AE%B0/","summary":"第六天笔记 组件库笔记 1. 组件库依赖、发布和使用 依赖方式对比 2.x版本 3.x版本 说明 apk runtimeOnly apk 功能同 runtimeOnly。只在生成 apk 时参与打包，编","title":"训练营第六天学习笔记"},{"content":"第四天笔记 Android UI 课程重点知识笔记 1. 了解Android控件常用属性 Android:id 任何 View 对象均可拥有与之关联的整型 ID，用于在结构树中对 View 对象进行唯一标识。 系统会以整型形式引用此 ID。 在布局 XML 文件中，系统通常以字符串的形式在 android:id 属性中指定该 ID。 // 使用系统资源 android:id=\u0026#34;@android:id/androidView\u0026#34; // 使用自己创建的资源 android:id=\u0026#34;@+id/myView\u0026#34; // 标识创建一个新资源 android:id=\u0026#34;@id/myView\u0026#34; // 使用现有资源 android:layout_width 和 android:layout_height android:layout_width 和 android:layout_height 分别表示控件的宽度和高度。 取值为 wrap_content、match_parent 和具体的数值（如 40dp）。 wrap_content：表示控件宽度/高度由内容决定。 match_parent：表示控件宽度/高度为父view允许的最大值。 \u0026lt;View android:layout_width=\u0026#34;wrap_content\u0026#34; // 设置宽 android:layout_height=\u0026#34;wrap_content\u0026#34; // 设置高 /\u0026gt; 2. 了解文本框 TextView TextView 介绍 \u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;utf-8\u0026#34;?\u0026gt; \u0026lt;LinearLayout xmlns:android=\u0026#34;http://schemas.android.com/apk/res/android\u0026#34; android:layout_width=\u0026#34;match_parent\u0026#34; android:layout_height=\u0026#34;match_parent\u0026#34; android:gravity=\u0026#34;center\u0026#34;\u0026gt; \u0026lt;TextView android:layout_width=\u0026#34;wrap_content\u0026#34; // 设置文字 android:layout_height=\u0026#34;wrap_content\u0026#34; android:background=\u0026#34;@color/teal_200\u0026#34; // 设置背景颜色 android:text=\u0026#34;Hello World\u0026#34; // 设置文本内容 android:textSize=\u0026#34;20dp\u0026#34; // 设置文字大小 android:textColor=\u0026#34;#FAFA02\u0026#34; // 设置文字颜色 android:textStyle=\u0026#34;bold\u0026#34;/\u0026gt; // 设置文字样式（normal, bold, italic） \u0026lt;/LinearLayout\u0026gt; 3. 了解按钮 Button Button 介绍 Button：在 UI 上生成一个按钮，用户点击时触发 onclick 事件。\nButton 是 TextView 的子类，所以 TextView 上的许多属性也可以应用到 Button 上。\n实际开发中对 Button 的使用：主要对按钮的几个状态做相应的操作，例如：\n按钮按下时的一种样式 松开时的另一种样式 按钮不可用时的样式等 示例代码 \u0026lt;LinearLayout xmlns:android=\u0026#34;http://schemas.android.com/apk/res/android\u0026#34; android:layout_width=\u0026#34;match_parent\u0026#34; android:layout_height=\u0026#34;match_parent\u0026#34; android:gravity=\u0026#34;center\u0026#34;\u0026gt; \u0026lt;Button android:id=\u0026#34;@+id/button\u0026#34; android:layout_width=\u0026#34;wrap_content\u0026#34; android:layout_height=\u0026#34;wrap_content\u0026#34; android:text=\u0026#34;button\u0026#34; /\u0026gt; \u0026lt;/LinearLayout\u0026gt; 4. 了解输入框 EditText EditText 介绍 EditText：输入框，是用户和 Android 应用进行数据传递的通道。通过它，可以获取到用户输入的数据。\nEditText 是一个输入框，开发中经常使用的控件，常用于需要获取用户输入的场景，例如：\n登录注册功能\n搜索功能 反馈功能等\n示例代码 \u0026lt;LinearLayout xmlns:android=\u0026#34;http://schemas.android.com/apk/res/android\u0026#34; android:layout_width=\u0026#34;match_parent\u0026#34; android:layout_height=\u0026#34;match_parent\u0026#34; android:gravity=\u0026#34;center\u0026#34; android:orientation=\u0026#34;vertical\u0026#34;\u0026gt; \u0026lt;EditText android:layout_width=\u0026#34;wrap_content\u0026#34; android:layout_height=\u0026#34;wrap_content\u0026#34; android:hint=\u0026#34;请输入内容\u0026#34; android:textColorHint=\u0026#34;@color/teal_200\u0026#34; /\u0026gt; \u0026lt;/LinearLayout\u0026gt; 5. 了解图片控件 ImageView ImageView 介绍 ImageView：用于显示图像的 View 或控件，让 App 界面更美观生动。可以直接显示 drawable 里的图片资源。 示例代码 \u0026lt;LinearLayout xmlns:android=\u0026#34;http://schemas.android.com/apk/res/android\u0026#34; android:layout_width=\u0026#34;match_parent\u0026#34; android:layout_height=\u0026#34;match_parent\u0026#34; android:gravity=\u0026#34;center\u0026#34;\u0026gt; \u0026lt;ImageView android:id=\u0026#34;@+id/image\u0026#34; android:layout_width=\u0026#34;150dp\u0026#34; android:layout_height=\u0026#34;150dp\u0026#34; android:background=\u0026#34;@drawable/icon1\u0026#34; /\u0026gt; \u0026lt;/LinearLayout\u0026gt; View常用属性 TextView 布局margin和padding View常用属性\n复杂XML\n\u0026lt;RelativeLayout xmlns:android=\u0026#34;http://schemas.android.com/apk/res/android\u0026#34; xmlns:tools=\u0026#34;http://schemas.android.com/tools\u0026#34; android:layout_width=\u0026#34;match_parent\u0026#34; android:layout_height=\u0026#34;match_parent\u0026#34; tools:context=\u0026#34;.MainActivity\u0026#34;\u0026gt; \u0026lt;!-- 顶部导航栏 --\u0026gt; \u0026lt;LinearLayout android:layout_width=\u0026#34;match_parent\u0026#34; android:layout_height=\u0026#34;wrap_content\u0026#34; android:orientation=\u0026#34;horizontal\u0026#34; android:padding=\u0026#34;10dp\u0026#34; android:background=\u0026#34;#000000\u0026#34; android:gravity=\u0026#34;center_vertical\u0026#34;\u0026gt; \u0026lt;ImageView android:layout_width=\u0026#34;40dp\u0026#34; android:layout_height=\u0026#34;40dp\u0026#34; android:src=\u0026#34;@drawable/ic_mi_logo\u0026#34; /\u0026gt; \u0026lt;EditText android:layout_width=\u0026#34;0dp\u0026#34; android:layout_height=\u0026#34;wrap_content\u0026#34; android:layout_weight=\u0026#34;1\u0026#34; android:hint=\u0026#34;平板\u0026#34; android:padding=\u0026#34;10dp\u0026#34; android:background=\u0026#34;@drawable/search_bar_shape\u0026#34; android:layout_marginLeft=\u0026#34;10dp\u0026#34; android:layout_marginRight=\u0026#34;10dp\u0026#34;/\u0026gt; \u0026lt;ImageView android:layout_width=\u0026#34;40dp\u0026#34; android:layout_height=\u0026#34;40dp\u0026#34; android:src=\u0026#34;@drawable/ic_scan\u0026#34; /\u0026gt; \u0026lt;ImageView android:layout_width=\u0026#34;40dp\u0026#34; android:layout_height=\u0026#34;40dp\u0026#34; android:src=\u0026#34;@drawable/ic_cart\u0026#34; /\u0026gt; \u0026lt;/LinearLayout\u0026gt; \u0026lt;!-- 主内容区域 --\u0026gt; \u0026lt;ScrollView android:layout_width=\u0026#34;match_parent\u0026#34; android:layout_height=\u0026#34;match_parent\u0026#34; android:layout_below=\u0026#34;@id/top_nav_bar\u0026#34;\u0026gt; \u0026lt;LinearLayout android:layout_width=\u0026#34;match_parent\u0026#34; android:layout_height=\u0026#34;wrap_content\u0026#34; android:orientation=\u0026#34;vertical\u0026#34;\u0026gt; \u0026lt;!-- 广告图片 --\u0026gt; \u0026lt;ImageView android:layout_width=\u0026#34;match_parent\u0026#34; android:layout_height=\u0026#34;200dp\u0026#34; android:src=\u0026#34;@drawable/ad_image\u0026#34; android:scaleType=\u0026#34;centerCrop\u0026#34; /\u0026gt; \u0026lt;!-- 产品信息 --\u0026gt; \u0026lt;LinearLayout android:layout_width=\u0026#34;match_parent\u0026#34; android:layout_height=\u0026#34;wrap_content\u0026#34; android:orientation=\u0026#34;vertical\u0026#34; android:padding=\u0026#34;10dp\u0026#34;\u0026gt; \u0026lt;TextView android:layout_width=\u0026#34;wrap_content\u0026#34; android:layout_height=\u0026#34;wrap_content\u0026#34; android:text=\u0026#34;xiaomi CIVI 3\u0026#34; android:textSize=\u0026#34;24sp\u0026#34; android:textColor=\u0026#34;#000000\u0026#34; /\u0026gt; \u0026lt;TextView android:layout_width=\u0026#34;wrap_content\u0026#34; android:layout_height=\u0026#34;wrap_content\u0026#34; android:text=\u0026#34;迪士尼100周年限定版\u0026#34; android:textSize=\u0026#34;16sp\u0026#34; android:textColor=\u0026#34;#888888\u0026#34; /\u0026gt; \u0026lt;TextView android:layout_width=\u0026#34;wrap_content\u0026#34; android:layout_height=\u0026#34;wrap_content\u0026#34; android:text=\u0026#34;影师Toy Story 专属限定款\u0026#34; android:textSize=\u0026#34;16sp\u0026#34; android:textColor=\u0026#34;#888888\u0026#34; /\u0026gt; \u0026lt;Button android:layout_width=\u0026#34;wrap_content\u0026#34; android:layout_height=\u0026#34;wrap_content\u0026#34; android:text=\u0026#34;立即购买\u0026#34; android:backgroundTint=\u0026#34;#FF0000\u0026#34; android:textColor=\u0026#34;#FFFFFF\u0026#34; android:layout_marginTop=\u0026#34;10dp\u0026#34;/\u0026gt; \u0026lt;/LinearLayout\u0026gt; \u0026lt;!-- 分类菜单 --\u0026gt; \u0026lt;LinearLayout android:layout_width=\u0026#34;match_parent\u0026#34; android:layout_height=\u0026#34;wrap_content\u0026#34; android:orientation=\u0026#34;horizontal\u0026#34; android:padding=\u0026#34;10dp\u0026#34; android:gravity=\u0026#34;center\u0026#34;\u0026gt; \u0026lt;!-- 分类项 示例 --\u0026gt; \u0026lt;LinearLayout android:layout_width=\u0026#34;0dp\u0026#34; android:layout_height=\u0026#34;wrap_content\u0026#34; android:layout_weight=\u0026#34;1\u0026#34; android:orientation=\u0026#34;vertical\u0026#34; android:gravity=\u0026#34;center\u0026#34;\u0026gt; \u0026lt;ImageView android:layout_width=\u0026#34;60dp\u0026#34; android:layout_height=\u0026#34;60dp\u0026#34; android:src=\u0026#34;@drawable/ic_category1\u0026#34; /\u0026gt; \u0026lt;TextView android:layout_width=\u0026#34;wrap_content\u0026#34; android:layout_height=\u0026#34;wrap_content\u0026#34; android:text=\u0026#34;小米笔记本\u0026#34; android:textSize=\u0026#34;14sp\u0026#34; android:textColor=\u0026#34;#000000\u0026#34; android:gravity=\u0026#34;center\u0026#34; /\u0026gt; \u0026lt;/LinearLayout\u0026gt; \u0026lt;!-- 其他分类项可以类似添加 --\u0026gt; \u0026lt;/LinearLayout\u0026gt; \u0026lt;!-- 智能生活口碑节广告 --\u0026gt; \u0026lt;ImageView android:layout_width=\u0026#34;match_parent\u0026#34; android:layout_height=\u0026#34;100dp\u0026#34; android:src=\u0026#34;@drawable/ad_smart_life\u0026#34; android:scaleType=\u0026#34;centerCrop\u0026#34; android:layout_marginTop=\u0026#34;10dp\u0026#34;/\u0026gt; \u0026lt;!-- 双旦新品手机广告 --\u0026gt; \u0026lt;ImageView android:layout_width=\u0026#34;match_parent\u0026#34; android:layout_height=\u0026#34;100dp\u0026#34; android:src=\u0026#34;@drawable/ad_new_phone\u0026#34; android:scaleType=\u0026#34;centerCrop\u0026#34; android:layout_marginTop=\u0026#34;10dp\u0026#34;/\u0026gt; \u0026lt;/LinearLayout\u0026gt; \u0026lt;/ScrollView\u0026gt; \u0026lt;!-- 底部导航栏 --\u0026gt; \u0026lt;LinearLayout android:layout_width=\u0026#34;match_parent\u0026#34; android:layout_height=\u0026#34;wrap_content\u0026#34; android:orientation=\u0026#34;horizontal\u0026#34; android:background=\u0026#34;#FFFFFF\u0026#34; android:gravity=\u0026#34;center\u0026#34; android:layout_alignParentBottom=\u0026#34;true\u0026#34;\u0026gt; \u0026lt;!-- 底部导航项 示例 --\u0026gt; \u0026lt;LinearLayout android:layout_width=\u0026#34;0dp\u0026#34; android:layout_height=\u0026#34;wrap_content\u0026#34; android:layout_weight=\u0026#34;1\u0026#34; android:orientation=\u0026#34;vertical\u0026#34; android:gravity=\u0026#34;center\u0026#34;\u0026gt; \u0026lt;ImageView android:layout_width=\u0026#34;30dp\u0026#34; android:layout_height=\u0026#34;30dp\u0026#34; android:src=\u0026#34;@drawable/ic_home\u0026#34; /\u0026gt; \u0026lt;TextView android:layout_width=\u0026#34;wrap_content\u0026#34; android:layout_height=\u0026#34;wrap_content\u0026#34; android:text=\u0026#34;首页\u0026#34; android:textSize=\u0026#34;12sp\u0026#34; android:textColor=\u0026#34;#000000\u0026#34; android:gravity=\u0026#34;center\u0026#34; /\u0026gt; \u0026lt;/LinearLayout\u0026gt; \u0026lt;!-- 其他底部导航项可以类似添加 --\u0026gt; \u0026lt;/LinearLayout\u0026gt; \u0026lt;/RelativeLayout\u0026gt; EditText ProgressBar 练习 RecycleView RecycleView.java package com.showguan.study.study_day4; import android.os.Bundle; import android.util.Log; import androidx.activity.EdgeToEdge; import androidx.appcompat.app.AppCompatActivity; import androidx.core.graphics.Insets; import androidx.core.view.ViewCompat; import androidx.core.view.WindowInsetsCompat; import androidx.recyclerview.widget.LinearLayoutManager; import androidx.recyclerview.widget.RecyclerView; import com.showguan.study.R; import com.showguan.study.study_day4.adapter.GameRecyclerAdapter; import com.showguan.study.study_day4.bean.GameBean; import java.util.ArrayList; import java.util.List; public class RecycleViewActivity extends AppCompatActivity { private static final String TAG = \u0026#34;ZhouGuan\u0026#34;; List\u0026lt;GameBean\u0026gt; data = new ArrayList\u0026lt;\u0026gt;(); @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); EdgeToEdge.enable(this); setContentView(R.layout.activity_recycle_view); RecyclerView recyclerView = findViewById(R.id.demo_recyclerview); // 1. 初始化数据 setData(); // 2. 实例化适配器 GameRecyclerAdapter adapter = new GameRecyclerAdapter(data); // 3. 设置适配器 recyclerView.setAdapter(adapter); // 4. 设置布局管理器 recyclerView.setLayoutManager(new LinearLayoutManager(this)); } private void setData() { String[] gameStatus = new String[]{\u0026#34;开始游戏\u0026#34;, \u0026#34;敬请期待\u0026#34;, \u0026#34;更新\u0026#34;, \u0026#34;预约\u0026#34;}; int[] icons = new int[]{R.drawable.game_icon1, R.drawable.game_icon2, R.drawable.game_icon3, R.drawable.game_icon4}; for (int i = 0; i \u0026lt; 100; i++) { GameBean gameBean = new GameBean(); gameBean.setGameName(\u0026#34;游戏数据\u0026#34; + i); gameBean.setGameIcon(icons[i % 4]); gameBean.setGameStatus(gameStatus[i % 4]); Log.d(TAG, gameBean.toString()); data.add(gameBean); } } } GameRecyclerAdapter.java package com.showguan.study.study_day4.adapter; import android.view.LayoutInflater; import android.view.View; import android.view.ViewGroup; import android.widget.ImageView; import android.widget.TextView; import androidx.annotation.NonNull; import androidx.recyclerview.widget.RecyclerView; import com.showguan.study.R; import com.showguan.study.study_day4.bean.GameBean; import java.util.List; public class GameRecyclerAdapter extends RecyclerView.Adapter\u0026lt;GameRecyclerAdapter.CarriageHolder\u0026gt; { // 数据列表，用于存储所有要显示的游戏数据 private final List\u0026lt;GameBean\u0026gt; mData; // 构造方法，初始化数据列表 public GameRecyclerAdapter(List\u0026lt;GameBean\u0026gt; data) { this.mData = data; } // 创建新的ViewHolder对象 @NonNull @Override public CarriageHolder onCreateViewHolder(@NonNull ViewGroup parent, int viewType) { // 加载布局文件并创建ViewHolder对象 View view = LayoutInflater.from(parent.getContext()).inflate(R.layout.carriage_view, parent, false); return new CarriageHolder(view); } // 绑定数据到ViewHolder上 @Override public void onBindViewHolder(@NonNull CarriageHolder holder, int position) { // 获取当前数据项 GameBean game = mData.get(position); // 设置游戏名称 holder.gameName.setText(game.getGameName()); // 设置游戏状态 holder.gameStatus.setText(game.getGameStatus()); // 设置游戏图标 holder.gameIcon.setImageResource(game.getGameIcon()); } // 获取数据项的数量 @Override public int getItemCount() { return mData.size(); } // 内部类，表示一个ViewHolder static class CarriageHolder extends RecyclerView.ViewHolder { // 定义ViewHolder中的视图 TextView gameName; TextView gameStatus; ImageView gameIcon; // 构造方法，绑定视图 public CarriageHolder(@NonNull View itemView) { super(itemView); // 绑定游戏名称视图 gameName = itemView.findViewById(R.id.game_name); // 确保这些ID与carriage_view.xml中的ID一致 // 绑定游戏状态视图 gameStatus = itemView.findViewById(R.id.game_status); // 绑定游戏图标视图 gameIcon = itemView.findViewById(R.id.game_icon); } } } ","permalink":"https://kennems.github.io/posts/tech/%E7%AC%AC%E5%9B%9B%E5%A4%A9%E7%AC%94%E8%AE%B0/","summary":"第四天笔记 Android UI 课程重点知识笔记 1. 了解Android控件常用属性 Android:id 任何 View 对象均可拥有与之关联的整型 ID，用于在结构树中对 View 对象进行唯一标识。 系","title":"训练营第四天学习笔记"},{"content":"第五天笔记 Android 布局与优化 基本布局 公共属性 布局类型 共有属性 layout_gravity: 控件相对于父控件的对齐方式 gravity: 控件内部的对齐方式 padding: 内间距 paddingTop: 上间距 paddingBottom: 下间距 paddingLeft: 左间距~ paddingRight: 右间距 layout_width: 控件的宽度 layout_height: 控件的高度 layout_margin: 外间距 layout_marginLeft: 控件的左间距 layout_marginRight: 控件的右间距 layout_marginTop: 控件的上间距 layout_marginBottom: 控件的下间距 示例代码 \u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;utf-8\u0026#34;?\u0026gt; \u0026lt;FrameLayout xmlns:android=\u0026#34;http://schemas.android.com/apk/res/android\u0026#34; android:layout_width=\u0026#34;match_parent\u0026#34; android:layout_height=\u0026#34;match_parent\u0026#34;\u0026gt; \u0026lt;TextView android:layout_width=\u0026#34;300dp\u0026#34; android:layout_height=\u0026#34;300dp\u0026#34; android:layout_weight=\u0026#34;1\u0026#34; android:gravity=\u0026#34;bottom\u0026#34; android:text=\u0026#34;AA\u0026#34; android:textSize=\u0026#34;30sp\u0026#34; android:background=\u0026#34;@color/colorPrimary\u0026#34; /\u0026gt; \u0026lt;TextView android:layout_width=\u0026#34;200dp\u0026#34; android:layout_height=\u0026#34;200dp\u0026#34; android:layout_weight=\u0026#34;2\u0026#34; android:gravity=\u0026#34;bottom\u0026#34; android:text=\u0026#34;BB\u0026#34; android:textSize=\u0026#34;30sp\u0026#34; android:background=\u0026#34;@color/colorAccent\u0026#34; /\u0026gt; \u0026lt;TextView android:layout_width=\u0026#34;100dp\u0026#34; android:layout_height=\u0026#34;100dp\u0026#34; android:layout_weight=\u0026#34;3\u0026#34; android:gravity=\u0026#34;bottom\u0026#34; android:text=\u0026#34;CC\u0026#34; android:textSize=\u0026#34;30sp\u0026#34; android:background=\u0026#34;@color/colorPrimaryDark\u0026#34; /\u0026gt; \u0026lt;/FrameLayout\u0026gt; 基本布局 FrameLayout 特点：FrameLayout 允许子视图堆叠在一起，只显示最后添加的子视图。 示例代码 \u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;utf-8\u0026#34;?\u0026gt; \u0026lt;FrameLayout xmlns:android=\u0026#34;http://schemas.android.com/apk/res/android\u0026#34; android:layout_width=\u0026#34;match_parent\u0026#34; android:layout_height=\u0026#34;match_parent\u0026#34;\u0026gt; \u0026lt;TextView android:layout_width=\u0026#34;300dp\u0026#34; android:layout_height=\u0026#34;300dp\u0026#34; android:layout_weight=\u0026#34;1\u0026#34; android:gravity=\u0026#34;bottom\u0026#34; android:text=\u0026#34;AA\u0026#34; android:textSize=\u0026#34;30sp\u0026#34; android:background=\u0026#34;@color/colorPrimary\u0026#34; /\u0026gt; \u0026lt;TextView android:layout_width=\u0026#34;200dp\u0026#34; android:layout_height=\u0026#34;200dp\u0026#34; android:layout_weight=\u0026#34;2\u0026#34; android:gravity=\u0026#34;bottom\u0026#34; android:text=\u0026#34;BB\u0026#34; android:textSize=\u0026#34;30sp\u0026#34; android:background=\u0026#34;@color/colorAccent\u0026#34; /\u0026gt; \u0026lt;TextView android:layout_width=\u0026#34;100dp\u0026#34; android:layout_height=\u0026#34;100dp\u0026#34; android:layout_weight=\u0026#34;3\u0026#34; android:gravity=\u0026#34;bottom\u0026#34; android:text=\u0026#34;CC\u0026#34; android:textSize=\u0026#34;30sp\u0026#34; android:background=\u0026#34;@color/colorPrimaryDark\u0026#34; /\u0026gt; \u0026lt;/FrameLayout\u0026gt; 效果：如右侧预览图所示，三个TextView控件堆叠在一起，显示最上层的控件内容。 LinearLayout 特点：LinearLayout 以线性排列子视图，可以设置为水平或垂直布局。 属性介绍 orientation：排列方式 horizontal：水平布局 vertical：垂直布局 layout_weight：权重 使用比例的方式来指定控件的大小 属性关系图 属性\r├─ orientation 排列方式\r│ ├─ horizontal 水平布局\r│ └─ vertical 垂直布局\r└─ layout_weight 权重：使用比例的方式来指定控件的大小 以上为Android布局中的FrameLayout和LinearLayout的基本概念与属性介绍。\nRelativeLayout 示例 应用场景：使用 RelativeLayout 定义相对布局，以下代码展示了在不同位置放置按钮的示例。\n\u0026lt;RelativeLayout xmlns:android=\u0026#34;http://schemas.android.com/apk/res/android\u0026#34; android:layout_width=\u0026#34;match_parent\u0026#34; android:layout_height=\u0026#34;match_parent\u0026#34;\u0026gt; \u0026lt;Button android:layout_width=\u0026#34;150dp\u0026#34; android:layout_height=\u0026#34;150dp\u0026#34; android:layout_alignParentLeft=\u0026#34;true\u0026#34; android:text=\u0026#34;左上角\u0026#34; android:textSize=\u0026#34;30dp\u0026#34; /\u0026gt; \u0026lt;Button android:layout_width=\u0026#34;150dp\u0026#34; android:layout_height=\u0026#34;150dp\u0026#34; android:layout_alignParentRight=\u0026#34;true\u0026#34; android:text=\u0026#34;右上角\u0026#34; android:textSize=\u0026#34;30dp\u0026#34; /\u0026gt; \u0026lt;Button android:layout_width=\u0026#34;150dp\u0026#34; android:layout_height=\u0026#34;150dp\u0026#34; android:layout_alignParentBottom=\u0026#34;true\u0026#34; android:text=\u0026#34;左下角\u0026#34; android:textSize=\u0026#34;30dp\u0026#34; /\u0026gt; \u0026lt;Button android:layout_width=\u0026#34;150dp\u0026#34; android:layout_height=\u0026#34;150dp\u0026#34; android:layout_alignParentBottom=\u0026#34;true\u0026#34; android:layout_alignParentRight=\u0026#34;true\u0026#34; android:text=\u0026#34;右下角\u0026#34; android:textSize=\u0026#34;30dp\u0026#34; /\u0026gt; \u0026lt;Button android:layout_width=\u0026#34;150dp\u0026#34; android:layout_height=\u0026#34;150dp\u0026#34; android:layout_centerInParent=\u0026#34;true\u0026#34; android:text=\u0026#34;中间\u0026#34; android:textSize=\u0026#34;30dp\u0026#34; /\u0026gt; \u0026lt;/RelativeLayout\u0026gt; ConstraintLayout 特点：可以灵活控制子控件的位置和大小的新布局方式。\n这张图展示了 ConstraintLayout 类及其相关属性和方法,让我们深入了解其作用:\nConstraintLayout 是 Android 中一种强大的布局管理器,它允许开发者通过定义各视图之间的约束关系来实现复杂的布局。\n属性 layout_constraintX_bias 和 layout_constraintCircle 等用于控制视图在父容器中的位置和方向。\nlayout_constraintX 系列属性用于定义视图间的对齐关系,如 layout_constraintLeft_toLeftOf、layout_constraintRight_toRightOf 等。\nlayout_constraintDimensionRatio 属性可用于设置视图的宽高比。\napp:layout_constrainedWidth/Height 属性控制视图是否受约束。\nGuidelineLink 和 Chain 则提供了更复杂的布局能力,如将多个视图串联成一个整体。\nlayout_goneMargin 系列属性则用于控制当关联的视图不可见时,其他视图的边距。\n总的来说,ConstraintLayout 提供了丰富的属性和方法,允许开发者以编程方式定义复杂的视图布局关系,非常适用于需要灵活、动态布局的场景。掌握好这些概念对于开发高质量的 Android 应用程序至关重要。\n相对定位 说明：如下图所示，TextView2 在 TextView1 的右边，TextView3 在 TextView1 的下面，这个时候在布局文件里面应该这样写：\n\u0026lt;TextView android:id=\u0026#34;@+id/TextView1\u0026#34; ... android:text=\u0026#34;TextView1\u0026#34; /\u0026gt; \u0026lt;TextView android:id=\u0026#34;@+id/TextView2\u0026#34; ... app:layout_constraintLeft_toRightOf=\u0026#34;@+id/TextView1\u0026#34; /\u0026gt; \u0026lt;TextView android:id=\u0026#34;@+id/TextView3\u0026#34; ... app:layout_constraintTop_toBottomOf=\u0026#34;@+id/TextView1\u0026#34; /\u0026gt; 角度定位 说明：利用 ConstraintLayout 实现更为灵活的控件布局。\n角度定位\n角度定位指的是可以用一个角度和一个距离来约束两个空间的中心。以下是一个示例：\n\u0026lt;TextView android:id=\u0026#34;@+id/TextView1\u0026#34; android:layout_width=\u0026#34;wrap_content\u0026#34; android:layout_height=\u0026#34;wrap_content\u0026#34; /\u0026gt; \u0026lt;TextView android:id=\u0026#34;@+id/TextView2\u0026#34; android:layout_width=\u0026#34;wrap_content\u0026#34; android:layout_height=\u0026#34;wrap_content\u0026#34; app:layout_constraintCircle=\u0026#34;@+id/TextView1\u0026#34; app:layout_constraintCircleAngle=\u0026#34;120\u0026#34; app:layout_constraintCircleRadius=\u0026#34;150dp\u0026#34; /\u0026gt; 约束布局 上面的例子中的 TextView2 用到了 3 个属性：\napp:layout_constraintCircle=\u0026#34;@+id/TextView1\u0026#34;：指定参考视图 TextView1。\rapp:layout_constraintCircleAngle=\u0026#34;120\u0026#34;：指定角度为 120 度。\rapp:layout_constraintCircleRadius=\u0026#34;150dp\u0026#34;：指定距离为 150dp。 居中和偏移\n在 RelativeLayout 中，把控件放在布局中间的方法是把 layout_centerInParent 设为 true，而在 ConstraintLayout 中的写法是：\napp:layout_constraintBottom_toBottomOf=\u0026#34;parent\u0026#34; app:layout_constraintLeft_toLeftOf=\u0026#34;parent\u0026#34; app:layout_constraintRight_toRightOf=\u0026#34;parent\u0026#34; app:layout_constraintTop_toTopOf=\u0026#34;parent\u0026#34; 这意味着把控件的上下左右约束在布局的上下左右，这样就能把控件放在布局的中间了。同理，RelativeLayout 中的水平居中 layout_centerHorizontal 相当于在 ConstraintLayout 约束控件的左右为 parent 的左右；RelativeLayout 中的垂直居中 layout_centerVertical 相当于在 ConstraintLayout 约束控件的上下为 parent 的上下。 链\n如果两个或以上控件通过下图的方式约束在一起，就可以认为它们是一条链（图为横向的链，纵向同理）。\n布局优化和加载原理 掌握常用布局的用法、特性，能实现简单的布局。 布局加载原理\n了解布局加载过程，不要求一定掌握。 布局优化\n了解布局优化的方法：\nInclude的用法\rMerge的用法\rViewStub的用法\r约束布局代码示例\n\u0026lt;TextView android:id=\u0026#34;@+id/TextView1\u0026#34; android:layout_width=\u0026#34;wrap_content\u0026#34; android:layout_height=\u0026#34;wrap_content\u0026#34; app:layout_constraintLeft_toLeftOf=\u0026#34;parent\u0026#34; app:layout_constraintRight_toLeftOf=\u0026#34;@id/TextView2\u0026#34; /\u0026gt; \u0026lt;TextView android:id=\u0026#34;@+id/TextView2\u0026#34; android:layout_width=\u0026#34;wrap_content\u0026#34; android:layout_height=\u0026#34;wrap_content\u0026#34; app:layout_constraintLeft_toRightOf=\u0026#34;@id/TextView1\u0026#34; app:layout_constraintRight_toLeftOf=\u0026#34;@id/TextView3\u0026#34; app:layout_constraintRight_toRightOf=\u0026#34;parent\u0026#34; /\u0026gt; \u0026lt;TextView android:id=\u0026#34;@+id/TextView3\u0026#34; android:layout_width=\u0026#34;wrap_content\u0026#34; android:layout_height=\u0026#34;wrap_content\u0026#34; app:layout_constraintLeft_toRightOf=\u0026#34;@id/TextView2\u0026#34; app:layout_constraintRight_toRightOf=\u0026#34;parent\u0026#34; /\u0026gt; 说明\nTextView1 左边约束在父布局左边，右边约束在 TextView2 左边。 TextView2 左边约束在 TextView1 右边，右边约束在 TextView3 左边，同时右边约束在父布局右边。 TextView3 左边约束在 TextView2 右边，右边约束在父布局右边。\n通过这种方式，可以实现多个控件之间的相对位置约束，使得它们在布局中保持一致的排列和间距。\nViewStub 过度绘制（Overdraw) 作业 进程和进程之间数据是隔离的。跑多个线程\n","permalink":"https://kennems.github.io/posts/tech/%E7%AC%AC%E4%BA%94%E5%A4%A9%E7%AC%94%E8%AE%B0/","summary":"第五天笔记 Android 布局与优化 基本布局 公共属性 布局类型 共有属性 layout_gravity: 控件相对于父控件的对齐方式 gravity: 控件内部的对齐方式 padding: 内间距 paddingTop: 上间距 paddingBottom: 下间距 paddingLeft: 左间距~ paddingRight: 右","title":"训练营第五天学习笔记"},{"content":"第三天笔记 Fragment 重点知识总结 1. fragment背景 Fragment的诞生 引入版本: Android 3.0 (API 11)\n背景和目的:\n初衷是为了适应大屏幕的平板电脑，由于平板电脑的屏幕比手机屏幕更大，因此可以容纳更多的UI组件，且这些UI组件之间存在交互关系。\n使用Fragment对UI组件进行分组、模块化管理，就可以更方便地在运行过程中动态更新Activity的用户界面。 作为一个微型Activity而诞生，迈出了缩减Activity之路上的一步。\n2. 创建fragment 添加Fragment依赖 Fragment需要依赖于AndroidX Fragment库： 添加Google Maven代码库，并在build.gradle中添加此依赖项。 dependencyResolutionManagement { repositoriesMode.set(RepositoriesMode.FAIL_ON_PROJECT_REPOS) repositories { google() } } dependencies { def fragment_version = \u0026#34;1.5.5\u0026#34; // Java language implementation implementation \u0026#34;androidx.fragment:fragment:$fragment_version\u0026#34; // Kotlin implementation \u0026#34;androidx.fragment:fragment-ktx:$fragment_version\u0026#34; } 查看gradle版本依赖：\n./gradlew app:dependencies 创建Fragment 在res/layout文件夹下，创建example_fragment.xml布局文件： \u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;utf-8\u0026#34;?\u0026gt; \u0026lt;LinearLayout xmlns:android=\u0026#34;http://schemas.android.com/apk/res/android\u0026#34; android:orientation=\u0026#34;vertical\u0026#34; android:layout_width=\u0026#34;match_parent\u0026#34; android:layout_height=\u0026#34;match_parent\u0026#34;\u0026gt; \u0026lt;TextView android:layout_width=\u0026#34;wrap_content\u0026#34; android:layout_height=\u0026#34;wrap_content\u0026#34; android:text=\u0026#34;Fragment View\u0026#34;/\u0026gt; \u0026lt;/LinearLayout\u0026gt; 创建ExampleFragment类，继承Fragment类，并向基本构造函数提供Fragment的布局资源： class ExampleFragment extends Fragment { public ExampleFragment() { super(R.layout.example_fragment); } } Fragment 事务操作 add 和 replace 操作 add: 不会删除容器内已存在的Fragment 原Fragment生命周期不受影响 原Fragment会被保存和自动恢复 内存占用多 搭配hide/show使用 replace: 删除容器内已存在的Fragment 原Fragment被销毁 原Fragment状态无法恢复 内存占用少 事务commit的几种方式 方法 说明 commit 非立即执行，将消息发送到主线程队列等待执行。需要立即执行时配合executePendingTransactions将队列中所有事务全部执行。 commitNow 立刻仅执行当前事务，不能与addToBackStack同时使用。 commitAllowingStateLoss onDestroy时提交不再抛出IllegalStateException，而是丢弃提交的Fragment。 commitNowAllowingStateLoss 立刻执行并允许状态丢失。 \u0026lt;!-- android:label=\u0026#34;@string/app_name\u0026#34;--\u0026gt; 随堂练习\n目标： 掌握Fragment生命周期的执行过程\nTodo List:\n在MainActivity、DemoFragment和DemoFragment2生命周期各方法中添加日志 分析启动并添加DemoFragment时的生命周期日志 分析按下Home键后的生命周期日志 分析使用add与replace显示DemoFragment2时生命周期日志差异 分析按下返回键后的生命周期日志 Fragment通信 每个Fragment应为完全独立的模块化组件，定义它自己的布局和行为 两个Fragment不能直接通信 通信方式：\n与Activity通信\n外部对外public方法\nFragment Result API\nFragment动画 可以使用按钮实现\n重点：Activity BroadCastReceiver Fragment\n","permalink":"https://kennems.github.io/posts/tech/%E7%AC%AC%E4%B8%89%E5%A4%A9%E7%AC%94%E8%AE%B0/","summary":"第三天笔记 Fragment 重点知识总结 1. fragment背景 Fragment的诞生 引入版本: Android 3.0 (API 11) 背景和目的: 初衷是为了适应大屏幕的平板电脑，由于平板电","title":"训练营第三天学习笔记"},{"content":"第二天笔记 Android 四大组件课程概要总结 1. Activity a. 创建\n自动创建 在新建项目后，会自动为我们创建一个 MainActivity。Activity 组成部分如下： 继承自 Activity 的类 放在 res/layout 文件夹的布局 XML 文件 在 AndroidManifest.xml 文件中声明 b. Activity 生命周期回调方法\nActivity 生命周期方法\nonCreate(): 是 - 它会在系统创建您的 Activity 时被唤起。必须在此类中调用 setContentView() 来定义 Activity 的布局。 onStart(): 否 - onCreate 完成后，Activity 将进入已启动状态，并对用户可见。此回调通常会在 Activity 进入前台与用户互动之前的最后准备工作。 onResume(): 否 - 系统会在 Activity 开始与用户互动之前调用此回调。此时，Activity 位于 Activity 堆栈的顶部，并获取所有用户输入。 onPause(): 否 - 当 Activity 失焦点并进入“暂停”状态时，系统会调用 onPause()。 onStop(): 否 - 当 Activity 对用户不可见时，系统会调用 onStop()。出现这种情况的原因可能是新活动启动、现有 Activity 返回前台，或销毁旧的 Activity 正在进入它“停止”状态之前即将终止的 Activity。 onRestart(): 否 - 当用户已中断的 Activity 直接重新启动时，系统会调用 onRestart()。 onDestroy(): 否 - 系统会在销毁 Activity 之前调用此回调。Activity 被销毁的最后一个回调 onDestroy() 是 Activity 进行清理工作和释放所有资源的最后机会。 Activity 理解生命周期\n通过生命周期执行顺序简化图了解生命周期的各个阶段。 c. Activity 的四种启动方式\ni. 通过如下命令查看详细的 Activity 任务栈信息：adb shell dumpsys activity activities\n这份总结涵盖了 Activity 的创建、生命周期方法及其理解、以及启动方式的概述。希望这些内容对您的学习有帮助！\nAB页面跳转： // 普通样式\rA.onPause\rB.onCreate\rB.onStart\rB.onResume\rA.stop\r// B是透明或者dialog样式\rA.onPause\rB.onCreate\rB.onStart\rB.onResume\r// B页面关闭重新回到A页面\rB.onPause\rA.onRestart\rA.onStart\rA.onResume\rB.onStop\rB.onDestory 启动模式与避坑指南笔记 定义启动模式 可以通过启动模式定义Activity的新实例如何与当前任务关联：\nAndroidManifest.xml中声明\n\u0026lt;activity android:name=\u0026#34;.YourActivity\u0026#34; android:launchMode=\u0026#34;singleTask\u0026#34; /\u0026gt; 启动模式介绍 属性值 对应 flags 描述 standard \u0026ndash; 默认模式。系统在启动Activity的任务中创建新实例，并将intent传递给该实例。每个实例可以属于不同的任务。 singleTop FLAG_ACTIVITY_SINGLE_TOP 如果当前任务的顶部已有该Activity实例，系统调用onNewIntent()方法传递intent给该实例，而不是创建新实例。 singleTask FLAG_ACTIVITY_NEW_TASK 系统会创建新任务，并实例化新的Activity。如果任务中已有该Activity实例，则调用onNewIntent()方法传递intent，而不是创建新实例。 singleInstance \u0026ndash; 与singleTask相似，唯一不同是该模式下的Activity在启动时会独占一个任务栈，且不会与其他Activity共享。 standard : 不管怎样都会新建activity singleTop：如果目标在任务栈的栈顶，那么直接复用实例，触发目标activity的onNewIntent方法， 如果目标任务不在任务栈的栈顶，那么新建一个目标实例，添加到任务栈 singleTask：如果任务栈内没有目标实例，则直接创建新的目标实例到任务栈，如果有，则直接把目标activity上面所有的activity都移出栈，把目标activity置于栈顶。 singleInstance： 设置singleInstance 在 Android 中，如果你希望一个 Activity 采用 singleInstance 启动模式，需要在 AndroidManifest.xml 文件中为该 Activity 设置相应的 launchMode 属性。此外，你还可以通过 Intent 设置 Flags 来控制 Activity 的启动行为。\n在 AndroidManifest.xml 中设置 singleInstance 在 AndroidManifest.xml 文件中为目标 Activity 添加 launchMode 属性，并将其值设置为 singleInstance：\n\u0026lt;activity android:name=\u0026#34;.YourActivity\u0026#34; android:launchMode=\u0026#34;singleInstance\u0026#34;\u0026gt; \u0026lt;/activity\u0026gt; 通过 Intent 设置 Flags 当你启动一个 Activity 时，可以通过设置 Intent Flags 来影响 Activity 的启动行为。常见的 Flags 包括：\nFLAG_ACTIVITY_NEW_TASK: 如果 Activity 不存在于当前任务中，将启动一个新的任务并将 Activity 放置在该任务的根上。 FLAG_ACTIVITY_CLEAR_TOP: 如果 Activity 已存在于任务中，将清除其上的所有 Activity，并将其置于顶部。 下面是一个示例代码，展示了如何使用 Intent 启动 singleInstance 模式的 Activity 并设置 Flags：\nIntent intent = new Intent(this, YourActivity.class); intent.setFlags(Intent.FLAG_ACTIVITY_NEW_TASK | Intent.FLAG_ACTIVITY_CLEAR_TOP); startActivity(intent); 结合使用 singleInstance 和 Intent Flags 结合上述方法，确保在 AndroidManifest.xml 中正确配置 singleInstance 模式，并在启动 Activity 时设置合适的 Flags。以下是一个完整的示例：\n1. 在 AndroidManifest.xml 中配置： \u0026lt;activity android:name=\u0026#34;.YourActivity\u0026#34; android:launchMode=\u0026#34;singleInstance\u0026#34;\u0026gt; \u0026lt;/activity\u0026gt; 2. 在代码中启动 Activity 并设置 Flags： Intent intent = new Intent(this, YourActivity.class); intent.setFlags(Intent.FLAG_ACTrIVITY_NEW_TASK | Intent.FLAG_ACTIVITY_CLEAR_TOP); startActivity(intent); 通过这种方式，你可以确保目标 Activity 以 singleInstance 模式启动，并根据需要设置相应的 Flags 来控制其启动行为。\nIntent两种启动方式 显式 Intent 隐式 Intent Activity 避坑指南 资源回收：在Activity的生命周期结束时，确保释放资源、取消网络请求、注销监听器等操作，以防止内存泄漏。 内存泄漏：避免在Activity中引用长生命周期对象，使用弱引用或在适当的生命周期方法中释放资源。 Context 使用：谨慎使用Context，避免持有Activity的引用，以免引发内存泄漏。尽量使用Application的Context。 生命周期管理：理解Activity的生命周期并正确地管理资源。确保在onPause、onStop、onDestroy等生命周期方法中释放资源和取消注册监听器。 横竖屏切换：当横竖屏切换时，Activity会销毁并重新创建。确保在这个过程中保存和恢复必要的状态信息，以防止用户体验的中断。 Activity-Service两种启动方式及关键方法回调（start bind） Service创建 Service的创建包括两部分：\n新建类需要继承 Service 在 AndroidManifest.xml 文件中进行声明 示例代码：\n\u0026lt;service android:name=\u0026#34;.service.FirstService\u0026#34; android:enabled=\u0026#34;true\u0026#34; android:exported=\u0026#34;true\u0026#34;\u0026gt; \u0026lt;/service\u0026gt; 启动和停止服务 方法 描述 startService() 启动服务 startForegroundService() 启动前台服务 stopService()、stopSelf() 停止服务 启动服务的生命周期 方法 描述 onCreate() 首次创建服务时，系统会（在调用 onStartCommand() 或 onBind() 之前）调用此方法来执行一次性设置程序。如果服务已在运行，则不会调用此方法。 onStartCommand() 通过 startService() 方法启动 Service 时调用此方法，执行此方法时，服务即会启动并可在后台无限期运行。 onDestroy() 当不再使用服务且准备销毁时，系统会调用此方法。 服务生命周期示意图 Call to startService() ↓ onCreate() ↓ onStartCommand() ↓ Service running ↓ onDestroy() ↓ Service shut down Service的启动与绑定 一、启动和停止服务 Service创建 新建类继承 Service\n在 AndroidManifest.xml 文件中声明\n\u0026lt;service android:name=\u0026#34;.service.FirstService\u0026#34; android:enabled=\u0026#34;true\u0026#34; android:exported=\u0026#34;true\u0026#34;\u0026gt; \u0026lt;/service\u0026gt; 启动和停止服务方法 方法 描述 startService() 启动服务 startForegroundService() 启动前台服务 stopService()、stopSelf() 停止服务 启动服务的生命周期 方法 描述 onCreate() 首次创建服务时调用，用于一次性设置程序。如果服务已在运行，则不会调用此方法。 onStartCommand() 通过 startService() 方法启动 Service 时调用此方法。 onDestroy() 服务不再使用且准备销毁时调用。 服务生命周期示意图 Call to startService()\r↓\ronCreate()\r↓\ronStartCommand()\r↓\rService running\r↓\ronDestroy()\r↓\rService shut down 二、绑定和解绑服务 绑定和解绑方法 方法 描述 bindService() 绑定服务 unbindService() 解绑服务 绑定服务的生命周期 方法 描述 onCreate() 首次创建服务时系统调用（在调用 onStartCommand() 或 onBind() 之前）。 onBind() 通过 bindService() 启动 Service 时调用，返回 IBinder 接口供客户端与服务通信。 onUnbind() 所有客户端通过 unbindService() 解绑时调用。 onDestroy() 服务不再使用且准备销毁时系统调用。 unbindService() 解绑服务。 绑定服务生命周期示意图 Call to bindService()\r↓\ronCreate()\r↓\ronBind()\r↓\rClients are bound to service\r↓\rAll clients unbind by calling unbindService()\r↓\ronUnbind()\r↓\ronDestroy()\r↓\rService shut down 三、其他概念 广播 实现方式：使用 IntentService 代码实现。 广播回调：两种实现方式。 ContentProvider 理解原理：掌握 ContentProvider 的工作机制和使用方法。 跨进程实现方式 Messenger 和 AIDL：使用 Messenger 和 AIDL 实现跨进程通信。 总结 activity: 生命周期：onCreate/onStart/onResume/onPause/onStop/onDestroy 其中 onStart：可见，不可交互 onResume:可见，可交互 onPause：可见、不可交互 onStop:不可见，不可交互 onCreate - onDestroy onStart - onStop onResume - onPause 场景1：直接A跳转B A.onpause B.oncreate B.onstart B.onresume A.stop 场景2: A跳B，但是B是透明的 or dialog样式的 A.onpause B.oncreate B.onstart B.onresume 场景3： B页面关闭，重新回到A页面 B.onpause A.onrestart A.onstart A.onReusme B.onstop B.ondestroy activity三大要素 1： 创建一个新的activity，继承自系统的AppCompatActivity 2： res/layout文件夹中创建对应的xml布局文件 3： activity 与 layout的结合，在activity.onCreate的setContentView（R.layout.xxx） 4. 清单文件中androidManifast必须要声明组件activity 启动模式 standard : 不管怎么样，都会新建一个目标activity的示例 singleTop: 如果目标activity在任务栈的栈顶，那么直接复用实例，会触发目标activity的onnewintent方法 如果目标activity不在任务栈的栈顶，新建一个目标实例，添加到任务栈 singleTask：1. 如果任务栈没有目标实例，则直接创建新的实例，添加到任务栈 2. 如果任务栈中已经存在目标activity，那么直接把目标activity上面的所有的其他activity都移除任务栈， 把目标activity置于栈顶 activity跳转： 显式跳转： Intent intent = new Intent(this,XXXActivity.class) startActivity(intent) 隐式跳转：通过action进行跳转 Intent intent = new Intent() intent.setAction(\u0026#34;xxxx\u0026#34;) startActivity 示例代码：跳转拨号页面 Intent intent = new Intent(); intent.setAction(Intent.ACTION_DIAL); intent.setData(Uri.parse(\u0026#34;tel:110\u0026#34;)); startActivity(intent); intent：组件之间消息传递的媒介，同时我们可以用它启动各个组件（activity、service） Service创建流程 1. 继承系统Service,实现抽象方法 onBind 2. 清单文件中注册组件 示例： \u0026lt;service android:name=\u0026#34;.service.MyService\u0026#34; android:exported=\u0026#34;true\u0026#34; android:enabled=\u0026#34;true\u0026#34;/\u0026gt; Service启动模式： 1. startService（new Intent(this,xxxService.class)） 触发生命周期：onCreate、onStartCommand，如果service已经创建了，则不会再次触发onCreate 2. stopService、stopSelf 触发生命周期：onDestroy 1. bindService (intent,serviceConnection,BIND_AUTO_CREATE) 触发生命周期：onCreate、onbind. 如果服务已经绑定，再次绑定不会触发生命周期 2. unBindService 触发生命周期：onDestroy intent传值： putExtra(\u0026#34;key\u0026#34;,value) value是任何数据类型 Object getExtra(\u0026#34;key\u0026#34;) 有些类型需要默认值 示例：传递 intent.putExtra(\u0026#34;name\u0026#34;,\u0026#34;唐鸿程\u0026#34;); intent.putExtra(\u0026#34;age\u0026#34;,32); intent.putExtra(\u0026#34;gender\u0026#34;,false); 示例：获取 Intent intent = getIntent(); String name = intent.getStringExtra(\u0026#34;name\u0026#34;); int age = intent.getIntExtra(\u0026#34;age\u0026#34;, 18); boolean gender = intent.getBooleanExtra(\u0026#34;gender\u0026#34;, true); 注意重点：获取的时候，是通过getIntent（），不是自己new intent() 注意点：key前后一定要保持一致 如果我们需要传递的属性比较多，可以选择使用序列化的实体类来进行传递 序列化：Serializable、Parcelable 获取对象的时候，需要转型，示例： Person person = (Person) intent.getSerializableExtra(\u0026#34;personInfo\u0026#34;); broadcastreceiver 注册方式： 1. 静态注册 step1:创建一个广播接收器 ，继承自BroadcastReceiver(不能内部类) step2:在清单文件中进行声明 \u0026lt;!-- 清单文件中 声明静态注册广播--\u0026gt; \u0026lt;receiver android:name=\u0026#34;.MyBroadCastReceiver\u0026#34; android:exported=\u0026#34;true\u0026#34;\u0026gt; \u0026lt;intent-filter\u0026gt; \u0026lt;!-- action可以开发者自己指定--\u0026gt; \u0026lt;action android:name=\u0026#34;myFirstBroadCast\u0026#34;/\u0026gt; \u0026lt;/intent-filter\u0026gt; \u0026lt;/receiver\u0026gt; step3:可以自己发送广播（可选） //发送广播 Intent intent = new Intent(); intent.setAction(\u0026#34;myFirstBroadCast\u0026#34;); //发送广播一定要指定包名 intent.setPackage(getPackageName()); sendBroadcast(intent); step4:接收并处理广播， 是在第一步自定义创建的广播接收器的onReceive方法中，处理广播，可以通过intent来获取对应的action @Override public void onReceive(Context context, Intent intent) { //获取action，后续可以根据action的不同，做逻辑区分处理 String action = intent.getAction(); switch (action){ case \u0026#34;myFirstBroadCast\u0026#34;: Toast.makeText(context,\u0026#34;第一个广播:\u0026#34; +action,Toast.LENGTH_SHORT).show(); break; case \u0026#34;secondBroadcast\u0026#34;: Toast.makeText(context,\u0026#34;第二个广播:\u0026#34; +action,Toast.LENGTH_SHORT).show(); break; } Log.d(\u0026#34;lollipop\u0026#34;,\u0026#34;llll:\u0026#34; + action); } 注意重点：如果我们想要接受到action，我们必须要保证 清单文件中注册的action和 广播发送者发送的action是一致的 ","permalink":"https://kennems.github.io/posts/tech/%E7%AC%AC%E4%BA%8C%E5%A4%A9%E7%AC%94%E8%AE%B0/","summary":"第二天笔记 Android 四大组件课程概要总结 1. Activity a. 创建 自动创建 在新建项目后，会自动为我们创建一个 MainActivity。Activity 组成部分如下：","title":"训练营第二天学习笔记"},{"content":"第一天学习笔记 老师：唐鸿程\nAndroid按照运行方式分为3阶段 JIT\tAOT AOT+JIT\nAndroid系统可以分5层 kernel 层 ，硬件抽象层 ， art c++层 ， java framework层 ， app层\n字节码对齐（Bytecode Alignment）：在 Android 应用开发中是一个优化步骤，旨在提高应用程序的启动速度和运行效率。它主要用于优化 DEX 文件的加载过程。\ngit 项目管理工具 git使用\ngit配置多个ssh账号\n1、账号密码登陆 ： git config --global user.name “xx” git config --global user.email \u0026#34;[fangqi@xiaomi.com](mailto:fangqi@xiaomi.com)\u0026#34; 需要和你的登录的账户邮箱一致 2、配置ssh方式：生成本地的指纹 ： ssh-keygen -t rsa cat /Users/{tournament}/.ssh/id_rsa.pub 将文档全部字符串复制到 gitlab 的 sshkey 3、将代码推到新仓库： git init git remote add origin [git@partner-gitlab.mioffice.cn](mailto:git@partner-gitlab.mioffice.cn):nj-trainingcollege/miclassroom240108/{yourproject}.git git add * git commit -m \u0026#34;Initial commit\u0026#34; git push -u origin master 4、拉以后仓库代码并更新 git clone [git@partner-gitlab.mioffice.cn](mailto:git@partner-gitlab.mioffice.cn):nj-trainingcollege/miclassroom240108/hello.git git status git add * git commit -m \u0026#34;Initial commit\u0026#34; git push -u origin master 5、Android studio 使用 下载 2020-2022版本的 android studio\n配置 java_home\n配置 android_home\n配置 adb_home {androidsdk} /platform-tools\n新建项目 hello\n在app目录下 找打res文件夹 新建layout文件夹 ，新建文件 activity_hello.xml\n添加代码\n\u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;utf-8\u0026#34;?\u0026gt; \u0026lt;LinearLayout xmlns:android=\u0026#34;http://schemas.android.com/apk/res/android\u0026#34; android:layout_width=\u0026#34;match_parent\u0026#34; android:layout_height=\u0026#34;match_parent\u0026#34; android:orientation=\u0026#34;vertical\u0026#34;\u0026gt; \u0026lt;TextView android:layout_width=\u0026#34;wrap_content\u0026#34; android:layout_height=\u0026#34;wrap_content\u0026#34; android:layout_margin=\u0026#34;50dp\u0026#34; android:layout_gravity=\u0026#34;center\u0026#34; android:text=\u0026#34;hello world\u0026#34;/\u0026gt; \u0026lt;/LinearLayout\u0026gt; 切换到文件mainactivity.java 文件（如果是kt文件，请删掉，新建mainactivity.java ） 改成如下代码\npackage com.example.hello; import android.app.Activity; import android.os.Bundle; public class MainActivity extends Activity { @Override protected void onCreate( Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.activity_hello); } } gradle 构建项目 ./gradlew build 如果build失败提示 java 版本问题 ，请切换到相应版本\nadb 安装 apk 手机\n找到根目录下已经编译好的 release 文件 release/app-release.apk\nadb install {rootdir}/release/app-release.apk 新建项目 签名打包 创建一个keystore。\nApplication中不要做一些耗时的操作\nADB\n其他资源 Android官方文档：https://developer.android.google.cn/docs?hl=zh-cn 各种开源代码：https://github.com/ kotlin https://kotlinlang.org/docs/home.html java： https://www.oracle.com/java/technologies/downloads/ 系统源码 https://cs.android.com/ gradle https://developer.android.google.cn/studio/build/building-cmdline?hl=zh-cn\n","permalink":"https://kennems.github.io/posts/tech/%E7%AC%AC%E4%B8%80%E5%A4%A9%E7%AC%94%E8%AE%B0/","summary":"第一天学习笔记 老师：唐鸿程 Android按照运行方式分为3阶段 JIT AOT AOT+JIT Android系统可以分5层 kernel 层 ，硬件抽象层 ， art c++层 ， java framew","title":"训练营第一天学习笔记"},{"content":"Android内存管理知识点 问题 1: 什么是垃圾回收机制？ 解答： 垃圾回收（GC）是由Java虚拟机（JVM）垃圾回收器提供的一种对内存回收的机制。它会在内存空间不足或者内存占用过高的时候，自动回收那些没有引用的对象，以释放内存资源。垃圾回收的主要目标是自动管理内存，避免内存泄漏和内存溢出。\n问题 2: JVM的内存模型有哪些部分组成？ 解答： JVM内存模型主要分为以下几部分：\n程序计数器（Program Counter Register）：记录当前线程执行的字节码指令地址。 本地方法栈（Native Method Stacks）：用于执行本地方法。 JVM栈（JVM Stacks）：每个线程一个栈，存储局部变量、操作数栈、动态链接和方法出口等。 堆（Heap）：所有线程共享的内存区域，用于存储所有对象实例和数组。堆又分为年轻代（Young Generation）和老年代（Old Generation），其中年轻代又划分为Eden区、S0区和S1区。 方法区（Method Area）：存储已被虚拟机加载的类信息、常量、静态变量和即时编译后的代码等。 运行时常量池（Runtime Constant Pool）：方法区的一部分，用于存储编译期生成的各种字面量和符号引用。 直接内存（Direct Memory）：并不是JVM规范的一部分，但被广泛使用，主要用于NIO（New Input/Output）中的缓冲区。 问题 3: 什么是引用计数算法？ 解答： 引用计数算法是一种判断对象是否是垃圾的算法。对象被创建后，系统会给该对象初始化一个引用计数器，当该对象被引用时，计数器+1；当引用失效时，计数器-1。当计数器为0时，表示该对象不再被使用，可以进行回收。\n问题 4: 引用计数算法的优缺点是什么？ 解答：\n优点：判定比较简单，效率高。 缺点：无法避免循环引用。例如，当对象A和对象B相互引用时，即使它们都不再被其他对象引用，其引用计数器也不会变为0，导致内存泄漏。 问题 5: 如何处理引用计数算法的循环引用问题？ 解答： 引用计数算法无法直接解决循环引用问题。通常需要结合其他算法，如标记-清除算法（Mark-Sweep），来处理循环引用。标记-清除算法通过从根对象出发，遍历所有可达对象并进行标记，然后回收未被标记的对象。\n补充问题 6: 常见的垃圾回收器有哪些？ 解答：\nSerial 收集器：单线程收集，适用于单核处理器和内存较小的场景。 ParNew 收集器：Serial 收集器的多线程版本，常用于多处理器系统。 Parallel Scavenge 收集器：关注吞吐量，适用于后台运算而不要求高响应速度的场景。 CMS（Concurrent Mark-Sweep）收集器：关注低延迟，适用于需要较快响应的应用。 G1（Garbage First）收集器：适用于多核处理器和大内存场景，能够提供高吞吐量和低延迟。 补充问题 7: 如何检测和解决内存泄漏？ 解答：\n工具：使用MAT（Memory Analyzer Tool）、VisualVM、JProfiler等工具。 方法：通过分析内存快照，找到长时间存在的对象，检查它们的引用链，找出可能的内存泄漏点。 编码规范：及时释放不再使用的资源，避免长时间持有对象引用，使用弱引用（WeakReference）、软引用（SoftReference）和虚引用（PhantomReference）来辅助垃圾回收。 面试提示 面试官可能会深入探讨垃圾回收器的具体实现，如Serial、Parallel、CMS、G1等不同类型的垃圾回收器。 可能会涉及内存泄漏的具体场景及排查工具和方法，如MAT（Memory Analyzer Tool）。 了解其他垃圾回收算法及其优缺点，如标记-清除算法、标记-压缩算法、分代收集算法等。 熟悉各种垃圾回收调优参数及其配置方法，如-Xms、-Xmx、-XX、-XX 等。 可达性分析法 问题 1: 什么是可达性分析法？\n解答： 可达性分析法是一种垃圾回收算法，通过从根对象（GC Roots）开始，沿着引用链遍历整个对象图。如果一个对象到GC Roots没有任何引用链相连，则认为该对象不可达，可以被垃圾回收。\n问题 2: GC Roots包含哪些对象？\n解答： GC Roots包含以下几类对象：\n虚拟机栈（Java线程栈）中引用的对象：例如栈帧中的本地变量表。 方法区中类静态属性引用的对象：例如静态变量引用的对象。 方法区中常量引用的对象：例如常量池中的引用。 本地方法栈中JNI（Native方法）引用的对象。 问题 3: 在可达性分析中，如果一个对象不可达，是否立即被回收？\n解答： 不一定。即使一个对象在可达性分析中被判定为不可达，它也不会立即被回收。它将首先进入一个“缓冲阶段”（如在Java中会经历两次标记过程），以防止对象在缓冲阶段中被错误地回收。只有在缓冲阶段结束后，且对象仍然不可达时，才会被标记为真正的垃圾，进行回收。\nJava 中的对象引用 问题 4: Java中的对象引用有几种类型？\n解答： Java中的对象引用有四种类型：\n强引用（Strong Reference）： 示例：Object obj = new Object(); 特点：最常见的引用类型，垃圾回收器不会回收这类对象，即使内存不足，也会抛出OutOfMemoryError错误。 软引用（Soft Reference）： 特点：比强引用弱一些，当内存不足时，垃圾回收器会回收软引用指向的对象，以避免内存溢出。常用于实现缓存。 示例：SoftReference\u0026lt;Object\u0026gt; softRef = new SoftReference\u0026lt;\u0026gt;(new Object()); 弱引用（Weak Reference）： 特点：比软引用更弱，只要垃圾回收器运行，不论内存是否充足，都会回收弱引用指向的对象。常用于防止内存泄漏。 示例：WeakReference\u0026lt;Object\u0026gt; weakRef = new WeakReference\u0026lt;\u0026gt;(new Object()); 虚引用（Phantom Reference）： 特点：最弱的引用，不能通过虚引用来访问对象，唯一的作用是在对象被回收时收到一个系统通知，通常用来实现一些清理机制。 示例：PhantomReference\u0026lt;Object\u0026gt; phantomRef = new PhantomReference\u0026lt;\u0026gt;(new Object(), new ReferenceQueue\u0026lt;\u0026gt;()); 问题 5: 软引用和弱引用的区别是什么？\n解答：\n软引用： 在内存不足时，垃圾回收器会回收软引用指向的对象，以避免内存溢出。 适用于实现缓存，当内存足够时，保留对象；当内存不足时，回收对象。 弱引用： 只要垃圾回收器运行，不论内存是否充足，都会回收弱引用指向的对象。 适用于防止内存泄漏，如避免长生命周期对象引用短生命周期对象。 问题 6: 什么是虚引用，有什么用处？\n解答：\n虚引用（Phantom Reference）： 也称为幽灵引用或幻影引用，是最弱的一种引用关系。 作用：不能通过虚引用访问对象，主要用于在对象被垃圾回收时收到一个系统通知，从而进行相关清理操作。它为对象设置一个虚引用关联，这样对象被收集器回收时，会收到通知。 面试提示 面试官可能会深入探讨可达性分析法的具体实现和优化策略。 了解如何在实际项目中应用不同类型的引用，特别是软引用和弱引用的应用场景。 可以准备一些实际案例，说明如何使用这些引用类型来优化内存管理和防止内存泄漏。 Java中的对象引用 问题 1: Java中的对象引用有几种类型？请解释它们的特点。\n解答： Java中的对象引用有四种类型：\n强引用（Strong Reference）： 示例：Object obj = new Object(); 特点：最常见的引用类型，垃圾回收器不会回收这类对象，即使内存不足，也会抛出OutOfMemoryError错误。 软引用（Soft Reference）： 特点：比强引用弱一些，当内存不足时，垃圾回收器会回收软引用指向的对象，以避免内存溢出。常用于实现缓存。 示例：SoftReference\u0026lt;Object\u0026gt; softRef = new SoftReference\u0026lt;\u0026gt;(new Object()); 弱引用（Weak Reference）： 特点：比软引用更弱，只要垃圾回收器运行，不论内存是否充足，都会回收弱引用指向的对象。常用于防止内存泄漏。 示例：WeakReference\u0026lt;Object\u0026gt; weakRef = new WeakReference\u0026lt;\u0026gt;(new Object()); 虚引用（Phantom Reference）： 特点：最弱的引用，不能通过虚引用来访问对象，唯一的作用是在对象被回收时收到一个系统通知，通常用来实现一些清理机制。 示例：PhantomReference\u0026lt;Object\u0026gt; phantomRef = new PhantomReference\u0026lt;\u0026gt;(new Object(), new ReferenceQueue\u0026lt;\u0026gt;()); 问题 2: 软引用和弱引用的区别是什么？\n解答：\n软引用： 在内存不足时，垃圾回收器会回收软引用指向的对象，以避免内存溢出。 适用于实现缓存，当内存足够时，保留对象；当内存不足时，回收对象。 弱引用： 只要垃圾回收器运行，不论内存是否充足，都会回收弱引用指向的对象。 适用于防止内存泄漏，如避免长生命周期对象引用短生命周期对象。 问题 3: 什么是虚引用，有什么用处？\n解答：\n**虚引用（Phantom Reference）**也称为幽灵引用或幻影引用，是最弱的一种引用关系。 作用：不能通过虚引用访问对象，主要用于在对象被垃圾回收时收到一个系统通知，从而进行相关清理操作。虚引用与一个引用队列（ReferenceQueue）一起使用，当垃圾回收器准备回收一个对象时，如果发现它有虚引用，会在回收对象之前把这个虚引用加入到引用队列中。 Android内存泄漏 问题 1: 什么是内存泄漏？内存泄漏的原因是什么？\n解答： 内存泄漏是指程序中已分配的内存无法被释放或回收，导致内存资源逐渐耗尽的问题。内存泄漏的主要原因是短生命周期的对象被长生命周期的对象持有，导致短生命周期的对象无法回收。例如，Activity、Fragment、View或Service持有了一个短生命周期的对象并且未及时释放。\n问题 2: Android中哪些对象被长生命周期对象持有会导致内存泄漏？\n解答： 在Android中，以下对象被长生命周期对象持有会导致内存泄漏：\nActivity Fragment View Service 问题 3: 如何检测和解决内存泄漏问题？\n解答： 可以使用工具如LeakCanary来检测和解决内存泄漏问题。LeakCanary是Square公司为Android开发者提供的一个自动检测内存泄漏的工具。它基于MAT进行Android应用程序内存泄漏的自动化检测。通过集成LeakCanary提供的jar包到自己的工程中，一旦检测到内存泄漏，LeakCanary会dump Memory信息，并通过另一个进程分析内存泄漏的信息并展示出来，帮助开发者及时发现和定位内存泄漏问题。\n面试提示 面试官可能会深入探讨引用类型的具体实现和使用场景，特别是软引用和弱引用在实际项目中的应用。 对于内存泄漏部分，准备一些实际案例说明如何检测和解决内存泄漏问题，以及如何使用LeakCanary等工具进行内存管理优化。 了解内存泄漏的常见场景，如静态持有Activity、匿名内部类或非静态内部类、未取消的Handler或AsyncTask等。 ANR（Application Not Responding） 问题 1: 什么是ANR？\n解答： ANR的全称是Application Not Responding，即应用程序无响应。它指的是在Android应用的UI线程（主线程）中，有特定的消息（例如按键、触摸事件、广播、服务等）没有在规定时间内处理完毕，从而触发了ANR异常。\nAndroid系统通过消息处理机制，确保在规定的时间间隔内处理消息，如果超过这个时间，系统将认为应用程序无响应，并触发ANR异常。\n问题 2: ANR有哪几种类型？请详细解释每种类型。\n解答： ANR有三种类型：\nKeyDispatchTimeout： 描述：当按键或触摸事件没有在特定时间内无响应时触发。 默认时间：一般Android平台默认超时时间是5秒，但有些平台会修改这个时间，例如MTK平台超时时间为8秒。 BroadcastTimeout： 描述：当BroadcastReceiver在规定时间内无法处理完广播消息时触发。 默认时间：前台广播超时时间是10秒，后台广播超时时间是60秒。 ServiceTimeout： 描述：当Service在规定时间内无法处理完操作时触发。 默认时间：前台Service超时时间是20秒，后台Service超时时间是200秒。 问题 3: 如何检测ANR问题？\n解答： ANR发生时，系统会在日志中输出错误信息，并生成一个/data/anr/traces.txt的文件。这个文件中包含当前应用进程和系统进程的函数堆栈信息，是分析ANR原因的关键文件。通过检查这个文件，可以看到当前的CPU使用率等信息，这些都是重要的线索。\n问题 4: 主线程执行耗时操作会导致ANR，请解释并举例说明。\n解答： 主线程（UI线程）执行耗时操作，例如大量计算、循环、递归、I/O操作等，会占用主线程的时间，导致无法及时处理UI更新和用户输入，从而引发ANR。\n示例代码：\njavaCopy codemBind.textView.setOnClickListener(new View.OnClickListener() {\r@Override\rpublic void onClick(View v) {\rwhile (true) {\rLog.i(\u0026#34;TAG\u0026#34;, \u0026#34;主线程执行耗时操作\u0026#34;);\rtry {\rThread.sleep(500);\r} catch (Exception e) {\re.printStackTrace();\r}\r}\r}\r}); 问题 5: 死锁会导致ANR，请解释并举例说明。\n解答： 死锁是指两个或多个线程互相等待对方释放资源，导致线程永久阻塞。主线程长时间无法获取到所需的资源锁，导致无法响应用户操作，从而引发ANR。\n示例代码：\njavaCopy codepublic class MainThreadAnrActivity extends BaseActivity\u0026lt;ActivityHandlerBinding\u0026gt; { private final Object object = new Object(); private final String TAG = MainThreadAnrActivity.class.getSimpleName(); private boolean taskComplete = false; @Override protected void bindListener() { super.bindListener(); mBind.textView.setOnClickListener(new View.OnClickListener() { @Override public void onClick(View v) { synchronized (object) { Log.i(TAG, \u0026#34;死锁导致ANR \u0026#34; + taskComplete); } } }); new Thread(new Runnable() { @Override public void run() { synchronized (object) { try { Thread.sleep(30 * 1000); taskComplete = true; } catch (Exception e) { e.printStackTrace(); } } } }).start(); } } 面试提示 面试官可能会深入探讨ANR的具体类型和触发条件，了解如何分析和解决ANR问题。 准备一些实际项目中的ANR案例，说明如何检测、分析和解决这些问题。 熟悉ANR相关的日志文件（如traces.txt）的结构和内容，能够根据日志进行问题定位和分析。 ","permalink":"https://kennems.github.io/posts/tech/android%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E7%9F%A5%E8%AF%86%E7%82%B9/","summary":"Android内存管理知识点 问题 1: 什么是垃圾回收机制？ 解答： 垃圾回收（GC）是由Java虚拟机（JVM）垃圾回收器提供的一种对内存回收的机制","title":"Android内存管理知识点"},{"content":"Android（5） 高级控件 SpinnerDialog + ArrayAdapter XML \u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;utf-8\u0026#34;?\u0026gt; \u0026lt;LinearLayout xmlns:android=\u0026#34;http://schemas.android.com/apk/res/android\u0026#34; xmlns:app=\u0026#34;http://schemas.android.com/apk/res-auto\u0026#34; xmlns:tools=\u0026#34;http://schemas.android.com/tools\u0026#34; android:id=\u0026#34;@+id/main\u0026#34; android:layout_width=\u0026#34;match_parent\u0026#34; android:layout_height=\u0026#34;match_parent\u0026#34; tools:context=\u0026#34;.SpinnerDropdownActivity\u0026#34; android:orientation=\u0026#34;vertical\u0026#34;\u0026gt; \u0026lt;TextView android:layout_width=\u0026#34;match_parent\u0026#34; android:layout_height=\u0026#34;wrap_content\u0026#34; android:text=\u0026#34;下拉模式的列表框\u0026#34; android:textSize=\u0026#34;17sp\u0026#34;/\u0026gt; \u0026lt;Spinner android:id=\u0026#34;@id/sp_dialog\u0026#34; android:layout_width=\u0026#34;match_parent\u0026#34; android:layout_height=\u0026#34;wrap_content\u0026#34; android:spinnerMode=\u0026#34;dialog\u0026#34;/\u0026gt; \u0026lt;/LinearLayout\u0026gt; item_select.xml \u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;utf-8\u0026#34;?\u0026gt; \u0026lt;TextView xmlns:android=\u0026#34;http://schemas.android.com/apk/res/android\u0026#34; xmlns:tools=\u0026#34;http://schemas.android.com/tools\u0026#34; android:layout_width=\u0026#34;match_parent\u0026#34; android:layout_height=\u0026#34;50dp\u0026#34; android:gravity=\u0026#34;center\u0026#34; android:textColor=\u0026#34;#0000ff\u0026#34; android:textSize=\u0026#34;17sp\u0026#34; tools:text=\u0026#34;火星\u0026#34;\u0026gt; \u0026lt;/TextView\u0026gt; Java package com.showguan.chapter08; import android.os.Bundle; import android.view.View; import android.widget.AdapterView; import android.widget.ArrayAdapter; import android.widget.Spinner; import androidx.appcompat.app.AppCompatActivity; import com.showguan.chapter08.util.ToastUtil; public class SpinnerDialogActivity extends AppCompatActivity implements AdapterView.OnItemSelectedListener { private Spinner sp_dialog; private static final String[] starArray = new String[]{ \u0026#34;水星\u0026#34;, \u0026#34;金星\u0026#34;, \u0026#34;地球\u0026#34;, \u0026#34;火星\u0026#34;, \u0026#34;木星\u0026#34;, \u0026#34;土星\u0026#34;, \u0026#34;天王星\u0026#34;, \u0026#34;海王星\u0026#34; }; @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.activity_spinner_dialog); sp_dialog = findViewById(R.id.sp_dialog); ArrayAdapter\u0026lt;String\u0026gt; starAdapter = new ArrayAdapter\u0026lt;\u0026gt;(this, R.layout.item_select, starArray); sp_dialog.setPrompt(\u0026#34;🌤选择行星\u0026#34;); sp_dialog.setAdapter(starAdapter); sp_dialog.setSelection(0); sp_dialog.setOnItemSelectedListener(this); } @Override public void onItemSelected(AdapterView\u0026lt;?\u0026gt; parent, View view, int position, long id) { ToastUtil.show(this, \u0026#34;您选择了： \u0026#34; + starArray[position]); } @Override public void onNothingSelected(AdapterView\u0026lt;?\u0026gt; parent) { } } SpinnerDropdown XML \u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;utf-8\u0026#34;?\u0026gt; \u0026lt;LinearLayout xmlns:android=\u0026#34;http://schemas.android.com/apk/res/android\u0026#34; xmlns:app=\u0026#34;http://schemas.android.com/apk/res-auto\u0026#34; xmlns:tools=\u0026#34;http://schemas.android.com/tools\u0026#34; android:id=\u0026#34;@+id/main\u0026#34; android:layout_width=\u0026#34;match_parent\u0026#34; android:layout_height=\u0026#34;match_parent\u0026#34; tools:context=\u0026#34;.SpinnerDropdownActivity\u0026#34; android:orientation=\u0026#34;vertical\u0026#34;\u0026gt; \u0026lt;TextView android:layout_width=\u0026#34;match_parent\u0026#34; android:layout_height=\u0026#34;wrap_content\u0026#34; android:text=\u0026#34;下拉模式的列表框\u0026#34; android:textSize=\u0026#34;17sp\u0026#34;/\u0026gt; \u0026lt;Spinner android:id=\u0026#34;@id/sp_dropdown\u0026#34; android:layout_width=\u0026#34;match_parent\u0026#34; android:layout_height=\u0026#34;wrap_content\u0026#34; android:spinnerMode=\u0026#34;dropdown\u0026#34;/\u0026gt; \u0026lt;/LinearLayout\u0026gt; Java package com.showguan.chapter08; import android.os.Bundle; import android.view.View; import android.widget.AdapterView; import android.widget.ArrayAdapter; import android.widget.Spinner; import androidx.activity.EdgeToEdge; import androidx.appcompat.app.AppCompatActivity; import androidx.core.graphics.Insets; import androidx.core.view.ViewCompat; import androidx.core.view.WindowInsetsCompat; import com.showguan.chapter08.util.ToastUtil; public class SpinnerDropdownActivity extends AppCompatActivity implements AdapterView.OnItemSelectedListener { private Spinner sp_dropdown; private static final String[] starArray = new String[]{ \u0026#34;水星\u0026#34;, \u0026#34;金星\u0026#34;, \u0026#34;地球\u0026#34;, \u0026#34;火星\u0026#34;, \u0026#34;木星\u0026#34;, \u0026#34;土星\u0026#34;, \u0026#34;天王星\u0026#34;, \u0026#34;海王星\u0026#34; }; @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.activity_spinner_dropdown); sp_dropdown = findViewById(R.id.sp_dropdown); ArrayAdapter\u0026lt;String\u0026gt; starAdapter = new ArrayAdapter\u0026lt;\u0026gt;(this, R.layout.item_select, starArray); sp_dropdown.setAdapter(starAdapter); sp_dropdown.setSelection(0); sp_dropdown.setOnItemSelectedListener(this); } @Override public void onItemSelected(AdapterView\u0026lt;?\u0026gt; parent, View view, int position, long id) { ToastUtil.show(this, \u0026#34;您选择了： \u0026#34; + starArray[position]); } @Override public void onNothingSelected(AdapterView\u0026lt;?\u0026gt; parent) { } } SimpleAdapter简单适配器 XML \u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;utf-8\u0026#34;?\u0026gt; \u0026lt;LinearLayout xmlns:android=\u0026#34;http://schemas.android.com/apk/res/android\u0026#34; xmlns:app=\u0026#34;http://schemas.android.com/apk/res-auto\u0026#34; xmlns:tools=\u0026#34;http://schemas.android.com/tools\u0026#34; android:id=\u0026#34;@+id/main\u0026#34; android:layout_width=\u0026#34;match_parent\u0026#34; android:layout_height=\u0026#34;match_parent\u0026#34; android:orientation=\u0026#34;vertical\u0026#34; tools:context=\u0026#34;.SpinnerDropdownActivity\u0026#34;\u0026gt; \u0026lt;TextView android:layout_width=\u0026#34;match_parent\u0026#34; android:layout_height=\u0026#34;wrap_content\u0026#34; android:gravity=\u0026#34;center\u0026#34; android:text=\u0026#34;行星的简单适配器\u0026#34; android:textSize=\u0026#34;17sp\u0026#34; /\u0026gt; \u0026lt;Spinner android:id=\u0026#34;@id/sp_icon\u0026#34; android:layout_width=\u0026#34;match_parent\u0026#34; android:layout_height=\u0026#34;wrap_content\u0026#34; android:spinnerMode=\u0026#34;dropdown\u0026#34; /\u0026gt; \u0026lt;/LinearLayout\u0026gt; Java package com.showguan.chapter08; // 包名 public class SpinnerIconActivity extends AppCompatActivity implements AdapterView.OnItemSelectedListener { // 定义一个整型数组，存储星球图标的资源ID private static final int[] iconArray = { R.drawable.shuixing, R.drawable.jinxing, R.drawable.diqiu, R.drawable.huoxing, R.drawable.muxing, R.drawable.tuxing, }; // 定义一个字符串数组，存储星球的名称 private static final String[] starArray = new String[]{ \u0026#34;水星\u0026#34;, \u0026#34;金星\u0026#34;, \u0026#34;地球\u0026#34;, \u0026#34;火星\u0026#34;, \u0026#34;木星\u0026#34;, \u0026#34;土星\u0026#34;, \u0026#34;天王星\u0026#34;, \u0026#34;海王星\u0026#34; }; @Override protected void onCreate(Bundle savedInstanceState) { // onCreate方法，活动启动时调用 super.onCreate(savedInstanceState); // 调用父类的onCreate方法 setContentView(R.layout.activity_spinner_icon); // 设置活动的布局文件 List\u0026lt;Map\u0026lt;String, Object\u0026gt;\u0026gt; list = new ArrayList\u0026lt;\u0026gt;(); // 创建一个列表，用于存储图标和名称 for (int i = 0; i \u0026lt; iconArray.length; i++) { // 遍历图标数组 Map\u0026lt;String, Object\u0026gt; item = new HashMap\u0026lt;\u0026gt;(); // 创建一个HashMap对象 item.put(\u0026#34;icon\u0026#34;, iconArray[i]); // 将图标资源ID放入Map中 item.put(\u0026#34;name\u0026#34;, starArray[i]); // 将名称放入Map中 list.add(item); // 将Map添加到列表中 } // 创建一个SimpleAdapter，连接数据和布局 SimpleAdapter startAdapter = new SimpleAdapter(this, list, // 数据源 R.layout.item_simple, // 列表项布局 new String[]{\u0026#34;icon\u0026#34;, \u0026#34;name\u0026#34;}, // Map中的键 new int[]{R.id.iv_icon, R.id.tv_name}); // 布局中的视图ID Spinner sp_icon = findViewById(R.id.sp_icon); // 获取Spinner控件 sp_icon.setAdapter(startAdapter); // 为Spinner设置适配器 sp_icon.setSelection(0); // 默认选中第0项 sp_icon.setOnItemSelectedListener(this); // 设置选项选中监听器 } @Override public void onItemSelected(AdapterView\u0026lt;?\u0026gt; parent, View view, int position, long id) { // 当选择一个选项时调用 ToastUtil.show(this, \u0026#34;你选择的是：\u0026#34; + starArray[position]); // 显示选择的星球名称 } @Override public void onNothingSelected(AdapterView\u0026lt;?\u0026gt; parent) { // 当没有选项被选择时调用 } } BaseAdapter基本适配器 BaseAdapter是一个抽象类，所以需要重写\nPlanetBaseAdapter.java package com.showguan.chapter08.adapter; // 包名 import android.content.Context; // 导入Context类 import android.view.LayoutInflater; // 导入LayoutInflater类 import android.view.View; // 导入View类 import android.view.ViewGroup; // 导入ViewGroup类 import android.widget.BaseAdapter; // 导入BaseAdapter类 import android.widget.ImageView; // 导入ImageView类 import android.widget.TextView; // 导入TextView类 import com.showguan.chapter08.R; // 导入项目的R类 import com.showguan.chapter08.bean.Planet; // 导入自定义的Planet类 import java.util.List; // 导入List接口 public class PlanetBaseAdapter extends BaseAdapter { // 定义PlanetBaseAdapter类，继承自BaseAdapter private Context mContext; // 上下文对象 private List\u0026lt;Planet\u0026gt; mPlanetList; // 存储Planet对象的列表 // 构造方法，初始化上下文和列表 public PlanetBaseAdapter(Context mContext, List\u0026lt;Planet\u0026gt; mPlanetList) { this.mContext = mContext; // 初始化上下文 this.mPlanetList = mPlanetList; // 初始化星球列表 } @Override public int getCount() { // 返回列表项的数量 return mPlanetList.size(); // 返回星球列表的大小 } @Override public Object getItem(int position) { // 获取指定位置的列表项 return mPlanetList.get(position); // 返回指定位置的Planet对象 } @Override public long getItemId(int position) { // 获取指定位置项的ID return position; // 返回位置作为项的ID } @Override public View getView(int position, View convertView, ViewGroup parent) { // 获取每个列表项的视图 // 根据布局文件item_base.xml生成转换视图对象 View view = LayoutInflater.from(mContext).inflate(R.layout.item_base, null); ImageView iv_icon = view.findViewById(R.id.iv_icon); // 获取图标视图 TextView tv_name = view.findViewById(R.id.tv_name); // 获取名称视图 TextView tv_desc = view.findViewById(R.id.tv_desc); // 获取描述视图 // 给控件设置数据 Planet planet = mPlanetList.get(position); // 获取当前星球对象 iv_icon.setImageResource(planet.image); // 设置图标资源 tv_name.setText(planet.name); // 设置星球名称 tv_desc.setText(planet.desc); // 设置星球描述 return view; // 返回生成的视图 } } item_base.xml \u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;utf-8\u0026#34;?\u0026gt; \u0026lt;LinearLayout xmlns:android=\u0026#34;http://schemas.android.com/apk/res/android\u0026#34; xmlns:tools=\u0026#34;http://schemas.android.com/tools\u0026#34; android:layout_width=\u0026#34;match_parent\u0026#34; android:layout_height=\u0026#34;wrap_content\u0026#34; android:orientation=\u0026#34;horizontal\u0026#34;\u0026gt; \u0026lt;ImageView android:id=\u0026#34;@+id/iv_icon\u0026#34; android:layout_width=\u0026#34;0dp\u0026#34; android:layout_height=\u0026#34;60dp\u0026#34; android:layout_weight=\u0026#34;1\u0026#34; tools:src=\u0026#34;@drawable/diqiu\u0026#34; /\u0026gt; \u0026lt;LinearLayout android:layout_width=\u0026#34;0dp\u0026#34; android:layout_height=\u0026#34;match_parent\u0026#34; android:layout_weight=\u0026#34;3\u0026#34; android:orientation=\u0026#34;vertical\u0026#34;\u0026gt; \u0026lt;TextView android:id=\u0026#34;@+id/tv_name\u0026#34; android:layout_width=\u0026#34;match_parent\u0026#34; android:layout_height=\u0026#34;wrap_content\u0026#34; android:text=\u0026#34;地球\u0026#34; android:textColor=\u0026#34;@color/black\u0026#34; android:textSize=\u0026#34;20sp\u0026#34; /\u0026gt; \u0026lt;TextView android:id=\u0026#34;@+id/tv_desc\u0026#34; android:layout_width=\u0026#34;match_parent\u0026#34; android:layout_height=\u0026#34;match_parent\u0026#34; android:text=\u0026#34;地球\u0026#34; android:textColor=\u0026#34;@color/black\u0026#34; android:textSize=\u0026#34;12sp\u0026#34; tools:text=\u0026#34;地球快一点毁灭吧！地球快一点毁灭吧！地球快一点毁灭吧！地球快一点毁灭吧！地球快一点毁灭吧！地球快一点毁灭吧！\u0026#34;/\u0026gt; \u0026lt;/LinearLayout\u0026gt; \u0026lt;/LinearLayout\u0026gt; BaseAdapterActivity.java package com.showguan.chapter08; // 包名 public class BaseAdapterActivity extends AppCompatActivity implements AdapterView.OnItemSelectedListener { // 定义活动类，实现选项选择监听器 private static final String[] starArray = new String[]{ // 定义星球名称数组 \u0026#34;水星\u0026#34;, \u0026#34;金星\u0026#34;, \u0026#34;地球\u0026#34;, \u0026#34;火星\u0026#34;, \u0026#34;木星\u0026#34;, \u0026#34;土星\u0026#34;, \u0026#34;天王星\u0026#34;, \u0026#34;海王星\u0026#34; }; private List\u0026lt;Planet\u0026gt; planetList; // 存储Planet对象的列表 @Override protected void onCreate(Bundle savedInstanceState) { // 活动创建时调用 super.onCreate(savedInstanceState); // 调用父类的onCreate方法 setContentView(R.layout.activity_base_adapter); // 设置活动的布局文件 Spinner sp_planet = findViewById(R.id.sp_planet); // 获取Spinner控件 planetList = Planet.getDefaultList(); // 获取默认的星球列表 PlanetBaseAdapter adapter = new PlanetBaseAdapter(this, planetList); // 创建适配器 sp_planet.setAdapter(adapter); // 为Spinner设置适配器 sp_planet.setSelection(0); // 默认选中第0项 sp_planet.setOnItemSelectedListener(this); // 设置选项选中监听器 } @Override public void onItemSelected(AdapterView\u0026lt;?\u0026gt; parent, View view, int position, long id) { // 当选择一个选项时调用 ToastUtil.show(this, \u0026#34;您选择的是\u0026#34; + planetList.get(position).name); // 显示选择的星球名称 } @Override public void onNothingSelected(AdapterView\u0026lt;?\u0026gt; parent) { // 当没有选项被选择时调用 } } BaseAdapter优化 @Override public View getView(int position, View convertView, ViewGroup parent) { // 获取每个列表项的视图 ViewHolder holder = null; if (convertView == null) { convertView = LayoutInflater.from(mContext).inflate(R.layout.item_base, null); holder = new ViewHolder(); holder.iv_icon = convertView.findViewById(R.id.iv_icon); // 获取图标视图 holder.tv_name = convertView.findViewById(R.id.tv_name); // 获取名称视图 holder.tv_desc = convertView.findViewById(R.id.tv_desc); // 获取描述视图 // 将视图持有者保存到转换视图当中 convertView.setTag(holder); } else { holder = (ViewHolder) convertView.getTag(); } Planet planet = mPlanetList.get(position); holder.iv_icon.setImageResource(planet.image); holder.tv_name.setText(planet.name); holder.tv_desc.setText(planet.desc); return convertView; } 列表视图ListView XML \u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;utf-8\u0026#34;?\u0026gt; \u0026lt;LinearLayout xmlns:android=\u0026#34;http://schemas.android.com/apk/res/android\u0026#34; xmlns:app=\u0026#34;http://schemas.android.com/apk/res-auto\u0026#34; xmlns:tools=\u0026#34;http://schemas.android.com/tools\u0026#34; android:id=\u0026#34;@+id/main\u0026#34; android:layout_width=\u0026#34;match_parent\u0026#34; android:layout_height=\u0026#34;match_parent\u0026#34; android:orientation=\u0026#34;vertical\u0026#34; tools:context=\u0026#34;.ListViewActivity\u0026#34;\u0026gt; \u0026lt;LinearLayout android:layout_width=\u0026#34;match_parent\u0026#34; android:layout_height=\u0026#34;wrap_content\u0026#34; android:orientation=\u0026#34;horizontal\u0026#34;\u0026gt; \u0026lt;CheckBox android:id=\u0026#34;@+id/ck_divider\u0026#34; android:layout_width=\u0026#34;0dp\u0026#34; android:layout_height=\u0026#34;40dp\u0026#34; android:layout_weight=\u0026#34;1\u0026#34; android:gravity=\u0026#34;start|center\u0026#34; android:text=\u0026#34;显示分割线\u0026#34; android:textSize=\u0026#34;17sp\u0026#34; /\u0026gt; \u0026lt;CheckBox android:id=\u0026#34;@+id/ck_bgc\u0026#34; android:layout_width=\u0026#34;0dp\u0026#34; android:layout_height=\u0026#34;40dp\u0026#34; android:layout_weight=\u0026#34;1\u0026#34; android:gravity=\u0026#34;start|center\u0026#34; android:text=\u0026#34;显示按压背景\u0026#34; android:textSize=\u0026#34;17sp\u0026#34; /\u0026gt; \u0026lt;/LinearLayout\u0026gt; \u0026lt;ListView android:id=\u0026#34;@+id/lv_planet\u0026#34; android:layout_width=\u0026#34;match_parent\u0026#34; android:layout_height=\u0026#34;wrap_content\u0026#34; android:divider=\u0026#34;@null\u0026#34; android:dividerHeight=\u0026#34;0dp\u0026#34; android:listSelector=\u0026#34;@color/transparent\u0026#34; /\u0026gt; \u0026lt;/LinearLayout\u0026gt; Java package com.showguan.chapter08; public class ListViewActivity extends AppCompatActivity implements AdapterView.OnItemClickListener, View.OnClickListener, CompoundButton.OnCheckedChangeListener { // 星球列表 private List\u0026lt;Planet\u0026gt; planetList; // 分割线复选框 private CheckBox ck_divider; // 背景色复选框 private CheckBox ck_bgc; // 列表视图 private ListView lv_planet; @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.activity_list_view); // 初始化列表视图 lv_planet = findViewById(R.id.lv_planet); // 初始化分割线复选框并设置监听器 ck_divider = findViewById(R.id.ck_divider); ck_divider.setOnCheckedChangeListener(this); // 初始化背景色复选框并设置监听器 ck_bgc = findViewById(R.id.ck_bgc); ck_bgc.setOnCheckedChangeListener(this); // 获取默认星球列表 planetList = Planet.getDefaultList(); // 创建适配器并设置给列表视图 PlanetBaseAdapter adapter = new PlanetBaseAdapter(this, planetList); lv_planet.setAdapter(adapter); // 设置列表项点击监听器 lv_planet.setOnItemClickListener(this); } @Override public void onItemClick(AdapterView\u0026lt;?\u0026gt; parent, View view, int position, long id) { // 当列表项被点击时，显示对应星球名称的 Toast 消息 ToastUtil.show(this, \u0026#34;您选择的是\u0026#34; + planetList.get(position).name); } @Override public void onClick(View v) { // 空实现，暂时没有需要处理的点击事件 } @Override public void onCheckedChanged(CompoundButton buttonView, boolean isChecked) { // 当复选框状态改变时调用 if (buttonView.getId() == R.id.ck_divider) { // 处理分割线复选框的状态改变 if (ck_divider.isChecked()) { // 如果复选框被选中，设置黑色分割线和高度 Drawable black = getResources().getDrawable(R.color.black, getTheme()); lv_planet.setDivider(black); lv_planet.setDividerHeight(Utils.dip2px(this, 1)); } else { // 如果复选框未选中，移除分割线 lv_planet.setDivider(null); lv_planet.setDividerHeight(Utils.dip2px(this, 0)); } } else if (buttonView.getId() == R.id.ck_bgc) { // 处理背景色复选框的状态改变 if (ck_bgc.isChecked()) { // 如果复选框被选中，设置列表项的选择器背景 lv_planet.setSelector(R.drawable.list_selector); } else { // 如果复选框未选中，设置透明背景 Drawable transparent = getResources().getDrawable(R.color.transparent, getTheme()); lv_planet.setSelector(transparent); } } } } ListView注意点 在ListView中添加按钮并设置监听时， 会导致原来的ListView中onItemClick无效，此时需要在XML文件中设置android:descendantFocusability=\u0026quot;blocksDescendants才能同时生效。\nandroid:descendantFocusability=\u0026#34;blocksDescendants\u0026#34; 网格视图GridView XML \u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;utf-8\u0026#34;?\u0026gt; \u0026lt;LinearLayout xmlns:android=\u0026#34;http://schemas.android.com/apk/res/android\u0026#34; xmlns:app=\u0026#34;http://schemas.android.com/apk/res-auto\u0026#34; xmlns:tools=\u0026#34;http://schemas.android.com/tools\u0026#34; android:id=\u0026#34;@+id/main\u0026#34; android:layout_width=\u0026#34;match_parent\u0026#34; android:layout_height=\u0026#34;wrap_content\u0026#34; android:orientation=\u0026#34;vertical\u0026#34;\u0026gt; \u0026lt;GridView android:id=\u0026#34;@+id/gv_planet\u0026#34; android:layout_width=\u0026#34;match_parent\u0026#34; android:layout_height=\u0026#34;wrap_content\u0026#34; android:numColumns=\u0026#34;2\u0026#34; android:background=\u0026#34;@color/pink\u0026#34; android:columnWidth=\u0026#34;100dp\u0026#34; android:verticalSpacing=\u0026#34;10dp\u0026#34; android:stretchMode=\u0026#34;none\u0026#34;/\u0026gt; \u0026lt;/LinearLayout\u0026gt; Java package com.showguan.chapter08; import android.os.Bundle; import android.view.View; import android.widget.AdapterView; import android.widget.GridView; import androidx.appcompat.app.AppCompatActivity; import com.showguan.chapter08.adapter.PlanetGridAdapter; import com.showguan.chapter08.entity.Planet; import com.showguan.chapter08.util.ToastUtil; import java.util.List; // GridViewActivity 类实现了 AdapterView.OnItemClickListener 接口 public class GridViewActivity extends AppCompatActivity implements AdapterView.OnItemClickListener { // 声明一个 Planet 对象的 List，用于存储行星数据 private List\u0026lt;Planet\u0026gt; planetList; @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); // 设置活动的布局文件 setContentView(R.layout.activity_grid_view); // 获取 GridView 控件 GridView gv_planet = findViewById(R.id.gv_planet); // 获取默认的行星列表 planetList = Planet.getDefaultList(); // 创建一个适配器，将行星列表传递给适配器 PlanetGridAdapter adapter = new PlanetGridAdapter(this, planetList); // 设置 GridView 的适配器 gv_planet.setAdapter(adapter); // 设置 GridView 的 item 点击事件监听器 gv_planet.setOnItemClickListener(this); // 设置 GridView 的拉伸模式 gv_planet.setStretchMode(GridView.STRETCH_COLUMN_WIDTH); } // 当 GridView 的 item 被点击时调用此方法 @Override public void onItemClick(AdapterView\u0026lt;?\u0026gt; parent, View view, int position, long id) { // 显示一个 Toast，提示用户选择了哪个行星 ToastUtil.show(this, \u0026#34;你选择了\u0026#34; + planetList.get(position).name); } } 使用GridView重构购物车 XML \u0026lt;LinearLayout xmlns:android=\u0026#34;http://schemas.android.com/apk/res/android\u0026#34; android:layout_width=\u0026#34;match_parent\u0026#34; android:layout_height=\u0026#34;match_parent\u0026#34; android:background=\u0026#34;@color/AntiqueWhite1\u0026#34; android:orientation=\u0026#34;vertical\u0026#34;\u0026gt; \u0026lt;include layout=\u0026#34;@layout/title_shopping\u0026#34; /\u0026gt; \u0026lt;GridView android:id=\u0026#34;@+id/gv_channel\u0026#34; android:layout_width=\u0026#34;match_parent\u0026#34; android:layout_height=\u0026#34;wrap_content\u0026#34; android:numColumns=\u0026#34;2\u0026#34; /\u0026gt; \u0026lt;/LinearLayout\u0026gt; Java GoodsGridAdapter.java package com.showguan.chapter08.adapter; import android.content.Context; import android.net.Uri; import android.view.LayoutInflater; import android.view.View; import android.view.ViewGroup; import android.widget.BaseAdapter; import android.widget.Button; import android.widget.ImageView; import android.widget.TextView; import com.showguan.chapter08.R; import com.showguan.chapter08.ShoppingChannelActivity; import com.showguan.chapter08.entity.GoodsInfo; import java.util.List; public class GoodsGridAdapter extends BaseAdapter { public Context mContext; public List\u0026lt;GoodsInfo\u0026gt; mGoodsInfo; private AddCartListener mAddCartListener; public GoodsGridAdapter(Context mContext, List\u0026lt;GoodsInfo\u0026gt; mGoodsInfo, AddCartListener addCartListener) { this.mContext = mContext; this.mGoodsInfo = mGoodsInfo; this.mAddCartListener = addCartListener; } @Override public int getCount() { return mGoodsInfo.size(); } @Override public Object getItem(int position) { return mGoodsInfo.get(position); } @Override public long getItemId(int position) { return position; } @Override public View getView(int position, View convertView, ViewGroup parent) { GoodsInfo goodsInfo = mGoodsInfo.get(position); ViewHolder holder; if(convertView == null){ holder = new ViewHolder(); // 将 XML 布局文件扩展为相应的 View 对象的类 convertView = LayoutInflater.from(mContext).inflate(R.layout.item_goods, null); holder.iv_thumb = convertView.findViewById(R.id.iv_thumb); holder.tv_name = convertView.findViewById(R.id.tv_name); holder.tv_price = convertView.findViewById(R.id.tv_price); holder.btn_add = convertView.findViewById(R.id.btn_add); convertView.setTag(holder); }else{ holder = (ViewHolder) convertView.getTag(); } GoodsInfo info = mGoodsInfo.get(position); holder.iv_thumb.setImageURI(Uri.parse(info.picPath)); holder.tv_name.setText(info.name); holder.tv_price.setText(String.valueOf(info.price)); holder.btn_add.setOnClickListener(v -\u0026gt; { // ShoppingChannelActivity activity = (ShoppingChannelActivity) mContext; // activity.addToCart(info.id, info.name); mAddCartListener.addToCart(info.id, info.name); }); return convertView; } public final class ViewHolder{ public ImageView iv_thumb; public TextView tv_name; public TextView tv_price; public Button btn_add; } public interface AddCartListener{ abstract void addToCart(int goodsId, String goodsName); } } ShoppingChannelActivity.java package com.showguan.chapter08; // ShoppingChannelActivity 类实现了 GoodsGridAdapter.AddCartListener 和 View.OnClickListener 接口 public class ShoppingChannelActivity extends AppCompatActivity implements GoodsGridAdapter.AddCartListener, View.OnClickListener { private static String TAG = \u0026#34;Kennem\u0026#34;; // 日志标签 private ShoppingDBHelper mDBHelper; // 数据库助手对象 private TextView tv_title; // 显示标题的 TextView private GridView gv_channel; // 显示商品的 GridView private TextView tv_count; // 显示购物车商品数量的 TextView @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); // 设置活动的布局文件 setContentView(R.layout.activity_shopping_channel); // 初始化控件 tv_title = findViewById(R.id.tv_title); tv_title.setText(\u0026#34;手机商城\u0026#34;); tv_count = findViewById(R.id.tv_count); gv_channel = findViewById(R.id.gv_channel); // 设置点击事件监听器 findViewById(R.id.iv_back).setOnClickListener(this); findViewById(R.id.iv_cart).setOnClickListener(this); // 初始化数据库助手并打开读写链接 mDBHelper = ShoppingDBHelper.getInstance(this); mDBHelper.openWriteLink(); mDBHelper.openReadLink(); // 显示商品信息 showGoods(); } @Override protected void onResume() { super.onResume(); // 在活动恢复时，显示购物车的总信息 showCartTotalInfo(); } // 显示购物车总信息的方法 private void showCartTotalInfo() { int count = mDBHelper.countCartInfo(); MyApplication.getInstance().goodsCount = count; tv_count.setText(String.valueOf(count)); } // 显示商品信息的方法 private void showGoods() { List\u0026lt;GoodsInfo\u0026gt; list = mDBHelper.queryAllGoods(); GoodsGridAdapter adapter = new GoodsGridAdapter(this, list, this); gv_channel.setAdapter(adapter); } // 添加商品到购物车的方法 @Override public void addToCart(int goodsId, String name) { mDBHelper.insertCartInfo(goodsId); int count = ++MyApplication.getInstance().goodsCount; tv_count.setText(String.valueOf(count)); ToastUtil.show(this, \u0026#34;已添加一部 \u0026#34; + name + \u0026#34;到购物车成功！\u0026#34;); } @Override protected void onDestroy() { super.onDestroy(); // 在活动销毁时，关闭数据库链接 mDBHelper.closeLink(); } // 处理点击事件的方法 @Override public void onClick(View v) { if (v.getId() == R.id.iv_back) { // 点击返回按钮时，结束当前活动 finish(); } else if (v.getId() == R.id.iv_cart) { // 点击购物车按钮时，启动购物车活动 Intent intent = new Intent(this, ShoppingCartActivity.class); intent.setFlags(Intent.FLAG_ACTIVITY_SINGLE_TOP); startActivity(intent); } } @Override public void onPointerCaptureChanged(boolean hasCapture) { super.onPointerCaptureChanged(hasCapture); } } ViewPager XML \u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;utf-8\u0026#34;?\u0026gt; \u0026lt;LinearLayout xmlns:android=\u0026#34;http://schemas.android.com/apk/res/android\u0026#34; xmlns:app=\u0026#34;http://schemas.android.com/apk/res-auto\u0026#34; xmlns:tools=\u0026#34;http://schemas.android.com/tools\u0026#34; android:id=\u0026#34;@+id/main\u0026#34; android:layout_width=\u0026#34;match_parent\u0026#34; android:layout_height=\u0026#34;match_parent\u0026#34; android:orientation=\u0026#34;vertical\u0026#34; tools:context=\u0026#34;.ViewPageActivity\u0026#34;\u0026gt; \u0026lt;androidx.viewpager.widget.ViewPager android:id=\u0026#34;@+id/vp_content\u0026#34; android:layout_width=\u0026#34;match_parent\u0026#34; android:layout_height=\u0026#34;300dp\u0026#34; /\u0026gt; \u0026lt;/LinearLayout\u0026gt; Java package com.showguan.chapter08; import android.os.Bundle; import android.view.View; import androidx.activity.EdgeToEdge; import androidx.appcompat.app.AppCompatActivity; import androidx.core.graphics.Insets; import androidx.core.view.ViewCompat; import androidx.core.view.WindowInsetsCompat; import androidx.viewpager.widget.ViewPager; import com.showguan.chapter08.adapter.ImagePagerAdapter; import com.showguan.chapter08.entity.GoodsInfo; import com.showguan.chapter08.util.ToastUtil; import java.util.ArrayList; public class ViewPageActivity extends AppCompatActivity implements ViewPager.OnPageChangeListener { // 商品信息列表 private ArrayList\u0026lt;GoodsInfo\u0026gt; mGoodsList; @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); // 设置当前活动的布局文件 setContentView(R.layout.activity_view_page); // 获取 ViewPager 控件 ViewPager vp_content = findViewById(R.id.vp_content); // 获取默认的商品信息列表 mGoodsList = GoodsInfo.getDefaultList(); // 创建 ImagePagerAdapter 适配器 ImagePagerAdapter adapter = new ImagePagerAdapter(this, mGoodsList); // 为 ViewPager 设置适配器 vp_content.setAdapter(adapter); // 设置页面变更监听器 vp_content.addOnPageChangeListener(this); } /** * 在翻页过程中触发 * @param position 当前页面位置 * @param positionOffset 页面偏移百分比 * @param positionOffsetPixels 页面偏移像素 */ @Override public void onPageScrolled(int position, float positionOffset, int positionOffsetPixels) { // 可以在这里实现页面滚动时的相关逻辑 } /** * 页面选中时触发 * @param position 选中页面的位置 */ @Override public void onPageSelected(int position) { // 显示当前选中页面的商品名称 ToastUtil.show(this, \u0026#34;当前滑动的页面为 \u0026#34; + mGoodsList.get(position).name); } /** * 翻页状态改变时触发 * @param state 页面状态 */ @Override public void onPageScrollStateChanged(int state) { // 可以在这里实现页面滚动状态变化时的相关逻辑 } } 翻页标签栏PagerTabStrip XML \u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;utf-8\u0026#34;?\u0026gt; \u0026lt;LinearLayout xmlns:android=\u0026#34;http://schemas.android.com/apk/res/android\u0026#34; xmlns:app=\u0026#34;http://schemas.android.com/apk/res-auto\u0026#34; xmlns:tools=\u0026#34;http://schemas.android.com/tools\u0026#34; android:id=\u0026#34;@+id/main\u0026#34; android:layout_width=\u0026#34;match_parent\u0026#34; android:layout_height=\u0026#34;match_parent\u0026#34; android:orientation=\u0026#34;vertical\u0026#34; tools:context=\u0026#34;.PagerTabActivity\u0026#34;\u0026gt; \u0026lt;androidx.viewpager.widget.ViewPager android:id=\u0026#34;@+id/vp_content\u0026#34; android:layout_width=\u0026#34;match_parent\u0026#34; android:layout_height=\u0026#34;wrap_content\u0026#34;\u0026gt; \u0026lt;androidx.viewpager.widget.PagerTabStrip android:id=\u0026#34;@+id/pts_tab\u0026#34; android:layout_width=\u0026#34;wrap_content\u0026#34; android:layout_height=\u0026#34;wrap_content\u0026#34; /\u0026gt; \u0026lt;/androidx.viewpager.widget.ViewPager\u0026gt; \u0026lt;/LinearLayout\u0026gt; Java package com.showguan.chapter08; import android.graphics.Color; import android.os.Bundle; import android.util.TypedValue; import android.view.View; import androidx.activity.EdgeToEdge; import androidx.appcompat.app.AppCompatActivity; import androidx.core.graphics.Insets; import androidx.core.view.ViewCompat; import androidx.core.view.WindowInsetsCompat; import androidx.viewpager.widget.PagerTabStrip; import androidx.viewpager.widget.ViewPager; import com.showguan.chapter08.adapter.ImagePagerAdapter; import com.showguan.chapter08.entity.GoodsInfo; import com.showguan.chapter08.util.ToastUtil; import java.util.ArrayList; public class PagerTabActivity extends AppCompatActivity implements ViewPager.OnPageChangeListener { // 商品信息列表 private ArrayList\u0026lt;GoodsInfo\u0026gt; mGoodsList; @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.activity_pager_tab); initPagerStrip(); initViewPager(); } // 初始化翻页标签栏 private void initPagerStrip() { PagerTabStrip pts_tab = findViewById(R.id.pts_tab); pts_tab.setTextSize(TypedValue.COMPLEX_UNIT_SP, 20); pts_tab.setTextColor(Color.GRAY); } private void initViewPager() { // 获取 ViewPager 控件 ViewPager vp_content = findViewById(R.id.vp_content); // 获取默认的商品信息列表 mGoodsList = GoodsInfo.getDefaultList(); // 创建 ImagePagerAdapter 适配器 ImagePagerAdapter adapter = new ImagePagerAdapter(this, mGoodsList); // 为 ViewPager 设置适配器 vp_content.setAdapter(adapter); // 设置页面变更监听器 vp_content.addOnPageChangeListener(this); vp_content.setCurrentItem(2); } @Override public void onPageScrolled(int position, float positionOffset, int positionOffsetPixels) { } @Override public void onPageSelected(int position) { ToastUtil.show(this, \u0026#34;当前滑动的页面为 \u0026#34; + mGoodsList.get(position).name); } @Override public void onPageScrollStateChanged(int state) { } } 简单的启动引导页 XML activity_launch_simple.xml \u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;utf-8\u0026#34;?\u0026gt; \u0026lt;LinearLayout xmlns:android=\u0026#34;http://schemas.android.com/apk/res/android\u0026#34; xmlns:app=\u0026#34;http://schemas.android.com/apk/res-auto\u0026#34; xmlns:tools=\u0026#34;http://schemas.android.com/tools\u0026#34; android:id=\u0026#34;@+id/main\u0026#34; android:layout_width=\u0026#34;match_parent\u0026#34; android:layout_height=\u0026#34;match_parent\u0026#34; android:orientation=\u0026#34;vertical\u0026#34; tools:context=\u0026#34;.LaunchSimpleActivity\u0026#34;\u0026gt; \u0026lt;androidx.viewpager.widget.ViewPager android:id=\u0026#34;@+id/vp_launch\u0026#34; android:layout_width=\u0026#34;match_parent\u0026#34; android:layout_height=\u0026#34;match_parent\u0026#34;/\u0026gt; \u0026lt;/LinearLayout\u0026gt; item_launch.xml \u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;utf-8\u0026#34;?\u0026gt; \u0026lt;RelativeLayout xmlns:android=\u0026#34;http://schemas.android.com/apk/res/android\u0026#34; xmlns:app=\u0026#34;http://schemas.android.com/apk/res-auto\u0026#34; xmlns:tools=\u0026#34;http://schemas.android.com/tools\u0026#34; android:id=\u0026#34;@+id/main\u0026#34; android:layout_width=\u0026#34;match_parent\u0026#34; android:layout_height=\u0026#34;match_parent\u0026#34; android:orientation=\u0026#34;vertical\u0026#34; tools:context=\u0026#34;.LaunchSimpleActivity\u0026#34;\u0026gt; \u0026lt;ImageView android:id=\u0026#34;@+id/iv_launch\u0026#34; android:layout_width=\u0026#34;match_parent\u0026#34; android:layout_height=\u0026#34;match_parent\u0026#34; android:scaleType=\u0026#34;fitXY\u0026#34; /\u0026gt; \u0026lt;RadioGroup android:id=\u0026#34;@+id/rg_indicate\u0026#34; android:layout_width=\u0026#34;wrap_content\u0026#34; android:layout_height=\u0026#34;wrap_content\u0026#34; android:layout_alignParentBottom=\u0026#34;true\u0026#34; android:layout_centerHorizontal=\u0026#34;true\u0026#34; android:orientation=\u0026#34;horizontal\u0026#34; android:paddingBottom=\u0026#34;20dp\u0026#34; /\u0026gt; \u0026lt;Button android:id=\u0026#34;@+id/btn_launch\u0026#34; android:layout_width=\u0026#34;wrap_content\u0026#34; android:layout_height=\u0026#34;wrap_content\u0026#34; android:layout_centerInParent=\u0026#34;true\u0026#34; android:text=\u0026#34;点击开始美好生活\u0026#34; android:textColor=\u0026#34;@color/blue\u0026#34; android:textSize=\u0026#34;22sp\u0026#34; android:visibility=\u0026#34;gone\u0026#34; /\u0026gt; \u0026lt;/RelativeLayout\u0026gt; Java LaunchSimpleActivity.java package com.showguan.chapter08; import android.annotation.SuppressLint; import android.os.Bundle; import android.view.View; import androidx.activity.EdgeToEdge; import androidx.appcompat.app.AppCompatActivity; import androidx.core.graphics.Insets; import androidx.core.view.ViewCompat; import androidx.core.view.WindowInsetsCompat; import androidx.viewpager.widget.ViewPager; import com.showguan.chapter08.adapter.LaunchPagerAdapter; public class LaunchSimpleActivity extends AppCompatActivity { // 定义一个数组，用于存储启动界面的背景图片资源ID private static int[] launchImageArray = { R.drawable.guide_bg1, R.drawable.guide_bg2, R.drawable.guide_bg3, R.drawable.guide_bg4 }; // 当Activity被创建时调用 @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); // 设置布局文件 setContentView(R.layout.activity_launch_simple); // 查找布局文件中的ViewPager控件 ViewPager vp_launch = findViewById(R.id.vp_launch); // 创建适配器对象，将图片数组传递进去 LaunchPagerAdapter adapter = new LaunchPagerAdapter(this, launchImageArray); // 为ViewPager设置适配器 vp_launch.setAdapter(adapter); } } LaunchPagerAdapter.java package com.showguan.chapter08.adapter; import android.content.Context; import android.view.View; import android.view.ViewGroup; import android.widget.ImageView; import androidx.annotation.NonNull; import androidx.annotation.Nullable; import androidx.viewpager.widget.PagerAdapter; import com.showguan.chapter08.ViewPageActivity; import com.showguan.chapter08.entity.GoodsInfo; import java.util.ArrayList; import java.util.List; public class ImagePagerAdapter extends PagerAdapter { private final Context mContext; private final ArrayList\u0026lt;GoodsInfo\u0026gt; mGoodsList; private List\u0026lt;ImageView\u0026gt; mViewList = new ArrayList\u0026lt;\u0026gt;(); public ImagePagerAdapter(Context context, ArrayList\u0026lt;GoodsInfo\u0026gt; goodsInfos) { this.mContext = context; this.mGoodsList = goodsInfos; for (GoodsInfo goodsInfo : mGoodsList) { ImageView view = new ImageView(mContext); view.setLayoutParams(new ViewGroup.LayoutParams( ViewGroup.LayoutParams.MATCH_PARENT, ViewGroup.LayoutParams.WRAP_CONTENT )); view.setImageResource(goodsInfo.pic); mViewList.add(view); } } @Override public int getCount() { return mViewList.size(); } @Override public boolean isViewFromObject(@NonNull View view, @NonNull Object object) { return (view == object); } // 实例化指定位置的页面，并将其添加到容器中 @NonNull @Override public Object instantiateItem(@NonNull ViewGroup container, int position) { ImageView item = mViewList.get(position); container.addView(item); return item; } // 从容器中销毁指定位置的页面 @Override public void destroyItem(@NonNull ViewGroup container, int position, @NonNull Object object) { container.removeView(mViewList.get(position)); } @Nullable @Override public CharSequence getPageTitle(int position) { return mGoodsList.get(position).name; } } 碎片Fragment ⭐⭐⭐⭐⭐ 传统的Activity并不能很好的处理大屏问题，所以急需一个碎片化的东西能够划区域的展示内容，并且有属于自己的独立可操作空间，所以就出现了Fragment。\nStaticFragment XML activity_fragement_static.xml \u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;utf-8\u0026#34;?\u0026gt; \u0026lt;LinearLayout xmlns:android=\u0026#34;http://schemas.android.com/apk/res/android\u0026#34; xmlns:app=\u0026#34;http://schemas.android.com/apk/res-auto\u0026#34; xmlns:tools=\u0026#34;http://schemas.android.com/tools\u0026#34; android:id=\u0026#34;@+id/main\u0026#34; android:layout_width=\u0026#34;match_parent\u0026#34; android:layout_height=\u0026#34;match_parent\u0026#34; tools:context=\u0026#34;.FragmentStaticActivity\u0026#34; android:orientation=\u0026#34;vertical\u0026#34;\u0026gt; \u0026lt;androidx.fragment.app.FragmentContainerView android:id=\u0026#34;@+id/fragment_static\u0026#34; android:name=\u0026#34;com.showguan.chapter08.fragment.StaticFragment\u0026#34; android:layout_width=\u0026#34;match_parent\u0026#34; android:layout_height=\u0026#34;60dp\u0026#34;/\u0026gt; \u0026lt;TextView android:layout_width=\u0026#34;match_parent\u0026#34; android:layout_height=\u0026#34;wrap_content\u0026#34; android:textSize=\u0026#34;@dimen/common_font_size\u0026#34; android:gravity=\u0026#34;center\u0026#34; android:text=\u0026#34;每个页面的具体内容：\u0026#34;/\u0026gt; \u0026lt;/LinearLayout\u0026gt; fragment_static.xml \u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;utf-8\u0026#34;?\u0026gt; \u0026lt;LinearLayout xmlns:android=\u0026#34;http://schemas.android.com/apk/res/android\u0026#34; xmlns:tools=\u0026#34;http://schemas.android.com/tools\u0026#34; android:layout_width=\u0026#34;match_parent\u0026#34; android:layout_height=\u0026#34;wrap_content\u0026#34; android:background=\u0026#34;@color/pink\u0026#34; android:orientation=\u0026#34;horizontal\u0026#34; tools:context=\u0026#34;.fragment.StaticFragment\u0026#34;\u0026gt; \u0026lt;TextView android:id=\u0026#34;@+id/tv_adv\u0026#34; android:layout_width=\u0026#34;0dp\u0026#34; android:layout_height=\u0026#34;match_parent\u0026#34; android:layout_weight=\u0026#34;1\u0026#34; android:gravity=\u0026#34;center\u0026#34; android:text=\u0026#34;广告图片\u0026#34; android:textColor=\u0026#34;@color/brown\u0026#34; android:textSize=\u0026#34;@dimen/common_font_size\u0026#34; /\u0026gt; \u0026lt;ImageView android:id=\u0026#34;@+id/iv_adv\u0026#34; android:layout_width=\u0026#34;0dp\u0026#34; android:layout_height=\u0026#34;match_parent\u0026#34; android:layout_weight=\u0026#34;4\u0026#34; android:scaleType=\u0026#34;fitCenter\u0026#34; android:src=\u0026#34;@drawable/adv\u0026#34; /\u0026gt; \u0026lt;/LinearLayout\u0026gt; Java FragmentStaticActivity.java package com.showguan.chapter08; import com.showguan.chapter08.adapter.PlanetBaseAdapter; import com.showguan.chapter08.entity.Planet; public class FragmentStaticActivity extends AppCompatActivity { private static final String TAG = \u0026#34;fragment\u0026#34;; @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.activity_fragement_static); } } StaticFragment.java package com.showguan.chapter08.fragment; import android.content.Context; import android.os.Bundle; import androidx.annotation.NonNull; import androidx.annotation.Nullable; import androidx.fragment.app.Fragment; import android.util.Log; import android.view.LayoutInflater; import android.view.View; import android.view.ViewGroup; import com.showguan.chapter08.R; public class StaticFragment extends Fragment { private static final String TAG = \u0026#34;fragment\u0026#34;; @Override public void onAttach(@NonNull Context context) { super.onAttach(context); Log.d(TAG, \u0026#34;Fragment onAttach: \u0026#34;); } @Override public void onCreate(@Nullable Bundle savedInstanceState) { super.onCreate(savedInstanceState); Log.d(TAG, \u0026#34;Fragment onCreate: \u0026#34;); } @Override public void onStart() { super.onStart(); Log.d(TAG, \u0026#34;Fragment onStart: \u0026#34;); } @Override public void onResume() { super.onResume(); Log.d(TAG, \u0026#34;Fragment onResume: \u0026#34;); } @Override public void onPause() { super.onPause(); Log.d(TAG, \u0026#34;Fragment onPause: \u0026#34;); } @Override public void onStop() { super.onStop(); Log.d(TAG, \u0026#34;Fragment onStop: \u0026#34;); } @Override public void onDestroy() { super.onDestroy(); Log.d(TAG, \u0026#34;Fragment onDestroy: \u0026#34;); } @Override public void onDetach() { super.onDetach(); Log.d(TAG, \u0026#34;Fragment onDetach: \u0026#34;); } @Nullable @Override public View onCreateView(@NonNull LayoutInflater inflater, @Nullable ViewGroup container, @Nullable Bundle savedInstanceState) { Log.d(TAG, \u0026#34;Fragment onCreateView: \u0026#34;); return inflater.inflate(R.layout.fragment_static, container, false); } @Override public void onActivityCreated(@Nullable Bundle savedInstanceState) { super.onActivityCreated(savedInstanceState); Log.d(TAG, \u0026#34;Fragment onActivityCreated: \u0026#34;); } } Fragment注册 静态注册在布局文件中直接指定Fragment，而动态注册直到代码中才动态添加Fragment。\nFragment声明周期 DynamicFragment 用DynamicFragment重构普通的PagerTabStrip\nXML activity_fragment_dynamic.xml \u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;utf-8\u0026#34;?\u0026gt; \u0026lt;LinearLayout xmlns:android=\u0026#34;http://schemas.android.com/apk/res/android\u0026#34; xmlns:tools=\u0026#34;http://schemas.android.com/tools\u0026#34; android:id=\u0026#34;@+id/main\u0026#34; android:layout_width=\u0026#34;match_parent\u0026#34; android:layout_height=\u0026#34;match_parent\u0026#34; android:orientation=\u0026#34;vertical\u0026#34; tools:context=\u0026#34;.FragmentDynamicActivity\u0026#34;\u0026gt; \u0026lt;androidx.viewpager.widget.ViewPager android:id=\u0026#34;@+id/vp_content\u0026#34; android:layout_width=\u0026#34;match_parent\u0026#34; android:layout_height=\u0026#34;wrap_content\u0026#34;\u0026gt; \u0026lt;androidx.viewpager.widget.PagerTabStrip android:id=\u0026#34;@+id/pts_tab\u0026#34; android:layout_width=\u0026#34;wrap_content\u0026#34; android:layout_height=\u0026#34;wrap_content\u0026#34; /\u0026gt; \u0026lt;/androidx.viewpager.widget.ViewPager\u0026gt; \u0026lt;/LinearLayout\u0026gt; fragment_dynamic.xml \u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;utf-8\u0026#34;?\u0026gt; \u0026lt;LinearLayout xmlns:android=\u0026#34;http://schemas.android.com/apk/res/android\u0026#34; xmlns:tools=\u0026#34;http://schemas.android.com/tools\u0026#34; android:layout_width=\u0026#34;match_parent\u0026#34; android:layout_height=\u0026#34;match_parent\u0026#34; tools:context=\u0026#34;.fragment.DynamicFragment\u0026#34; android:orientation=\u0026#34;vertical\u0026#34;\u0026gt; \u0026lt;ImageView android:id=\u0026#34;@+id/iv_pic\u0026#34; android:layout_width=\u0026#34;match_parent\u0026#34; android:layout_height=\u0026#34;360dp\u0026#34; android:scaleType=\u0026#34;fitCenter\u0026#34; tools:src=\u0026#34;@drawable/adv\u0026#34; /\u0026gt; \u0026lt;TextView android:id=\u0026#34;@+id/tv_desc\u0026#34; android:layout_width=\u0026#34;match_parent\u0026#34; android:layout_height=\u0026#34;wrap_content\u0026#34; android:gravity=\u0026#34;left\u0026#34; android:textColor=\u0026#34;@color/black\u0026#34; android:textSize=\u0026#34;17sp\u0026#34; tools:text=\u0026#34;Test\u0026#34; /\u0026gt; \u0026lt;/LinearLayout\u0026gt; Java FragmentDynamicActivity.java package com.showguan.chapter08; import android.graphics.Color; import android.os.Bundle; import android.util.Log; import android.util.TypedValue; import androidx.appcompat.app.AppCompatActivity; import androidx.viewpager.widget.PagerTabStrip; import androidx.viewpager.widget.ViewPager; import com.showguan.chapter08.adapter.MobilePagerAdapter; import com.showguan.chapter08.entity.GoodsInfo; import com.showguan.chapter08.util.ToastUtil; import java.util.ArrayList; public class FragmentDynamicActivity extends AppCompatActivity implements ViewPager.OnPageChangeListener { private static String TAG = \u0026#34;Kennem\u0026#34;; // 商品信息列表 private ArrayList\u0026lt;GoodsInfo\u0026gt; mGoodsList; @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.activity_fragment_dynamic); initPagerStrip(); initViewPager(); } // 初始化翻页标签栏 private void initPagerStrip() { PagerTabStrip pts_tab = findViewById(R.id.pts_tab); pts_tab.setTextSize(TypedValue.COMPLEX_UNIT_SP, 20); pts_tab.setTextColor(Color.GRAY); pts_tab.setDrawFullUnderline(false); pts_tab.setTabIndicatorColor(Color.BLUE); } private void initViewPager() { // 获取 ViewPager 控件 ViewPager vp_content = findViewById(R.id.vp_content); // 获取默认的商品信息列表 mGoodsList = GoodsInfo.getDefaultList(); Log.d(TAG, mGoodsList.toString()); // 创建 MobilePagerAdapter 适配器 MobilePagerAdapter adapter = new MobilePagerAdapter(getSupportFragmentManager(), mGoodsList); // 为 ViewPager 设置适配器 vp_content.setAdapter(adapter); // 设置页面变更监听器 vp_content.addOnPageChangeListener(this); vp_content.setCurrentItem(2); // 设置当前显示的页 } @Override public void onPageScrolled(int position, float positionOffset, int positionOffsetPixels) { // 页面滑动时触发 } @Override public void onPageSelected(int position) { // 页面选中时触发 ToastUtil.show(this, \u0026#34;当前滑动的页面为 \u0026#34; + mGoodsList.get(position).name); } @Override public void onPageScrollStateChanged(int state) { // 页面滑动状态改变时触发 } } MobilePagerAdapter.java package com.showguan.chapter08.adapter; import androidx.annotation.NonNull; import androidx.annotation.Nullable; import androidx.fragment.app.Fragment; import androidx.fragment.app.FragmentManager; import androidx.fragment.app.FragmentPagerAdapter; import com.showguan.chapter08.entity.GoodsInfo; import com.showguan.chapter08.fragment.DynamicFragment; import java.util.List; public class MobilePagerAdapter extends FragmentPagerAdapter { // 商品信息列表 private final List\u0026lt;GoodsInfo\u0026gt; mGoodsList; /** * 构造函数，初始化适配器 * @param fm FragmentManager 用于管理 Fragment 的事务 * @param mGoodsList 商品信息列表 */ public MobilePagerAdapter(@NonNull FragmentManager fm, List\u0026lt;GoodsInfo\u0026gt; mGoodsList) { super(fm, BEHAVIOR_RESUME_ONLY_CURRENT_FRAGMENT); this.mGoodsList = mGoodsList; } /** * 获取指定位置的 Fragment * @param position 位置索引 * @return 对应位置的 Fragment 实例 */ @NonNull @Override public Fragment getItem(int position) { // 从列表中获取商品信息 GoodsInfo info = mGoodsList.get(position); // 创建并返回新的 DynamicFragment 实例 return DynamicFragment.newInstance(position, info.pic, info.description); } /** * 获取列表中的项目数量 * @return 商品信息列表的大小 */ @Override public int getCount() { return mGoodsList.size(); } /** * 获取页面标题 * @param position 位置索引 * @return 对应位置的页面标题 */ @Nullable @Override public CharSequence getPageTitle(int position) { // 返回商品名称作为页面标题 return mGoodsList.get(position).name; } } DynamicFragment.java package com.showguan.chapter08.fragment; import android.os.Bundle; import androidx.fragment.app.Fragment; import android.view.LayoutInflater; import android.view.View; import android.view.ViewGroup; import android.widget.ImageView; import android.widget.TextView; import com.showguan.chapter08.R; public class DynamicFragment extends Fragment { /** * 静态工厂方法，用于创建新的 DynamicFragment 实例并传递参数 * @param position 位置索引 * @param pic_id 图片资源 ID * @param desc 描述文本 * @return 新的 DynamicFragment 实例 */ public static DynamicFragment newInstance(int position, int pic_id, String desc) { DynamicFragment fragment = new DynamicFragment(); // 参数打包 Bundle args = new Bundle(); args.putInt(\u0026#34;position\u0026#34;, position); args.putInt(\u0026#34;image_id\u0026#34;, pic_id); args.putString(\u0026#34;desc\u0026#34;, desc); fragment.setArguments(args); return fragment; } /** * 创建并返回该 fragment 的视图层次结构 * @param inflater 用于实例化布局 XML 文件的布局填充器对象 * @param container 父级视图，null 表示没有父级视图 * @param savedInstanceState 用于保存的状态 * @return 返回 fragment 的根视图 */ @Override public View onCreateView(LayoutInflater inflater, ViewGroup container, Bundle savedInstanceState) { // 使用给定的布局文件实例化视图 View view = inflater.inflate(R.layout.fragment_dynamic, container, false); // 获取传递的参数 Bundle arguments = getArguments(); if(arguments != null){ // 获取并设置 ImageView 和 TextView 的内容 ImageView iv_pic = view.findViewById(R.id.iv_pic); TextView tv_desc = view.findViewById(R.id.tv_desc); iv_pic.setImageResource(arguments.getInt(\u0026#34;image_id\u0026#34;, R.drawable.diqiu)); tv_desc.setText(arguments.getString(\u0026#34;desc\u0026#34;, \u0026#34;\u0026#34;)); } return view; } } ","permalink":"https://kennems.github.io/posts/tech/android5/","summary":"Android（5） 高级控件 SpinnerDialog + ArrayAdapter XML \u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;utf-8\u0026#34;?\u0026gt; \u0026lt;LinearLayout xmlns:android=\u0026#34;http://schemas.android.com/apk/res/android\u0026#34; xmlns:app=\u0026#34;http://schemas.android.com/apk/res-auto\u0026#34; xmlns:tools=\u0026#34;http://schemas.android.com/tools\u0026#34; android:id=\u0026#34;@+id/main\u0026#34; android:layout_width=\u0026#34;match_parent\u0026#34; android:layout_height=\u0026#34;match_parent\u0026#34; tools:context=\u0026#34;.SpinnerDropdownActivity\u0026#34; android:orientation=\u0026#34;vertical\u0026#34;\u0026gt; \u0026lt;TextView android:layout_width=\u0026#34;match_parent\u0026#34; android:layout_height=\u0026#34;wrap_content\u0026#34; android:text=\u0026#34;下拉模式的列表框\u0026#34; android:textSize=\u0026#34;17sp\u0026#34;/\u0026gt; \u0026lt;Spinner android:id=\u0026#34;@id/sp_dialog\u0026#34; android:layout_width=\u0026#34;match_parent\u0026#34; android:layout_height=\u0026#34;wrap_content\u0026#34; android:spinnerMode=\u0026#34;dialog\u0026#34;/\u0026gt;","title":"Android（5）"},{"content":"《数字图像处理》课程综合项目——基于多种滤波器的图像去噪算法比较与分析 GUI界面： 本项目源代码和报告均已开源：\n开源仓库：https://github.com/Kennems/Image_Processing_GUI\n项目简介 本项目旨在设计一个基于Matlab的图像去噪GUI系统，通过应用多种图像去噪算法，提高图像的质量和可用性。该系统集成了多种经典和现代的去噪方法，并提供了直观的用户界面，方便用户对图像进行去噪处理和效果评估。\n主要功能概述 1. 图像去噪方法 系统实现了多种常见的图像去噪方法，包括：\n均值滤波：通过邻域像素的平均值来替代中心像素的值，有效减少高频噪声，但可能导致图像细节丢失 。 中值滤波：采用滤波窗口内像素的中值替代中心像素的值，能够有效去除椒盐噪声和脉冲噪声，同时保留图像边缘和细节信息 。 高斯低通滤波：利用高斯函数对图像进行低通滤波，平滑图像并减少噪声 。 巴特沃斯低通滤波：一种频域滤波方法，适用于去除频率较高的噪声 。 小波变换：通过小波分解和重构来实现图像去噪，能够有效保留图像的细节和边缘 。 非局部均值去噪：基于图像中相似区域的像素值信息，对目标像素进行加权平均，保留图像细节但计算复杂度较高 。 维纳滤波：基于最小均方误差准则，恢复由噪声污染的图像，效果显著但需预估噪声性质 。 同态滤波：结合对数变换和频域滤波，增强图像对比度，去除光照变化和噪声 。 2. 图像噪声添加 系统支持多种噪声类型的添加，以模拟实际应用中的噪声环境，包括高斯噪声、椒盐噪声、泊松噪声和运动噪声等 。\n3. 去噪效果评估 提供了多种图像质量评价指标，包括峰值信噪比（PSNR）、均方误差（MSE）、信噪比（SNR）和结构相似性指数（SSIM）等，帮助用户客观比较不同去噪算法的性能 。\n4. 用户界面 系统采用Matlab GUI设计，用户可以通过界面选择去噪方法、设置相关参数、添加噪声以及查看去噪效果图，操作简便直观 。\n结论 本项目设计的数字图像处理GUI系统，通过集成多种图像去噪方法和提供直观的用户界面，方便用户进行图像去噪处理和效果评估。该系统具有重要的理论意义和实际应用价值，为推动数字图像处理技术的进步和满足实际应用需求提供了有力支持。\n","permalink":"https://kennems.github.io/posts/tech/%E6%95%B0%E5%AD%97%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86%E8%AF%BE%E7%A8%8B%E7%BB%BC%E5%90%88%E9%A1%B9%E7%9B%AE%E5%9F%BA%E4%BA%8E%E5%A4%9A%E7%A7%8D%E6%BB%A4%E6%B3%A2%E5%99%A8%E7%9A%84%E5%9B%BE%E5%83%8F%E5%8E%BB%E5%99%AA%E7%AE%97%E6%B3%95%E6%AF%94%E8%BE%83%E4%B8%8E%E5%88%86%E6%9E%90/","summary":"《数字图像处理》课程综合项目——基于多种滤波器的图像去噪算法比较与分析 GUI界面： 本项目源代码和报告均已开源： 开源仓库：https://gi","title":"《数字图像处理》课程综合项目(Matlab)"},{"content":"Android（4） 就算是最低的15x15都已经不错了，以后还有时间去学，上了研究生也没人能保证你有15x15的收入\n内容提供者(ContentProvider) CountentProvider为App存取内部数据提供统一的外部接口，让不同的应用之间得以共享数据\nUri 通用资源标识符 Universal Resource Identifer， 代表数据操作的地址，每一个ContentProvider都会有唯一的地址。ContentProvider使用的Uri语法结构如下：\ncontent://authority/data_path/id content://是通用前缀，表示该Uri用于ContentProvider定位资源。 authority是授权者名称，用来确定具体由哪一个ContentProvider提供资源。因此一般anthority都由类的小写全称组成，以保证唯一性。 data_path是数据路径，用来确定请求的是哪个数据集 id是数据编号，用来请求单条数据。如果是多条这个字段忽略。 server内容提供程序 UserInfoProvider.java package com.showguan.chapter07_server.provider; import android.content.ContentProvider; import android.content.ContentValues; import android.content.UriMatcher; import android.database.Cursor; import android.database.sqlite.SQLiteDatabase; import android.net.Uri; import android.util.Log; import com.showguan.chapter07_server.database.UserDBHelper; public class UserInfoProvider extends ContentProvider { private static String TAG = \u0026#34;Kennem\u0026#34;; private UserDBHelper dbHelper; private static final int USER = 1; private static final int USERS = 2; private static final UriMatcher URI_MATCHER = new UriMatcher(UriMatcher.NO_MATCH); static { URI_MATCHER.addURI(UserInfoContent.AUTHORITIES, \u0026#34;/user/#\u0026#34;, USER); URI_MATCHER.addURI(UserInfoContent.AUTHORITIES, \u0026#34;/user\u0026#34;, USERS); } @Override public boolean onCreate() { // TODO: Implement this to initialize your content provider on startup. Log.d(TAG, \u0026#34;ContentProvider onCreate: \u0026#34;); dbHelper = UserDBHelper.getInstance(getContext()); return true; } @Override public Uri insert(Uri uri, ContentValues values) { if (URI_MATCHER.match(uri) == USERS) { SQLiteDatabase db = dbHelper.getWritableDatabase(); db.insert(UserDBHelper.TABLE_NAME, null, values); } return uri; } @Override public Cursor query(Uri uri, String[] projection, String selection, String[] selectionArgs, String sortOrder) { if (URI_MATCHER.match(uri) == USERS) { Log.d(TAG, \u0026#34;UserInfoProvider query: \u0026#34;); SQLiteDatabase db = dbHelper.getReadableDatabase(); Cursor cursor = db.query(UserDBHelper.TABLE_NAME, projection, selection, selectionArgs, null, null, null); return cursor; } return null; } @Override public int delete(Uri uri, String selection, String[] selectionArgs) { int count = 0; switch (URI_MATCHER.match(uri)) { case USER: String id = uri.getLastPathSegment(); SQLiteDatabase db1 = dbHelper.getWritableDatabase(); count = db1.delete(UserDBHelper.TABLE_NAME, \u0026#34;_id = ?\u0026#34;, new String[]{id}); db1.close(); break; case USERS: SQLiteDatabase db2 = dbHelper.getWritableDatabase(); count = db2.delete(UserDBHelper.TABLE_NAME, selection, selectionArgs); db2.close(); break; } return count; } @Override public String getType(Uri uri) { // TODO: Implement this to handle requests for the MIME type of the data // at the given URI. throw new UnsupportedOperationException(\u0026#34;Not yet implemented\u0026#34;); } @Override public int update(Uri uri, ContentValues values, String selection, String[] selectionArgs) { // TODO: Implement this to handle requests to update one or more rows. throw new UnsupportedOperationException(\u0026#34;Not yet implemented\u0026#34;); } } UserInfoContent.java 定义常量 package com.showguan.chapter07_server.provider; import android.net.Uri; import android.provider.BaseColumns; public class UserInfoContent implements BaseColumns { public static final String AUTHORITIES = \u0026#34;com.showguan.chapter07_server.provider.UserInfoProvider\u0026#34;; public static final Uri CONTENT_URI = Uri.parse(\u0026#34;content://\u0026#34; + AUTHORITIES + \u0026#34;/user\u0026#34;); public static final String USER_NAME = \u0026#34;name\u0026#34;; public static final String USER_AGE = \u0026#34;age\u0026#34;; public static final String USER_HEIGHT = \u0026#34;height\u0026#34;; public static final String USER_WEIGHT = \u0026#34;weight\u0026#34;; public static final String USER_MARRIED = \u0026#34;married\u0026#34;; } UserDBHelper.java创建表 package com.showguan.chapter07_server.database; import android.content.ContentValues; import android.content.Context; import android.database.Cursor; import android.database.sqlite.SQLiteDatabase; import android.database.sqlite.SQLiteOpenHelper; import androidx.annotation.Nullable; import java.util.ArrayList; import java.util.List; public class UserDBHelper extends SQLiteOpenHelper { public static final String DB_NAME = \u0026#34;user.db\u0026#34;; public static final String TABLE_NAME = \u0026#34;user_info\u0026#34;; private static final int DB_VERSION = 2; private static UserDBHelper mHelper = null; private SQLiteDatabase mRDB = null; private SQLiteDatabase mWDB = null; private UserDBHelper(@Nullable Context context) { super(context, DB_NAME, null, DB_VERSION); } public static UserDBHelper getInstance(Context context) { if (mHelper == null) { mHelper = new UserDBHelper(context); } return mHelper; } @Override public void onCreate(SQLiteDatabase db) { String sql = \u0026#34;CREATE TABLE IF NOT EXISTS \u0026#34; + TABLE_NAME + \u0026#34; (\u0026#34; + \u0026#34;_id INTEGER PRIMARY KEY AUTOINCREMENT NOT NULL,\u0026#34; + \u0026#34; name VARCHAR NOT NULL,\u0026#34; + \u0026#34; age INTEGER NOT NULL,\u0026#34; + \u0026#34; height LONG NOT NULL,\u0026#34; + \u0026#34; weight FLOAT NOT NULL,\u0026#34; + \u0026#34; married INTEGER NOT NULL);\u0026#34;; db.execSQL(sql); } @Override public void onUpgrade(SQLiteDatabase db, int oldVersion, int newVersion) { } } client接受数据端 首先在Manifest中添加如下，表示需要访问的内容提供者的包\nContentWriteActivity.java package com.showguan.chapter07_client; public class ContentWriteActivity extends AppCompatActivity implements View.OnClickListener { private static String TAG = \u0026#34;Kennem\u0026#34;; private EditText et_name; private EditText et_age; private EditText et_height; private EditText et_weight; private CheckBox ck_isMarried; @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.activity_content_write); et_name = findViewById(R.id.et_name); et_age = findViewById(R.id.et_age); et_height = findViewById(R.id.et_height); et_weight = findViewById(R.id.et_weight); ck_isMarried = findViewById(R.id.ck_isMarried); findViewById(R.id.btn_read).setOnClickListener(this); findViewById(R.id.btn_write).setOnClickListener(this); findViewById(R.id.btn_delete).setOnClickListener(this); } @SuppressLint(\u0026#34;Range\u0026#34;) @Override public void onClick(View v) { if(v.getId() == R.id.btn_write){ ContentValues values = new ContentValues(); values.put(UserInfoContent.USER_NAME, et_name.getText().toString()); values.put(UserInfoContent.USER_AGE, et_age.getText().toString()); values.put(UserInfoContent.USER_HEIGHT, et_height.getText().toString()); values.put(UserInfoContent.USER_WEIGHT, et_weight.getText().toString()); values.put(UserInfoContent.USER_MARRIED, ck_isMarried.isChecked()); getContentResolver().insert(UserInfoContent.CONTENT_URI, values); ToastUtil.show(this, \u0026#34;保存成功！\u0026#34;); } else if (v.getId() == R.id.btn_read) { Cursor cursor = getContentResolver().query(UserInfoContent.CONTENT_URI, null, null, null, null); if (cursor != null) { while(cursor.moveToNext()){ User info = new User(); info.setId(cursor.getInt(cursor.getColumnIndex(UserInfoContent._ID))); info.setAge(cursor.getInt(cursor.getColumnIndex(UserInfoContent.USER_AGE))); info.setName(cursor.getString(cursor.getColumnIndex(UserInfoContent.USER_NAME))); info.setHeight(cursor.getFloat(cursor.getColumnIndex(UserInfoContent.USER_HEIGHT))); info.setWeight(cursor.getFloat(cursor.getColumnIndex(UserInfoContent.USER_WEIGHT))); info.setMarried(cursor.getInt(cursor.getColumnIndex(UserInfoContent.USER_MARRIED)) == 1); Log.d(TAG, info.toString()); } cursor.close(); } } else if (v.getId() == R.id.btn_delete) { // 根据id删除单条 // Uri uri = ContentUris.withAppendedId(UserInfoContent.CONTENT_URI, 1); // int count = getContentResolver().delete(uri, null, null); //根据名称删除多条 int count = getContentResolver().delete(UserInfoContent.CONTENT_URI, \u0026#34;name = ?\u0026#34;, new String[]{et_name.getText().toString()}); if(count \u0026gt; 0){ ToastUtil.show(this, \u0026#34;删除成功\u0026#34;); }else{ ToastUtil.show(this, \u0026#34;删除失败，不存在名为\u0026#34; + et_name.getText().toString() + \u0026#34;的用户！\u0026#34;); } } } } 通过Uri格式删除一个用户 // 根据id删除单条 Uri uri = ContentUris.withAppendedId(UserInfoContent.CONTENT_URI, 1); int count = getContentResolver().delete(uri, null, null); 动态申请权限 步骤：\n检查App是否开启了指定权限 调用ContextCompat的checkSelfPermission方法 请求系统弹窗，以便用户选择是否开启权限 调用ActivityCompat的requestPermission方法，即可命令系统自动弹出权限申请窗口。 判断用户的权限选择结果 重写活动页面的权限请求回调方法onRequestPermissionResult， 在该方法内部处理用户的权限选择结果。 懒汉式获取权限 首先添加按钮事件监听： @Override public void onClick(View v) { if (v.getId() == R.id.btn_contacts) { PermissionUtil.checkPermission(this, PERMISSIONS_CONTACTS, REQUEST_CODE_CONTACTS); } else if (v.getId() == R.id.btn_sms) { PermissionUtil.checkPermission(this, PERMISSIONS_SMS, REQUEST_CODE_SMS); } } 在工具类中判断是否有没有获取到的权限，申请获取 public static boolean checkPermission(Activity act, String[] permissions, int requestCode){ if(Build.VERSION.SDK_INT \u0026gt;= Build.VERSION_CODES.M){ int check = PackageManager.PERMISSION_GRANTED; for (String permission : permissions) { check = ContextCompat.checkSelfPermission(act, permission); if(check != PackageManager.PERMISSION_GRANTED){ break; } } if(check != PackageManager.PERMISSION_GRANTED){ ActivityCompat.requestPermissions(act, permissions, requestCode); return false; } } return true; } 其中ActivityCompat.requestPermissions方法的参数在onRequestPermissionsResult中返回 @Override public void onRequestPermissionsResult(int requestCode, @NonNull String[] permissions, @NonNull int[] grantResults) { super.onRequestPermissionsResult(requestCode, permissions, grantResults); switch (requestCode) { case REQUEST_CODE_CONTACTS: for (int grantResult : grantResults) { Log.d(TAG, String.valueOf(grantResult)); } if (PermissionUtil.checkGranted(grantResults)) { Log.d(TAG, \u0026#34;通讯录权限获取成功\u0026#34;); } else { ToastUtil.show(this, \u0026#34;获取权限失败!\u0026#34;); jumpToSettings(); } break; case REQUEST_CODE_SMS: if (PermissionUtil.checkGranted(grantResults)) { Log.d(TAG, \u0026#34;短信收发权限获取成功\u0026#34;); } else { ToastUtil.show(this, \u0026#34;获取权限失败!\u0026#34;); jumpToSettings(); } break; } } PermissionLazyActivity.java package com.showguan.chapter07_client; import android.Manifest; import android.content.Intent; import android.net.Uri; import android.os.Bundle; import android.provider.Settings; import android.util.Log; import android.view.View; import androidx.activity.EdgeToEdge; import androidx.annotation.NonNull; import androidx.appcompat.app.AppCompatActivity; import androidx.core.graphics.Insets; import androidx.core.view.ViewCompat; import androidx.core.view.WindowInsetsCompat; import com.showguan.chapter07_client.util.PermissionUtil; import com.showguan.chapter07_client.util.ToastUtil; public class PermissionLazyActivity extends AppCompatActivity implements View.OnClickListener { private static String TAG = \u0026#34;Kennem\u0026#34;; private static final String[] PERMISSIONS_CONTACTS = new String[]{ android.Manifest.permission.READ_CONTACTS, android.Manifest.permission.WRITE_CONTACTS }; private static final String[] PERMISSIONS_SMS = new String[]{ Manifest.permission.SEND_SMS, Manifest.permission.READ_SMS }; private static final int REQUEST_CODE_CONTACTS = 1; private static final int REQUEST_CODE_SMS = 2; @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.activity_permission_lazy); findViewById(R.id.btn_contacts).setOnClickListener(this); findViewById(R.id.btn_sms).setOnClickListener(this); } @Override public void onClick(View v) { if (v.getId() == R.id.btn_contacts) { PermissionUtil.checkPermission(this, PERMISSIONS_CONTACTS, REQUEST_CODE_CONTACTS); } else if (v.getId() == R.id.btn_sms) { PermissionUtil.checkPermission(this, PERMISSIONS_SMS, REQUEST_CODE_SMS); } } @Override public void onRequestPermissionsResult(int requestCode, @NonNull String[] permissions, @NonNull int[] grantResults) { super.onRequestPermissionsResult(requestCode, permissions, grantResults); switch (requestCode) { case REQUEST_CODE_CONTACTS: for (int grantResult : grantResults) { Log.d(TAG, String.valueOf(grantResult)); } if (PermissionUtil.checkGranted(grantResults)) { Log.d(TAG, \u0026#34;通讯录权限获取成功\u0026#34;); } else { ToastUtil.show(this, \u0026#34;获取权限失败!\u0026#34;); jumpToSettings(); } break; case REQUEST_CODE_SMS: if (PermissionUtil.checkGranted(grantResults)) { Log.d(TAG, \u0026#34;短信收发权限获取成功\u0026#34;); } else { ToastUtil.show(this, \u0026#34;获取权限失败!\u0026#34;); jumpToSettings(); } break; } } private void jumpToSettings() { Intent intent = new Intent(); intent.setAction(Settings.ACTION_APPLICATION_DETAILS_SETTINGS); intent.setData(Uri.fromParts(\u0026#34;package\u0026#34;, getPackageName(), null)); intent.setFlags(Intent.FLAG_ACTIVITY_NEW_TASK); startActivity(intent); } } 跳转到系统权限设计界面： private void jumpToSettings() { Intent intent = new Intent(); intent.setAction(Settings.ACTION_APPLICATION_DETAILS_SETTINGS); intent.setData(Uri.fromParts(\u0026#34;package\u0026#34;, getPackageName(), null)); intent.setFlags(Intent.FLAG_ACTIVITY_NEW_TASK); startActivity(intent); } 饿汉式获取权限 PermissionHungryActivity.java 不同于懒汉式，创建时即申请全部权限\npackage com.showguan.chapter07_client; import android.Manifest; import android.content.Intent; import android.content.pm.PackageManager; import android.net.Uri; import android.os.Bundle; import android.provider.Settings; import android.util.Log; import android.view.View; import androidx.activity.EdgeToEdge; import androidx.annotation.NonNull; import androidx.appcompat.app.AppCompatActivity; import androidx.core.graphics.Insets; import androidx.core.view.ViewCompat; import androidx.core.view.WindowInsetsCompat; import com.showguan.chapter07_client.util.PermissionUtil; import com.showguan.chapter07_client.util.ToastUtil; public class PermissionHungryActivity extends AppCompatActivity implements View.OnClickListener { private static String TAG = \u0026#34;Kennem\u0026#34;; private static final String[] PERMISSIONS_ALL = new String[]{ android.Manifest.permission.READ_CONTACTS, android.Manifest.permission.WRITE_CONTACTS, android.Manifest.permission.SEND_SMS, Manifest.permission.READ_SMS }; private static final int REQUEST_CODE_ALL = 1; private static final int REQUEST_CODE_CONTACTS = 2; private static final int REQUEST_CODE_SMS = 3; @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.activity_permission_lazy); findViewById(R.id.btn_contacts).setOnClickListener(this); findViewById(R.id.btn_sms).setOnClickListener(this); PermissionUtil.checkPermission(this, PERMISSIONS_ALL, REQUEST_CODE_ALL); } @Override public void onClick(View v) { if (v.getId() == R.id.btn_contacts) { PermissionUtil.checkPermission(this, new String[]{PERMISSIONS_ALL[0], PERMISSIONS_ALL[1]}, REQUEST_CODE_CONTACTS); } else if (v.getId() == R.id.btn_sms) { PermissionUtil.checkPermission(this, new String[]{PERMISSIONS_ALL[2], PERMISSIONS_ALL[3]}, REQUEST_CODE_SMS); } } @Override public void onRequestPermissionsResult(int requestCode, @NonNull String[] permissions, @NonNull int[] grantResults) { super.onRequestPermissionsResult(requestCode, permissions, grantResults); switch (requestCode) { case REQUEST_CODE_ALL: if (PermissionUtil.checkGranted(grantResults)) { Log.d(TAG, \u0026#34;所有权限获取成功！\u0026#34;); } else { for (int i = 0; i \u0026lt; grantResults.length; i++) { if (grantResults[i] != PackageManager.PERMISSION_GRANTED) { switch (permissions[i]) { case Manifest.permission.READ_CONTACTS: case Manifest.permission.WRITE_CONTACTS: ToastUtil.show(this, \u0026#34;获取通讯录读写权限失败\u0026#34;); jumpToSettings(); return; case Manifest.permission.SEND_SMS: case Manifest.permission.READ_SMS: ToastUtil.show(this, \u0026#34;获取短信读写权限失败\u0026#34;); jumpToSettings(); return; } } } } break; case REQUEST_CODE_CONTACTS: for (int grantResult : grantResults) { Log.d(TAG, String.valueOf(grantResult)); } if (PermissionUtil.checkGranted(grantResults)) { Log.d(TAG, \u0026#34;通讯录权限获取成功\u0026#34;); } else { ToastUtil.show(this, \u0026#34;获取权限失败!\u0026#34;); jumpToSettings(); } break; case REQUEST_CODE_SMS: if (PermissionUtil.checkGranted(grantResults)) { Log.d(TAG, \u0026#34;短信收发权限获取成功\u0026#34;); } else { ToastUtil.show(this, \u0026#34;获取权限失败!\u0026#34;); jumpToSettings(); } break; } } private void jumpToSettings() { Intent intent = new Intent(); intent.setAction(Settings.ACTION_APPLICATION_DETAILS_SETTINGS); intent.setData(Uri.fromParts(\u0026#34;package\u0026#34;, getPackageName(), null)); intent.setFlags(Intent.FLAG_ACTIVITY_NEW_TASK); startActivity(intent); } } 添加联系人 添加用户到通讯录，读取所有联系人信息到logcat中。\npackage com.showguan.chapter07_client; public class ContactAddActivity extends AppCompatActivity implements View.OnClickListener { private static String TAG = \u0026#34;Kennem\u0026#34;; private TextView et_name; private TextView et_phone; private TextView et_email; @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.activity_contact_add); et_name = findViewById(R.id.et_name); et_phone = findViewById(R.id.et_phone); et_email = findViewById(R.id.et_email); findViewById(R.id.btn_read).setOnClickListener(this); findViewById(R.id.btn_write).setOnClickListener(this); } @Override public void onClick(View v) { if (v.getId() == R.id.btn_write) { // 创建一个联系人对象 Contact contact = new Contact(); contact.name = et_name.getText().toString(); contact.phone = et_phone.getText().toString(); contact.email = et_email.getText().toString(); //addContacts(getContentResolver(), contact); //批处理方式，每一次操作都是一个ContentProviderOperation， 构建一个操作集合，然后一次性执行 // 好处：要么全部成功，要么全部失败，保证了事务的一致性 addFullContacts(getContentResolver(), contact); } else if (v.getId() == R.id.btn_read) { readPhoneContact(getContentResolver()); } } @SuppressLint(\u0026#34;Range\u0026#34;) // 禁用范围警告，因为我们手动处理列索引 private void readPhoneContact(ContentResolver resolver) { // 查询RawContacts表，获取所有联系人的_raw_contact_id Cursor cursor = resolver.query( ContactsContract.RawContacts.CONTENT_URI, new String[]{ContactsContract.RawContacts._ID}, // 只查询_raw_contact_id列 null, // 无筛选条件 null, // 无筛选条件参数 null // 无排序 ); // 遍历查询结果 while (cursor.moveToNext()) { // 获取当前记录的raw_contact_id int rawContactId = cursor.getInt(0); // 构建用于查询联系人的Data URI Uri uri = Uri.parse(\u0026#34;content://com.android.contacts/contacts/\u0026#34; + rawContactId + \u0026#34;/data\u0026#34;); // 查询Data表，获取与当前联系人相关的所有数据 Cursor dataCursor = resolver.query( uri, new String[]{Contacts.Data.MIMETYPE, Contacts.Data.DATA1, Contacts.Data.DATA2}, // 查询MIME类型和数据列 null, // 无筛选条件 null, // 无筛选条件参数 null // 无排序 ); // 创建一个Contact对象用于存储查询结果 Contact contact = new Contact(); // 遍历查询结果 while (dataCursor.moveToNext()) { // 获取当前记录的DATA1列的值 String data1 = dataCursor.getString(dataCursor.getColumnIndex(Contacts.Data.DATA1)); // 获取当前记录的MIMETYPE列的值 String mimeType = dataCursor.getString(dataCursor.getColumnIndex(Contacts.Data.MIMETYPE)); // 根据MIME类型，将数据存储到相应的Contact属性中 switch (mimeType) { case CommonDataKinds.StructuredName.CONTENT_ITEM_TYPE: // 如果MIME类型是StructuredName，则将data1赋值给contact的name属性 contact.name = data1; break; case CommonDataKinds.Phone.CONTENT_ITEM_TYPE: // 如果MIME类型是Phone，则将data1赋值给contact的phone属性 contact.phone = data1; break; case CommonDataKinds.Email.CONTENT_ITEM_TYPE: // 如果MIME类型是Email，则将data1赋值给contact的email属性 contact.email = data1; break; } } // 关闭Data表的查询结果游标 dataCursor.close(); // 如果contact的name属性不为空，则输出联系人姓名到日志 if (contact.name != null) { Log.d(TAG, contact.name); } } // 关闭RawContacts表的查询结果游标 cursor.close(); } // 往手机通讯录一次性添加一个联系人信息（包括主记录，姓名，电话号码，电子邮箱） // 事务性，要么全部成功，要么全部失败 private void addFullContacts(ContentResolver contentResolver, Contact contact) { // 创建一个插入联系人主记录的内容操作器 ContentProviderOperation op_main = ContentProviderOperation // 设置操作类型为插入 .newInsert(ContactsContract.RawContacts.CONTENT_URI) // 设置插入的ACCOUNT_NAME为null，表示使用默认账户 .withValue(ContactsContract.RawContacts.ACCOUNT_NAME, null) // 构建操作 .build(); // 创建一个插入联系人姓名的内容操作器 ContentProviderOperation op_name = ContentProviderOperation // 设置操作类型为插入 .newInsert(ContactsContract.Data.CONTENT_URI) // 设置引用的RAW_CONTACT_ID为前一个操作生成的ID .withValueBackReference(Contacts.Data.RAW_CONTACT_ID, 0) // 设置数据的MIME类型为StructuredName（联系人的名字） .withValue(Contacts.Data.MIMETYPE, CommonDataKinds.StructuredName.CONTENT_ITEM_TYPE) // 设置联系人的名字 .withValue(Contacts.Data.DATA1, contact.name) // 构建操作 .build(); // 创建一个插入联系人电话号码的内容操作器 ContentProviderOperation op_phone = ContentProviderOperation // 设置操作类型为插入 .newInsert(ContactsContract.Data.CONTENT_URI) // 设置引用的RAW_CONTACT_ID为前一个操作生成的ID .withValueBackReference(Contacts.Data.RAW_CONTACT_ID, 0) // 设置数据的MIME类型为Phone（联系人的电话） .withValue(Contacts.Data.MIMETYPE, CommonDataKinds.Phone.CONTENT_ITEM_TYPE) // 设置联系人的电话号码 .withValue(Contacts.Data.DATA1, contact.phone) // 设置电话号码的类型为Mobile（手机） .withValue(Contacts.Data.DATA2, CommonDataKinds.Phone.TYPE_MOBILE) // 构建操作 .build(); // 创建一个插入联系人电子邮箱的内容操作器 ContentProviderOperation op_email = ContentProviderOperation // 设置操作类型为插入 .newInsert(ContactsContract.Data.CONTENT_URI) // 设置引用的RAW_CONTACT_ID为前一个操作生成的ID .withValueBackReference(Contacts.Data.RAW_CONTACT_ID, 0) // 设置数据的MIME类型为Email（联系人的邮箱） .withValue(Contacts.Data.MIMETYPE, CommonDataKinds.Email.CONTENT_ITEM_TYPE) // 设置联系人的电子邮箱地址 .withValue(Contacts.Data.DATA1, contact.email) // 设置电子邮箱的类型为Mobile（手机邮箱） .withValue(Contacts.Data.DATA2, CommonDataKinds.Email.TYPE_MOBILE) // 构建操作 .build(); // 创建一个操作列表，用于批量执行所有操作 ArrayList\u0026lt;ContentProviderOperation\u0026gt; operations = new ArrayList\u0026lt;\u0026gt;(); // 将插入主记录的操作添加到操作列表 operations.add(op_main); // 将插入姓名的操作添加到操作列表 operations.add(op_name); // 将插入电话号码的操作添加到操作列表 operations.add(op_phone); // 将插入电子邮箱的操作添加到操作列表 operations.add(op_email); try { // 执行批量操作，将所有数据插入联系人数据库 contentResolver.applyBatch(ContactsContract.AUTHORITY, operations); } catch (OperationApplicationException e) { // 捕获OperationApplicationException异常并抛出RuntimeException throw new RuntimeException(e); } catch (RemoteException e) { // 捕获RemoteException异常并抛出RuntimeException throw new RuntimeException(e); } } private void addContacts(ContentResolver resolver, Contact contact) { // 创建一个ContentValues对象，用于存储新联系人数据 ContentValues values = new ContentValues(); // 插入一个空的RawContact记录，返回该记录的URI Uri uri = resolver.insert(ContactsContract.RawContacts.CONTENT_URI, values); // 解析出新插入记录的ID long rawContactId = ContentUris.parseId(uri); // 创建一个ContentValues对象，用于存储联系人的名字数据 ContentValues name = new ContentValues(); // 设置RAW_CONTACT_ID，表示该数据属于哪个联系人 name.put(Contacts.Data.RAW_CONTACT_ID, rawContactId); // 设置数据的MIME类型为StructuredName（联系人的名字） name.put(Contacts.Data.MIMETYPE, CommonDataKinds.StructuredName.CONTENT_ITEM_TYPE); // 设置联系人的名字 name.put(Contacts.Data.DATA1, contact.name); // 将联系人的名字数据插入到Data表中 resolver.insert(ContactsContract.Data.CONTENT_URI, name); // 创建一个ContentValues对象，用于存储联系人的电话号码数据 ContentValues phone = new ContentValues(); // 设置RAW_CONTACT_ID，表示该数据属于哪个联系人 phone.put(Contacts.Data.RAW_CONTACT_ID, rawContactId); // 设置数据的MIME类型为Phone（联系人的电话） phone.put(Contacts.Data.MIMETYPE, CommonDataKinds.Phone.CONTENT_ITEM_TYPE); // 设置联系人的电话号码 phone.put(Contacts.Data.DATA1, contact.phone); // 设置电话号码的类型为Mobile（手机） phone.put(Contacts.Data.DATA2, CommonDataKinds.Phone.TYPE_MOBILE); // 将联系人的电话号码数据插入到Data表中 resolver.insert(ContactsContract.Data.CONTENT_URI, phone); // 创建一个ContentValues对象，用于存储联系人的邮箱数据 ContentValues email = new ContentValues(); // 设置RAW_CONTACT_ID，表示该数据属于哪个联系人 email.put(Contacts.Data.RAW_CONTACT_ID, rawContactId); // 设置数据的MIME类型为Email（联系人的邮箱） email.put(Contacts.Data.MIMETYPE, CommonDataKinds.Email.CONTENT_ITEM_TYPE); // 设置联系人的邮箱地址（此处错误，应该是contact.email，而不是contact.phone） email.put(Contacts.Data.DATA1, contact.email); // 纠正了原来的错误 // 设置邮箱地址的类型为Work（工作邮箱） email.put(Contacts.Data.DATA2, CommonDataKinds.Email.TYPE_WORK); // 将联系人的邮箱数据插入到Data表中 resolver.insert(ContactsContract.Data.CONTENT_URI, email); } private void addContact(ContentResolver resolver, Contact contact) { ContentValues values = new ContentValues(); Uri uri = resolver.insert(ContactsContract.RawContacts.CONTENT_URI, values); long rawDataId = ContentUris.parseId(uri); } } 发送短信 Java package com.showguan.chapter07_client; // 定义包名 public class SentMmsActivity extends AppCompatActivity implements View.OnClickListener { // 定义SentMmsActivity类，继承AppCompatActivity，实现View.OnClickListener接口 private static String TAG = \u0026#34;Kennem\u0026#34;; // 定义TAG用于日志 private ActivityResultLauncher\u0026lt;Intent\u0026gt; mResultLauncher; // 定义ActivityResultLauncher变量 private EditText et_phone_number; // 定义EditText变量用于电话号码输入 private EditText et_title; // 定义EditText变量用于标题输入 private EditText et_desc; // 定义EditText变量用于描述输入 private Uri picUri; // 定义Uri变量用于存储图片URI @Override protected void onCreate(Bundle savedInstanceState) { // onCreate方法，Activity创建时调用 super.onCreate(savedInstanceState); // 调用父类onCreate方法 setContentView(R.layout.activity_sent_mms); // 设置布局文件 ImageView iv_add_pic = findViewById(R.id.iv_add_pic); // 获取ImageView用于添加图片 findViewById(R.id.btn_send).setOnClickListener(this); // 设置发送按钮的点击监听 iv_add_pic.setOnClickListener(this); // 设置添加图片按钮的点击监听 et_phone_number = findViewById(R.id.et_phone_number); // 获取EditText用于电话号码输入 et_title = findViewById(R.id.et_title); // 获取EditText用于标题输入 et_desc = findViewById(R.id.et_desc); // 获取EditText用于描述输入 mResultLauncher = registerForActivityResult(new ActivityResultContracts.StartActivityForResult(), result -\u0026gt; { // 注册Activity结果启动器 if(result.getResultCode() == RESULT_OK){ // 检查结果码是否为RESULT_OK Intent intent = result.getData(); // 获取结果数据 picUri = intent.getData(); // 获取图片URI if(picUri != null){ // 如果URI不为空 iv_add_pic.setImageURI(picUri); // 设置ImageView显示图片 Log.d(TAG, picUri.toString()); // 打印图片URI到日志 } } }); } @Override public void onClick(View v) { // onClick方法，处理点击事件 if(v.getId() == R.id.iv_add_pic){ // 如果点击的是添加图片按钮 Intent intent = new Intent(Intent.ACTION_GET_CONTENT); // 创建Intent用于选择内容 intent.setType(\u0026#34;image/*\u0026#34;); // 设置选择类型为图片 mResultLauncher.launch(intent); // 启动选择图片的Activity } else if (v.getId() == R.id.btn_send) { // 如果点击的是发送按钮 sendMms(et_phone_number.getText().toString(), // 调用sendMms方法发送MMS et_title.getText().toString(), // 获取标题文本 et_desc.getText().toString()); // 获取描述文本 } } private void sendMms(String phone, String title, String desc) { // sendMms方法，用于发送MMS Intent intent = new Intent(Intent.ACTION_SEND); // 创建发送Intent intent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK); // 添加新任务标志 intent.addFlags(Intent.FLAG_GRANT_READ_URI_PERMISSION); // 添加URI读权限标志 intent.putExtra(\u0026#34;address\u0026#34;, phone); // 设置电话号码 intent.putExtra(\u0026#34;subject\u0026#34;, title); // 设置标题 intent.putExtra(\u0026#34;sms_body\u0026#34;, desc); // 设置描述 intent.putExtra(Intent.EXTRA_STREAM, picUri); // 添加图片URI intent.setType(\u0026#34;image/*\u0026#34;); // 设置类型为图片 startActivity(intent); // 启动发送MMS的Activity ToastUtil.show(this, \u0026#34;从在弹窗中选择信息或短信应用\u0026#34;); // 显示提示信息 } } FileProvider指定获取图片路径并发送短信 package com.showguan.chapter07_client; // 定义包名 public class ProvideMmsActivity extends AppCompatActivity { // 定义ProvideMmsActivity类，继承AppCompatActivity private static String TAG = \u0026#34;Kennem\u0026#34;; // 定义TAG用于日志 private List\u0026lt;ImageInfo\u0026gt; mImageList = new ArrayList\u0026lt;\u0026gt;(); // 定义用于存储图片信息的列表 private GridLayout gl_appendix; // 定义GridLayout用于显示图片 private static final String[] PERMISSION_STORAGE = new String[]{ // 定义存储权限数组 Manifest.permission.READ_EXTERNAL_STORAGE, }; private static final int PERMISSION_STORAGE_CODE = 1; // 定义存储权限请求码 private EditText et_phone_number; // 定义EditText用于输入电话号码 private EditText et_message; // 定义EditText用于输入消息 private EditText et_title; // 定义EditText用于输入标题 @Override protected void onCreate(Bundle savedInstanceState) { // onCreate方法，Activity创建时调用 super.onCreate(savedInstanceState); // 调用父类onCreate方法 setContentView(R.layout.activity_provide_mms); // 设置布局文件 gl_appendix = findViewById(R.id.gl_appendix); // 获取GridLayout用于显示图片 et_title = findViewById(R.id.et_title); // 获取EditText用于输入标题 et_message = findViewById(R.id.et_message); // 获取EditText用于输入消息 et_phone_number = findViewById(R.id.et_phone_number); // 获取EditText用于输入电话号码 MediaScannerConnection.scanFile( // 调用MediaScannerConnection扫描文件 this, new String[]{Environment.getExternalStoragePublicDirectory(Environment.DIRECTORY_DOWNLOADS).toString()}, // 扫描下载目录 null, null ); if (PermissionUtil.checkPermission(this, PERMISSION_STORAGE, PERMISSION_STORAGE_CODE)) { // 检查存储权限 loadImageList(); // 加载图片列表 showImageGrid(); // 显示图片网格 } } @Override public void onRequestPermissionsResult(int requestCode, @NonNull String[] permissions, @NonNull int[] grantResults) { // 权限请求结果回调 super.onRequestPermissionsResult(requestCode, permissions, grantResults); // 调用父类方法 if (requestCode == PERMISSION_STORAGE_CODE) { // 判断请求码是否为存储权限 if (PermissionUtil.checkGranted(grantResults)) { // 检查权限是否被授予 loadImageList(); // 加载图片列表 showImageGrid(); // 显示图片网格 } } } private void showImageGrid() { // 显示图片网格的方法 gl_appendix.removeAllViews(); // 移除所有视图 for (ImageInfo image : mImageList) { // 遍历图片列表 ImageView imageView = new ImageView(this); // 创建ImageView Bitmap bitmap = BitmapFactory.decodeFile(image.path); // 解码图片文件 imageView.setImageBitmap(bitmap); // 设置图片 imageView.setScaleType(ImageView.ScaleType.FIT_CENTER); // 设置缩放类型 int px = Utils.dip2px(this, 110); // 将110dp转换为px ViewGroup.LayoutParams params = new ViewGroup.LayoutParams(px, px); // 创建布局参数 imageView.setLayoutParams(params); // 设置布局参数 int padding = Utils.dip2px(this, 5); // 将5dp转换为px imageView.setPadding(padding, padding, padding, padding); // 设置内边距 imageView.setOnClickListener(v -\u0026gt; { // 设置点击监听器 sendMms(et_phone_number.getText().toString(), // 获取输入的电话号码 et_title.getText().toString(), // 获取输入的标题 et_message.getText().toString(), // 获取输入的消息 image.path); // 获取图片路径 }); gl_appendix.addView(imageView); // 将ImageView添加到GridLayout } } private void sendMms(String phone, String title, String desc, String path) { // 发送MMS的方法 Uri uri = Uri.parse(path); // 将路径解析为Uri // 兼容Android 7.0 把访问文件的Uri方式改为FileProvider if (Build.VERSION.SDK_INT \u0026gt;= Build.VERSION_CODES.N) { // 判断是否为Android 7.0及以上 uri = FileProvider.getUriForFile(this, getString(R.string.file_Provider), new File(path)); // 使用FileProvider获取Uri Log.d(TAG, String.format(\u0026#34;FileProvider Uri : %s\u0026#34;, uri.toString())); // 打印FileProvider的Uri } Intent intent = new Intent(Intent.ACTION_SEND); // 创建发送Intent intent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK); // 添加新任务标志 intent.addFlags(Intent.FLAG_GRANT_READ_URI_PERMISSION); // 添加读取URI权限标志 intent.putExtra(\u0026#34;address\u0026#34;, phone); // 设置电话号码 intent.putExtra(\u0026#34;subject\u0026#34;, title); // 设置标题 intent.putExtra(\u0026#34;sms_body\u0026#34;, desc); // 设置消息内容 intent.putExtra(Intent.EXTRA_STREAM, uri); // 添加图片Uri intent.setType(\u0026#34;image/*\u0026#34;); // 设置类型为图片 startActivity(intent); // 启动Activity ToastUtil.show(this, \u0026#34;从在弹窗中选择信息或短信应用\u0026#34;); // 显示提示信息 } @SuppressLint(\u0026#34;Range\u0026#34;) private void loadImageList() { // 加载图片列表的方法 String[] columns = new String[]{ // 定义要查询的列 MediaStore.Images.Media._ID, MediaStore.Images.Media.TITLE, MediaStore.Images.Media.SIZE, MediaStore.Images.Media.DATA }; Cursor cursor = getContentResolver().query( // 查询图片媒体库 MediaStore.Images.Media.EXTERNAL_CONTENT_URI, // 查询外部图片URI columns, // 查询的列 \u0026#34;_size \u0026lt; 307200\u0026#34;, // 查询条件：大小小于300KB null, // 查询参数 \u0026#34;_size DESC\u0026#34;); // 排序方式：按大小降序 int count = 0; // 定义计数器 if (cursor != null) { // 如果游标不为空 while (cursor.moveToNext() \u0026amp;\u0026amp; count \u0026lt; 6) { // 遍历查询结果，最多6个 ImageInfo image = new ImageInfo(); // 创建ImageInfo对象 image.id = cursor.getLong(cursor.getColumnIndex(MediaStore.Images.Media._ID)); // 获取图片ID image.name = cursor.getString(cursor.getColumnIndex(MediaStore.Images.Media.TITLE)); // 获取图片标题 image.size = cursor.getLong(cursor.getColumnIndex(MediaStore.Images.Media.SIZE)); // 获取图片大小 image.path = cursor.getString(cursor.getColumnIndex(MediaStore.Images.Media.DATA)); // 获取图片路径 if (FileUtil.checkFileUri(this, image.path)) { // 检查文件URI是否有效 count += 1; // 增加计数 mImageList.add(image); // 将图片信息添加到列表 } Log.d(TAG, image.toString()); // 打印图片信息 } } } } xml \u0026lt;LinearLayout xmlns:android=\u0026#34;http://schemas.android.com/apk/res/android\u0026#34; android:layout_width=\u0026#34;match_parent\u0026#34; android:layout_height=\u0026#34;match_parent\u0026#34; android:orientation=\u0026#34;vertical\u0026#34; android:padding=\u0026#34;5dp\u0026#34;\u0026gt; \u0026lt;LinearLayout android:layout_width=\u0026#34;match_parent\u0026#34; android:layout_height=\u0026#34;40dp\u0026#34; android:orientation=\u0026#34;horizontal\u0026#34;\u0026gt; \u0026lt;TextView android:layout_width=\u0026#34;wrap_content\u0026#34; android:layout_height=\u0026#34;match_parent\u0026#34; android:gravity=\u0026#34;center\u0026#34; android:text=\u0026#34;对方号码：\u0026#34; android:textColor=\u0026#34;@color/black\u0026#34; android:textSize=\u0026#34;17sp\u0026#34; /\u0026gt; \u0026lt;EditText android:id=\u0026#34;@+id/et_phone_number\u0026#34; android:layout_width=\u0026#34;0dp\u0026#34; android:layout_height=\u0026#34;match_parent\u0026#34; android:layout_margin=\u0026#34;3dp\u0026#34; android:layout_weight=\u0026#34;1\u0026#34; android:background=\u0026#34;@drawable/edittext_selector\u0026#34; android:inputType=\u0026#34;number\u0026#34; android:textColor=\u0026#34;@color/black\u0026#34; android:textSize=\u0026#34;17sp\u0026#34; android:text=\u0026#34;10086\u0026#34;/\u0026gt; \u0026lt;/LinearLayout\u0026gt; \u0026lt;LinearLayout android:layout_width=\u0026#34;match_parent\u0026#34; android:layout_height=\u0026#34;40dp\u0026#34; android:orientation=\u0026#34;horizontal\u0026#34;\u0026gt; \u0026lt;TextView android:layout_width=\u0026#34;wrap_content\u0026#34; android:layout_height=\u0026#34;match_parent\u0026#34; android:gravity=\u0026#34;center\u0026#34; android:text=\u0026#34;彩信标题：\u0026#34; android:textColor=\u0026#34;@color/black\u0026#34; android:textSize=\u0026#34;17sp\u0026#34; /\u0026gt; \u0026lt;EditText android:id=\u0026#34;@+id/et_title\u0026#34; android:layout_width=\u0026#34;0dp\u0026#34; android:layout_height=\u0026#34;match_parent\u0026#34; android:layout_margin=\u0026#34;3dp\u0026#34; android:layout_weight=\u0026#34;1\u0026#34; android:background=\u0026#34;@drawable/edittext_selector\u0026#34; android:textColor=\u0026#34;@color/black\u0026#34; android:textSize=\u0026#34;17sp\u0026#34; android:text=\u0026#34;Hallo\u0026#34;/\u0026gt; \u0026lt;/LinearLayout\u0026gt; \u0026lt;LinearLayout android:layout_width=\u0026#34;match_parent\u0026#34; android:layout_height=\u0026#34;100dp\u0026#34; android:orientation=\u0026#34;horizontal\u0026#34;\u0026gt; \u0026lt;TextView android:layout_width=\u0026#34;wrap_content\u0026#34; android:layout_height=\u0026#34;match_parent\u0026#34; android:gravity=\u0026#34;center\u0026#34; android:text=\u0026#34;彩信内容：\u0026#34; android:textColor=\u0026#34;@color/black\u0026#34; android:textSize=\u0026#34;17sp\u0026#34; /\u0026gt; \u0026lt;EditText android:id=\u0026#34;@+id/et_message\u0026#34; android:layout_width=\u0026#34;0dp\u0026#34; android:layout_height=\u0026#34;match_parent\u0026#34; android:layout_margin=\u0026#34;3dp\u0026#34; android:layout_weight=\u0026#34;1\u0026#34; android:background=\u0026#34;@drawable/edittext_selector\u0026#34; android:gravity=\u0026#34;left|top\u0026#34; android:textColor=\u0026#34;@color/black\u0026#34; android:textSize=\u0026#34;17sp\u0026#34; android:text=\u0026#34;test\u0026#34;/\u0026gt; \u0026lt;/LinearLayout\u0026gt; \u0026lt;TextView android:layout_width=\u0026#34;match_parent\u0026#34; android:layout_height=\u0026#34;30dp\u0026#34; android:text=\u0026#34;点击下方图片开始发送彩信\u0026#34; android:textColor=\u0026#34;@color/black\u0026#34; android:textSize=\u0026#34;17sp\u0026#34; /\u0026gt; \u0026lt;GridLayout andddroid:id=\u0026#34;@+id/gl_appendix\u0026#34; android:layout_width=\u0026#34;match_parent\u0026#34; android:layout_height=\u0026#34;wrap_content\u0026#34; android:columnCount=\u0026#34;3\u0026#34; /\u0026gt; \u0026lt;/LinearLayout\u0026gt; FileProvider 安装apk Java package com.showguan.chapter07_client; public class ProviderApkActivity extends AppCompatActivity implements View.OnClickListener { private static final String TAG = \u0026#34;Kennem\u0026#34;; // 所需权限列表 private static final String[] PERMISSIONS = new String[]{ Manifest.permission.REQUEST_INSTALL_PACKAGES, Manifest.permission.READ_EXTERNAL_STORAGE, Manifest.permission.WRITE_EXTERNAL_STORAGE }; // 请求码，用于权限请求回调标识 private static final int REQUEST_CODE = 1; @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.activity_provider_apk); // 设置按钮点击监听 findViewById(R.id.btn_install).setOnClickListener(this); } @Override public void onClick(View v) { // 检查权限并安装APK checkAndInstall(); } /** * 检查权限并安装APK */ private void checkAndInstall() { if (Build.VERSION.SDK_INT \u0026gt;= Build.VERSION_CODES.R) { Log.d(TAG, \u0026#34;android 11 + \u0026#34;); // 检查是否具有管理所有文件的权限 if (!Environment.isExternalStorageManager()) { Log.d(TAG, \u0026#34;checkisExternalStorageManager\u0026#34;); // 跳转到设置页面请求权限 Intent intent = new Intent(Settings.ACTION_MANAGE_APP_ALL_FILES_ACCESS_PERMISSION); intent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK); intent.setData(Uri.fromParts(\u0026#34;package\u0026#34;, getPackageName(), null)); startActivity(intent); } else { // 权限已授予， // 安装APK installApk(); } } else { // 检查所需权限是否已全部授予 if (PermissionUtil.checkPermission(this, PERMISSIONS, REQUEST_CODE)) { // 权限已授予，安装APK installApk(); } } } /** * 安装APK文件 */ private void installApk() { // 获取APK文件的路径 String apkPath = Environment.getExternalStoragePublicDirectory(Environment.DIRECTORY_DOWNLOADS).toString() + \u0026#34;/chapter06-release.apk\u0026#34;; Log.d(TAG, \u0026#34;apkPath:\u0026#34; + apkPath); // 获取应用包管理器 PackageManager pm = getPackageManager(); // 获取APK文件的包信息 PackageInfo pi = pm.getPackageArchiveInfo(apkPath, PackageManager.GET_ACTIVITIES); if (pi == null) { // 如果包信息为空，显示文件损坏提示 ToastUtil.show(this, \u0026#34;安装文件已经损坏!\u0026#34;); return; } // 获取APK文件的Uri Uri uri = Uri.parse(apkPath); // 兼容Android 7.0及以上版本，通过FileProvider获取Uri if (Build.VERSION.SDK_INT \u0026gt;= Build.VERSION_CODES.N) { // 通过FileProvider获取文件的Uri uri = FileProvider.getUriForFile(this, getString(R.string.file_provider), new File(apkPath)); Log.d(\u0026#34;Kennem\u0026#34;, String.format(\u0026#34;new uri:%s\u0026#34;, uri.toString())); } // 创建Intent以启动APK安装程序 Intent intent = new Intent(Intent.ACTION_VIEW); intent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK); intent.addFlags(Intent.FLAG_GRANT_READ_URI_PERMISSION); // 设置Uri的数据类型为APK文件 intent.setDataAndType(uri, \u0026#34;application/vnd.android.package-archive\u0026#34;); // 启动系统自带的应用安装程序 startActivity(intent); } @Override public void onRequestPermissionsResult(int requestCode, @NonNull String[] permissions, @NonNull int[] grantResults) { super.onRequestPermissionsResult(requestCode, permissions, grantResults); // 检查权限请求结果 if (requestCode == REQUEST_CODE \u0026amp;\u0026amp; PermissionUtil.checkGranted(grantResults)) { // 权限已授予，安装APK installApk(); } } } ","permalink":"https://kennems.github.io/posts/tech/android4/","summary":"Android（4） 就算是最低的15x15都已经不错了，以后还有时间去学，上了研究生也没人能保证你有15x15的收入 内容提供者(Conten","title":"Android（4）"},{"content":"Android（2） Activity的启动和结束 从当前页面跳转到新页面，跳转代码如下：\nstartActivity(new Intent(源页面.this， 目标页面.class)) 从当前页面回到上一个页面，相当于关闭当前页面，返回代码如下：\nfinish(); //结束当前的活动页面 Activity声明周期 onCreate ：创建活动。把页面布局加载进内存，进入了初始状态。 onStart：开始活动。把活动显示在屏幕上，进入了就绪状态 onResume：恢复活动。活动页面进入了活跃状态，能够与用户正常交互，例如允许响应用户的点击动作，允许用户输入文字等等。动画开启 onPause：暂停活动。页面进入暂停状态，无法与用户正常交互。动画暂停 onStop：停止活动。页面不在屏幕上显示。 onDestroy：销毁活动。回收活动占用的系统资源，把页面从内存中清除。 onRestart：重启活动。重新加载内存中的页面数据。 onNewIntent：重用已有的活动实例 Activity的启动模式 launchMode属性值 说明 standard 标准模式，无论何时启动哪个活动，都是重新创建该页面的实例并放入栈顶。如果不指定launchMode属性，则默认为标准模式 singleTop 启动新活动时，判断如果栈顶正好就是该活动的实例，则重用该实例；否则创建新的实例并放入栈顶，也就是按照standard模式处理 singleTask 启动新活动时，判断如果栈中存在该活动的实例，则重用该实例，启动新活动时，判断如果栈中存在该活动的实例，则重用该实例，并清除位于该实例上面的所有实例；否则按照standard模式处理 singleInstance 启动新活动时，将该活动的实例放入一个新栈中，原栈的实例列表保持不变 启动标志的取值说明如下：\nIntent.FLAG_ACTIVITY_NEW_TASK：开辟一个新的任务栈\nIntent.FLAG_ACTIVITY_SINGLE_TOP：当栈顶为待跳转的活动实例之时，则重用栈顶的实例\nIntent.FLAG_ACTIVITY_CLEAR_TOP：当栈中存在待跳转的活动实例时，则重新创建一个新实例，并清除原实例上方的所有实例\nIntent.FLAG_ACTIVITY_NO_HISTORY：栈中不保存新启动的活动实例\nIntent.FLAG_ACTIVITY_CLEAR_TASK：跳转到新页面时，栈中的原有实例都被清空\n显示Intent和隐式Intent Intent是各个组件之间信息沟通的桥梁，它用于Android各组件之间的通信，主要完成下列工作：\n标明本次通信请求从哪里来，到哪里去，要怎么走。 发起方携带本次通信需要的数据内容，接收方从收到的意图中解析数据 发起方若想判断接收方的处理结果，意图就要负责让接收方传回应答的数据内容 显示Intent 显示Intent，直接指定来源活动与目标活动，属于精确匹配。三种构建方式：\n在Intent的构造函数中指定 调用意图对象的setClass方法指定 调用意图对象的setComponent方法指定 @Override public void onClick(View v) { // startActivity(new Intent(this, ActFinishActivity.class)); // Intent intent = new Intent(); // intent.setClass(this, ActFinishActivity.class) // startActivity(intent); Intent intent = new Intent(); ComponentName componentName = new ComponentName(this, ActFinishActivity.class); intent.setComponent(componentName); Log.d(TAG, \u0026#34;ActStartActivity onClick\u0026#34;); } 隐式Intent 没有明确指定要跳转的目标活动，只给出一个动作字符串让系统自动匹配。属于模糊匹配。动作名称既可以通过setAction方法指定，也可以通过构造函数Intent(String action)直接生成意图对象。常用的系统动作如下表：\nAndroidManifest.xml 指定一个需要自定义跳转的View, 将\u0026lt;action\u0026gt; 和 \u0026lt;category\u0026gt;两个标签分别修改为，自定义包名，以及android.intent.category.DEFAULT\n\u0026lt;activity android:name=\u0026#34;.LoginInputActivity\u0026#34; android:exported=\u0026#34;true\u0026#34;\u0026gt; \u0026lt;intent-filter\u0026gt; \u0026lt;action android:name=\u0026#34;android.intent.action.kennem\u0026#34; /\u0026gt; \u0026lt;category android:name=\u0026#34;android.intent.category.DEFAULT\u0026#34; /\u0026gt; \u0026lt;/intent-filter\u0026gt; \u0026lt;/activity\u0026gt; XML \u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;utf-8\u0026#34;?\u0026gt; \u0026lt;LinearLayout xmlns:android=\u0026#34;http://schemas.android.com/apk/res/android\u0026#34; android:id=\u0026#34;@+id/main\u0026#34; android:layout_width=\u0026#34;match_parent\u0026#34; android:layout_height=\u0026#34;match_parent\u0026#34; android:orientation=\u0026#34;vertical\u0026#34;\u0026gt; \u0026lt;TextView android:layout_width=\u0026#34;match_parent\u0026#34; android:layout_height=\u0026#34;wrap_content\u0026#34; android:padding=\u0026#34;5dp\u0026#34; android:text=\u0026#34;点击以下按钮对号码123321发起请求\u0026#34;/\u0026gt; \u0026lt;Button android:id=\u0026#34;@+id/btn_dial\u0026#34; android:layout_width=\u0026#34;match_parent\u0026#34; android:layout_height=\u0026#34;wrap_content\u0026#34; android:text=\u0026#34;跳转到拨号页面\u0026#34;/\u0026gt; \u0026lt;Button android:id=\u0026#34;@+id/btn_sms\u0026#34; android:layout_width=\u0026#34;match_parent\u0026#34; android:layout_height=\u0026#34;wrap_content\u0026#34; android:text=\u0026#34;跳转到发短信页面\u0026#34;/\u0026gt; \u0026lt;Button android:id=\u0026#34;@+id/btn_my\u0026#34; android:layout_width=\u0026#34;match_parent\u0026#34; android:layout_height=\u0026#34;wrap_content\u0026#34; android:text=\u0026#34;跳转到我的页面\u0026#34;/\u0026gt; \u0026lt;/LinearLayout\u0026gt; Java // 定义一个名为 ActUriActivity 的 Activity 类，继承自 AppCompatActivity 并实现 View.OnClickListener 接口 public class ActUriActivity extends AppCompatActivity implements View.OnClickListener { @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); // 设置 Activity 的布局文件 setContentView(R.layout.activity_act_uri); // 为三个按钮设置点击监听器 findViewById(R.id.btn_dial).setOnClickListener(this); findViewById(R.id.btn_sms).setOnClickListener(this); findViewById(R.id.btn_my).setOnClickListener(this); } @Override public void onClick(View v) { // 创建一个 Intent 对象，用于启动其他 Activity Intent intent = new Intent(); // 定义一个电话号码字符串 String phoneNum = \u0026#34;123654789\u0026#34;; // 根据点击的按钮 ID 执行相应的操作 if (v.getId() == R.id.btn_dial) { // 设置 Intent 的 Action 为拨号 intent.setAction(Intent.ACTION_DIAL); // 创建一个 Uri 对象，表示电话号码 Uri uri = Uri.parse(\u0026#34;tel:\u0026#34; + phoneNum); // 将 Uri 数据设置到 Intent 中 intent.setData(uri); // 启动拨号界面 startActivity(intent); } else if (v.getId() == R.id.btn_sms) { // 设置 Intent 的 Action 为发送短信 intent.setAction(Intent.ACTION_SENDTO); // 创建一个 Uri 对象，表示短信号码 Uri uri2 = Uri.parse(\u0026#34;smsto:\u0026#34; + phoneNum); // 将 Uri 数据设置到 Intent 中 intent.setData(uri2); // 启动短信界面 startActivity(intent); } else if (v.getId() == R.id.btn_my) { // 设置 Intent 的 Action 为自定义 Action intent.setAction(\u0026#34;android.intent.action.kennem\u0026#34;); // 添加默认类别 intent.addCategory(Intent.CATEGORY_DEFAULT); // 启动自定义的 Activity startActivity(intent); } } } 向下一个Activity发送数据\nIntent使用Bundle对象存放待传递的数据信息。 Bundle对象操作各种类型数据的读写方法说明： 向下一个Activity发送数据 XML send.xml \u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;utf-8\u0026#34;?\u0026gt; \u0026lt;LinearLayout xmlns:android=\u0026#34;http://schemas.android.com/apk/res/android\u0026#34; android:id=\u0026#34;@+id/main\u0026#34; android:layout_width=\u0026#34;match_parent\u0026#34; android:layout_height=\u0026#34;match_parent\u0026#34; android:orientation=\u0026#34;vertical\u0026#34;\u0026gt; \u0026lt;TextView android:id=\u0026#34;@+id/tv_send\u0026#34; android:layout_width=\u0026#34;match_parent\u0026#34; android:layout_height=\u0026#34;wrap_content\u0026#34; android:text=\u0026#34;坚持下去\u0026#34; android:textSize=\u0026#34;20sp\u0026#34;/\u0026gt; \u0026lt;Button android:id=\u0026#34;@+id/btn_send\u0026#34; android:layout_width=\u0026#34;match_parent\u0026#34; android:layout_height=\u0026#34;wrap_content\u0026#34; android:gravity=\u0026#34;center\u0026#34; android:text=\u0026#34;发送以上的文字\u0026#34; /\u0026gt; \u0026lt;/LinearLayout\u0026gt; receive.xml \u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;utf-8\u0026#34;?\u0026gt; \u0026lt;LinearLayout xmlns:android=\u0026#34;http://schemas.android.com/apk/res/android\u0026#34; android:id=\u0026#34;@+id/main\u0026#34; android:layout_width=\u0026#34;match_parent\u0026#34; android:layout_height=\u0026#34;match_parent\u0026#34; android:orientation=\u0026#34;vertical\u0026#34;\u0026gt; \u0026lt;TextView android:id=\u0026#34;@+id/tv_receive\u0026#34; android:layout_width=\u0026#34;match_parent\u0026#34; android:layout_height=\u0026#34;wrap_content\u0026#34; android:text=\u0026#34;坚持下去\u0026#34; android:textSize=\u0026#34;20sp\u0026#34;/\u0026gt; \u0026lt;/LinearLayout\u0026gt; Java ActSentActivity.java package com.showguan.chapter04; public class ActSentActivity extends AppCompatActivity implements View.OnClickListener { private TextView tv_send; @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.activity_act_sent); tv_send = findViewById(R.id.tv_send); findViewById(R.id.btn_send).setOnClickListener(this); } @Override public void onClick(View v) { Intent intent = new Intent(this, ActReceiveActivity.class); Bundle bundle = new Bundle(); bundle.putString(\u0026#34;request_time\u0026#34;, DateUtil.getNowTime()); bundle.putString(\u0026#34;request_content\u0026#34;, tv_send.getText().toString()); intent.putExtras(bundle); startActivity(intent); } } ActReceiveActivity.java package com.showguan.chapter04; public class ActReceiveActivity extends AppCompatActivity { private TextView tv_send; private TextView tv_receive; @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.activity_act_receive); tv_receive = findViewById(R.id.tv_receive); Bundle bundle = getIntent().getExtras(); String request_time = bundle.getString(\u0026#34;request_time\u0026#34;); String request_content = bundle.getString(\u0026#34;request_content\u0026#34;); String desc = String.format(\u0026#34;成功收到消息，收到时间为%s, 收到内容为%s\u0026#34;, request_time, request_content); tv_receive.setText(desc); } } 向上一个Activity返回数据 XML request.xml \u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;utf-8\u0026#34;?\u0026gt; \u0026lt;LinearLayout xmlns:android=\u0026#34;http://schemas.android.com/apk/res/android\u0026#34; android:id=\u0026#34;@+id/main\u0026#34; android:layout_width=\u0026#34;match_parent\u0026#34; android:layout_height=\u0026#34;match_parent\u0026#34; android:orientation=\u0026#34;vertical\u0026#34;\u0026gt; \u0026lt;TextView android:id=\u0026#34;@+id/tv_request\u0026#34; android:layout_margin=\u0026#34;30dp\u0026#34; android:layout_width=\u0026#34;match_parent\u0026#34; android:textSize=\u0026#34;15sp\u0026#34; android:layout_height=\u0026#34;wrap_content\u0026#34; /\u0026gt; \u0026lt;Button android:id=\u0026#34;@+id/btn_request\u0026#34; android:layout_width=\u0026#34;match_parent\u0026#34; android:layout_height=\u0026#34;wrap_content\u0026#34; android:layout_margin=\u0026#34;30dp\u0026#34; android:gravity=\u0026#34;center\u0026#34; android:text=\u0026#34;请求传送数据\u0026#34; /\u0026gt; \u0026lt;TextView android:id=\u0026#34;@+id/tv_response\u0026#34; android:layout_margin=\u0026#34;30dp\u0026#34; android:layout_width=\u0026#34;match_parent\u0026#34; android:layout_height=\u0026#34;wrap_content\u0026#34;/\u0026gt; \u0026lt;/LinearLayout\u0026gt; response.xml \u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;utf-8\u0026#34;?\u0026gt; \u0026lt;LinearLayout xmlns:android=\u0026#34;http://schemas.android.com/apk/res/android\u0026#34; xmlns:app=\u0026#34;http://schemas.android.com/apk/res-auto\u0026#34; xmlns:tools=\u0026#34;http://schemas.android.com/tools\u0026#34; android:id=\u0026#34;@+id/main\u0026#34; android:layout_width=\u0026#34;match_parent\u0026#34; android:layout_height=\u0026#34;match_parent\u0026#34; android:orientation=\u0026#34;vertical\u0026#34;\u0026gt; \u0026lt;TextView android:id=\u0026#34;@+id/tv_request\u0026#34; android:layout_width=\u0026#34;match_parent\u0026#34; android:layout_height=\u0026#34;wrap_content\u0026#34; /\u0026gt; \u0026lt;Button android:id=\u0026#34;@+id/btn_response\u0026#34; android:layout_width=\u0026#34;match_parent\u0026#34; android:layout_height=\u0026#34;wrap_content\u0026#34; android:gravity=\u0026#34;center\u0026#34; android:text=\u0026#34;请求传送数据\u0026#34; /\u0026gt; \u0026lt;TextView android:id=\u0026#34;@+id/tv_response\u0026#34; android:layout_width=\u0026#34;match_parent\u0026#34; android:layout_height=\u0026#34;wrap_content\u0026#34;/\u0026gt; \u0026lt;/LinearLayout\u0026gt; Java ActRequestActivity.java package com.showguan.chapter04; public class ActRequestActivity extends AppCompatActivity implements View.OnClickListener { // 要发送的请求内容 private final String mRequest = \u0026#34;今天是2024/06/18， 坚持就是胜利，效率就是王者\u0026#34;; // 用于启动活动并接收结果的启动器 private ActivityResultLauncher\u0026lt;Intent\u0026gt; register; // 显示响应内容的TextView private TextView tv_response; // 显示请求内容的TextView private TextView tv_request; @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); // 设置活动的布局 setContentView(R.layout.activity_act_request); // 绑定显示请求内容的TextView tv_request = findViewById(R.id.tv_request); // 绑定显示响应内容的TextView tv_response = findViewById(R.id.tv_response); // 设置待发送的文本内容 tv_request.setText(\u0026#34;待发送的文本：\u0026#34; + mRequest); // 绑定按钮点击事件 findViewById(R.id.btn_request).setOnClickListener(this); // 注册一个用于启动活动并接收结果的启动器 register = registerForActivityResult(new ActivityResultContracts.StartActivityForResult(), result -\u0026gt; { if (result != null) { // 获取返回的Intent Intent intent = result.getData(); if (intent != null \u0026amp;\u0026amp; result.getResultCode() == Activity.RESULT_OK) { // 获取Intent中的数据 Bundle bundle = intent.getExtras(); String request_time = bundle.getString(\u0026#34;response_time\u0026#34;); String request_content = bundle.getString(\u0026#34;response_content\u0026#34;); // 格式化显示响应消息 String desc = String.format(\u0026#34;收到应答消息，应答时间为%s, 应答内容为%s\u0026#34;, request_time, request_content); tv_response.setText(desc); } } }); } @Override public void onClick(View v) { // 创建一个启动ActResponseActivity的Intent Intent intent = new Intent(this, ActResponseActivity.class); // 创建一个Bundle用于传递请求数据 Bundle bundle = new Bundle(); // 将当前时间和请求内容放入Bundle bundle.putString(\u0026#34;request_time\u0026#34;, DateUtil.getNowTime()); bundle.putString(\u0026#34;request_content\u0026#34;, mRequest); // 将Bundle放入Intent intent.putExtras(bundle); // 启动活动并等待结果 register.launch(intent); } } ActResponseActivity.java package com.showguan.chapter04; public class ActResponseActivity extends AppCompatActivity implements View.OnClickListener { // 静态常量，表示响应的内容 private static final String mResponse = \u0026#34;我™一定能进小米\u0026#34;; @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); // 设置活动的布局 setContentView(R.layout.activity_act_response); // 绑定显示请求内容的TextView TextView tv_request = findViewById(R.id.tv_request); // 获取启动此活动时传递的Intent中的Extras Bundle bundle = getIntent().getExtras(); // 从Extras中获取请求的时间和内容 String request_time = bundle.getString(\u0026#34;request_time\u0026#34;); String request_content = bundle.getString(\u0026#34;request_content\u0026#34;); // 格式化显示接收到的请求消息 String desc = String.format(\u0026#34;成功收到消息，收到时间为%s, 收到内容为%s\u0026#34;, request_time, request_content); tv_request.setText(desc); // 绑定响应按钮的点击事件 findViewById(R.id.btn_response).setOnClickListener(this); // 绑定显示响应内容的TextView TextView tv_response = findViewById(R.id.tv_response); // 设置待返回的响应内容 tv_response.setText(\u0026#34;待返回的内容：\u0026#34; + mResponse); } @Override public void onClick(View v) { // 创建一个返回给ActRequestActivity的Intent Intent intent = new Intent(this, ActRequestActivity.class); // 创建一个Bundle用于传递响应数据 Bundle bundle = new Bundle(); // 将当前时间和响应内容放入Bundle bundle.putString(\u0026#34;response_time\u0026#34;, DateUtil.getNowTime()); bundle.putString(\u0026#34;response_content\u0026#34;, \u0026#34;应答内容：\u0026#34; + mResponse); // 将Bundle放入Intent intent.putExtras(bundle); // 设置结果码和返回的Intent setResult(Activity.RESULT_OK, intent); // 结束当前活动 finish(); } } 为活动补充附加信息 将string信息定义在strings.xml\n\u0026lt;resources\u0026gt; \u0026lt;string name=\u0026#34;app_name\u0026#34;\u0026gt;chapter04\u0026lt;/string\u0026gt; \u0026lt;string name=\u0026#34;weather_info\u0026#34;\u0026gt;今天是个糟糕的一天\u0026lt;/string\u0026gt; \u0026lt;/resources\u0026gt; java代码中引用即可：\nTextView tv_resource = findViewById(R.id.tv_resource); String value = getString(R.string.weather_info); tv_resource.setText(value); 在代码中获取元数据 在AndroidManifest.xml文件中指定metadata \u0026lt;activity android:name=\u0026#34;.ActStartActivity\u0026#34; android:exported=\u0026#34;true\u0026#34; android:launchMode=\u0026#34;standard\u0026#34;\u0026gt; \u0026lt;intent-filter\u0026gt; \u0026lt;action android:name=\u0026#34;android.intent.action.MAIN\u0026#34; /\u0026gt; \u0026lt;category android:name=\u0026#34;android.intent.category.LAUNCHER\u0026#34; /\u0026gt; \u0026lt;/intent-filter\u0026gt; \u0026lt;meta-data android:name=\u0026#34;android.app.shortcuts\u0026#34; android:resource=\u0026#34;@xml/shortcuts\u0026#34; /\u0026gt; \u0026lt;/activity\u0026gt; 编写shortcuts.xml， 指定显示的名称和要跳转的页面 \u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;utf-8\u0026#34;?\u0026gt; \u0026lt;shortcuts xmlns:android=\u0026#34;http://schemas.android.com/apk/res/android\u0026#34;\u0026gt; \u0026lt;shortcut android:enabled=\u0026#34;true\u0026#34; android:icon=\u0026#34;@mipmap/ic_launcher\u0026#34; android:shortcutId=\u0026#34;first\u0026#34; android:shortcutLongLabel=\u0026#34;@string/first_long\u0026#34; android:shortcutShortLabel=\u0026#34;@string/first_short\u0026#34;\u0026gt; \u0026lt;intent android:action=\u0026#34;android.intent.action.VIEW\u0026#34; android:targetClass=\u0026#34;com.showguan.chapter04.ActStartActivity\u0026#34; android:targetPackage=\u0026#34;com.showguan.chapter04\u0026#34;\u0026gt; \u0026lt;categories android:name=\u0026#34;android.shortcut.conversation\u0026#34; /\u0026gt; \u0026lt;/intent\u0026gt; \u0026lt;/shortcut\u0026gt; \u0026lt;shortcut android:enabled=\u0026#34;true\u0026#34; android:icon=\u0026#34;@mipmap/ic_launcher\u0026#34; android:shortcutId=\u0026#34;second\u0026#34; android:shortcutLongLabel=\u0026#34;@string/second_long\u0026#34; android:shortcutShortLabel=\u0026#34;@string/second_short\u0026#34;\u0026gt; \u0026lt;intent android:action=\u0026#34;android.intent.action.VIEW\u0026#34; android:targetClass=\u0026#34;com.showguan.chapter04.JumpFirstActivity\u0026#34; android:targetPackage=\u0026#34;com.showguan.chapter04\u0026#34;\u0026gt; \u0026lt;categories android:name=\u0026#34;android.shortcut.conversation\u0026#34; /\u0026gt; \u0026lt;/intent\u0026gt; \u0026lt;/shortcut\u0026gt; \u0026lt;shortcut android:enabled=\u0026#34;true\u0026#34; android:icon=\u0026#34;@mipmap/ic_launcher\u0026#34; android:shortcutId=\u0026#34;third\u0026#34; android:shortcutLongLabel=\u0026#34;@string/third_long\u0026#34; android:shortcutShortLabel=\u0026#34;@string/third_short\u0026#34;\u0026gt; \u0026lt;intent android:action=\u0026#34;android.intent.action.VIEW\u0026#34; android:targetClass=\u0026#34;com.showguan.chapter04.LoginInputActivity\u0026#34; android:targetPackage=\u0026#34;com.showguan.chapter04\u0026#34;\u0026gt; \u0026lt;categories android:name=\u0026#34;android.shortcut.conversation\u0026#34; /\u0026gt; \u0026lt;/intent\u0026gt; \u0026lt;/shortcut\u0026gt; \u0026lt;/shortcuts\u0026gt; 注意名称需要存储在strings.xml中\nAndroidManifest.xml中需要跳转的页面exported属性要设置为true 中级控件 图形Drawable Drawable类型表达了各种各样的图形，包括图片，色块，画板， 背景等\n包含图片在内的图形文件放在res目录的各个drawable目录下，其中drawable目录一般保存描述性的XML文件，而图片文件一般放在具体分辨率的drawable目录下。\ndrawable-ldpi, drawable-mdpi, drawable-hdpi, drawable-xhdpi,drawable-xxhdpi， drawable-xxhdpi表示低分辨率，中等分辨率，高分辨率，超高分辨率， 超超高分辨率 各视图的background属性，ImageView和ImageButton的src属性，TextView和Button四个方向的drawable系列属性都可以引用图形文件。\n形状图形 shape图形又称形状图形，它用来描述常见的几何形状，包括矩形，圆角矩形，圆形，椭圆等。 形状图形 drawable中xml \u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;utf-8\u0026#34;?\u0026gt; \u0026lt;shape xmlns:android=\u0026#34;http://schemas.android.com/apk/res/android\u0026#34; android:shape=\u0026#34;oval\u0026#34;\u0026gt; \u0026lt;solid android:color=\u0026#34;#ff66aa\u0026#34;/\u0026gt; \u0026lt;stroke android:width=\u0026#34;1dp\u0026#34; android:color=\u0026#34;#aaaaaa\u0026#34;/\u0026gt; \u0026lt;/shape\u0026gt; \u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;utf-8\u0026#34;?\u0026gt; \u0026lt;shape xmlns:android=\u0026#34;http://schemas.android.com/apk/res/android\u0026#34;\u0026gt; \u0026lt;!-- 填充颜色--\u0026gt; \u0026lt;solid android:color=\u0026#34;#ffdd66\u0026#34; /\u0026gt; \u0026lt;!-- 轮廓粗细与颜色--\u0026gt; \u0026lt;stroke android:width=\u0026#34;1dp\u0026#34; android:color=\u0026#34;#aaaaaa\u0026#34; /\u0026gt; \u0026lt;!-- 形状四个圆角的半径--\u0026gt; \u0026lt;corners android:radius=\u0026#34;10dp\u0026#34; /\u0026gt; \u0026lt;/shape\u0026gt; activity_draw_shape.xml \u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;utf-8\u0026#34;?\u0026gt; \u0026lt;LinearLayout xmlns:android=\u0026#34;http://schemas.android.com/apk/res/android\u0026#34; android:id=\u0026#34;@+id/main\u0026#34; android:layout_width=\u0026#34;match_parent\u0026#34; android:layout_height=\u0026#34;match_parent\u0026#34; android:orientation=\u0026#34;vertical\u0026#34;\u0026gt; \u0026lt;View android:id=\u0026#34;@+id/v_content\u0026#34; android:layout_width=\u0026#34;match_parent\u0026#34; android:layout_height=\u0026#34;200dp\u0026#34; android:layout_margin=\u0026#34;10dp\u0026#34;/\u0026gt; \u0026lt;LinearLayout android:layout_width=\u0026#34;match_parent\u0026#34; android:layout_height=\u0026#34;wrap_content\u0026#34; android:orientation=\u0026#34;horizontal\u0026#34;\u0026gt; \u0026lt;Button android:id=\u0026#34;@+id/btn_rect\u0026#34; android:layout_width=\u0026#34;0dp\u0026#34; android:layout_height=\u0026#34;wrap_content\u0026#34; android:layout_weight=\u0026#34;1\u0026#34; android:text=\u0026#34;圆角矩形按钮\u0026#34;/\u0026gt; \u0026lt;Button android:id=\u0026#34;@+id/btn_oval\u0026#34; android:layout_width=\u0026#34;0dp\u0026#34; android:layout_height=\u0026#34;wrap_content\u0026#34; android:layout_weight=\u0026#34;1\u0026#34; android:text=\u0026#34;椭圆按钮\u0026#34;/\u0026gt; \u0026lt;/LinearLayout\u0026gt; \u0026lt;/LinearLayout\u0026gt; Java package com.showguan.chapter05; public class DrawShapeActivity extends AppCompatActivity implements View.OnClickListener { private View v_content; @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.activity_draw_shape); v_content = findViewById(R.id.v_content); findViewById(R.id.btn_rect).setOnClickListener(this); findViewById(R.id.btn_oval).setOnClickListener(this); v_content.setBackgroundResource(R.drawable.shape_rect_gold); } @Override public void onClick(View v) { if(v.getId() == R.id.btn_rect){ v_content.setBackgroundResource(R.drawable.shape_rect_gold); }else if (v.getId()==R.id.btn_oval){ v_content.setBackgroundResource(R.drawable.shape_oval_rose); } } } 九宫格图片 将某张图片设置为视图背景时，如果图片尺寸太小，则系统会自动拉伸图片使之填满背景 可是一旦图片拉得过大，其画面容易变得模糊 创建.9文件 状态列表图形 btn_nice_selector.xml \u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;utf-8\u0026#34;?\u0026gt; \u0026lt;selector xmlns:android=\u0026#34;http://schemas.android.com/apk/res/android\u0026#34;\u0026gt; \u0026lt;item android:state_pressed=\u0026#34;true\u0026#34; android:drawable=\u0026#34;@drawable/button_pressed\u0026#34; /\u0026gt; \u0026lt;item android:drawable=\u0026#34;@drawable/button_normal\u0026#34; /\u0026gt; \u0026lt;/selector\u0026gt; 复选框checkbox xml \u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;utf-8\u0026#34;?\u0026gt; \u0026lt;LinearLayout xmlns:android=\u0026#34;http://schemas.android.com/apk/res/android\u0026#34; android:id=\u0026#34;@+id/main\u0026#34; android:layout_width=\u0026#34;match_parent\u0026#34; android:layout_height=\u0026#34;match_parent\u0026#34; android:orientation=\u0026#34;vertical\u0026#34;\u0026gt; \u0026lt;CheckBox android:id=\u0026#34;@+id/ck_system\u0026#34; android:layout_width=\u0026#34;match_parent\u0026#34; android:layout_height=\u0026#34;wrap_content\u0026#34; android:layout_marginTop=\u0026#34;5dp\u0026#34; android:text=\u0026#34;系统的checkbox\u0026#34;/\u0026gt; \u0026lt;CheckBox android:id=\u0026#34;@+id/ck_custom\u0026#34; android:layout_width=\u0026#34;match_parent\u0026#34; android:layout_height=\u0026#34;wrap_content\u0026#34; android:button=\u0026#34;@drawable/checkbox_selector\u0026#34; android:layout_marginTop=\u0026#34;10dp\u0026#34; android:checked=\u0026#34;true\u0026#34; android:text=\u0026#34;系统的checkbox\u0026#34;/\u0026gt; \u0026lt;/LinearLayout\u0026gt; Java package com.showguan.chapter05; import android.os.Bundle; import android.view.View; import android.widget.CheckBox; import android.widget.CompoundButton; import androidx.activity.EdgeToEdge; import androidx.appcompat.app.AppCompatActivity; import androidx.core.graphics.Insets; import androidx.core.view.ViewCompat; import androidx.core.view.WindowInsetsCompat; public class CheckBoxActivity extends AppCompatActivity implements CompoundButton.OnCheckedChangeListener { @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.activity_check_box); CheckBox ck_system = findViewById(R.id.ck_system); CheckBox ck_custom = findViewById(R.id.ck_custom); ck_system.setOnCheckedChangeListener(this); ck_custom.setOnCheckedChangeListener(this); } @Override public void onCheckedChanged(CompoundButton buttonView, boolean isChecked) { String desc = String.format(\u0026#34;您%s此按钮。\u0026#34; , isChecked ? \u0026#34;勾选了\u0026#34; : \u0026#34;取消勾选了\u0026#34;); buttonView.setText(desc); } } 开关Switch xml \u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;utf-8\u0026#34;?\u0026gt; \u0026lt;LinearLayout xmlns:android=\u0026#34;http://schemas.android.com/apk/res/android\u0026#34; android:id=\u0026#34;@+id/main\u0026#34; android:layout_width=\u0026#34;match_parent\u0026#34; android:layout_height=\u0026#34;match_parent\u0026#34; android:orientation=\u0026#34;vertical\u0026#34;\u0026gt; \u0026lt;LinearLayout android:layout_width=\u0026#34;match_parent\u0026#34; android:layout_height=\u0026#34;wrap_content\u0026#34; android:orientation=\u0026#34;horizontal\u0026#34;\u0026gt; \u0026lt;TextView android:layout_width=\u0026#34;0dp\u0026#34; android:layout_height=\u0026#34;wrap_content\u0026#34; android:layout_gravity=\u0026#34;start\u0026#34; android:layout_marginTop=\u0026#34;5dp\u0026#34; android:layout_weight=\u0026#34;1\u0026#34; android:text=\u0026#34;开关\u0026#34; android:textSize=\u0026#34;17sp\u0026#34; /\u0026gt; \u0026lt;Switch android:id=\u0026#34;@+id/sw_status\u0026#34; android:layout_width=\u0026#34;wrap_content\u0026#34; android:layout_height=\u0026#34;wrap_content\u0026#34; android:layout_gravity=\u0026#34;end\u0026#34; android:width=\u0026#34;80dp\u0026#34; android:height=\u0026#34;30dp\u0026#34; android:padding=\u0026#34;5dp\u0026#34; /\u0026gt; \u0026lt;/LinearLayout\u0026gt; \u0026lt;TextView android:id=\u0026#34;@+id/tv_result\u0026#34; android:layout_width=\u0026#34;0dp\u0026#34; android:layout_height=\u0026#34;wrap_content\u0026#34; android:layout_gravity=\u0026#34;start\u0026#34; android:layout_marginTop=\u0026#34;10dp\u0026#34; android:layout_weight=\u0026#34;1\u0026#34; android:gravity=\u0026#34;start\u0026#34; /\u0026gt; \u0026lt;/LinearLayout\u0026gt; Java package com.showguan.chapter05; public class SwitchActivity extends AppCompatActivity implements CompoundButton.OnCheckedChangeListener { private TextView tv_result; @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.activity_switch); Switch sw_status = findViewById(R.id.sw_status); tv_result = findViewById(R.id.tv_result); sw_status.setOnCheckedChangeListener(this); } @Override public void onCheckedChanged(CompoundButton buttonView, boolean isChecked) { String desc = String.format(\u0026#34;Switch按钮的状态是%s\u0026#34;, isChecked ? \u0026#34;开\u0026#34; : \u0026#34;关\u0026#34;); tv_result.setText(desc); } } 用checkbox实现switch xml \u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;utf-8\u0026#34;?\u0026gt; \u0026lt;LinearLayout xmlns:android=\u0026#34;http://schemas.android.com/apk/res/android\u0026#34; android:id=\u0026#34;@+id/main\u0026#34; android:layout_width=\u0026#34;match_parent\u0026#34; android:layout_height=\u0026#34;match_parent\u0026#34; android:orientation=\u0026#34;vertical\u0026#34;\u0026gt; \u0026lt;LinearLayout android:layout_width=\u0026#34;match_parent\u0026#34; android:layout_height=\u0026#34;wrap_content\u0026#34; android:orientation=\u0026#34;horizontal\u0026#34;\u0026gt; \u0026lt;TextView android:layout_width=\u0026#34;0dp\u0026#34; android:layout_height=\u0026#34;wrap_content\u0026#34; android:layout_gravity=\u0026#34;start\u0026#34; android:layout_marginTop=\u0026#34;5dp\u0026#34; android:layout_weight=\u0026#34;1\u0026#34; android:text=\u0026#34;开关\u0026#34; android:textSize=\u0026#34;17sp\u0026#34; /\u0026gt; \u0026lt;CheckBox android:id=\u0026#34;@+id/ck_status\u0026#34; android:layout_width=\u0026#34;60dp\u0026#34; android:layout_height=\u0026#34;30dp\u0026#34; android:layout_gravity=\u0026#34;end\u0026#34; android:width=\u0026#34;80dp\u0026#34; android:height=\u0026#34;30dp\u0026#34; android:background=\u0026#34;@drawable/switch_selector\u0026#34; android:button=\u0026#34;@null\u0026#34; /\u0026gt; \u0026lt;/LinearLayout\u0026gt; \u0026lt;TextView android:id=\u0026#34;@+id/tv_result\u0026#34; android:layout_width=\u0026#34;match_parent\u0026#34; android:layout_height=\u0026#34;wrap_content\u0026#34; android:layout_gravity=\u0026#34;start\u0026#34; android:layout_marginTop=\u0026#34;10dp\u0026#34; android:gravity=\u0026#34;start\u0026#34; /\u0026gt; \u0026lt;/LinearLayout\u0026gt; Java package com.showguan.chapter05; public class SwitchIOSActivity extends AppCompatActivity implements CompoundButton.OnCheckedChangeListener { private TextView tv_result; @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.activity_switch_iosactivity); CheckBox ck_status = findViewById(R.id.ck_status); tv_result = findViewById(R.id.tv_result); ck_status.setOnCheckedChangeListener(this); } @Override public void onCheckedChanged(CompoundButton buttonView, boolean isChecked) { String desc = String.format(\u0026#34;开关按钮的状态是%s\u0026#34;, isChecked ? \u0026#34;开\u0026#34; : \u0026#34;关\u0026#34;); tv_result.setText(desc); } } 单选按钮RadioButton XML \u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;utf-8\u0026#34;?\u0026gt; \u0026lt;LinearLayout xmlns:android=\u0026#34;http://schemas.android.com/apk/res/android\u0026#34; android:id=\u0026#34;@+id/main\u0026#34; android:layout_width=\u0026#34;match_parent\u0026#34; android:layout_height=\u0026#34;match_parent\u0026#34; android:orientation=\u0026#34;vertical\u0026#34;\u0026gt; \u0026lt;TextView android:layout_width=\u0026#34;match_parent\u0026#34; android:layout_height=\u0026#34;wrap_content\u0026#34; android:layout_gravity=\u0026#34;start\u0026#34; android:layout_marginTop=\u0026#34;5dp\u0026#34; android:text=\u0026#34;请选择你的性别\u0026#34; android:textSize=\u0026#34;17sp\u0026#34; /\u0026gt; \u0026lt;RadioGroup android:id=\u0026#34;@+id/rg_gender\u0026#34; android:layout_width=\u0026#34;match_parent\u0026#34; android:layout_height=\u0026#34;wrap_content\u0026#34; android:orientation=\u0026#34;horizontal\u0026#34;\u0026gt; \u0026lt;RadioButton android:id=\u0026#34;@+id/rb_male\u0026#34; android:layout_width=\u0026#34;0dp\u0026#34; android:layout_height=\u0026#34;wrap_content\u0026#34; android:layout_weight=\u0026#34;1\u0026#34; android:text=\u0026#34;男\u0026#34; /\u0026gt; \u0026lt;RadioButton android:id=\u0026#34;@+id/rb_female\u0026#34; android:layout_width=\u0026#34;0dp\u0026#34; android:layout_height=\u0026#34;wrap_content\u0026#34; android:layout_weight=\u0026#34;1\u0026#34; android:text=\u0026#34;女\u0026#34; /\u0026gt; \u0026lt;/RadioGroup\u0026gt; \u0026lt;TextView android:id=\u0026#34;@+id/tv_result\u0026#34; android:layout_width=\u0026#34;match_parent\u0026#34; android:layout_height=\u0026#34;wrap_content\u0026#34; android:layout_marginTop=\u0026#34;10dp\u0026#34; android:textSize=\u0026#34;17sp\u0026#34; /\u0026gt; \u0026lt;/LinearLayout\u0026gt; Java package com.showguan.chapter05; public class RadioHorizontalActivity extends AppCompatActivity implements RadioGroup.OnCheckedChangeListener { private TextView tv_result; @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.activity_radio_horizontal); RadioGroup rg_gender = findViewById(R.id.rg_gender); rg_gender.setOnCheckedChangeListener(this); tv_result = findViewById(R.id.tv_result); } @Override public void onCheckedChanged(RadioGroup group, int checkedId) { if(checkedId == R.id.rb_male){ tv_result.setText(\u0026#34;你是个帅气的男孩\u0026#34;); } else if (checkedId==R.id.rb_female) { tv_result.setText(\u0026#34;你是个漂亮的女孩\u0026#34;); } } } EditText设置外框 XML \u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;utf-8\u0026#34;?\u0026gt; \u0026lt;LinearLayout xmlns:android=\u0026#34;http://schemas.android.com/apk/res/android\u0026#34; android:id=\u0026#34;@+id/main\u0026#34; android:layout_width=\u0026#34;match_parent\u0026#34; android:layout_height=\u0026#34;match_parent\u0026#34; android:orientation=\u0026#34;vertical\u0026#34; android:padding=\u0026#34;5dp\u0026#34;\u0026gt; \u0026lt;EditText android:layout_width=\u0026#34;match_parent\u0026#34; android:layout_height=\u0026#34;wrap_content\u0026#34; android:hint=\u0026#34;这里是默认边框\u0026#34; android:inputType=\u0026#34;text\u0026#34;/\u0026gt; \u0026lt;EditText android:layout_width=\u0026#34;match_parent\u0026#34; android:layout_height=\u0026#34;wrap_content\u0026#34; android:hint=\u0026#34;这里没有边框\u0026#34; android:inputType=\u0026#34;text\u0026#34; android:layout_marginTop=\u0026#34;5dp\u0026#34; android:background=\u0026#34;@null\u0026#34;/\u0026gt; \u0026lt;EditText android:layout_width=\u0026#34;match_parent\u0026#34; android:layout_height=\u0026#34;wrap_content\u0026#34; android:hint=\u0026#34;这里是圆角边框\u0026#34; android:inputType=\u0026#34;text\u0026#34; android:layout_marginTop=\u0026#34;5dp\u0026#34; android:background=\u0026#34;@drawable/edittext_selector\u0026#34; /\u0026gt; \u0026lt;/LinearLayout\u0026gt; Java public class EditBoardActivity extends AppCompatActivity { @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.activity_edit_board); } } 对话提示框 XML \u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;utf-8\u0026#34;?\u0026gt; \u0026lt;LinearLayout xmlns:android=\u0026#34;http://schemas.android.com/apk/res/android\u0026#34; android:id=\u0026#34;@+id/main\u0026#34; android:layout_width=\u0026#34;match_parent\u0026#34; android:layout_height=\u0026#34;match_parent\u0026#34; android:orientation=\u0026#34;vertical\u0026#34; android:padding=\u0026#34;5dp\u0026#34;\u0026gt; \u0026lt;Button android:id=\u0026#34;@+id/btn_alert\u0026#34; android:layout_width=\u0026#34;match_parent\u0026#34; android:layout_height=\u0026#34;wrap_content\u0026#34; android:hint=\u0026#34;这里没有边框\u0026#34; android:text=\u0026#34;点击弹出提醒对话框\u0026#34; android:layout_marginTop=\u0026#34;5dp\u0026#34; android:background=\u0026#34;@null\u0026#34;/\u0026gt; \u0026lt;TextView android:id=\u0026#34;@+id/tv_alert\u0026#34; android:layout_width=\u0026#34;match_parent\u0026#34; android:layout_height=\u0026#34;wrap_content\u0026#34; android:layout_marginTop=\u0026#34;5dp\u0026#34; /\u0026gt; \u0026lt;/LinearLayout\u0026gt; Java package com.showguan.chapter05; import android.os.Bundle; import android.view.View; import android.widget.TextView; import androidx.appcompat.app.AlertDialog; import androidx.appcompat.app.AppCompatActivity; public class AlertDialogActivity extends AppCompatActivity implements View.OnClickListener { private TextView tv_alert; @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.activity_alert_dialog); findViewById(R.id.btn_alert).setOnClickListener(this); tv_alert = findViewById(R.id.tv_alert); } @Override public void onClick(View v) { AlertDialog.Builder builder = new AlertDialog.Builder(this); builder.setTitle(\u0026#34;尊敬的用户朋友\u0026#34;); builder.setMessage(\u0026#34;你真的确定没点错吗？\u0026#34;); builder.setPositiveButton(\u0026#34;残忍卸载\u0026#34;, (dialog, which) -\u0026gt; { tv_alert.setText(\u0026#34;虽然依依不舍，但是希望能再见面\u0026#34;); }); builder.setNegativeButton(\u0026#34;点错了哦\u0026#34;, (dialog, which) -\u0026gt; { tv_alert.setText(\u0026#34;我还要再陪你365*n个日夜\u0026#34;); }); AlertDialog dialog = builder.create(); dialog.show(); } } 文本框提示信息 XML \u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;utf-8\u0026#34;?\u0026gt; \u0026lt;LinearLayout xmlns:android=\u0026#34;http://schemas.android.com/apk/res/android\u0026#34; android:id=\u0026#34;@+id/main\u0026#34; android:layout_width=\u0026#34;match_parent\u0026#34; android:layout_height=\u0026#34;match_parent\u0026#34; android:orientation=\u0026#34;vertical\u0026#34; android:padding=\u0026#34;5dp\u0026#34;\u0026gt; \u0026lt;EditText android:id=\u0026#34;@+id/et_phone\u0026#34; android:layout_width=\u0026#34;match_parent\u0026#34; android:layout_height=\u0026#34;wrap_content\u0026#34; android:hint=\u0026#34;请输入11位手机号码\u0026#34; android:inputType=\u0026#34;number\u0026#34; android:maxLength=\u0026#34;11\u0026#34; android:layout_marginTop=\u0026#34;15dp\u0026#34; android:background=\u0026#34;@drawable/edittext_selector\u0026#34;/\u0026gt; \u0026lt;EditText android:id=\u0026#34;@+id/et_password\u0026#34; android:layout_width=\u0026#34;match_parent\u0026#34; android:layout_height=\u0026#34;wrap_content\u0026#34; android:hint=\u0026#34;请输入6位密码\u0026#34; android:inputType=\u0026#34;numberPassword\u0026#34; android:maxLength=\u0026#34;11\u0026#34; android:layout_marginTop=\u0026#34;15dp\u0026#34; android:background=\u0026#34;@drawable/edittext_selector\u0026#34;/\u0026gt; \u0026lt;Button android:layout_width=\u0026#34;match_parent\u0026#34; android:layout_marginTop=\u0026#34;15dp\u0026#34; android:layout_height=\u0026#34;wrap_content\u0026#34; android:text=\u0026#34;登录\u0026#34;/\u0026gt; \u0026lt;/LinearLayout\u0026gt; Java package com.showguan.chapter05; public class EditFocusActivity extends AppCompatActivity implements View.OnFocusChangeListener { private EditText et_phone; @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.activity_edit_focus); et_phone = findViewById(R.id.et_phone); et_phone.setOnFocusChangeListener(this); } @Override public void onFocusChange(View v, boolean hasFocus) { if(!hasFocus){ String phone = et_phone.getText().toString(); if(TextUtils.isEmpty(phone) || phone.length() \u0026lt; 11){ // et_phone.requestFocus(); Toast.makeText(this, \u0026#34;请输入11位手机号码\u0026#34;, Toast.LENGTH_SHORT).show(); } } } } 实现当文本长度符合时自动收起输入法 @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.activity_edit_hide); // 设置当前活动的布局 // 获取布局文件中的EditText控件 EditText et_phone = findViewById(R.id.et_phone); EditText et_password = findViewById(R.id.et_password); // 为EditText控件添加文本变化监听器 et_phone.addTextChangedListener(new HideTextWatcher(et_phone, 11)); et_password.addTextChangedListener(new HideTextWatcher(et_password, 6)); } // 自定义的文本监听器类，用于在文本长度达到指定值时隐藏输入法 private class HideTextWatcher implements TextWatcher { private EditText mView; // 需要监听的EditText控件 private int mMaxLength; // 文本长度的最大值 // 构造函数，初始化控件和最大长度 public HideTextWatcher(EditText et, int maxLength) { this.mView = et; this.mMaxLength = maxLength; } // 文本变化前的回调方法 @Override public void beforeTextChanged(CharSequence s, int start, int count, int after) { // 在文本变化前执行的操作，这里不需要实现 } // 文本变化中的回调方法 @Override public void onTextChanged(CharSequence s, int start, int before, int count) { // 在文本变化中执行的操作，这里不需要实现 } // 文本变化后的回调方法 @Override public void afterTextChanged(Editable s) { String str = s.toString(); // 获取当前文本内容 if(str.length() == mMaxLength) { // 如果文本长度等于最大值 // 调用自定义工具类隐藏输入法 ViewUtil.hideOneInputMethod(EditHideActivity.this, mView); } } } 日期选择器 DatePicker XML \u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;utf-8\u0026#34;?\u0026gt; \u0026lt;LinearLayout xmlns:android=\u0026#34;http://schemas.android.com/apk/res/android\u0026#34; android:id=\u0026#34;@+id/main\u0026#34; android:layout_width=\u0026#34;match_parent\u0026#34; android:layout_height=\u0026#34;match_parent\u0026#34; android:orientation=\u0026#34;vertical\u0026#34; \u0026gt; \u0026lt;Button android:id=\u0026#34;@+id/btn_calendar\u0026#34; android:layout_width=\u0026#34;match_parent\u0026#34; android:layout_height=\u0026#34;wrap_content\u0026#34; android:text=\u0026#34;请选择日期\u0026#34; android:layout_marginTop=\u0026#34;40dp\u0026#34;/\u0026gt; \u0026lt;DatePicker android:id=\u0026#34;@+id/dp_date\u0026#34; android:layout_width=\u0026#34;match_parent\u0026#34; android:layout_height=\u0026#34;wrap_content\u0026#34; android:datePickerMode=\u0026#34;spinner\u0026#34; android:calendarViewShown=\u0026#34;false\u0026#34;/\u0026gt; \u0026lt;Button android:id=\u0026#34;@+id/btn_confirm\u0026#34; android:layout_width=\u0026#34;match_parent\u0026#34; android:layout_height=\u0026#34;wrap_content\u0026#34; android:text=\u0026#34;确定\u0026#34;/\u0026gt; \u0026lt;TextView android:id=\u0026#34;@+id/tv_result\u0026#34; android:layout_width=\u0026#34;match_parent\u0026#34; android:layout_height=\u0026#34;wrap_content\u0026#34; android:background=\u0026#34;@drawable/edittext_selector\u0026#34; /\u0026gt; \u0026lt;/LinearLayout\u0026gt; Java package com.showguan.chapter05; import android.app.DatePickerDialog; import android.os.Bundle; import android.view.View; import android.widget.Button; import android.widget.DatePicker; import android.widget.TextView; import androidx.activity.EdgeToEdge; import androidx.appcompat.app.AppCompatActivity; import androidx.core.graphics.Insets; import androidx.core.view.ViewCompat; import androidx.core.view.WindowInsetsCompat; public class DatePickerActivity extends AppCompatActivity implements View.OnClickListener, DatePickerDialog.OnDateSetListener { private DatePicker dp_date; private TextView tv_result; @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); EdgeToEdge.enable(this); setContentView(R.layout.activity_date_picker); findViewById(R.id.btn_confirm).setOnClickListener(this); findViewById(R.id.btn_calendar).setOnClickListener(this); dp_date = findViewById(R.id.dp_date); tv_result = findViewById(R.id.tv_result); } @Override public void onClick(View v) { if(v.getId() == R.id.btn_confirm){ String desc = String.format(\u0026#34;您选择的日期为%s年 %s月 %s日\u0026#34;, dp_date.getYear(), dp_date.getMonth() + 1, dp_date.getDayOfMonth()); tv_result.setText(desc); } else if (v.getId() == R.id.btn_calendar) { DatePickerDialog dialog = new DatePickerDialog(this, this, 2027, 4, 13); dialog.show(); } } @Override public void onDateSet(DatePicker view, int year, int month, int dayOfMonth) { String desc = String.format(\u0026#34;您选择的日期为%s年 %s月 %s日\u0026#34;, year, month, dayOfMonth); tv_result.setText(desc); } } 时间选择器 TimePicker XML \u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;utf-8\u0026#34;?\u0026gt; \u0026lt;LinearLayout xmlns:android=\u0026#34;http://schemas.android.com/apk/res/android\u0026#34; android:id=\u0026#34;@+id/main\u0026#34; android:layout_width=\u0026#34;match_parent\u0026#34; android:layout_height=\u0026#34;match_parent\u0026#34; android:orientation=\u0026#34;vertical\u0026#34; \u0026gt; \u0026lt;Button android:id=\u0026#34;@+id/btn_time\u0026#34; android:layout_width=\u0026#34;match_parent\u0026#34; android:layout_height=\u0026#34;wrap_content\u0026#34; android:text=\u0026#34;请选择时间\u0026#34; android:layout_marginTop=\u0026#34;40dp\u0026#34;/\u0026gt; \u0026lt;TimePicker android:id=\u0026#34;@+id/tp_time\u0026#34; android:layout_width=\u0026#34;match_parent\u0026#34; android:layout_height=\u0026#34;wrap_content\u0026#34; android:timePickerMode=\u0026#34;spinner\u0026#34; android:layout_marginTop=\u0026#34;5dp\u0026#34; android:calendarViewShown=\u0026#34;false\u0026#34;/\u0026gt; \u0026lt;Button android:id=\u0026#34;@+id/btn_confirm\u0026#34; android:layout_width=\u0026#34;match_parent\u0026#34; android:layout_height=\u0026#34;wrap_content\u0026#34; android:text=\u0026#34;确定\u0026#34;/\u0026gt; \u0026lt;TextView android:id=\u0026#34;@+id/tv_result\u0026#34; android:layout_width=\u0026#34;match_parent\u0026#34; android:layout_height=\u0026#34;wrap_content\u0026#34; android:layout_marginTop=\u0026#34;5dp\u0026#34; android:background=\u0026#34;@drawable/edittext_selector\u0026#34; /\u0026gt; \u0026lt;/LinearLayout\u0026gt; Java public class TimePickerActivity extends AppCompatActivity implements View.OnClickListener, TimePickerDialog.OnTimeSetListener { private TimePicker tp_time; private TextView tv_result; @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.activity_time_picker); findViewById(R.id.btn_confirm).setOnClickListener(this); findViewById(R.id.btn_time).setOnClickListener(this); tp_time = findViewById(R.id.tp_time); tv_result = findViewById(R.id.tv_result); } @Override public void onClick(View v) { if (v.getId() == R.id.btn_confirm) { String desc = String.format(\u0026#34;您选择的时间为%s时 %s分\u0026#34;, tp_time.getHour(), tp_time.getMinute()); tv_result.setText(desc); } else if (v.getId() == R.id.btn_time) { Log.d(\u0026#34;Kennem\u0026#34;, \u0026#34;onClick: R.id.btn_time\u0026#34;); Calendar calendar = Calendar.getInstance(); TimePickerDialog dialog = new TimePickerDialog(this, AlertDialog.THEME_HOLO_DARK,this, calendar.get(Calendar.HOUR_OF_DAY), calendar.get(Calendar.MINUTE), true); dialog.show(); } } @Override public void onTimeSet(TimePicker view, int hourOfDay, int minute) { String desc = String.format(\u0026#34;您选择的时间为%s时 %s分\u0026#34;, hourOfDay, minute); tv_result.setText(desc); } } 案例 登录页面以及找回密码页面\n","permalink":"https://kennems.github.io/posts/tech/android2/","summary":"Android（2） Activity的启动和结束 从当前页面跳转到新页面，跳转代码如下： startActivity(new Intent(源页面.this， 目标页面.class","title":"Android（2）"},{"content":"Android（3） 数据存储 共享参数的用法 SharedPreferences 是 Android的一个轻量级存储工具，采用的存储结构是key-value的键值对方式 共享参数的存储介质是符合XML规范的配置文件。保存路径是：/data/data/应用包名/shared_prefs/文件名.xml 共享参数主要适用的场合：\n简单且孤立的数据。若是复杂且相互间有关的数据，则要保存在数据库中。 文本形式的数据。若是二进制数据，则要保存在文件中。 需要持久化存储的数据。在App退出后再次启动时，之前保存的数据仍然有效。 实际开发中，共享参数经常存储的数据有App的个性化配置信息，用户使用App的行为信息，临时需要保存的片段信息。\nShareWriteActivity.java package com.showguan.chapter06; public class ShareWriteActivity extends AppCompatActivity implements View.OnClickListener { private EditText et_name; private EditText et_age; private EditText et_height; private EditText et_weight; private SharedPreferences preferences; private CheckBox ck_isMarried; @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.activity_share_write); et_name = findViewById(R.id.et_name); et_age = findViewById(R.id.et_age); et_height = findViewById(R.id.et_height); et_weight = findViewById(R.id.et_weight); ck_isMarried = findViewById(R.id.ck_isMarried); findViewById(R.id.btn_save).setOnClickListener(this); preferences = getSharedPreferences(\u0026#34;config\u0026#34;, Context.MODE_PRIVATE); reload(); } private void reload() { String name = preferences.getString(\u0026#34;name\u0026#34;, null); if(name != null){ et_name.setText(name); } int age = preferences.getInt(\u0026#34;age\u0026#34;, 0); if(age != 0){ et_age.setText(String.valueOf(age)); } Float height = preferences.getFloat(\u0026#34;height\u0026#34;, 0.0F); if(height != 0.0F){ et_height.setText(height.toString()); } Float weight = preferences.getFloat(\u0026#34;weight\u0026#34;, 0.0F); if(weight != 0.0F){ et_weight.setText(weight.toString()); } Boolean isMarried = preferences.getBoolean(\u0026#34;married\u0026#34;, false); ck_isMarried.setChecked(isMarried); } @Override public void onClick(View v) { String name = et_name.getText().toString(); String age = et_age.getText().toString(); String height = et_height.getText().toString(); String weight = et_weight.getText().toString(); SharedPreferences.Editor editor = preferences.edit(); editor.putString(\u0026#34;name\u0026#34;, name); editor.putInt(\u0026#34;age\u0026#34;, Integer.valueOf(age)); editor.putFloat(\u0026#34;height\u0026#34;, Float.valueOf(height)); editor.putFloat(\u0026#34;weight\u0026#34;, Float.valueOf(weight)); editor.putBoolean(\u0026#34;married\u0026#34;, ck_isMarried.isChecked()); editor.commit(); } } 实现保存密码 Java 用数据库存储\npackage com.showguan.chapter06; import java.util.Random; public class LoginSQLliteActivity extends AppCompatActivity implements RadioGroup.OnCheckedChangeListener, View.OnClickListener, View.OnFocusChangeListener { // 定义界面中的控件 private TextView login_passFun; private EditText login_input; private TextView login_input_option; private View remember_password_layout; private RadioButton rb_phonecode; private RadioButton rb_password; private CheckBox ck_save_password; private EditText et_phone; private Button login; private String mPassword = \u0026#34;123456\u0026#34;; // 默认密码 private String mVerifyCode; // 验证码 // ActivityResultLauncher用于处理从FindPasswordActivity返回的结果 private ActivityResultLauncher\u0026lt;Intent\u0026gt; register = registerForActivityResult(new ActivityResultContracts.StartActivityForResult(), new ActivityResultCallback\u0026lt;ActivityResult\u0026gt;() { @Override public void onActivityResult(ActivityResult o) { Intent intent = o.getData(); if (intent != null \u0026amp;\u0026amp; o.getResultCode() == Activity.RESULT_OK) { mPassword = intent.getStringExtra(\u0026#34;new_password\u0026#34;); // 获取新密码 } } }); private SharedPreferences preferences; private LoginDBHelper mHelper; @Override protected void onStart() { super.onStart(); mHelper = LoginDBHelper.getInstance(this); // 获取数据库帮助类实例 mHelper.openReadLink(); // 打开数据库读取连接 mHelper.openWriteLink(); // 打开数据库写入连接 reload(); // 重新加载用户信息 } @Override protected void onStop() { super.onStop(); mHelper.closeLink(); // 关闭数据库连接 } @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.activity_login_main); // 设置活动布局 // 初始化控件 RadioGroup rg_login = findViewById(R.id.rg_login); login_passFun = findViewById(R.id.login_passFun); login_input = findViewById(R.id.login_input); login_input_option = findViewById(R.id.login_input_option); remember_password_layout = findViewById(R.id.remember_password_layout); rb_password = findViewById(R.id.rb_password); rb_phonecode = findViewById(R.id.rb_phonecode); et_phone = findViewById(R.id.et_phone); ck_save_password = findViewById(R.id.ck_save_password); login = findViewById(R.id.login); // 设置监听器 rg_login.setOnCheckedChangeListener(this); et_phone.addTextChangedListener(new HideTextWatcher(et_phone, 11)); login_input.addTextChangedListener(new HideTextWatcher(login_input, 6)); login_input.setOnFocusChangeListener(this); login_input_option.setOnClickListener(this); login.setOnClickListener(this); // 获取SharedPreferences对象 preferences = getSharedPreferences(\u0026#34;config\u0026#34;, Context.MODE_PRIVATE); } // 重新加载用户信息 private void reload() { LoginInfo info = mHelper.queryTop(); // 查询最新的用户信息 if (info != null \u0026amp;\u0026amp; info.isRemember()) { et_phone.setText(info.getPhone()); login_input.setText(info.getPassword()); ck_save_password.setChecked(true); } } // 监听RadioGroup选中状态变化 @Override public void onCheckedChanged(RadioGroup group, int checkedId) { if (checkedId == R.id.rb_password) { login_passFun.setText(R.string.login_password); login_input.setHint(R.string.password_hint); login_input_option.setText(R.string.forget_password); remember_password_layout.setVisibility(View.VISIBLE); } else if (checkedId == R.id.rb_phonecode) { login_passFun.setText(R.string.login_phonecode); login_input.setHint(R.string.code_hint); login_input_option.setText(R.string.get_code); remember_password_layout.setVisibility(View.GONE); } } // 监听点击事件 @Override public void onClick(View v) { String phoneNum = et_phone.getText().toString(); if (phoneNum.length() \u0026lt; 11) { Toast.makeText(this, \u0026#34;您输入的手机号不足11位，请重新输入\u0026#34;, Toast.LENGTH_SHORT).show(); return; } if (v.getId() == R.id.login_input_option) { if (rb_password.isChecked()) { Intent intent = new Intent(this, FindPasswordActivity.class); intent.putExtra(\u0026#34;phone\u0026#34;, phoneNum); register.launch(intent); // 启动FindPasswordActivity } else if (rb_phonecode.isChecked()) { mVerifyCode = String.format(\u0026#34;%06d\u0026#34;, new Random().nextInt(999999)); // 生成随机验证码 AlertDialog.Builder builder = new AlertDialog.Builder(this); builder.setTitle(\u0026#34;手机验证码\u0026#34;); builder.setMessage(\u0026#34;手机号\u0026#34; + phoneNum + \u0026#34;, 本次验证码是\u0026#34; + mVerifyCode); builder.setPositiveButton(\u0026#34;好的\u0026#34;, null); AlertDialog dialog = builder.create(); dialog.show(); } } else if (v.getId() == R.id.login) { if (rb_password.isChecked()) { if (!mPassword.equals(login_input.getText().toString())) { Toast.makeText(this, \u0026#34;用户名或密码错误，请检查输入：\u0026#34;, Toast.LENGTH_SHORT).show(); return; } loginSuccess(); } else if (rb_phonecode.isChecked()) { if (mVerifyCode == null || !mVerifyCode.equals(login_input.getText().toString())) { Toast.makeText(this, \u0026#34;验证码错误，请检查输入：\u0026#34;, Toast.LENGTH_SHORT).show(); return; } loginSuccess(); } } } // 登录成功处理 private void loginSuccess() { String desc = String.format(\u0026#34;你的手机号是%s, 恭喜你登录成功，点击确认返回上一个页面\u0026#34;, et_phone.getText().toString()); AlertDialog.Builder builder = new AlertDialog.Builder(this); builder.setTitle(\u0026#34;登录成功\u0026#34;); builder.setMessage(desc); builder.setPositiveButton(\u0026#34;确认返回\u0026#34;, (dialog, which) -\u0026gt; { finish(); // 结束当前活动 }); builder.setNegativeButton(\u0026#34;我再看看吧\u0026#34;, null); AlertDialog dialog = builder.create(); dialog.show(); if (rb_password.isChecked() \u0026amp;\u0026amp; ck_save_password.isChecked()) { SharedPreferences.Editor editor = preferences.edit(); editor.putString(\u0026#34;account\u0026#34;, et_phone.getText().toString()); editor.putString(\u0026#34;password\u0026#34;, login_input.getText().toString()); editor.putBoolean(\u0026#34;is_save_password\u0026#34;, true); editor.commit(); // 提交保存 } LoginInfo info = new LoginInfo(et_phone.getText().toString(), login_input.getText().toString(), ck_save_password.isChecked()); mHelper.insert(info); // 将用户信息插入数据库 } // 监听控件焦点变化 @Override public void onFocusChange(View v, boolean hasFocus) { if (v.getId() == R.id.login_input \u0026amp;\u0026amp; hasFocus) { LoginInfo info = mHelper.queryByPhone(et_phone.getText().toString()); if (info != null) { login_input.setText(info.getPassword()); ck_save_password.setChecked(true); } else { login_input.setText(\u0026#34;\u0026#34;); ck_save_password.setChecked(false); } } } // 自定义TextWatcher类，用于隐藏输入法 class HideTextWatcher implements TextWatcher { private EditText mView; private int maxLength; public HideTextWatcher(EditText editText, int maxLength) { this.mView = editText; this.maxLength = maxLength; } @Override public void beforeTextChanged(CharSequence s, int start, int count, int after) { // 在文本改变前执行的操作 } @Override public void onTextChanged(CharSequence s, int start, int before, int count) { // 在文本改变时执行的操作 } @Override public void afterTextChanged(Editable s) { // 在文本改变后执行的操作 if (s.toString().length() == maxLength) { ViewUtil.hideOneInputMethod(LoginSQLliteActivity.this, mView); } } } } 数据库管理器SQLiteDatabase SQLiteDatabase是SQLite的数据库管理类，它提供了托干操作数据表的API， 常用的方法有3类： 管理类，用户数据库层面的操作 openDatabase：打开指定路径的数据库 isOpen：判断数据库是否已打开 close：关闭数据库 getVersion：获取数据库的版本号 setVersion：设置数据库的版本号 SQLiteDatabase实现保存密码 效果和SharePreference一致，但是是保存在数据库中。\nLoginDBHelper.java package com.showguan.chapter06.database; import android.content.ContentValues; import android.content.Context; import android.database.Cursor; import android.database.sqlite.SQLiteDatabase; import android.database.sqlite.SQLiteOpenHelper; import android.util.Log; import androidx.annotation.Nullable; import com.showguan.chapter06.enity.LoginInfo; import com.showguan.chapter06.enity.User; import java.util.ArrayList; import java.util.List; public class LoginDBHelper extends SQLiteOpenHelper { private static final String DB_NAME = \u0026#34;login.db\u0026#34;; private static final String TABLE_NAME = \u0026#34;login_info\u0026#34;; private static final int DB_VERSION = 1; private static LoginDBHelper mHelper = null; private SQLiteDatabase mRDB = null; private SQLiteDatabase mWDB = null; private LoginDBHelper(@Nullable Context context) { super(context, DB_NAME, null, DB_VERSION); } public static LoginDBHelper getInstance(Context context) { if (mHelper == null) { mHelper = new LoginDBHelper(context); } return mHelper; } public SQLiteDatabase openReadLink() { if (mRDB == null || !mRDB.isOpen()) { mRDB = mHelper.getReadableDatabase(); } return mRDB; } public SQLiteDatabase openWriteLink() { if (mWDB == null || !mWDB.isOpen()) { mWDB = mHelper.getReadableDatabase(); } return mWDB; } public void closeLink() { if (mRDB != null \u0026amp;\u0026amp; mRDB.isOpen()) { mRDB.close(); mRDB = null; } if (mWDB != null \u0026amp;\u0026amp; mWDB.isOpen()) { mWDB.close(); mWDB = null; } } @Override public void onCreate(SQLiteDatabase db) { String sql = \u0026#34;CREATE TABLE IF NOT EXISTS \u0026#34; + TABLE_NAME + \u0026#34; (\u0026#34; + \u0026#34;_id INTEGER PRIMARY KEY AUTOINCREMENT NOT NULL,\u0026#34; + \u0026#34; phone VARCHAR NOT NULL,\u0026#34; + \u0026#34; password VARCHAR NOT NULL,\u0026#34; + \u0026#34; remember INTEGER NOT NULL);\u0026#34;; db.execSQL(sql); } @Override public void onUpgrade(SQLiteDatabase db, int oldVersion, int newVersion) { // 数据库版本更新时使用 String sql = \u0026#34;ALTER TABLE \u0026#34; + TABLE_NAME + \u0026#34; ADD COLUMN phone VARCHAR;\u0026#34;; db.execSQL(sql); sql = \u0026#34;ALTER TABLE \u0026#34; + TABLE_NAME + \u0026#34; ADD COLUMN password VARCHAR;\u0026#34;; db.execSQL(sql); } public void save(LoginInfo info){ try { mWDB.beginTransaction(); delete(info); insert(info); mWDB.setTransactionSuccessful(); }catch (Exception e){ e.printStackTrace(); }finally { mWDB.endTransaction(); } } public long delete(LoginInfo info){ return mWDB.delete(TABLE_NAME, \u0026#34;phone=?\u0026#34;, new String[]{ info.getPhone() }); } public long insert(LoginInfo info) { ContentValues values = new ContentValues(); values.put(\u0026#34;phone\u0026#34;, info.getPhone()); values.put(\u0026#34;password\u0026#34;, info.getPassword()); values.put(\u0026#34;remember\u0026#34;, info.isRemember()); // 返回行号 return mWDB.insert(TABLE_NAME, null, values); } public long deleteByName(String name) { return mWDB.delete(TABLE_NAME, \u0026#34;name = ?\u0026#34;, new String[]{ name }); } public List\u0026lt;User\u0026gt; queryAll() { List\u0026lt;User\u0026gt; list = new ArrayList\u0026lt;\u0026gt;(); Cursor cursor = mRDB.query(TABLE_NAME, null, null, null, null, null, null); while (cursor.moveToNext()) { User user = new User(); user.setId(cursor.getInt(0)); user.setName(cursor.getString(1)); user.setAge(cursor.getInt(2)); user.setHeight(cursor.getFloat(3)); user.setWeight(cursor.getFloat(4)); user.setMarried(cursor.getInt(5) == 1 ? true : false); list.add(user); } return list; } public LoginInfo queryTop() { LoginInfo info = null; String sql = \u0026#34;SELECT * FROM \u0026#34; + TABLE_NAME + \u0026#34; WHERE remember = 1 ORDER BY _id DESC LIMIT 1\u0026#34;; Cursor cursor = null; try { cursor = mRDB.rawQuery(sql, null); if (cursor != null \u0026amp;\u0026amp; cursor.moveToNext()) { info = new LoginInfo(); int phoneIndex = cursor.getColumnIndex(\u0026#34;phone\u0026#34;); int passwordIndex = cursor.getColumnIndex(\u0026#34;password\u0026#34;); int rememberIndex = cursor.getColumnIndex(\u0026#34;remember\u0026#34;); if (phoneIndex != -1) { info.setPhone(cursor.getString(phoneIndex)); } if (passwordIndex != -1) { info.setPassword(cursor.getString(passwordIndex)); } if (rememberIndex != -1) { info.setRemember(cursor.getInt(rememberIndex) == 1); } } } finally { if (cursor != null) { cursor.close(); } } return info; } public LoginInfo queryByPhone(String phone) { LoginInfo info = null; String sql = \u0026#34;SELECT * FROM \u0026#34; + TABLE_NAME; Cursor cursor = mRDB.query(TABLE_NAME, null, \u0026#34;phone=? and remember=1\u0026#34;, new String[]{phone}, null, null, null); try { if (cursor != null \u0026amp;\u0026amp; cursor.moveToNext()) { info = new LoginInfo(); int phoneIndex = cursor.getColumnIndex(\u0026#34;phone\u0026#34;); int passwordIndex = cursor.getColumnIndex(\u0026#34;password\u0026#34;); int rememberIndex = cursor.getColumnIndex(\u0026#34;remember\u0026#34;); if (phoneIndex != -1) { info.setPhone(cursor.getString(phoneIndex)); } if (passwordIndex != -1) { info.setPassword(cursor.getString(passwordIndex)); } if (rememberIndex != -1) { info.setRemember(cursor.getInt(rememberIndex) == 1); } } } finally { if (cursor != null) { cursor.close(); } } return info; } } 实体类LoginInfo.java package com.showguan.chapter06.enity; public class LoginInfo { private String phone; private String password; private boolean remember; public LoginInfo(String phone, String password, boolean remember) { this.phone = phone; this.password = password; this.remember = remember; } public LoginInfo() { } public String getPhone() { return phone; } public void setPhone(String phone) { this.phone = phone; } public String getPassword() { return password; } public void setPassword(String password) { this.password = password; } public boolean isRemember() { return remember; } public void setRemember(boolean remember) { this.remember = remember; } @Override public String toString() { return \u0026#34;LoginInfo{\u0026#34; + \u0026#34;phone=\u0026#39;\u0026#34; + phone + \u0026#39;\\\u0026#39;\u0026#39; + \u0026#34;, password=\u0026#39;\u0026#34; + password + \u0026#39;\\\u0026#39;\u0026#39; + \u0026#34;, remember=\u0026#34; + remember + \u0026#39;}\u0026#39;; } } LoginSQLliteActivity.java package com.showguan.chapter06; public class LoginSQLliteActivity extends AppCompatActivity implements RadioGroup.OnCheckedChangeListener, View.OnClickListener, View.OnFocusChangeListener { // UI元素 private TextView login_passFun; private EditText login_input; private TextView login_input_option; private View remember_password_layout; private RadioButton rb_phonecode; private RadioButton rb_password; private CheckBox ck_save_password; private EditText et_phone; private Button login; // 密码和验证码 private String mPassword = \u0026#34;123456\u0026#34;; private String mVerifyCode; // ActivityResultLauncher 用于启动另一个Activity并接收结果 private ActivityResultLauncher\u0026lt;Intent\u0026gt; register = registerForActivityResult(new ActivityResultContracts.StartActivityForResult(), new ActivityResultCallback\u0026lt;ActivityResult\u0026gt;() { @Override public void onActivityResult(ActivityResult o) { Intent intent = o.getData(); if (intent != null \u0026amp;\u0026amp; o.getResultCode() == Activity.RESULT_OK) { // 获取从FindPasswordActivity返回的新密码 mPassword = intent.getStringExtra(\u0026#34;new_password\u0026#34;); } } }); // SharedPreferences 用于存储数据 private SharedPreferences preferences; // SQLite数据库助手 private LoginDBHelper mHelper; // Activity生命周期方法，在Activity启动时调用 @Override protected void onStart() { super.onStart(); // 打开数据库读写连接 mHelper = LoginDBHelper.getInstance(this); mHelper.openReadLink(); mHelper.openWriteLink(); // 重新加载登录信息 reload(); } // Activity生命周期方法，在Activity停止时调用 @Override protected void onStop() { super.onStop(); // 关闭数据库连接 mHelper.closeLink(); } // Activity创建时调用 @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); // 设置Activity的布局文件 setContentView(R.layout.activity_login_main); // 绑定UI元素 RadioGroup rg_login = findViewById(R.id.rg_login); login_passFun = findViewById(R.id.login_passFun); login_input = findViewById(R.id.login_input); login_input_option = findViewById(R.id.login_input_option); remember_password_layout = findViewById(R.id.remember_password_layout); rb_password = findViewById(R.id.rb_password); rb_phonecode = findViewById(R.id.rb_phonecode); et_phone = findViewById(R.id.et_phone); ck_save_password = findViewById(R.id.ck_save_password); login = findViewById(R.id.login); // 设置事件监听 rg_login.setOnCheckedChangeListener(this); et_phone.addTextChangedListener(new HideTextWatcher(et_phone, 11)); login_input.addTextChangedListener(new HideTextWatcher(login_input, 6)); login_input.setOnFocusChangeListener(this); login_input_option.setOnClickListener(this); login.setOnClickListener(this); // 初始化SharedPreferences preferences = getSharedPreferences(\u0026#34;config\u0026#34;, Context.MODE_PRIVATE); } // 重新加载登录信息 private void reload() { LoginInfo info = mHelper.queryTop(); if (info != null \u0026amp;\u0026amp; info.isRemember()) { // 如果有保存的登录信息，填充到UI元素中 et_phone.setText(info.getPhone()); login_input.setText(info.getPassword()); ck_save_password.setChecked(true); } } // RadioGroup选项变化时调用 @Override public void onCheckedChanged(RadioGroup group, int checkedId) { if (checkedId == R.id.rb_password) { // 选择密码登录 login_passFun.setText(R.string.login_password); login_input.setHint(R.string.password_hint); login_input_option.setText(R.string.forget_password); remember_password_layout.setVisibility(View.VISIBLE); } else if (checkedId == R.id.rb_phonecode) { // 选择验证码登录 login_passFun.setText(R.string.login_phonecode); login_input.setHint(R.string.code_hint); login_input_option.setText(R.string.get_code); remember_password_layout.setVisibility(View.GONE); } } // 点击事件处理 @Override public void onClick(View v) { String phoneNum = et_phone.getText().toString(); if (phoneNum.length() \u0026lt; 11) { // 手机号不足11位，提示用户 Toast.makeText(this, \u0026#34;您输入的手机号不足11位，请重新输入\u0026#34;, Toast.LENGTH_SHORT).show(); return; } if (v.getId() == R.id.login_input_option) { if (rb_password.isChecked()) { // 找回密码 Intent intent = new Intent(this, FindPasswordActivity.class); intent.putExtra(\u0026#34;phone\u0026#34;, phoneNum); register.launch(intent); } else if (rb_phonecode.isChecked()) { // 获取验证码 mVerifyCode = String.format(\u0026#34;%06d\u0026#34;, new Random().nextInt(999999)); AlertDialog.Builder builder = new AlertDialog.Builder(this); builder.setTitle(\u0026#34;手机验证码\u0026#34;); builder.setMessage(\u0026#34;手机号\u0026#34; + phoneNum + \u0026#34;, 本次验证码是\u0026#34; + mVerifyCode); builder.setPositiveButton(\u0026#34;好的\u0026#34;, null); AlertDialog dialog = builder.create(); dialog.show(); } } else if (v.getId() == R.id.login) { if (rb_password.isChecked()) { // 验证密码登录 if (!mPassword.equals(login_input.getText().toString())) { Toast.makeText(this, \u0026#34;用户名或密码错误，请检查输入：\u0026#34;, Toast.LENGTH_SHORT).show(); return; } loginSuccess(); } else if (rb_phonecode.isChecked()) { // 验证验证码登录 if (mVerifyCode == null || !mVerifyCode.equals(login_input.getText().toString())) { Toast.makeText(this, \u0026#34;验证码错误，请检查输入：\u0026#34;, Toast.LENGTH_SHORT).show(); return; } loginSuccess(); } } } // 登录成功处理 private void loginSuccess() { String desc = String.format(\u0026#34;你的手机号是%s, 恭喜你登录成功，点击确认返回上一个页面\u0026#34;, et_phone.getText().toString()); AlertDialog.Builder builder = new AlertDialog.Builder(this); builder.setTitle(\u0026#34;登录成功\u0026#34;); builder.setMessage(desc); builder.setPositiveButton(\u0026#34;确认返回\u0026#34;, (dialog, which) -\u0026gt; { finish(); }); builder.setNegativeButton(\u0026#34;我再看看吧\u0026#34;, null); AlertDialog dialog = builder.create(); dialog.show(); if (rb_password.isChecked() \u0026amp;\u0026amp; ck_save_password.isChecked()) { // 保存密码到SharedPreferences SharedPreferences.Editor editor = preferences.edit(); editor.putString(\u0026#34;account\u0026#34;, et_phone.getText().toString()); editor.putString(\u0026#34;password\u0026#34;, login_input.getText().toString()); editor.putBoolean(\u0026#34;is_save_password\u0026#34;, true); editor.commit(); } if (rb_password.isChecked()) { // 保存登录信息到SQLite LoginInfo info = new LoginInfo(et_phone.getText().toString(), login_input.getText().toString(), ck_save_password.isChecked()); mHelper.insert(info); } } // 焦点变化处理 @Override public void onFocusChange(View v, boolean hasFocus) { if (v.getId() == R.id.login_input \u0026amp;\u0026amp; hasFocus) { // 输入框获得焦点时，从数据库中查询对应的密码 LoginInfo info = mHelper.queryByPhone(et_phone.getText().toString()); if (info != null) { login_input.setText(info.getPassword()); ck_save_password.setChecked(true); } else { login_input.setText(\u0026#34;\u0026#34;); ck_save_password.setChecked(false); } } } // 自定义TextWatcher类，用于监听文本变化 class HideTextWatcher implements TextWatcher { private EditText mView; private int maxLength; public HideTextWatcher(EditText editText, int i) { this.mView = editText; this.maxLength = i; } @Override public void beforeTextChanged(CharSequence s, int start, int count, int after) { } @Override public void onTextChanged(CharSequence s, int start, int before, int count) { } @Override public void afterTextChanged(Editable s) { if (s.toString().length() == maxLength) { // 当文本长度达到最大值时隐藏输入法 ViewUtil.hideOneInputMethod(LoginSQLliteActivity.this, mView); } } } } 存储卡存储 私有存储空间与公共存储空间\nXML \u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;utf-8\u0026#34;?\u0026gt; \u0026lt;LinearLayout xmlns:android=\u0026#34;http://schemas.android.com/apk/res/android\u0026#34; android:id=\u0026#34;@+id/main\u0026#34; android:layout_width=\u0026#34;match_parent\u0026#34; android:layout_height=\u0026#34;match_parent\u0026#34; android:orientation=\u0026#34;vertical\u0026#34;\u0026gt; \u0026lt;LinearLayout android:layout_width=\u0026#34;match_parent\u0026#34; android:layout_height=\u0026#34;wrap_content\u0026#34; android:orientation=\u0026#34;horizontal\u0026#34; android:layout_marginTop=\u0026#34;10dp\u0026#34;\u0026gt; \u0026lt;TextView android:layout_width=\u0026#34;wrap_content\u0026#34; android:layout_height=\u0026#34;wrap_content\u0026#34; android:text=\u0026#34;姓名: \u0026#34; android:textSize=\u0026#34;@dimen/common_font_size\u0026#34;/\u0026gt; \u0026lt;EditText android:id=\u0026#34;@+id/et_name\u0026#34; android:layout_width=\u0026#34;match_parent\u0026#34; android:layout_height=\u0026#34;wrap_content\u0026#34; android:background=\u0026#34;@drawable/edittext_selector\u0026#34;/\u0026gt; \u0026lt;/LinearLayout\u0026gt; \u0026lt;LinearLayout android:layout_width=\u0026#34;match_parent\u0026#34; android:layout_height=\u0026#34;wrap_content\u0026#34; android:orientation=\u0026#34;horizontal\u0026#34; android:layout_marginTop=\u0026#34;10dp\u0026#34;\u0026gt; \u0026lt;TextView android:layout_width=\u0026#34;wrap_content\u0026#34; android:layout_height=\u0026#34;wrap_content\u0026#34; android:text=\u0026#34;年龄: \u0026#34; android:textSize=\u0026#34;@dimen/common_font_size\u0026#34;/\u0026gt; \u0026lt;EditText android:id=\u0026#34;@+id/et_age\u0026#34; android:layout_width=\u0026#34;match_parent\u0026#34; android:layout_height=\u0026#34;wrap_content\u0026#34; android:background=\u0026#34;@drawable/edittext_selector\u0026#34;/\u0026gt; \u0026lt;/LinearLayout\u0026gt; \u0026lt;LinearLayout android:layout_width=\u0026#34;match_parent\u0026#34; android:layout_height=\u0026#34;wrap_content\u0026#34; android:orientation=\u0026#34;horizontal\u0026#34; android:layout_marginTop=\u0026#34;10dp\u0026#34;\u0026gt; \u0026lt;TextView android:layout_width=\u0026#34;wrap_content\u0026#34; android:layout_height=\u0026#34;wrap_content\u0026#34; android:text=\u0026#34;身高: \u0026#34; android:textSize=\u0026#34;@dimen/common_font_size\u0026#34;/\u0026gt; \u0026lt;EditText android:id=\u0026#34;@+id/et_height\u0026#34; android:layout_width=\u0026#34;match_parent\u0026#34; android:layout_height=\u0026#34;wrap_content\u0026#34; android:background=\u0026#34;@drawable/edittext_selector\u0026#34;/\u0026gt; \u0026lt;/LinearLayout\u0026gt; \u0026lt;LinearLayout android:layout_width=\u0026#34;match_parent\u0026#34; android:layout_height=\u0026#34;wrap_content\u0026#34; android:orientation=\u0026#34;horizontal\u0026#34; android:layout_marginTop=\u0026#34;10dp\u0026#34;\u0026gt; \u0026lt;TextView android:layout_width=\u0026#34;wrap_content\u0026#34; android:layout_height=\u0026#34;wrap_content\u0026#34; android:text=\u0026#34;体重: \u0026#34; android:textSize=\u0026#34;@dimen/common_font_size\u0026#34;/\u0026gt; \u0026lt;EditText android:id=\u0026#34;@+id/et_weight\u0026#34; android:layout_width=\u0026#34;match_parent\u0026#34; android:layout_height=\u0026#34;wrap_content\u0026#34; android:background=\u0026#34;@drawable/edittext_selector\u0026#34;/\u0026gt; \u0026lt;/LinearLayout\u0026gt; \u0026lt;LinearLayout android:layout_width=\u0026#34;match_parent\u0026#34; android:layout_height=\u0026#34;wrap_content\u0026#34; android:orientation=\u0026#34;horizontal\u0026#34;\u0026gt; \u0026lt;CheckBox android:id=\u0026#34;@+id/ck_isMarried\u0026#34; android:layout_width=\u0026#34;wrap_content\u0026#34; android:layout_height=\u0026#34;wrap_content\u0026#34;/\u0026gt; \u0026lt;TextView android:layout_width=\u0026#34;wrap_content\u0026#34; android:layout_height=\u0026#34;wrap_content\u0026#34; android:text=\u0026#34;已婚\u0026#34; android:textSize=\u0026#34;@dimen/common_small_font_size\u0026#34;/\u0026gt; \u0026lt;/LinearLayout\u0026gt; \u0026lt;Button android:id=\u0026#34;@+id/btn_write\u0026#34; android:layout_width=\u0026#34;match_parent\u0026#34; android:layout_height=\u0026#34;wrap_content\u0026#34; android:text=\u0026#34;保存\u0026#34;/\u0026gt; \u0026lt;Button android:id=\u0026#34;@+id/btn_read\u0026#34; android:layout_width=\u0026#34;match_parent\u0026#34; android:layout_height=\u0026#34;wrap_content\u0026#34; android:text=\u0026#34;读取\u0026#34;/\u0026gt; \u0026lt;TextView android:id=\u0026#34;@+id/tv_content\u0026#34; android:layout_width=\u0026#34;match_parent\u0026#34; android:layout_height=\u0026#34;wrap_content\u0026#34; /\u0026gt; \u0026lt;/LinearLayout\u0026gt; Java package com.showguan.chapter06; public class FileWriteActivity extends AppCompatActivity implements View.OnClickListener { // 定义界面中的控件 private EditText et_name; private EditText et_age; private EditText et_height; private EditText et_weight; private SharedPreferences preferences; private CheckBox ck_isMarried; private String path; private TextView tv_content; @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); // 设置活动布局 setContentView(R.layout.activity_file_write); // 初始化控件 et_name = findViewById(R.id.et_name); et_age = findViewById(R.id.et_age); et_height = findViewById(R.id.et_height); et_weight = findViewById(R.id.et_weight); ck_isMarried = findViewById(R.id.ck_isMarried); tv_content = findViewById(R.id.tv_content); // 设置按钮点击事件监听器 findViewById(R.id.btn_write).setOnClickListener(this); findViewById(R.id.btn_read).setOnClickListener(this); // 获取SharedPreferences对象，模式为私有 preferences = getSharedPreferences(\u0026#34;config\u0026#34;, Context.MODE_PRIVATE); } @Override public void onClick(View v) { if(v.getId() == R.id.btn_write){ // 获取输入框中的文本内容 String name = et_name.getText().toString(); String age = et_age.getText().toString(); String height = et_height.getText().toString(); String weight = et_weight.getText().toString(); // 拼接字符串内容 StringBuilder sb = new StringBuilder(); sb.append(\u0026#34;姓名:\u0026#34;).append(name); sb.append(\u0026#34;\\n年龄:\u0026#34;).append(age); sb.append(\u0026#34;\\n身高:\u0026#34;).append(height); sb.append(\u0026#34;\\n体重:\u0026#34;).append(weight); sb.append(\u0026#34;\\n婚否:\u0026#34;).append(ck_isMarried.isChecked()); String directory; String fileName = System.currentTimeMillis() + \u0026#34;.txt\u0026#34;; // 使用内部存储空间，卸载应用后文件将被删除 directory = getFilesDir().toString(); path = directory + File.separatorChar + fileName; // 打印路径日志 Log.d(\u0026#34;Kennem\u0026#34;, path); // 保存文本内容到文件 FileUtil.saveText(path, sb.toString()); // 显示保存成功的Toast消息 Toast.makeText(this, \u0026#34;保存成功\u0026#34;, Toast.LENGTH_SHORT).show(); } else if (v.getId() == R.id.btn_read) { // 从文件读取内容并显示到TextView tv_content.setText(FileUtil.openText(path)); } } } 存储卡保存图片 实际保存的文件路径：/sdcard/Android/data/com.showguan.chapter06/files/Download/1719307975140.jpg\nJava package com.showguan.chapter06; import android.graphics.Bitmap; import android.graphics.BitmapFactory; import android.net.Uri; import android.os.Bundle; import android.os.Environment; import android.util.Log; import android.view.View; import android.widget.ImageView; import android.widget.Toast; import androidx.activity.EdgeToEdge; import androidx.appcompat.app.AppCompatActivity; import androidx.core.graphics.Insets; import androidx.core.view.ViewCompat; import androidx.core.view.WindowInsetsCompat; import com.showguan.chapter06.util.FileUtil; import java.io.File; public class ImageWriteActivity extends AppCompatActivity implements View.OnClickListener { private ImageView iv_pic; private String path; @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.activity_image_write); findViewById(R.id.btn_read).setOnClickListener(this); findViewById(R.id.btn_save).setOnClickListener(this); iv_pic = findViewById(R.id.iv_pic); } @Override public void onClick(View v) { if(v.getId() == R.id.btn_save){ String directory = getExternalFilesDir(Environment.DIRECTORY_DOWNLOADS).toString(); String fileName = System.currentTimeMillis() + \u0026#34;.jpg\u0026#34;; path = directory + File.separatorChar + fileName; Log.d(\u0026#34;Kennem\u0026#34;, path); Bitmap bitmap = BitmapFactory.decodeResource(getResources(), R.drawable.cat2); FileUtil.saveImage(path, bitmap); Toast.makeText(this, \u0026#34;保存成功\u0026#34;, Toast.LENGTH_SHORT).show(); } else if (v.getId() == R.id.btn_read) { // 使用FileUtil工具类从指定路径读取图片文件并设置到ImageView中显示 // 注意：这里假设FileUtil类中有一个名为readImage的方法，可以根据路径返回Bitmap对象。 // 由于具体的FileUtil类实现不明确，这段代码是假设性的示例。 // 方法一：使用FileUtil工具类读取图片文件 // Bitmap bitmap = FileUtil.readImage(path); // 假设FileUtil类有这个方法 // iv_pic.setImageBitmap(bitmap); // 将读取的Bitmap对象设置到ImageView中显示 // 方法二：直接使用BitmapFactory解码指定路径的图片文件为Bitmap对象 // Bitmap bitmap = BitmapFactory.decodeFile(path); // 使用BitmapFactory解码文件 // iv_pic.setImageBitmap(bitmap); // 将解码得到的Bitmap对象设置到ImageView中显示 // 方法三：使用Uri对象加载指定路径的图片文件到ImageView中显示 iv_pic.setImageURI(Uri.parse(path)); // 将指定路径的图片文件通过Uri加载并显示到ImageView } } } FileUtil package com.showguan.chapter06.util; public class FileUtil { // 保存文本到指定路径 public static void saveText(String path, String txt) { // 注意，这里需要确保os被正确关闭之后才能保存文件 try (BufferedWriter os = new BufferedWriter(new FileWriter(path))) { os.write(txt); Log.d(\u0026#34;Kennem\u0026#34;, \u0026#34;保存成功\u0026#34;); Log.d(\u0026#34;Kennem\u0026#34;, \u0026#34;保存的内容\u0026#34; + txt); } catch (Exception e) { e.printStackTrace(); } } //从指定路径的文本文件中读取为字符串 public static String openText(String path){ BufferedReader is = null; StringBuilder sb = new StringBuilder(); try{ is = new BufferedReader(new FileReader(path)); String line = null; while((line = is.readLine()) != null){ sb.append(line); } }catch (Exception e){ e.printStackTrace(); }finally { if(is != null){ try{ is.close(); }catch (Exception e){ e.printStackTrace(); } } } return sb.toString(); } public static void saveImage(String path, Bitmap bitmap) { try(FileOutputStream fos = new FileOutputStream(path)){ bitmap.compress(Bitmap.CompressFormat.JPEG, 100, fos); }catch (Exception e){ e.printStackTrace(); } } public static Bitmap readImage(String path) { Bitmap bitmap = null; try(FileInputStream fis = new FileInputStream(path)) { bitmap = BitmapFactory.decodeStream(fis); }catch (Exception e){ e.printStackTrace(); } return bitmap; } } Application 声明周期 首先自定义一个Application\npackage com.showguan.chapter06; import android.app.Application; import android.content.res.Configuration; import android.util.Log; import androidx.annotation.NonNull; import java.util.HashMap; public class MyApplication extends Application { private static MyApplication mApp; public HashMap\u0026lt;String, String\u0026gt; infoMap = new HashMap\u0026lt;\u0026gt;(); public static MyApplication getInstance(){ return mApp; } @Override public void onCreate() { super.onCreate(); Log.d(\u0026#34;Kennem\u0026#34;, \u0026#34;MyApplication onCreate: \u0026#34;); } @Override public void onTerminate() { super.onTerminate(); Log.d(\u0026#34;Kennem\u0026#34;, \u0026#34;MyApplication onTerminate: \u0026#34;); } @Override public void onConfigurationChanged(@NonNull Configuration newConfig) { super.onConfigurationChanged(newConfig); Log.d(\u0026#34;Kennem\u0026#34;, \u0026#34;MyApplication onConfigurationChanged: \u0026#34;); } } 2、修改manifest文件\n3、Application声明周期\nApplication在Activity之前创建， 并且旋转屏幕时会调用onConfigurationChanged方法，并会重新创建Activity。\nApplication全局变量 数和在Application中保存的全局变量主要有下面三种数据：\n会频繁读取的信息，如用户名，手机号等。 不方便由意图传递的数据，例如位图对象，非字符串类型的集合对象等 容易因频繁分配内存二导致内存泄漏的对象，如Handler对象等。 通过在MyApplication中定义全局变量infoMap, 通过单例类获取app对象，实现在infoMap中， 即内存中存储数据。\nMyAppliaction.java package com.showguan.chapter06; import android.app.Application; import android.content.res.Configuration; import android.util.Log; import androidx.annotation.NonNull; import java.util.HashMap; public class MyApplication extends Application { private static MyApplication mApp = new MyApplication(); public HashMap\u0026lt;String, String\u0026gt; infoMap = new HashMap\u0026lt;\u0026gt;(); public static MyApplication getInstance(){ return mApp; } @Override public void onCreate() { super.onCreate(); Log.d(\u0026#34;Kennem\u0026#34;, \u0026#34;MyApplication onCreate: \u0026#34;); } @Override public void onTerminate() { super.onTerminate(); Log.d(\u0026#34;Kennem\u0026#34;, \u0026#34;MyApplication onTerminate: \u0026#34;); } @Override public void onConfigurationChanged(@NonNull Configuration newConfig) { super.onConfigurationChanged(newConfig); Log.d(\u0026#34;Kennem\u0026#34;, \u0026#34;MyApplication onConfigurationChanged: \u0026#34;); } } AppWriteActivity.java package com.showguan.chapter06; import android.content.SharedPreferences; import android.os.Bundle; import android.view.View; import android.widget.CheckBox; import android.widget.EditText; import androidx.appcompat.app.AppCompatActivity; import com.showguan.chapter06.util.ToastUtil; public class AppWriteActivity extends AppCompatActivity implements View.OnClickListener { private EditText et_name; private EditText et_age; private EditText et_height; private EditText et_weight; private SharedPreferences preferences; private CheckBox ck_isMarried; private MyApplication app; @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.activity_app_write); et_name = findViewById(R.id.et_name); et_age = findViewById(R.id.et_age); et_height = findViewById(R.id.et_height); et_weight = findViewById(R.id.et_weight); ck_isMarried = findViewById(R.id.ck_isMarried); findViewById(R.id.btn_save).setOnClickListener(this); app = MyApplication.getInstance(); reload(); } private void reload() { String name = app.infoMap.get(\u0026#34;name\u0026#34;); if (name == null) { return; } String age = app.infoMap.get(\u0026#34;age\u0026#34;); String height = app.infoMap.get(\u0026#34;height\u0026#34;); String weight = app.infoMap.get(\u0026#34;weight\u0026#34;); String married = app.infoMap.get(\u0026#34;married\u0026#34;); et_name.setText(name); et_age.setText(age); et_height.setText(height); et_weight.setText(weight); ck_isMarried.setChecked(married == \u0026#34;是\u0026#34;); } // @Override public void onClick(View v) { String name = et_name.getText().toString(); String age = et_age.getText().toString(); String height = et_height.getText().toString(); String weight = et_weight.getText().toString(); app.infoMap.put(\u0026#34;name\u0026#34;, name); app.infoMap.put(\u0026#34;age\u0026#34;, age); app.infoMap.put(\u0026#34;height\u0026#34;, height); app.infoMap.put(\u0026#34;weight\u0026#34;, weight); app.infoMap.put(\u0026#34;married\u0026#34;, ck_isMarried.isChecked() ? \u0026#34;是\u0026#34; : \u0026#34;否\u0026#34;); ToastUtil.show(this, \u0026#34;保存成功\u0026#34;); } } Room框架的导入 Room时谷歌公司推出的数据库处理框架，该框架同样基于SQLite, 但它通过注解技术极大简化了数据库操作，减少了原来相当一部分编码工作量。\n在使用Room之前，要先修改模块的build.gradle文件，往dependencies节点添加下面的配置，表示导入指定版本的Room库 dependencies { implementation \u0026#39;androidx.room:room-runtime:2.6.1\u0026#39; annotationProcessor \u0026#39;androidx.room:room-compiler:2.6.1\u0026#39; } 1、创建实体类 BookInfo.java package com.showguan.chapter06.enity; import androidx.room.Entity; import androidx.room.PrimaryKey; @Entity public class BookInfo { @PrimaryKey(autoGenerate = true) private int id; private String name; private String author; private String publish; private double price; public int getId() { return id; } public void setId(int id) { this.id = id; } public String getName() { return name; } public void setName(String name) { this.name = name; } public String getAuthor() { return author; } public void setAuthor(String author) { this.author = author; } public String getPublish() { return publish; } public void setPublish(String publish) { this.publish = publish; } public double getPrice() { return price; } public void setPrice(double price) { this.price = price; } @Override public String toString() { return \u0026#34;BookInfo{\u0026#34; + \u0026#34;id=\u0026#34; + id + \u0026#34;, name=\u0026#39;\u0026#34; + name + \u0026#39;\\\u0026#39;\u0026#39; + \u0026#34;, author=\u0026#39;\u0026#34; + author + \u0026#39;\\\u0026#39;\u0026#39; + \u0026#34;, publish=\u0026#39;\u0026#34; + publish + \u0026#39;\\\u0026#39;\u0026#39; + \u0026#34;, price=\u0026#34; + price + \u0026#39;}\u0026#39;; } } 2、创建Dao数据访问对象 package com.showguan.chapter06.dao; import androidx.room.Dao; import androidx.room.Delete; import androidx.room.Insert; import androidx.room.Query; import androidx.room.Update; import com.showguan.chapter06.enity.BookInfo; import java.util.List; @Dao public interface BookDao { @Insert void insert(BookInfo... bookInfos); @Delete void delete(BookInfo... bookInfos); @Query(\u0026#34;DELETE FROM BookInfo\u0026#34;) void deleteAll(); @Update int update(BookInfo... bookInfos); @Query(\u0026#34;SELECT * FROM BookInfo\u0026#34;) List\u0026lt;BookInfo\u0026gt; queryAll(); @Query(\u0026#34;SELECT * FROM BookInfo WHERE name = :name ORDER BY id DESC LIMIT 1\u0026#34;) BookInfo queryByName(String name); } 3、创建 BookDatabase 连接实体类和Dao package com.showguan.chapter06.database; import androidx.room.Database; import androidx.room.RoomDatabase; import com.showguan.chapter06.dao.BookDao; import com.showguan.chapter06.enity.BookInfo; @Database(entities = {BookInfo.class}, version = 1, exportSchema = true) public abstract class BookDatabase extends RoomDatabase{ public abstract BookDao bookDao(); } 4、在MyApplication中构建并返回数据库对象 package com.showguan.chapter06; import android.app.Application; import android.content.res.Configuration; import android.util.Log; import androidx.annotation.NonNull; import androidx.room.DatabaseConfiguration; import androidx.room.InvalidationTracker; import androidx.room.Room; import androidx.sqlite.db.SupportSQLiteOpenHelper; import com.showguan.chapter06.dao.BookDao; import com.showguan.chapter06.database.BookDatabase; import java.util.HashMap; public class MyApplication extends Application { private static MyApplication mApp = new MyApplication(); public HashMap\u0026lt;String, String\u0026gt; infoMap = new HashMap\u0026lt;\u0026gt;(); private static BookDatabase bookDatabase; public static MyApplication getInstance(){ return mApp; } @Override public void onCreate() { super.onCreate(); Log.d(\u0026#34;Kennem\u0026#34;, \u0026#34;MyApplication onCreate: \u0026#34;); bookDatabase = Room.databaseBuilder(this, BookDatabase.class, \u0026#34;book\u0026#34;) .addMigrations() // 允许迁移数据库（发生数据库变更时，Room默认删除原数据库再创建新数据库， 这样原来的数据会消失。 .allowMainThreadQueries() //允许再主线程中操作数据库（Room默认不能在主线程中操作数据库） .build(); } @Override public void onTerminate() { super.onTerminate(); Log.d(\u0026#34;Kennem\u0026#34;, \u0026#34;MyApplication onTerminate: \u0026#34;); } @Override public void onConfigurationChanged(@NonNull Configuration newConfig) { super.onConfigurationChanged(newConfig); Log.d(\u0026#34;Kennem\u0026#34;, \u0026#34;MyApplication onConfigurationChanged: \u0026#34;); } public BookDatabase getBookDatabase(){ return bookDatabase; } } 5、在使用时只需要用BookDao调用相应的方法即可 package com.showguan.chapter06; import android.os.Bundle; import android.util.Log; import android.view.View; import android.widget.EditText; import androidx.appcompat.app.AppCompatActivity; import com.showguan.chapter06.dao.BookDao; import com.showguan.chapter06.enity.BookInfo; import com.showguan.chapter06.util.ToastUtil; import java.util.List; public class RoomWriteActivity extends AppCompatActivity implements View.OnClickListener { private String TAG = \u0026#34;Kennem\u0026#34;; private EditText et_name; private EditText et_author; private EditText et_publish; private EditText et_price; private BookDao bookDao; @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.activity_room_write); et_name = findViewById(R.id.et_name); et_author = findViewById(R.id.et_author); et_publish = findViewById(R.id.et_publish); et_price = findViewById(R.id.et_price); findViewById(R.id.btn_add).setOnClickListener(this); findViewById(R.id.btn_delete).setOnClickListener(this); findViewById(R.id.btn_update).setOnClickListener(this); findViewById(R.id.btn_select).setOnClickListener(this); findViewById(R.id.btn_deleteAll).setOnClickListener(this); bookDao = MyApplication.getInstance().getBookDatabase().bookDao(); } @Override public void onClick(View v) { String name = null; String author = null; String publish = null; Double price = 0.0; if (!et_name.getText().toString().equals(\u0026#34;\u0026#34;)) { name = et_name.getText().toString(); } if (!et_author.getText().toString().equals(\u0026#34;\u0026#34;)) { author = et_author.getText().toString(); } if (!et_publish.getText().toString().equals(\u0026#34;\u0026#34;)) { publish = et_publish.getText().toString(); } if (!et_price.getText().toString().equals(\u0026#34;\u0026#34;)) { // Log.d(TAG, et_price.getText().toString()); price = Double.valueOf(et_price.getText().toString()); } if (v.getId() == R.id.btn_add) { BookInfo bookInfo = new BookInfo(); bookInfo.setName(name); bookInfo.setAuthor(author); bookInfo.setPublish(publish); bookInfo.setPrice(price); bookDao.insert(bookInfo); ToastUtil.show(this, \u0026#34;保存成功！\u0026#34;); } else if (v.getId() == R.id.btn_delete) { BookInfo b = new BookInfo(); int id = bookDao.queryByName(name).getId(); b.setId(id); bookDao.delete(b); } else if (v.getId() == R.id.btn_update) { BookInfo b3 = new BookInfo(); BookInfo b4 = bookDao.queryByName(name); b3.setId(b4.getId()); b3.setName(name); b3.setAuthor(author); b3.setPublish(publish); b3.setPrice(price); bookDao.update(b3); } else if (v.getId() == R.id.btn_select) { List\u0026lt;BookInfo\u0026gt; bookInfos = bookDao.queryAll(); for (BookInfo bookInfo : bookInfos) { Log.d(TAG, bookInfo.toString()); } } else if (v.getId() == R.id.btn_deleteAll) { bookDao.deleteAll(); } } } 案例-实现购物车 ","permalink":"https://kennems.github.io/posts/tech/android3/","summary":"Android（3） 数据存储 共享参数的用法 SharedPreferences 是 Android的一个轻量级存储工具，采用的存储结构是key-value的键值对方式 共享参数的存","title":"Android（3）"},{"content":"Android（1） 【金山文档 | WPS云文档】 Kotlin 讲义\rhttps://kdocs.cn/l/cu14rrCtfKxv\r【金山文档 | WPS云文档】 Android 四大组件课程概要 https://kdocs.cn/l/croaFl0RS5LA\r【金山文档 | WPS云文档】 Fragment 重点知识\rhttps://kdocs.cn/l/cj89XRLXypb8\r【金山文档 | WPS云文档】 Android UI 课程重点知识\rhttps://kdocs.cn/l/cokrSwEg1GF4\r【金山文档 | WPS云文档】 Android布局与优化\rhttps://kdocs.cn/l/ciwSdaSLRAwB\r【金山文档 | WPS云文档】 组件库\rhttps://kdocs.cn/l/cvsBNce6AfjI\r【金山文档 | WPS云文档】 Android 动画\rhttps://kdocs.cn/l/cf4bQiAeZdlI\r【金山文档 | WPS云文档】 自定义控件的实现\rhttps://kdocs.cn/l/cu3bUFFJVvn8\r【金山文档 | WPS云文档】 权限与网络请求课程预习\rhttps://kdocs.cn/l/cme7bRkDMYcB\r【金山文档 | WPS云文档】 内存泄漏和ANR预习\rhttps://kdocs.cn/l/cpFLi1gGV4Xs ctrl + alt + o 自动组织导入\nApp开发语言\nApp开发主要有两大技术路径，分别是原生开发和混合开发 Android的官方编程语言包括Java和Kotlin XML：Extensible Markup Language, 即可扩展标记语言\ngradle下载镜像\n使用官网下载非常的慢，建议使用镜像站：\n（1）官网地址：https://services.gradle.org/distributions/ （2）腾讯镜像 Gradle下载地址：https://mirrors.cloud.tencent.com/gradle/ （3）阿里云镜像 Gradle下载地址：https://mirrors.aliyun.com/macports/distfiles/gradle/\n虚拟机改成冷启动\nhttps://blog.csdn.net/gh8609123/article/details/118514352\n类似网页，XML描述界面，Java做交互效果\n简单控件 字体大小设置 Java代码 tv.setTextSize(10); 在XML文件中则通过属性android:textSize指定文本大小，此时需要指定字号单位。 px：是手机屏幕的最小显示单位，与设备的显示屏有关 dp：是与设备无关的显示单位**，只与屏幕的尺寸有关** sp：专门用来设置字体大小，在系统设置中可以调整字体大小 Dpi(像素密度dots-per-inch)计算规则\n以$4.95$英寸 $1920*1080$ 的手机设备为例：\n计算直角边像素数量：$1920^2 + 1080^2 = 2202^2$ 计算Dpi：$2205/4.95=445$ 得到Dpi为$445$ （每英寸的距离有$445$个像素） Density\n指屏幕上每平方英寸中含有的像素点数， $445^2$\nDip/dp (设备独立像素Device Independent Pixel)\n所有显示到屏幕上的图像都是以px为单位的，Dip是开发中使用的长度单位，最后也需要转换成px，计算这个设备上1dip等于多少px\n$px = dip * dpi / 160$\n根据换算关系：\n320*480像素，3.6寸的手机：dpi 为160，$ 1dp = 1px$\npublic class TextSizeActivity extends AppCompatActivity { @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); EdgeToEdge.enable(this); setContentView(R.layout.activity_text_size); TextView viewById = findViewById(R.id.hello_tv); viewById.setTextSize(30); } } \u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;utf-8\u0026#34;?\u0026gt; \u0026lt;LinearLayout xmlns:android=\u0026#34;http://schemas.android.com/apk/res/android\u0026#34; android:layout_width=\u0026#34;match_parent\u0026#34; android:layout_height=\u0026#34;match_parent\u0026#34; android:orientation=\u0026#34;vertical\u0026#34; android:gravity=\u0026#34;center\u0026#34; \u0026gt; \u0026lt;TextView android:id=\u0026#34;@+id/tv_TextSize_px\u0026#34; android:layout_width=\u0026#34;wrap_content\u0026#34; android:layout_height=\u0026#34;wrap_content\u0026#34; android:text=\u0026#34;@string/textSize\u0026#34; android:textSize=\u0026#34;30px\u0026#34; /\u0026gt; \u0026lt;TextView android:id=\u0026#34;@+id/tv_TextSize_dp\u0026#34; android:layout_width=\u0026#34;wrap_content\u0026#34; android:layout_height=\u0026#34;wrap_content\u0026#34; android:text=\u0026#34;@string/textSize\u0026#34; android:textSize=\u0026#34;30dp\u0026#34; /\u0026gt; \u0026lt;TextView android:id=\u0026#34;@+id/tv_TextSize_sp\u0026#34; android:layout_width=\u0026#34;wrap_content\u0026#34; android:layout_height=\u0026#34;wrap_content\u0026#34; android:text=\u0026#34;@string/textSize\u0026#34; android:textSize=\u0026#34;30sp\u0026#34; /\u0026gt; \u0026lt;!-- sp跟随系统字体变大而变大--\u0026gt; \u0026lt;TextView android:id=\u0026#34;@+id/hello_tv\u0026#34; android:layout_width=\u0026#34;wrap_content\u0026#34; android:layout_height=\u0026#34;wrap_content\u0026#34; android:text=\u0026#34;@string/textSize\u0026#34; android:textSize=\u0026#34;30px\u0026#34; /\u0026gt; \u0026lt;/LinearLayout\u0026gt; 字体颜色设置 在XML文件中通过属性android:textColor指定文本颜色，色值由透明度alpha和RGB三原色（红色red, 绿色green, 蓝色blue）联合定义。 色值有八位十六进制和六位十六进制两种表达方式，例如八位编码FFEEDDCC中，FF表示透明度，EE表示红色的浓度，DD表示绿色的浓度，CC表示蓝色的浓度。 透明度为FF表示完全不透明，为00表示完全透明。RGB三色的数值越大，表示颜色越浓，也就越亮；数值越小，表示颜色越淡，也就越暗。 Java中透明度设置的是透明（例如：0x00ff00 实际为：0x0000ff00），而XML文件中透明度设置默认为不透明（例如黑色：#000000， 实际为#ff000000）\n\u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;utf-8\u0026#34;?\u0026gt; \u0026lt;LinearLayout xmlns:android=\u0026#34;http://schemas.android.com/apk/res/android\u0026#34; android:layout_width=\u0026#34;match_parent\u0026#34; android:layout_height=\u0026#34;match_parent\u0026#34; android:gravity=\u0026#34;center\u0026#34; android:orientation=\u0026#34;vertical\u0026#34;\u0026gt; \u0026lt;TextView android:id=\u0026#34;@+id/tv_TextSize_code_system\u0026#34; android:layout_width=\u0026#34;wrap_content\u0026#34; android:layout_height=\u0026#34;wrap_content\u0026#34; android:text=\u0026#34;普通颜色设置\u0026#34; android:textSize=\u0026#34;17sp\u0026#34; /\u0026gt; \u0026lt;TextView android:id=\u0026#34;@+id/tv_code_eight\u0026#34; android:layout_width=\u0026#34;wrap_content\u0026#34; android:layout_height=\u0026#34;wrap_content\u0026#34; android:text=\u0026#34;八位十六进制颜色设置\u0026#34; android:textSize=\u0026#34;17sp\u0026#34; /\u0026gt; \u0026lt;TextView android:id=\u0026#34;@+id/tv_code_six\u0026#34; android:layout_width=\u0026#34;wrap_content\u0026#34; android:layout_height=\u0026#34;wrap_content\u0026#34; android:text=\u0026#34;六位十六进制颜色设置\u0026#34; android:textSize=\u0026#34;17sp\u0026#34; /\u0026gt; \u0026lt;TextView android:id=\u0026#34;@+id/tv_xml\u0026#34; android:layout_width=\u0026#34;wrap_content\u0026#34; android:layout_height=\u0026#34;wrap_content\u0026#34; android:text=\u0026#34;XML文件默认透明度颜色设置\u0026#34; android:textColor=\u0026#34;#00ff00\u0026#34; android:textSize=\u0026#34;17sp\u0026#34; /\u0026gt; \u0026lt;TextView android:id=\u0026#34;@+id/tv_values\u0026#34; android:layout_width=\u0026#34;wrap_content\u0026#34; android:layout_height=\u0026#34;wrap_content\u0026#34; android:text=\u0026#34;自定义颜色设置\u0026#34; android:textColor=\u0026#34;@color/kennemColor\u0026#34; android:textSize=\u0026#34;17sp\u0026#34; /\u0026gt; \u0026lt;TextView android:id=\u0026#34;@+id/tv_bgc\u0026#34; android:layout_width=\u0026#34;wrap_content\u0026#34; android:layout_height=\u0026#34;wrap_content\u0026#34; android:background=\u0026#34;@color/kennemColor\u0026#34; android:text=\u0026#34;XML背景色颜色设置\u0026#34; android:textSize=\u0026#34;17sp\u0026#34; /\u0026gt; \u0026lt;TextView android:id=\u0026#34;@+id/tv_java_bgc\u0026#34; android:layout_width=\u0026#34;wrap_content\u0026#34; android:layout_height=\u0026#34;wrap_content\u0026#34; android:text=\u0026#34;Java背景色设置\u0026#34; android:textSize=\u0026#34;17sp\u0026#34; /\u0026gt; \u0026lt;/LinearLayout\u0026gt; public class TextColorActivity extends AppCompatActivity { @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); // 设置当前活动的布局视图，布局文件为 activity_text_color.xml setContentView(R.layout.activity_text_color); // 获取布局文件中的 TextView，其 ID 为 tv_TextSize_code_system TextView textView = findViewById(R.id.tv_TextSize_code_system); // 将该 TextView 的文本颜色设置为绿色，使用 Color 类的静态常量 textView.setTextColor(Color.GREEN); // 获取布局文件中的 TextView，其 ID 为 tv_code_eight TextView tv_code_eight = findViewById(R.id.tv_code_eight); // 将该 TextView 的文本颜色设置为绿色，使用 ARGB 格式的 8 位十六进制颜色值 tv_code_eight.setTextColor(0xff00ff00); // 获取布局文件中的 TextView，其 ID 为 tv_code_six TextView tv_code_six = findViewById(R.id.tv_code_six); // 将该 TextView 的文本颜色设置为绿色，使用 RGB 格式的 6 位十六进制颜色值（0x00ff00） // 注意：这行代码存在问题，因为 0x00ff00 实际上是一个 24 位的值，会被解析为透明颜色。 // 应该使用 0xff00ff00 这种 32 位格式。 tv_code_six.setTextColor(0xff00ff00); // 修改了原有的错误 // 获取布局文件中的 TextView，其 ID 为 tv_java_bgc TextView tv_java_bgc = findViewById(R.id.tv_java_bgc); // 将该 TextView 的背景颜色设置为红色，使用 Color 类的静态常量 tv_java_bgc.setBackgroundColor(Color.RED); } } 设置视图的宽高 视图宽度通过属性android:layout_width表达，试图高度通过属性android:lay_height表达，宽高的取值主要有下列三种\nmatch_parent：表示与上级试图保持一致 wrap_content：表示与内容自适应 以dp为单位的具体尺寸 \u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;utf-8\u0026#34;?\u0026gt; \u0026lt;LinearLayout xmlns:android=\u0026#34;http://schemas.android.com/apk/res/android\u0026#34; android:layout_width=\u0026#34;match_parent\u0026#34; android:layout_height=\u0026#34;match_parent\u0026#34; android:gravity=\u0026#34;center\u0026#34; android:orientation=\u0026#34;vertical\u0026#34;\u0026gt; \u0026lt;TextView android:layout_width=\u0026#34;wrap_content\u0026#34; android:layout_height=\u0026#34;wrap_content\u0026#34; android:layout_marginTop=\u0026#34;5dp\u0026#34; android:background=\u0026#34;#00ffff\u0026#34; android:text=\u0026#34;视图宽高均用wrap_content定义\u0026#34; android:textColor=\u0026#34;#000000\u0026#34; android:textSize=\u0026#34;17sp\u0026#34; /\u0026gt; \u0026lt;TextView android:layout_width=\u0026#34;match_parent\u0026#34; android:layout_height=\u0026#34;wrap_content\u0026#34; android:layout_marginTop=\u0026#34;5dp\u0026#34; android:background=\u0026#34;#00ffff\u0026#34; android:text=\u0026#34;视图宽高均用match_parent定义\u0026#34; android:textColor=\u0026#34;#000000\u0026#34; android:textSize=\u0026#34;17sp\u0026#34; /\u0026gt; \u0026lt;TextView android:layout_width=\u0026#34;300dp\u0026#34; android:layout_height=\u0026#34;wrap_content\u0026#34; android:layout_marginTop=\u0026#34;5dp\u0026#34; android:background=\u0026#34;#00ffff\u0026#34; android:text=\u0026#34;视图宽度指定固定大小\u0026#34; android:textColor=\u0026#34;#000000\u0026#34; android:textSize=\u0026#34;17sp\u0026#34; /\u0026gt; \u0026lt;TextView android:id=\u0026#34;@+id/tv_code\u0026#34; android:layout_width=\u0026#34;wrap_content\u0026#34; android:layout_height=\u0026#34;wrap_content\u0026#34; android:layout_marginTop=\u0026#34;5dp\u0026#34; android:background=\u0026#34;#00ffff\u0026#34; android:text=\u0026#34;用代码定义视图宽高\u0026#34; android:textColor=\u0026#34;#000000\u0026#34; android:textSize=\u0026#34;17sp\u0026#34; /\u0026gt; \u0026lt;/LinearLayout\u0026gt; 设置视图的间距 layout_margin ： 当前视图与周围平级视图之间的距离。包括layout_margin， layout_marginLeft, layout_marginTop, layout_marginRight, layout_marginBottom.\nlayout_padding ： 当前视图和内部下级视图之间的关系， 包括padding, paddingLeft, paddingTop, paddingRight, paddingBottom\n\u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;utf-8\u0026#34;?\u0026gt; \u0026lt;LinearLayout xmlns:android=\u0026#34;http://schemas.android.com/apk/res/android\u0026#34; android:layout_width=\u0026#34;match_parent\u0026#34; android:layout_height=\u0026#34;300dp\u0026#34; android:background=\u0026#34;#00AAFF\u0026#34; android:orientation=\u0026#34;vertical\u0026#34;\u0026gt; \u0026lt;LinearLayout android:layout_width=\u0026#34;match_parent\u0026#34; android:layout_height=\u0026#34;match_parent\u0026#34; android:layout_margin=\u0026#34;20dp\u0026#34; android:background=\u0026#34;#FFFF99\u0026#34; android:padding=\u0026#34;60dp\u0026#34;\u0026gt; \u0026lt;View android:layout_width=\u0026#34;match_parent\u0026#34; android:layout_height=\u0026#34;match_parent\u0026#34; android:background=\u0026#34;#FF0000\u0026#34; /\u0026gt; \u0026lt;/LinearLayout\u0026gt; \u0026lt;/LinearLayout\u0026gt; 设置视图的对齐方式 设置视图的对齐方式有两种途径\n采用layout_gravity属性，它指定了当前视图相对于上级视图的对齐方式 采用gravity属性，它指定了下级视图相对于当前视图的对齐方式 layout_gravity与gravity的取值包括：left, top, right, bottom, 还可以用竖线连接各取值，例如 \u0026quot;left|top\u0026quot; 表示即靠左又靠上，左上角对齐。\n\u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;utf-8\u0026#34;?\u0026gt; \u0026lt;LinearLayout xmlns:android=\u0026#34;http://schemas.android.com/apk/res/android\u0026#34; android:layout_width=\u0026#34;match_parent\u0026#34; android:layout_height=\u0026#34;300dp\u0026#34; android:background=\u0026#34;#ffff99\u0026#34; android:orientation=\u0026#34;horizontal\u0026#34; \u0026gt; \u0026lt;LinearLayout android:layout_width=\u0026#34;0dp\u0026#34; android:layout_height=\u0026#34;200dp\u0026#34; android:layout_weight=\u0026#34;1\u0026#34; android:layout_margin=\u0026#34;10dp\u0026#34; android:background=\u0026#34;#ff0000\u0026#34; android:padding=\u0026#34;10dp\u0026#34; android:layout_gravity=\u0026#34;bottom\u0026#34; android:gravity=\u0026#34;left\u0026#34;\u0026gt; \u0026lt;View android:layout_width=\u0026#34;100dp\u0026#34; android:layout_height=\u0026#34;100dp\u0026#34; android:background=\u0026#34;#00ffff\u0026#34;/\u0026gt; \u0026lt;/LinearLayout\u0026gt; \u0026lt;LinearLayout android:layout_width=\u0026#34;0dp\u0026#34; android:layout_height=\u0026#34;200dp\u0026#34; android:layout_weight=\u0026#34;1\u0026#34; android:layout_margin=\u0026#34;10dp\u0026#34; android:background=\u0026#34;#ff0000\u0026#34; android:padding=\u0026#34;10dp\u0026#34; android:layout_gravity=\u0026#34;top\u0026#34; android:gravity=\u0026#34;right\u0026#34;\u0026gt; \u0026lt;View android:layout_width=\u0026#34;100dp\u0026#34; android:layout_height=\u0026#34;100dp\u0026#34; android:background=\u0026#34;#00ffff\u0026#34; /\u0026gt; \u0026lt;/LinearLayout\u0026gt; \u0026lt;/LinearLayout\u0026gt; 常用布局 线性布局LinearLayout 线性布局的权重\n线性布局的权重概念，指的是线性布局的下级视图各自拥有多大比例的宽高 权重属性名叫layout_weight， 但该属性不在LinearLayout节点设置，而在线性布局的直接下级视图设置，表示该下级视图占据的宽高比例。 layout_width填0dp时，layout_weight表示水平方向的宽度比例。 layout_height填0dp时， layout_weight表示垂直方向的高度比例。 \u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;utf-8\u0026#34;?\u0026gt; \u0026lt;LinearLayout xmlns:android=\u0026#34;http://schemas.android.com/apk/res/android\u0026#34; android:id=\u0026#34;@+id/main\u0026#34; android:layout_width=\u0026#34;match_parent\u0026#34; android:layout_height=\u0026#34;match_parent\u0026#34; android:orientation=\u0026#34;vertical\u0026#34; android:background=\u0026#34;@color/backgroundColor\u0026#34;\u0026gt; \u0026lt;LinearLayout android:layout_width=\u0026#34;match_parent\u0026#34; android:layout_height=\u0026#34;wrap_content\u0026#34; android:orientation=\u0026#34;horizontal\u0026#34;\u0026gt; \u0026lt;TextView android:layout_width=\u0026#34;0dp\u0026#34; android:layout_height=\u0026#34;wrap_content\u0026#34; android:layout_weight=\u0026#34;1\u0026#34; android:text=\u0026#34;The 横排第一个\u0026#34; android:textColor=\u0026#34;@color/kennemColor\u0026#34; android:textSize=\u0026#34;17sp\u0026#34; /\u0026gt; \u0026lt;TextView android:layout_width=\u0026#34;0dp\u0026#34; android:layout_height=\u0026#34;wrap_content\u0026#34; android:layout_weight=\u0026#34;2\u0026#34; android:text=\u0026#34;The 横排第二个\u0026#34; android:textColor=\u0026#34;@color/kennemColor\u0026#34; android:textSize=\u0026#34;17sp\u0026#34; /\u0026gt; \u0026lt;/LinearLayout\u0026gt; \u0026lt;LinearLayout android:layout_width=\u0026#34;match_parent\u0026#34; android:layout_height=\u0026#34;wrap_content\u0026#34; android:orientation=\u0026#34;vertical\u0026#34;\u0026gt; \u0026lt;TextView android:layout_width=\u0026#34;wrap_content\u0026#34; android:layout_height=\u0026#34;0dp\u0026#34; android:layout_weight=\u0026#34;1\u0026#34; android:text=\u0026#34;The 竖排第一个\u0026#34; android:textColor=\u0026#34;@color/kennemColor\u0026#34; android:textSize=\u0026#34;17sp\u0026#34; /\u0026gt; \u0026lt;TextView android:layout_width=\u0026#34;wrap_content\u0026#34; android:layout_height=\u0026#34;0dp\u0026#34; android:layout_weight=\u0026#34;1\u0026#34; android:text=\u0026#34;The 竖排第二个\u0026#34; android:textColor=\u0026#34;@color/kennemColor\u0026#34; android:textSize=\u0026#34;17sp\u0026#34; /\u0026gt; \u0026lt;/LinearLayout\u0026gt; \u0026lt;/LinearLayout\u0026gt; 相对布局RelativeLayout 相对布局的下级视图位置又其他视图决定。用于确定下级视图位置的参照物分两种： 与该视图自身平级的视图 该视图的上级视图（也就是它归属的RelativeLayout） 如果不设定下级视图的参照物，那么下级视图默认显示在RelativeLayout内部的坐上角。 ​\t\u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;utf-8\u0026#34;?\u0026gt; \u0026lt;RelativeLayout xmlns:android=\u0026#34;http://schemas.android.com/apk/res/android\u0026#34; android:layout_width=\u0026#34;match_parent\u0026#34; android:layout_height=\u0026#34;150dp\u0026#34; android:orientation=\u0026#34;vertical\u0026#34;\u0026gt; \u0026lt;TextView android:id=\u0026#34;@+id/tv_center\u0026#34; android:layout_width=\u0026#34;wrap_content\u0026#34; android:layout_height=\u0026#34;wrap_content\u0026#34; android:layout_centerInParent=\u0026#34;true\u0026#34; android:background=\u0026#34;#ffffff\u0026#34; android:text=\u0026#34;我在中间\u0026#34; android:textSize=\u0026#34;11sp\u0026#34; android:textColor=\u0026#34;@color/kennemColor\u0026#34;/\u0026gt; \u0026lt;TextView android:id=\u0026#34;@+id/tv_center_horizontal\u0026#34; android:layout_width=\u0026#34;wrap_content\u0026#34; android:layout_height=\u0026#34;wrap_content\u0026#34; android:layout_centerHorizontal=\u0026#34;true\u0026#34; android:background=\u0026#34;#ffffff\u0026#34; android:text=\u0026#34;我在水平中间\u0026#34; android:textSize=\u0026#34;11sp\u0026#34; android:textColor=\u0026#34;@color/kennemColor\u0026#34;/\u0026gt; \u0026lt;TextView android:id=\u0026#34;@+id/tv_center_vertical\u0026#34; android:layout_width=\u0026#34;wrap_content\u0026#34; android:layout_height=\u0026#34;wrap_content\u0026#34; android:layout_centerVertical=\u0026#34;true\u0026#34; android:background=\u0026#34;#ffffff\u0026#34; android:text=\u0026#34;我在垂直中间\u0026#34; android:textSize=\u0026#34;11sp\u0026#34; android:textColor=\u0026#34;@color/kennemColor\u0026#34;/\u0026gt; \u0026lt;TextView android:id=\u0026#34;@+id/tv_parent_left\u0026#34; android:layout_width=\u0026#34;wrap_content\u0026#34; android:layout_height=\u0026#34;wrap_content\u0026#34; android:layout_alignParentLeft=\u0026#34;true\u0026#34; android:background=\u0026#34;#ffffff\u0026#34; android:text=\u0026#34;和上级的左边对齐\u0026#34; android:textSize=\u0026#34;11sp\u0026#34; android:textColor=\u0026#34;@color/kennemColor\u0026#34;/\u0026gt; \u0026lt;TextView android:id=\u0026#34;@+id/tv_parent_right\u0026#34; android:layout_width=\u0026#34;wrap_content\u0026#34; android:layout_height=\u0026#34;wrap_content\u0026#34; android:layout_alignParentRight=\u0026#34;true\u0026#34; android:background=\u0026#34;#ffffff\u0026#34; android:text=\u0026#34;和上级的右边对齐\u0026#34; android:textSize=\u0026#34;11sp\u0026#34; android:textColor=\u0026#34;@color/kennemColor\u0026#34;/\u0026gt; \u0026lt;TextView android:id=\u0026#34;@+id/tv_parent_top\u0026#34; android:layout_width=\u0026#34;wrap_content\u0026#34; android:layout_height=\u0026#34;wrap_content\u0026#34; android:layout_alignParentTop=\u0026#34;true\u0026#34; android:background=\u0026#34;#ffffff\u0026#34; android:text=\u0026#34;和上级的顶部对齐\u0026#34; android:textSize=\u0026#34;11sp\u0026#34; android:textColor=\u0026#34;@color/kennemColor\u0026#34;/\u0026gt; \u0026lt;TextView android:id=\u0026#34;@+id/tv_parent_bottom\u0026#34; android:layout_width=\u0026#34;wrap_content\u0026#34; android:layout_height=\u0026#34;wrap_content\u0026#34; android:layout_alignParentBottom=\u0026#34;true\u0026#34; android:background=\u0026#34;#ffffff\u0026#34; android:text=\u0026#34;和上级的底部对齐\u0026#34; android:textSize=\u0026#34;11sp\u0026#34; android:textColor=\u0026#34;@color/kennemColor\u0026#34;/\u0026gt; \u0026lt;TextView android:id=\u0026#34;@+id/tv_left_center\u0026#34; android:layout_width=\u0026#34;wrap_content\u0026#34; android:layout_height=\u0026#34;wrap_content\u0026#34; android:layout_toLeftOf=\u0026#34;@id/tv_center\u0026#34; android:layout_alignTop=\u0026#34;@+id/tv_center\u0026#34; android:background=\u0026#34;#ffffff\u0026#34; android:text=\u0026#34;我在中间的左边\u0026#34; android:textSize=\u0026#34;11sp\u0026#34; android:textColor=\u0026#34;@color/kennemColor\u0026#34;/\u0026gt; \u0026lt;TextView android:id=\u0026#34;@+id/tv_right_center\u0026#34; android:layout_width=\u0026#34;wrap_content\u0026#34; android:layout_height=\u0026#34;wrap_content\u0026#34; android:layout_toRightOf=\u0026#34;@id/tv_center\u0026#34; android:layout_alignBottom=\u0026#34;@+id/tv_center\u0026#34; android:background=\u0026#34;#ffffff\u0026#34; android:text=\u0026#34;我在中间的右边\u0026#34; android:textSize=\u0026#34;11sp\u0026#34; android:textColor=\u0026#34;@color/kennemColor\u0026#34;/\u0026gt; \u0026lt;TextView android:id=\u0026#34;@+id/tv_top_center\u0026#34; android:layout_width=\u0026#34;wrap_content\u0026#34; android:layout_height=\u0026#34;wrap_content\u0026#34; android:layout_above=\u0026#34;@id/tv_center\u0026#34; android:layout_alignLeft=\u0026#34;@+id/tv_center\u0026#34; android:background=\u0026#34;#ffffff\u0026#34; android:text=\u0026#34;我在中间的上边\u0026#34; android:textSize=\u0026#34;11sp\u0026#34; android:textColor=\u0026#34;@color/kennemColor\u0026#34;/\u0026gt; \u0026lt;TextView android:id=\u0026#34;@+id/tv_blow_center\u0026#34; android:layout_width=\u0026#34;wrap_content\u0026#34; android:layout_height=\u0026#34;wrap_content\u0026#34; android:layout_below=\u0026#34;@id/tv_center\u0026#34; android:layout_alignRight=\u0026#34;@+id/tv_center\u0026#34; android:background=\u0026#34;#ffffff\u0026#34; android:text=\u0026#34;我在中间的下边\u0026#34; android:textSize=\u0026#34;11sp\u0026#34; android:textColor=\u0026#34;@color/kennemColor\u0026#34;/\u0026gt; \u0026lt;/RelativeLayout\u0026gt; 网格布局GridLayout 网格布局支持多行多列的表格排列。 网格布局默认从左往右、从上到下排列，它新增了两个属性： columnCount属性，它指定了网格的列数，即每行能放多少个视图； rowCount属性，它指定了网格的行数，即每列能放多少个视图 滚动视图ScrollView 滚动视图有两种：\nScrollView， 它是垂直方向的滚动视图，垂直方向滚动时，layout_width属性值设置为match_parent， layout_height属性值设置为wrap_content。\nHorizontalScrollView， 它是水平方向的滚动视图；水平方向滚动时，layout_width属性值设置为wrap_content， layout_height属性值设置为match_parent。\n哪个方向要滑动就将哪个方向设置为wrap_content\n\u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;utf-8\u0026#34;?\u0026gt; \u0026lt;LinearLayout xmlns:android=\u0026#34;http://schemas.android.com/apk/res/android\u0026#34; android:id=\u0026#34;@+id/main\u0026#34; android:layout_width=\u0026#34;match_parent\u0026#34; android:layout_height=\u0026#34;match_parent\u0026#34; android:orientation=\u0026#34;vertical\u0026#34;\u0026gt; \u0026lt;HorizontalScrollView android:layout_width=\u0026#34;wrap_content\u0026#34; android:layout_height=\u0026#34;200dp\u0026#34;\u0026gt; \u0026lt;LinearLayout android:layout_width=\u0026#34;wrap_content\u0026#34; android:layout_height=\u0026#34;match_parent\u0026#34; android:orientation=\u0026#34;horizontal\u0026#34;\u0026gt; \u0026lt;View android:layout_width=\u0026#34;300dp\u0026#34; android:layout_height=\u0026#34;match_parent\u0026#34; android:background=\u0026#34;#ffff00\u0026#34; /\u0026gt; \u0026lt;View android:layout_width=\u0026#34;300dp\u0026#34; android:layout_height=\u0026#34;match_parent\u0026#34; android:background=\u0026#34;#aaffff\u0026#34; /\u0026gt; \u0026lt;/LinearLayout\u0026gt; \u0026lt;/HorizontalScrollView\u0026gt; \u0026lt;ScrollView android:layout_width=\u0026#34;match_parent\u0026#34; android:layout_height=\u0026#34;wrap_content\u0026#34;\u0026gt; \u0026lt;LinearLayout android:layout_width=\u0026#34;wrap_content\u0026#34; android:layout_height=\u0026#34;match_parent\u0026#34; android:orientation=\u0026#34;vertical\u0026#34;\u0026gt; \u0026lt;View android:layout_width=\u0026#34;match_parent\u0026#34; android:layout_height=\u0026#34;700dp\u0026#34; android:background=\u0026#34;#aaff00\u0026#34; /\u0026gt; \u0026lt;View android:layout_width=\u0026#34;match_parent\u0026#34; android:layout_height=\u0026#34;700dp\u0026#34; android:background=\u0026#34;#ff6600\u0026#34; /\u0026gt; \u0026lt;/LinearLayout\u0026gt; \u0026lt;/ScrollView\u0026gt; \u0026lt;/LinearLayout\u0026gt; 按钮控件Button 按钮控件Button由TextView派生而来，它们之间的区别有：\nButton拥有默认的按钮背景，而TextView默认无背景 Button的内部文本默认居中对齐，而TextView的内部文本默认靠左对齐 Button会默认将英文字母转为大写，而TextView保持原始的英文大小写（新版保持原有格式） 按钮控件的新增属性 与TextView相比，Button增加了两个新属性：\ntextAllCaps属性，它指定了是否将英文字母转为大写，为true表示自动转为大写，为false表示不做大写转换 onClick属性：它用来接管用户的点击动作，指定了点击按钮时要触发哪个方法 ButtonStyleActivity.java 将 findViewById(R.id.button_result) 存储到一个全局变量中，快捷键：ctrl + alt + f\npublic class ButtonStyleActivity extends AppCompatActivity { private TextView button_result; @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.activity_button_style); button_result = findViewById(R.id.button_result); } public void doClick(View view){ String desc = String.format(\u0026#34;%s 您点击了按钮：%s\u0026#34;, DateUtil.getNowTime(), ((Button)view).getText()); button_result.setText(desc); } } 布局文件： \u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;utf-8\u0026#34;?\u0026gt; \u0026lt;LinearLayout xmlns:android=\u0026#34;http://schemas.android.com/apk/res/android\u0026#34; android:id=\u0026#34;@+id/main\u0026#34; android:layout_width=\u0026#34;match_parent\u0026#34; android:layout_height=\u0026#34;match_parent\u0026#34; android:orientation=\u0026#34;vertical\u0026#34; android:padding=\u0026#34;5dp\u0026#34;\u0026gt; \u0026lt;TextView android:layout_width=\u0026#34;wrap_content\u0026#34; android:layout_height=\u0026#34;wrap_content\u0026#34; android:text=\u0026#34;下面的button字母默认大写：\u0026#34; android:layout_gravity=\u0026#34;center\u0026#34; /\u0026gt; \u0026lt;Button android:layout_width=\u0026#34;match_parent\u0026#34; android:layout_height=\u0026#34;wrap_content\u0026#34; android:text=\u0026#34;Hello Button\u0026#34; android:textColor=\u0026#34;@color/black\u0026#34; android:textSize=\u0026#34;16sp\u0026#34; /\u0026gt; \u0026lt;Button android:layout_width=\u0026#34;match_parent\u0026#34; android:layout_height=\u0026#34;wrap_content\u0026#34; android:text=\u0026#34;直接指定点击方法\u0026#34; android:textColor=\u0026#34;@color/black\u0026#34; android:textSize=\u0026#34;16sp\u0026#34; android:onClick=\u0026#34;doClick\u0026#34; /\u0026gt; \u0026lt;TextView android:id=\u0026#34;@+id/button_result\u0026#34; android:layout_width=\u0026#34;wrap_content\u0026#34; android:layout_height=\u0026#34;wrap_content\u0026#34; android:text=\u0026#34;下面时点击按钮查看到的结果 \u0026#34; android:layout_gravity=\u0026#34;center\u0026#34; /\u0026gt; \u0026lt;/LinearLayout\u0026gt; 点击事件和长按事件 监听器，意思是对专门监听控件的动作行为。只有控件发生了指定的动作，监听器才会触发开关去执行对应的代码逻辑 按钮控件有两种常用的监听器： 点击监听器：通过setOnClickListener方法设置。按钮被按住少于500毫秒时，会触发点击事件 长按监听器，通过setOnLongClickListener方法设置。按钮被按住超过500毫秒时，会触发长按事件。 单击事件 XML布局文件 \u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;utf-8\u0026#34;?\u0026gt; \u0026lt;LinearLayout xmlns:android=\u0026#34;http://schemas.android.com/apk/res/android\u0026#34; android:id=\u0026#34;@+id/main\u0026#34; android:layout_width=\u0026#34;match_parent\u0026#34; android:layout_height=\u0026#34;match_parent\u0026#34; android:orientation=\u0026#34;vertical\u0026#34;\u0026gt; \u0026lt;Button android:id=\u0026#34;@+id/btn_click_sigle\u0026#34; android:layout_width=\u0026#34;match_parent\u0026#34; android:layout_height=\u0026#34;wrap_content\u0026#34; android:text=\u0026#34;指定单独的单击按钮\u0026#34; android:textColor=\u0026#34;@color/black\u0026#34; android:textSize=\u0026#34;15sp\u0026#34; /\u0026gt; \u0026lt;Button android:id=\u0026#34;@+id/btn_click_public\u0026#34; android:layout_width=\u0026#34;match_parent\u0026#34; android:layout_height=\u0026#34;wrap_content\u0026#34; android:text=\u0026#34;指定公共的单击按钮\u0026#34; android:textColor=\u0026#34;@color/black\u0026#34; android:textSize=\u0026#34;15sp\u0026#34; /\u0026gt; \u0026lt;TextView android:id=\u0026#34;@+id/tv_result\u0026#34; android:layout_width=\u0026#34;match_parent\u0026#34; android:layout_height=\u0026#34;wrap_content\u0026#34; android:padding=\u0026#34;5dp\u0026#34; android:gravity=\u0026#34;center\u0026#34; android:textColor=\u0026#34;@color/black\u0026#34; android:textSize=\u0026#34;15sp\u0026#34; android:text=\u0026#34;点击按钮查看显示结果\u0026#34;/\u0026gt; \u0026lt;/LinearLayout\u0026gt; Java文件 /** * ButtonClickActivity类，继承AppCompatActivity，实现View.OnClickListener接口 * 用于处理按钮点击事件 */ public class ButtonClickActivity extends AppCompatActivity implements View.OnClickListener { // 定义View和TextView类型的成员变量 private View btn_click_sigle; private TextView tv_result; /** * 在Activity创建时调用，初始化Activity * @param savedInstanceState 用于保存Activity的状态 */ @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.activity_button_click); // 设置布局文件 // 获取布局中的TextView控件 tv_result = findViewById(R.id.tv_result); // 获取布局中的按钮控件 btn_click_sigle = findViewById(R.id.btn_click_sigle); // 设置按钮的点击监听器 btn_click_sigle.setOnClickListener(new MyOnClickListener(tv_result)); // 获取另一个按钮控件 Button btn_click_public = findViewById(R.id.btn_click_public); // 设置当前类为按钮的点击监听器 btn_click_public.setOnClickListener(this); } /** * 重写View.OnClickListener接口中的onClick方法 * 处理按钮的点击事件 * @param v 被点击的View */ @Override public void onClick(View v) { if (v.getId() == R.id.btn_click_public) { // 判断点击的是否为btn_click_public按钮 // 获取当前时间和按钮文本，格式化字符串 String desc = String.format(\u0026#34;%s 您点击了按钮：%s\u0026#34;, DateUtil.getNowTime(), ((Button) v).getText()); // 设置TextView的文本内容 tv_result.setText(desc); } } /** * 静态内部类，实现View.OnClickListener接口 * 防止内存泄漏，处理按钮的点击事件 */ static class MyOnClickListener implements View.OnClickListener { // 定义TextView类型的成员变量 private final TextView tv_result; /** * 构造函数，初始化TextView * @param tv_result TextView控件 */ public MyOnClickListener(TextView tv_result) { this.tv_result = tv_result; } /** * 重写View.OnClickListener接口中的onClick方法 * 处理按钮的点击事件 * @param v 被点击的View */ @Override public void onClick(View v) { // 获取当前时间和按钮文本，格式化字符串 String desc = String.format(\u0026#34;%s 您点击了按钮：%s\u0026#34;, DateUtil.getNowTime(), ((Button) v).getText()); // 设置TextView的文本内容 tv_result.setText(desc); } } } 长按事件 XML \u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;utf-8\u0026#34;?\u0026gt; \u0026lt;LinearLayout xmlns:android=\u0026#34;http://schemas.android.com/apk/res/android\u0026#34; android:id=\u0026#34;@+id/main\u0026#34; android:layout_width=\u0026#34;match_parent\u0026#34; android:layout_height=\u0026#34;match_parent\u0026#34; android:orientation=\u0026#34;vertical\u0026#34;\u0026gt; \u0026lt;Button android:id=\u0026#34;@+id/btn_long_click\u0026#34; android:layout_width=\u0026#34;match_parent\u0026#34; android:layout_height=\u0026#34;wrap_content\u0026#34; android:text=\u0026#34;指定长按的点击监听器\u0026#34; android:textColor=\u0026#34;@color/black\u0026#34; android:textSize=\u0026#34;15sp\u0026#34; /\u0026gt; \u0026lt;TextView android:id=\u0026#34;@+id/tv_result\u0026#34; android:layout_width=\u0026#34;match_parent\u0026#34; android:layout_height=\u0026#34;wrap_content\u0026#34; android:padding=\u0026#34;5dp\u0026#34; android:gravity=\u0026#34;center\u0026#34; android:textColor=\u0026#34;@color/black\u0026#34; android:textSize=\u0026#34;15sp\u0026#34; android:text=\u0026#34;点击按钮查看显示结果\u0026#34;/\u0026gt; \u0026lt;/LinearLayout\u0026gt; Java package com.showguan.myapplication; import android.os.Bundle; import android.view.View; import android.widget.Button; import android.widget.TextView; import androidx.activity.EdgeToEdge; import androidx.appcompat.app.AppCompatActivity; import androidx.core.graphics.Insets; import androidx.core.view.ViewCompat; import androidx.core.view.WindowInsetsCompat; import com.showguan.myapplication.util.DateUtil; public class ButtomLongClickActivity extends AppCompatActivity { private TextView tv_result; @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.activity_buttom_long_click); tv_result = findViewById(R.id.tv_result); Button btn_long_click = findViewById(R.id.btn_long_click); btn_long_click.setOnLongClickListener(v -\u0026gt; { String desc = String.format(\u0026#34;%s 您点击了按钮：%s\u0026#34;, DateUtil.getNowTime(), ((Button) v).getText()); tv_result.setText(desc); return true; }); } } 禁用和恢复 在实际业务中，按钮通常拥有两种状态，即不可用状态和可用状态，它们在外观和功能上的区别如下：\n不可用按钮：按钮不允许点击，即使点击也没反应，同时按钮文字为灰色 可用按钮：按钮允许点击，点击按钮会触发点击事件，同时按钮文字为正常的黑色。 是否允许点击由enabled属性控制，属性值为true时表示允许点击，为false时表示不允许点击。\nXML文件 \u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;utf-8\u0026#34;?\u0026gt; \u0026lt;LinearLayout xmlns:android=\u0026#34;http://schemas.android.com/apk/res/android\u0026#34; android:id=\u0026#34;@+id/main\u0026#34; android:layout_width=\u0026#34;match_parent\u0026#34; android:layout_height=\u0026#34;match_parent\u0026#34; android:orientation=\u0026#34;vertical\u0026#34;\u0026gt; \u0026lt;LinearLayout android:layout_width=\u0026#34;match_parent\u0026#34; android:layout_height=\u0026#34;wrap_content\u0026#34;\u0026gt; \u0026lt;Button android:id=\u0026#34;@+id/btn_enable\u0026#34; android:layout_width=\u0026#34;0dp\u0026#34; android:layout_weight=\u0026#34;1\u0026#34; android:layout_height=\u0026#34;wrap_content\u0026#34; android:text=\u0026#34;启动测试按钮\u0026#34; android:textColor=\u0026#34;@color/black\u0026#34; android:textSize=\u0026#34;17sp\u0026#34;/\u0026gt; \u0026lt;Button android:id=\u0026#34;@+id/btn_disenable\u0026#34; android:layout_width=\u0026#34;0dp\u0026#34; android:layout_weight=\u0026#34;1\u0026#34; android:layout_height=\u0026#34;wrap_content\u0026#34; android:text=\u0026#34;禁用测试按钮\u0026#34; android:textColor=\u0026#34;@color/black\u0026#34; android:textSize=\u0026#34;17sp\u0026#34;/\u0026gt; \u0026lt;/LinearLayout\u0026gt; \u0026lt;Button android:id=\u0026#34;@+id/btn_test\u0026#34; android:layout_width=\u0026#34;match_parent\u0026#34; android:layout_height=\u0026#34;wrap_content\u0026#34; android:text=\u0026#34;测试按钮\u0026#34; android:textColor=\u0026#34;@color/black\u0026#34; android:textSize=\u0026#34;17sp\u0026#34; android:enabled=\u0026#34;false\u0026#34;/\u0026gt; \u0026lt;TextView android:id=\u0026#34;@+id/tv_content\u0026#34; android:layout_width=\u0026#34;match_parent\u0026#34; android:layout_height=\u0026#34;wrap_content\u0026#34; android:text=\u0026#34;这里查看测试按钮的结果\u0026#34; android:textColor=\u0026#34;@color/kennemColor\u0026#34; android:textSize=\u0026#34;17sp\u0026#34;/\u0026gt; \u0026lt;/LinearLayout\u0026gt; Java /** * ButtonEnableActivity类，继承AppCompatActivity，实现View.OnClickListener接口 * 用于处理按钮启用和禁用的功能 */ public class ButtonEnableActivity extends AppCompatActivity implements View.OnClickListener { // 定义TextView和Button类型的成员变量 private TextView tv_content; private Button btn_test; private Button btn_enable; private Button btn_disenable; /** * 在Activity创建时调用，初始化Activity * @param savedInstanceState 用于保存Activity的状态 */ @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.activity_button_enable); // 设置布局文件 // 获取布局中的按钮控件 btn_enable = findViewById(R.id.btn_enable); btn_disenable = findViewById(R.id.btn_disenable); btn_test = findViewById(R.id.btn_test); // 获取布局中的TextView控件 tv_content = findViewById(R.id.tv_content); // 设置按钮的点击监听器 btn_enable.setOnClickListener(this); btn_disenable.setOnClickListener(this); btn_test.setOnClickListener(this); } /** * 重写View.OnClickListener接口中的onClick方法 * 处理按钮的点击事件 * @param v 被点击的View */ @Override public void onClick(View v) { int id = v.getId(); // 获取被点击View的ID if (id == R.id.btn_enable) { // 如果点击的是启用按钮 btn_test.setEnabled(true); // 启用测试按钮 btn_test.setTextColor(Color.BLACK); // 设置按钮文字颜色为黑色 } else if (id == R.id.btn_disenable) { // 如果点击的是禁用按钮 btn_test.setEnabled(false); // 禁用测试按钮 btn_test.setTextColor(Color.GRAY); // 设置按钮文字颜色为灰色 } else if (id == R.id.btn_test) { // 如果点击的是测试按钮 tv_content.setText(\u0026#34;测试按钮被点击了\u0026#34;); // 设置TextView的文本内容 } } } 图像显示ImageView 图像视图展示的图片通常位于res/drawable***目录下，设置图像视图的显示图片有两种方式\n在XML文件中，通过属性android:src属性值格式如\u0026quot;@drawable/不含扩展名的图片名称\u0026quot; 在Java代码中，调用setImageResource方法设置图片资源，方法参数格式形如\u0026quot;R.drawable.不含扩展名的图片名称\u0026quot;。 centerInside和center， fitCenter的区别： fitCenter既允许缩小图片，也允许放大图片，centerInside只允许缩小图片，不允许放大图片，而center自始至终保持原始尺寸，既不允许缩小图片，也不允许放大图片\n默认为fitCenter\n代码设置方式：\nImageView iv_scale = findViewById(R.id.iv_scale); iv_scale.setImageResource(R.drawable.cat); iv_scale.setScaleType(ImageView.ScaleType.FIT_END); 图像按钮ImageButton ImageButton是显示图片的图像按钮，但它继承自ImageView， 而非继承Button\nImageButton 和 Button之间的区别：\nButton既可显示文本也可显示图片，ImageButton只能显示图片不能显示文本。 ImageButton上的图像可按比例缩放，而Button通过背景设置的图像会拉伸变形 Button只能靠背景显示一张图片，而ImageButton可分别在前景和背景显示图片，从而实现两张图片的叠加效果 \u0026lt;ImageButton android:layout_width=\u0026#34;match_parent\u0026#34; android:layout_height=\u0026#34;80dp\u0026#34; android:src=\u0026#34;@drawable/cat\u0026#34; android:scaleType=\u0026#34;fitCenter\u0026#34; \u0026gt;\u0026lt;/ImageButton\u0026gt; 同时展示文本与图像 XML 文件 \u0026lt;Button android:layout_width=\u0026#34;wrap_content\u0026#34; android:layout_height=\u0026#34;wrap_content\u0026#34; android:background=\u0026#34;#ffffffff\u0026#34; android:drawableRight=\u0026#34;@drawable/ic_launcher_foreground\u0026#34; android:drawablePadding=\u0026#34;15dp\u0026#34; android:text=\u0026#34;图标文字\u0026#34; android:textSize=\u0026#34;17sp\u0026#34; /\u0026gt; 坚持，一定要坚持下去，持续投入，一万小时定律 有困难了就停下来想一想 接受痛苦, 战胜痛苦 ","permalink":"https://kennems.github.io/posts/tech/android1/","summary":"Android（1） 【金山文档 | WPS云文档】 Kotlin 讲义 https://kdocs.cn/l/cu14rrCtfKxv 【金山文档 | WPS云文档】 Android 四大组件课程概要 https://kdocs.cn/l/croaFl0RS5LA 【金山文档 | WPS云文档】 Fragment 重点知识 https://kdocs.cn/l/cj89XRLXypb8 【","title":"Android（1）"},{"content":"Java Web开发(7) Spring原理 配置优先级 SpringBoot中支持三种格式配置文件的优先级\nproperties yaml yml 配置 SpringBoot除了支持配置文件属性配置，还支持Java系统属性和命令行参数的方式进行属性配置\nJava系统属性\n-Dserver.port=9000 命令行参数\n--server.port=10010 打包时指定端口号(cmd 命令)\njava -Dserver.port=9000 -jar tilas-web-management-0.0.1-SNAPSHOT.jar --server.port=10011 powershell命令行参数解释不同\njava -D\u0026#34;server.port=9000\u0026#34; -jar .\\tilas-web-management-0.0.1-SNAPSHOT.jar --server.port=10011 Java系统属性-Dserver.port=9000优先级高于三种配置文件， 而--server.port=10011高于Java系统属性\nBean管理 获取bean\n默认情况下，Spring项目启动时，会把bean都创建好放在IOC容器中，如果想要主动获取这些bean， 可以通过如下方式\n根据name获取bean\nObject getBean(String name) 根据类型获取bean\n\u0026lt;T\u0026gt; T getBean(Class\u0026lt;T\u0026gt; requiredType) 根据name获取bean（带类型转换）\n\u0026lt;T\u0026gt; T getBean(String name, Class\u0026lt;T\u0026gt; requiredType) BUG解决Could not autowire. No beans of 'ApplicationContext' type found.的问题\nidea导入出错\nimport org.springframework.context.ApplicationContext; DeptController bean1 = (DeptController) applicationContext.getBean(\u0026#34;deptController\u0026#34;); System.out.println(bean1); DeptController bean2 = (DeptController) applicationContext.getBean(DeptController.class); System.out.println(bean2); DeptController bean3 = (DeptController) applicationContext.getBean(\u0026#34;deptController\u0026#34;, DeptController.class); System.out.println(bean3); bean的作用域 作用域 说明 singleton 容器内同名称的bean只有一个实例（单例）默认 prototype 每次使用该bean时会创建新的实例（非单例） request 每个请求范围内会创建新的实例（web环境中，了解） session 每个会话范围内会创建新的实例（web环境中，了解） application 每个应用范围内会创建新的实例（web环境中，了解） //@Lazy @Scope(\u0026#34;prototype\u0026#34;) 注意事项：\n默认singleton的bean，在容器启动时背创建，可以使用@Lazy注解来延迟初始化（延迟到第一次使用） prototype的bean，每一次使用该bean的时候都会创建一个新的实例 实际开发中，绝大部分的bean都是单例的，也就是说绝大部分的bean不需要配置scope属性 第三方bean 如果要管理的bean对象来自第三方（不是自定义的），是无法使用@Component及衍生注解声明bean的，就需要用到@Bean注解 若要管理的第三方bean对象，建议对这些bean进行集中分类配置，可以通过@Configuration注解声明一个配置类。 @Configuration public class CommonConfig { @Bean // 第三方bean对象 // 获取bean对象 : 如果没有指定bean名称，则默认为方法名 // 第三方bean对象需要对象注入，只需要在方法参数中写该参数即可 public SAXReader reader(DeptService deptService){ System.out.println(deptService); return new SAXReader(); } } @Component及衍生注解与@Bean注解使用场景：\n项目中自定义的，使用@Component及其衍生注解 项目中引入第三方的，使用@Bean注解 SpringBoot原理 起步依赖：SpringBoot使用Maven依赖传递管理依赖，可以自动配置依赖\n自动配置：\nSpringBoot的自动配置就是当Spring容器启动后，一些配置类，bean对象就自动存入到了IOC容器中，不需要我们手动去声明，从而简化了开发，省去了繁琐的配置操作。 自动配置原理 方案一：@ComponentScan 组件扫描\n@ComponentScan({\u0026#34;com.example\u0026#34;, \u0026#34;com.showguan\u0026#34;}) public class TilasWebManagementApplication { 方案二：@Import导入。使用@Import导入的类会被Spring加载到IOC容器中，导入形式\n导入普通类 导入配置类 导入ImportSelector接口实现类 @EnableXXX注解，封装@Import注解 //@Import({TokenParser.class}) //@Import({HeaderConfig.class}) //@Import({MyImportSelector.class}) @EnableHeaderConfig public class TilasWebManagementApplication { } 源码跟踪 @SpringBootApplication\n该注解标识在SpringBoot工程引导类上，是SpringBoot中最最最重要的注解。 @SpringBootConfiguration：该注解与@Configuration注解作用相同，用来声明当前也是一个配置类 @ComponentScan：组件扫描，默认扫描当前引导类所在包及其子包 @EnableAutoConfiguration：SpringBoot实现自动化配置的核心注解 @Conditional 作用：按照一定的条件进行判断，在满足给定条件后才会注册对应的bean对象到Spring IOC容器中 位置：方法，类 @Conditional 本身是一个父注解，派生出大量的子注解 @ConditionalOnClass：判断环境中是否有对应字节码文件，才注册bean到IOC容器 @ConditonalOnMissingBean：判断环境中没有对应的bean（类型或名称），才注册这个bean到IOC容器中 （常用场景：先使用自己创建的bean，如果自己没有创建，则使用系统默认的bean）\u0026ndash; 指定类型（value属性） 或 名称（name属性） @ConditionalProperty：判断配置文件中有对应属性和值，才注册bean到IOC容器中 自定义starter 场景：在实际开发中，经常会定义一些公共组件，提供给项目团队使用。而在SpringBoot的项目中，一般会将这些公共组件封装为SpringBoot的starter 步骤：\n创建aliyun-oss-spring-boot-starter模块 创建aliyun-oss-spring-boot-autoconfigure模块，在starter中引入该模块 在aliyun-oss-spring-boot-autoconfigure 模块中的定义自动配置功能，并定义自动配置文件 META-INF/spring/xxx.imports 文件目录结构：\n外部类需要使用OSS功能时：\n1、引入依赖 2、编写yml文件的必要参数 3、直接注入即可\n总结 Web三层架构\nSpringMVC 是 Spring framework中的Web模块\nSSM(SpringMVC + Spring framework + Mybatis)\nMVN高级 maven生成imi文件\nmvn idea:module 为什么要分模块设计？ 方便项目的管理维护，扩展，也方便模块间的相互调用，资源共享。\n注意事项 分模块设计需要先针对模块功能进行设计，再进行编码。不会先将工程开发完毕，然后进行拆分。 继承关系实现 常见打包方式：\njar：普通模块打包，springboot项目基本都是jar包（内嵌tomcat运行） war：普通web程序打包，需要部署在外部的tomcat服务器上 pom：父工程或聚合工程，该模块不写代码，仅进行依赖管理 步骤:\n创建maven模块 tlias-parent，该工程为父工程， 设置打包方式pom\n\u0026lt;!-- 设置spring工程的父工程--\u0026gt; \u0026lt;parent\u0026gt; \u0026lt;groupId\u0026gt;org.springframework.boot\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-boot-starter-parent\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;3.2.6\u0026lt;/version\u0026gt; \u0026lt;relativePath/\u0026gt; \u0026lt;!-- lookup parent from repository --\u0026gt; \u0026lt;/parent\u0026gt; \u0026lt;groupId\u0026gt;com.showguan\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;tlias-parent\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;1.0-SNAPSHOT\u0026lt;/version\u0026gt; \u0026lt;!-- 设置打包方式--\u0026gt; \u0026lt;packaging\u0026gt;pom\u0026lt;/packaging\u0026gt; 在子工程的pom.xml文件中，配置继承关系\n\u0026lt;parent\u0026gt; \u0026lt;groupId\u0026gt;com.showguan\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;tlias-parent\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;1.0-SNAPSHOT\u0026lt;/version\u0026gt; \u0026lt;relativePath\u0026gt;../tlias-parent/pom.xml\u0026lt;/relativePath\u0026gt; \u0026lt;/parent\u0026gt; 注意事项：\n在子工程中，配置了继承关系之后，坐标中的groupid是可以省略的，因为会自动继承父工程的。 relativePath指定父工程的pom文件的相对位置（如果不指定，将从本地仓库/远程仓库查找该工程）。 在父工程中配置各个工程共有的依赖（子工程会自动继承父工程的依赖）\n\u0026lt;dependencies\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.projectlombok\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;lombok\u0026lt;/artifactId\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;/dependencies\u0026gt; 若父子工程都配置了同一个依赖，以子工程的依赖为准。 版本锁定 在maven中，可以在父工程的pom文件中 通过 \u0026lt;dependencyManagement\u0026gt; 来统一管理依赖版本 父工程：\n\u0026lt;properties\u0026gt; \u0026lt;jjwt.version\u0026gt;0.9.1\u0026lt;/jjwt.version\u0026gt; \u0026lt;/properties\u0026gt; \u0026lt;dependencyManagement\u0026gt; \u0026lt;dependencies\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;io.jsonwebtoken\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;jjwt\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;${jjwt.version}\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependencies\u0026gt; \u0026lt;dependencyManagement\u0026gt; 子工程（仍需引入依赖，但是不需要版本号）：\n\u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;io.jsonwebtoken\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;jjwt\u0026lt;/artifactId\u0026gt; \u0026lt;/dependency\u0026gt; 注意事项：\n子工程引入依赖时，无需指定\u0026lt;version\u0026gt;版本号，父工程统一管理，变更依赖版本，只需要父工程中统一变更。 聚合 将多个模块组织成一个整体，同时进行项目的构建\n聚合工程 一个不具有业务功能的\u0026quot;空\u0026quot;工程（有且仅有一个pom文件\n作用：快速构建项目（无需根据依赖关系手动构建，直接在聚合工程上构建即可）\n在parent 的pom.xml文件内添加\n\u0026lt;modules\u0026gt; \u0026lt;module\u0026gt;../tlias-pojo\u0026lt;/module\u0026gt; \u0026lt;module\u0026gt;../tlias-utils\u0026lt;/module\u0026gt; \u0026lt;module\u0026gt;../tlias-web-management\u0026lt;/module\u0026gt; \u0026lt;/modules\u0026gt; 聚合和继承：\n作用 聚合用于快速构建项目 继承用于简化依赖配置、统一管理依赖 相同点 聚合与继承的pom.xml文件打包方式均为pom， 可以将两种关系制作到同一个pom文件中 聚合与继承均属于设计型模块，并无实际的模块内容 不同点 聚合是在聚合工程中配置关系，聚合可以感知到参与聚合的模块有哪些 继承是在子模块中配置关系，父模块无法感知哪些子模块继承了自己 私服 私服是一种特殊的仓库，它是架设在局域网内的仓库服务，用来代理位于外部的中央仓库，用于解决团队内部的资源共享和资源同步问题。 资源上传与下载\n项目版本：\n\u0026lt;artifactId\u0026gt;tlias-web-management\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;0.0.1-SNAPSHOT\u0026lt;/version\u0026gt; \u0026lt;name\u0026gt;tilas-web-management\u0026lt;/name\u0026gt; \u0026lt;description\u0026gt;tilas-web-management\u0026lt;/description\u0026gt; RELEASE（发行版本）：功能趋于稳定，当前更新停止，可以用于发行的版本，存储在私服中的RELEASE仓库中。 SNAPSHOT（快照版本）：功能不稳定，尚处于开发中的版本，即快照版本，存储在私服的SNAPSHOT仓库中。 ","permalink":"https://kennems.github.io/posts/tech/java-web%E5%BC%80%E5%8F%917/","summary":"Java Web开发(7) Spring原理 配置优先级 SpringBoot中支持三种格式配置文件的优先级 properties yaml yml 配置 SpringBoot除了支持配置文件","title":"Java Web开发(7)"},{"content":"面经（1） 八股分为：基础知识，底层原理，场景应用\n基础知识：javaguide, 死记硬背，思维导图 底层原理：八股合集，面经+GPT+整理 场景应用：面经+积累 20240611 面向面经背八股，小米面经\n小米一面面经 自我介绍（项目经历和实习经历） 在自我介绍时，可以简要介绍自己的教育背景、工作经历、主要技能和项目经历。着重突出在项目中的具体职责和贡献，以及所使用的技术和取得的成果。\n1. Java的基本数据类型 Java有8种基本数据类型：\nbyte: 8位，范围是 -128 到 127 short: 16位，范围是 -32,768 到 32,767 int: 32位，范围是 -2^31 到 2^31-1 long: 64位，范围是 -2^63 到 2^63-1 float: 32位，单精度浮点数 double: 64位，双精度浮点数 char: 16位，无符号 Unicode 字符 boolean: 只有两个值：true 和 false 2. 了解哪些基本的数据结构 常见的数据结构包括：\n数组 链表（单链表、双链表） 栈 队列（普通队列、优先队列、循环队列） 哈希表 树（如二叉树、红黑树、B树、B+树） 图（有向图、无向图） 堆（如二叉堆、斐波那契堆） 3. 简单介绍二叉树 二叉树是一种树形数据结构，其中每个节点最多有两个子节点，分别称为左子节点和右子节点。常见的二叉树类型有：\n完全二叉树：除了最后一层，所有层的节点都填满，最后一层的节点都靠左对齐。 满二叉树：每个节点要么是叶子节点，要么有两个子节点。 二叉搜索树：对于每个节点，其左子节点的值小于该节点的值，其右子节点的值大于该节点的值。 4. 知道MySQL吗？MySQL中跟二叉树相关的结构你知道吗？ 在MySQL中，索引结构与二叉树相关的是B树和B+树。B树是一种自平衡的多路搜索树，B+树是B树的一种改进版，所有的叶子节点形成一个有序链表。MySQL的InnoDB存储引擎使用B+树来实现索引。\n5. 展开说说B树和B+树 B树：一种自平衡的多路搜索树，节点可以有多个子节点。所有叶子节点的深度相同，节点中的元素按顺序排列。 B+树：B树的改进版，非叶子节点不存储数据，只存储索引，所有数据都存储在叶子节点中。叶子节点之间形成一个有序链表，方便范围查询。 6. MySQL中现在主要用B树还是B+树？B+树的优势？ MySQL中的InnoDB存储引擎主要使用B+树。B+树的优势包括：\n所有数据都在叶子节点，查询效率高 叶子节点形成有序链表，方便范围查询 非叶子节点只存储索引，减少了树的高度，提高了查询效率 7. Redis的基本类型 Redis支持以下基本数据类型：\n字符串（String） 列表（List） 集合（Set） 有序集合（Sorted Set） 哈希（Hash） 8. Redis中Set和Sorted Set的区别 Set：无序集合，不允许重复元素，操作时间复杂度为O(1)。 Sorted Set：有序集合，每个元素都会关联一个分数，Redis通过分数进行排序，操作时间复杂度为O(log N)。 9. 有了解过JVM方面的知识吗？垃圾回收 JVM（Java虚拟机）是Java程序运行的基础，负责内存管理和垃圾回收。垃圾回收机制（GC）主要有以下几种算法：\n标记-清除（Mark-Sweep） 标记-整理（Mark-Compact） 复制（Copying） 分代收集（Generational Collecting）：年轻代（Young Generation）和老年代（Old Generation）分别采用不同的GC算法。 10. TCP通过什么来保证可靠传输的？ TCP通过以下机制保证可靠传输：\n三次握手建立连接 序列号和确认号 滑动窗口 超时重传 流量控制 拥塞控制 11. 细说三次握手、四次挥手 三次握手：\n客户端发送SYN包（同步序列编号）请求建立连接。 服务器接收到SYN包，返回一个SYN+ACK包表示同意建立连接。 客户端收到SYN+ACK包，回复一个ACK包，连接建立成功。 四次挥手：\n客户端发送FIN包（结束连接）请求断开连接。 服务器接收到FIN包，返回一个ACK包，表示确认断开连接请求。 服务器发送FIN包请求断开连接。 客户端收到FIN包，返回一个ACK包，连接断开。 「手撕」 链表相关 将链表转成数字，相加之后再转成链表。示例：\n输入：链表一：1-\u0026gt;6-\u0026gt;3，链表二：7-\u0026gt;1-\u0026gt;2 相当于361 + 217 = 578 输出：8-\u0026gt;7-\u0026gt;5 class ListNode { int val; ListNode next; ListNode(int x) { val = x; } } public class Solution { public ListNode addTwoNumbers(ListNode l1, ListNode l2) { ListNode dummyHead = new ListNode(0); ListNode p = l1, q = l2, curr = dummyHead; int carry = 0; while (p != null || q != null) { int x = (p != null) ? p.val : 0; int y = (q != null) ? q.val : 0; int sum = carry + x + y; carry = sum / 10; curr.next = new ListNode(sum % 10); curr = curr.next; if (p != null) p = p.next; if (q != null) q = q.next; } if (carry \u0026gt; 0) { curr.next = new ListNode(carry); } return dummyHead.next; } } 「继续QA」 1. 手撕这个算法的时间复杂度 上述算法的时间复杂度是O(max(m, n))，其中m和n分别是两个链表的长度。因为需要遍历两个链表的每一个节点。\n2. 如果能实习，每周几天、实习周期？ 根据个人情况回答，可以说出每周可以实习的天数和希望的实习周期长度。例如：\n每周3-5天 实习周期为3-6个月 参考资料 牛客网：https://www.nowcoder.com/feed/main/detail/61f2b3801d6b42d4b39adcf461b784b5?sourceSSR=users 小米二面面经 #面经 「QA」\nMyBatis 具体是干什么用的？在使用它之前可能会遇到什么问题，使用它之后会给你的项目带来什么便利？ 项目中有没有用到线程池？ MyBatis 中涉及到动态 sql，sql 的标签能说几个吗 MyBatis 能执行一对一或者一对多关联的查询吗？有哪些实现方式？ SpringBoot 中，读取配置的时候有哪些方式？ Integer 对象和基本数据类型 int，哪个占用更多的内存 ArrayList 和 LinkedList 的区别 对象的浅拷贝和深拷贝 了解哪些设计模式？ (逐渐离谱了起来)：tensorflow 是用来干嘛的 解释一下 softmax (聊我的科研项目里) 常用的强化学习算法 为什么用 PPO 算法不用 DQN 算法？ 为什么不用 A3C 算法？ 讲讲 Transformer…… 「手撕」\n很简单的数组题 2min 做完 反转链表 II 力扣 92 题（写过但忘了 啊啊啊啊啊啊） 好的，以下是对这些面试问题的详细回答：\n1. MyBatis 具体是干什么用的？在使用它之前可能会遇到什么问题，使用它之后会给你的项目带来什么便利？ MyBatis 是一款优秀的持久层框架，它支持定制化 SQL、存储过程以及高级映射。MyBatis 避免了几乎所有的 JDBC 代码和手动设置参数以及获取结果集。使用前可能遇到的问题包括：\n学习曲线：需要花时间学习和理解 MyBatis 的配置和使用方式。 配置复杂性：需要配置 XML 文件或注解，初期配置较复杂。 使用之后的便利包括： 降低了直接使用 JDBC 的复杂性，提高开发效率。 支持动态 SQL，灵活性高。 支持高级映射，可以方便地将查询结果映射为 Java 对象。 2. 项目中有没有用到线程池？ 线程池用于管理和复用多个线程，避免频繁创建和销毁线程带来的开销，提高系统性能。常用的线程池有：\nExecutors.newFixedThreadPool(int n): 固定大小的线程池。 Executors.newCachedThreadPool(): 可缓存的线程池。 Executors.newScheduledThreadPool(int n): 支持定时和周期性任务的线程池。 Executors.newSingleThreadExecutor(): 单线程池。 3. MyBatis 中涉及到动态 sql，sql 的标签能说几个吗 MyBatis 中的动态 SQL 标签包括：\n\u0026lt;if\u0026gt;: 根据条件是否包含某段 SQL。 \u0026lt;choose\u0026gt;: 类似 switch 语句，包含 \u0026lt;when\u0026gt; 和 \u0026lt;otherwise\u0026gt;。 \u0026lt;where\u0026gt;: 自动处理 AND/OR 逻辑。 \u0026lt;set\u0026gt;: 用于动态更新语句。 \u0026lt;foreach\u0026gt;: 用于遍历集合生成动态 SQL。 \u0026lt;trim\u0026gt;: 自定义 SQL 片段。 4. MyBatis 能执行一对一或者一对多关联的查询吗？有哪些实现方式？ MyBatis 可以执行一对一或一对多的关联查询。实现方式包括：\n使用 resultMap 进行结果映射，定义关联关系。 在 SQL 中使用 JOIN 语句进行关联查询。 使用 association 和 collection 标签实现一对一和一对多映射。 5. SpringBoot 中，读取配置的时候有哪些方式？ SpringBoot 读取配置的方式包括：\n@Value: 注入单个配置属性。 @ConfigurationProperties: 批量注入配置属性。 Environment 对象：通过 environment.getProperty 方法获取配置。 @PropertySource: 加载自定义配置文件。 application.properties 或 application.yml: 默认配置文件。 6. Integer 对象和基本数据类型 int，哪个占用更多的内存 Integer 对象占用的内存更多。int 是基本数据类型，直接存储数值，占用 4 个字节。而 Integer 是包装类，除了存储数值外，还包含对象头信息，至少占用 16 个字节（具体根据 JVM 实现和对象头信息有所不同）。\n7. ArrayList 和 LinkedList 的区别 ArrayList: 基于动态数组实现，查询速度快（O(1)），增删速度慢（O(n)）。 LinkedList: 基于双向链表实现，查询速度慢（O(n)），增删速度快（O(1)）。 8. 对象的浅拷贝和深拷贝 浅拷贝: 只复制对象的基本类型和引用类型的地址，不复制引用对象本身。修改引用对象会影响原对象。 深拷贝: 复制对象的基本类型和引用对象，生成一个全新的对象，互不影响。 9. 了解哪些设计模式？ 常见的设计模式包括：\n创建型模式: 工厂模式、抽象工厂模式、单例模式、建造者模式、原型模式。 结构型模式: 适配器模式、装饰器模式、代理模式、外观模式、桥接模式、组合模式、享元模式。 行为型模式: 策略模式、模板方法模式、观察者模式、迭代器模式、责任链模式、命令模式、备忘录模式、状态模式、访问者模式、解释器模式、中介者模式。 10. TensorFlow 是用来干嘛的 TensorFlow 是一个开源的机器学习框架，主要用于深度学习模型的开发、训练和部署。它提供了灵活的计算图结构，可以在 CPU、GPU 和 TPU 上运行，支持分布式计算。\n11. 解释一下 softmax Softmax 是一种激活函数，常用于多分类模型的输出层。它将输入的 logits 转换为概率分布，公式如下： [ \\text{softmax}(x_i) = \\frac{e^{x_i}}{\\sum_{j} e^{x_j}} ] 其中，( x_i ) 是输入向量的第 i 个分量，输出的每个分量都是介于 0 和 1 之间的概率值，且所有分量的和为 1。\n12. 常用的强化学习算法 为什么用 PPO 算法不用 DQN 算法？ PPO（Proximal Policy Optimization）和 DQN（Deep Q-Network）都是常用的强化学习算法。选择 PPO 而不是 DQN 的原因包括：\nPPO 是基于策略梯度的算法，适用于连续动作空间，而 DQN 主要用于离散动作空间。 PPO 引入了剪切概率比（clipped probability ratio），在更新策略时保持平稳，训练更稳定。 PPO 更加简单高效，不需要像 DQN 那样复杂的经验回放和目标网络。 13. 为什么不用 A3C 算法？ 尽管 A3C（Asynchronous Advantage Actor-Critic）是一个有效的算法，但相较于 PPO，有以下缺点：\nA3C 使用多线程并行，容易受到线程调度和同步的影响。 PPO 不需要复杂的多线程设置，具有更高的样本效率和训练稳定性。 PPO 算法相对更简单，更容易调试和实现。 14. 讲讲 Transformer Transformer 是一种用于自然语言处理的神经网络模型，克服了传统 RNN 模型在处理长序列时的局限性。它主要由以下部分组成：\n编码器（Encoder）: 由多个相同的编码层堆叠而成，每层包含自注意力机制和前馈神经网络。 解码器（Decoder）: 结构类似于编码器，但每个解码层在自注意力机制之后还增加了一个对编码器输出的注意力机制。 自注意力机制（Self-Attention）: 计算输入序列中每个元素与其他元素的关系，以捕捉全局依赖关系。 位置编码（Positional Encoding）: 为了保留序列信息，向输入中添加位置信息。 Transformer 的优势包括： 并行化计算效率高，适合处理长序列。 能够捕捉序列中全局依赖关系。 「手撕」 1. 很简单的数组题 2min 做完 假设这是一个简单的求数组最大值的题目，代码如下：\npublic int findMax(int[] nums) { int max = nums[0]; for (int num : nums) { if (num \u0026gt; max) { max = num; } } return max; } 2. 反转链表 II 力扣 92 题 反转链表 II 的解题思路是找到要反转的起点和终点，进行局部反转。代码如下：\npublic ListNode reverseBetween(ListNode head, int m, int n) { if (head == null) return null; ListNode dummy = new ListNode(0); dummy.next = head; ListNode pre = dummy; for (int i = 0; i \u0026lt; m - 1; i++) pre = pre.next; ListNode start = pre.next; ListNode then = start.next; for (int i = 0; i \u0026lt; n - m; i++) { start.next = then.next; then.next = pre.next; pre.next = then; then = start.next; } return dummy.next; } /** * Definition for singly-linked list. * public class ListNode { * int val; * ListNode next; * ListNode() {} * ListNode(int val) { this.val = val; } * ListNode(int val, ListNode next) { this.val = val; this.next = next; } * } */ class Solution { public ListNode reverseBetween(ListNode head, int m, int n) { if (head == null) return null; ListNode dummy = new ListNode(0); dummy.next = head; ListNode pre = dummy; for (int i = 0; i \u0026lt; m - 1; i++) pre = pre.next; ListNode start = pre.next; ListNode cur = null; ListNode newEnd = start; for (int i = 0; i \u0026lt;= n - m; i++) { ListNode nxt = start.next; start.next = cur; cur = start; start = nxt; } pre.next = cur; newEnd.next = start; return dummy.next; } } 希望这些回答能帮助你更好地准备面试。祝你面试成功！\n","permalink":"https://kennems.github.io/posts/tech/%E9%9D%A2%E7%BB%8F1/","summary":"面经（1） 八股分为：基础知识，底层原理，场景应用 基础知识：javaguide, 死记硬背，思维导图 底层原理：八股合集，面经+GPT+整理 场景应","title":"面经（1）"},{"content":"Java Web开发(6) 事务：事务是一组操作的集合，它是一个不可分割的工作单位，这些操作要么同时成功，要么同时失败\nstart transaction / begin commit rollback Spring事务管理 @Transactional 位置：业务（service）层的方法上、类上、接口上 作用：将当前方法交给spring进行事务管理，方法执行前，开启事务；成功执行完毕，提交事务；出现异常，回滚事务。 事务属性\n默认情况下，只有出现RuntimeException 才回滚异常。rollbackFor属性用于控制出现何种异常类型是回滚事务 @Transactional(rollbackFor = Exception.class) 传播行为\npropagation\n事务传播行为：指的是当一个事务方法被另一个事务方法调用时，这个事务方法应该如何进行事务控制\nREQUIRED：大部分情况下都是用该传播行为即可\nREQUIRES_NEW：当我们不希望事务之间相互影响时，可以使用该传播行为。比如：下订单前需要记录日志，不论订单保存成功与否，都需要保证日志记录能够记录成功。\nAOP AOP（Aspect Oriented Programming）面向切面编程，面向方面编程，其实就是面向特定方法编程。 场景：\n统计Service各项方法的运行耗时\n@Slf4j @Component @Aspect public class TimeAspect { @Around(\u0026#34;execution(* com.showguan.service.*.*(..))\u0026#34;) public Object recordTime(ProceedingJoinPoint joinPoint) throws Throwable { long begin = System.currentTimeMillis(); Object result = joinPoint.proceed(); long end = System.currentTimeMillis(); log.info(joinPoint.getSignature() + \u0026#34;方法耗时 :{} ms\u0026#34;, (end-begin)); return result; } } AOP核心概念\n连接点：JoinPoint，可以被AOP控制的方法（暗含方法执行时的相关信息） 通知：Advice， 指哪些重复的逻辑，也就是共性功能（最终体现为一个方法） 切入点：PointCut，匹配连接点的条件，通知仅会在切入点方法执行时被应用 切面：Aspect，描述通知与切入点的对应关系（通知+切入点） 目标对象：Target, 通知所应用的对象 通知类型\n@Around：环绕通知，此注解标注的通知方法在目标方法前后都被执行 @Before：前置通知，此注解标注的通知方法在目标方法前被执行 @After：后置通知，此注解标注的通知方法在目标方法后被执行，无论是否有异常都会执行 @AfterReturning：返回后通知，此注解标注的通知方法在目标方法后被执行，有异常不会执行 @AfterThrowing：异常后通知，此注解标注的通知方法发生异常后执行 注意事项；\n@Around 环绕通知需要自己调用 Object result = proceedingJoinPoint.proceed(); 来让原始方法执行，其他通知不需要考虑目标方法执行\n@Around 环绕通知方法的返回值，必须指定为Object，来接收原始方法的返回值 通知顺序 当有多个切面的切入点都匹配到了目标方法，目标方法运行时，多个通知方法都会被执行\n执行顺序\n不同切面类中，默认按照切面类的类名字母排序 目标方法前的通知方法：字母排名靠前的先执行 目标方法后的通知方法：字母排名靠前的后执行 用@Order（数字）加在切面类上来控制顺序 目标方法前的通知方法：数字小的先执行 目标方法后的通知方法：数字小的后执行 切入点表达式\n描述切入点方法的一种表达式 作用：主要用来决定项目中哪些方法需要加入通知 常见形式 execution(...)：根据方法的签名来匹配 @annotation(...)：根据注解匹配 execution根据方法的返回值，包名，类名，方法名，方法参数等信息来匹配，语法为：\nexecution(访问修饰符? 返回值 包名.类名.?方法名(方法参数) throws 异常?) 其中带 ? 表示可以省略的部分\n访问修饰符：可省略（public, protected) 包名.类名：可省略 throws异常：可省略（注意时方法上声明抛出的异常，不是实际抛出的异常） 可以使用通配符描述切入点\n*：单个独立的任意符号，可以通配任意返回值，包名，类名，方法名，任意类型的一个参数，也可以统配包，类，方法名的一部分\nexecution(* com.*.service.*.update*(*)) .. : 多个连续的任意符号，可以通配任意层级的包，或任意类型，任意个数的参数\nexecution(* com.showguan..DeptService.*(..)) 根据业务需要， 可以使用 \u0026amp;\u0026amp;， ||， ! 来组合比较复杂的切入点表达式\n书写建议：\n所有业务方法名在命名时尽量规范，方便切入点表达式快速匹配。如：查询类方法都是find开头，更新类方法都是update开头 描述切入点方法通常基于接口描述，而不是直接描述实现类，增强拓展性 在满足业务需要的前提下，尽量缩小切入点的匹配范围，如：包名尽量不使用\u0026hellip;， 使用*匹配单个包名 注解形式 在apo文件夹内新建注解文件 Mylog.java\n@Retention(RetentionPolicy.RUNTIME) //什么时候运行 @Target(ElementType.METHOD) // 运行范围 public @interface MyLog { } Aspect文件配置：\n@Slf4j @Component @Aspect public class MyAspect2 { // @Pointcut(\u0026#34;execution(* com.showguan.service.DeptService.list()) ||\u0026#34; + // \u0026#34;execution(* com.showguan.service.DeptService.delete(java.lang.Integer))\u0026#34; // ) @Pointcut(\u0026#34;@annotation(com.showguan.apo.MyLog)\u0026#34;) private void pt(){} @Before(\u0026#34;pt()\u0026#34;) private void before(){ log.info(\u0026#34;My Aspect6 ... Before ...\u0026#34;); } } 在需要匹配的方法前面加上 @MyLog 注解即可。\n连接点\n在Spring中用JoinPoint抽象了连接点，用它可以后的方法执行时的相关信息，如目标类名，方法名，方法参数等 对于@Around通知，获取连接点信息只能用ProceedingJoinPoing 对于其他四种通知，获取连接点信息只能使用JointPoint， 它是ProceedingPoint的父类型 package com.showguan.apo; import lombok.extern.slf4j.Slf4j; import net.sf.jsqlparser.statement.select.Join; import org.aspectj.lang.JoinPoint; import org.aspectj.lang.ProceedingJoinPoint; import org.aspectj.lang.annotation.Around; import org.aspectj.lang.annotation.Aspect; import org.aspectj.lang.annotation.Before; import org.aspectj.lang.annotation.Pointcut; import org.springframework.stereotype.Component; @Slf4j @Component @Aspect public class MyAspect3 { @Pointcut(\u0026#34;execution(* com.showguan.service.impl.DeptServiceImpl.*(..))\u0026#34;) // private void pt(){} public void pt(){} @Before(\u0026#34;pt()\u0026#34;) public void before(JoinPoint joinPoint){ log.info(\u0026#34;before ...\u0026#34;); } @Around(\u0026#34;pt()\u0026#34;) public Object around(ProceedingJoinPoint JoinPoint) throws Throwable { log.info(\u0026#34;around before\u0026#34;); Object target = JoinPoint.getTarget(); log.info(\u0026#34;目标 对象的类名：{}\u0026#34;, JoinPoint); String name = JoinPoint.getSignature().getName(); log.info(\u0026#34;目标方法的方法名\u0026#34;, name); Object[] args = JoinPoint.getArgs(); log.info(\u0026#34;目标方法运行时传入的参数：{}\u0026#34;, args); Object result = JoinPoint.proceed(); log.info(\u0026#34;目标方法的返回值：{}\u0026#34;, result); log.info(\u0026#34;around after ...\u0026#34;); return result; } } 实践 对员工和部分的增删改部分进行日志记录\n@Slf4j @Component @Aspect public class LogAspect { @Autowired private OperateLogMapper operateLogMapper; @Autowired private HttpServletRequest request; @Around(\u0026#34;@annotation(com.showguan.anno.Log)\u0026#34;) public Object recordLog(ProceedingJoinPoint joinPoint) throws Throwable { String jwt = request.getHeader(\u0026#34;token\u0026#34;); Claims claims = JwtUtils.parseJWT(jwt); Integer operateUser = (Integer) claims.get(\u0026#34;id\u0026#34;); LocalDateTime operateTime = LocalDateTime.now(); String className = joinPoint.getTarget().getClass().getName(); String methodName = joinPoint.getSignature().getName(); Object[] args = joinPoint.getArgs(); String methodParams = Arrays.toString(args); long begin = System.currentTimeMillis(); Object result = joinPoint.proceed(); long end = System.currentTimeMillis(); String returnValue = JSONObject.toJSONString(result); Long costTime = end - begin; OperateLog operateLog = new OperateLog(null, operateUser, operateTime, className, methodName, methodParams, returnValue, costTime); operateLogMapper.insert(operateLog); return result; } } ","permalink":"https://kennems.github.io/posts/tech/java-web%E5%BC%80%E5%8F%916/","summary":"Java Web开发(6) 事务：事务是一组操作的集合，它是一个不可分割的工作单位，这些操作要么同时成功，要么同时失败 start transaction / begin commit rollback Spring事务管理","title":"Java Web开发(6)"},{"content":"LeetCode双周赛132 \u0026amp; 周赛401(240608/09) 3181. 执行操作可获得的最大总奖励 II周赛第四题 题目大意 给定一个整数数组 rewardValues，长度为 n，表示不同位置的奖励值。初始时，总奖励 x 为 0，所有下标都是未标记的。可以执行以下操作任意次：\n从区间 [0, n-1] 中选择一个未标记的下标 i。 如果 rewardValues[i] 大于当前的总奖励 x，则将 rewardValues[i] 加到 x 上，并标记下标 i。 要求返回执行最优操作能够获得的最大总奖励。\n实现思路 使用动态规划的思想解决问题，考虑如何选择操作能使得总奖励最大化。 使用一个状态 f 表示当前可以达到的最大总奖励的二进制表示。初始状态 f = 1 表示可以达到总奖励为 0 的状态。 遍历奖励值 rewardValues 的不同值，对每个值进行处理： 将该奖励值作为新的状态加入到当前状态 f 中。 最终 f 的位长度减去 1 即为可以达到的最大总奖励。 该解法利用了动态规划和位运算的特性，通过状态的更新和转移，实现了对最优操作序列的求解，保证了时间复杂度在合理范围内。\nclass Solution: def maxTotalReward(self, r: List[int]) -\u0026gt; int: f = 1 for v in sorted(set(r)): mask = (1 \u0026lt;\u0026lt; v) - 1 mask = mask \u0026amp; f mask = mask \u0026lt;\u0026lt; v f |= mask return f.bit_length() - 1 3177. 求出最长好子序列 II双周赛第四题 题目大意 给你一个整数数组 nums 和一个非负整数 k。如果一个整数序列 seq 满足在下标范围 [0, seq.length - 2] 中存在不超过 k 个下标 i 使得 seq[i] != seq[i + 1]，那么我们称这个整数序列为 好序列。\n请你返回 nums 中 好子序列 的最长长度。\n实现思路 预处理：将 nums 中的元素离散化，即将每个元素映射到一个新的唯一整数，这样可以简化后续的处理。用 d 字典保存每个元素的离散化后的值。 动态规划：使用二维数组 f 记录当前子序列的最大长度，其中 f[nm][i] 表示以 nm 结尾且有 i 次不连续的最大长度。 另用 mx 记录使用 i 次变换的最大长度，lst 记录该最大长度对应的最后一个元素。 状态转移：遍历 nums 中的每个元素 nm，并更新 f 和 mx、lst。 如果 i \u0026gt; 0，则 f[nm][i] 更新为 f[lst[i-1]][i-1] + 1。 更新 mx[i] 和 lst[i]，保证它们记录当前的最大值和对应元素。 结果：最终的结果为 res，记录所有情况下的最大长度。 class Solution: def maximumLength(self, nums: List[int], k: int) -\u0026gt; int: # 离散化 d = {v: i for i, v in enumerate(set(nums))} if len(d) == 1: return len(nums) n = len(d) nums = [d[x] for x in nums] # 初始化动态规划数组 f = [[0] * (k + 1) for _ in range(n + 1)] mx, lst = [0] * (k + 1), [0] * (k + 1) res = 0 for nm in nums: for i in range(k, -1, -1): f[nm][i] += 1 if i and f[lst[i - 1]][i - 1] + 1 \u0026gt; f[nm][i]: f[nm][i] = f[lst[i - 1]][i - 1] + 1 if f[nm][i] \u0026gt; mx[i]: mx[i] = f[nm][i] lst[i] = nm if f[nm][i] \u0026gt; res: res = f[nm][i] return res ","permalink":"https://kennems.github.io/posts/tech/leetcode%E5%8F%8C%E5%91%A8%E8%B5%9B132--%E5%91%A8%E8%B5%9B40124060809/","summary":"LeetCode双周赛132 \u0026amp; 周赛401(240608/09) 3181. 执行操作可获得的最大总奖励 II周赛第四题 题目大意 给定一个整数数组 reward","title":"LeetCode双周赛132 \u0026 周赛401(240608/09)"},{"content":"Java Web开发(5) MyBatis MyBatis是一款优秀的持久层框架，用于简化JDBC的开发。 使用Mybatis查询所有用户数据\n创建SpringBoot工程， 数据库表user， 实体类User\n引入Mybatis的相关依赖，配置Mybatis\n\u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.mybatis.spring.boot\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;mybatis-spring-boot-starter-test\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;3.0.3\u0026lt;/version\u0026gt; \u0026lt;scope\u0026gt;test\u0026lt;/scope\u0026gt; \u0026lt;/dependency\u0026gt; 编写SQL语句（注解/XML）\n遇到的Bug 在mybatisquickstart 中的MybatisQuickstartApplication.java添加下面这一行\n@MapperScan(\u0026#34;com.showguan.mapper\u0026#34;) // 添加这一行 package com.showguan.mybatisquickstart; import org.mybatis.spring.annotation.MapperScan; import org.springframework.boot.SpringApplication; import org.springframework.boot.autoconfigure.SpringBootApplication; @SpringBootApplication @MapperScan(\u0026#34;com.showguan.mapper\u0026#34;) // 添加这一行 public class MybatisQuickstartApplication { public static void main(String[] args) { SpringApplication.run(MybatisQuickstartApplication.class, args); } } JDBC JDBC：(Java DataBase Connectivity)， 就是使用Java语言操作关系型数据库的一套API。\n本质：\nSun公司官方定义的一套操作所有关系型数据库的规范， 即接口 各个数据库厂商去实现这套接口，提供数据库驱动jar包 我们可以使用这套接口（JDBC）编程， 真正执行的代码是驱动jar包中的实现类 数据库连接池 数据库连接池是一个容器，负责分配，管理数据库连接（Connection） 它允许应用程序重复使用一个现有的数据库连接，而不是再重新建立一个 释放空闲时间超过最大空闲时间的连接，来避免因为没有释放连接而引起的数据库连接遗漏 标准接口：DataSource\n官方提供的数据库连接池接口，由第三方组织实现此接口 功能：获取连接 Druid(德鲁伊)， Hikari\nLombok Lombok是一个实用的Java类库， 能通过注解的形式自动生成构造器，getter/setter, equals, hashcode, toString等方法， 并可以自动化生成日志变量， 简化Java开发， 提高效率。 \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.projectlombok\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;lombok\u0026lt;/artifactId\u0026gt; \u0026lt;/dependency\u0026gt; 注解 作用 @Getter/Setter 为所有的属性提供get/set方法 @ToString 会给类自动生成易阅读的toString方法 @EqualsAndHashCode 根据类所拥有的非静态字段自动重写equals方法和hashCode方法 @Data 提供更综合的生成代码功能（@Getter + @Setter + @ToString + @EqualsAndHashCode） @NoArgsConstructor 为实体类生成无参数的构造器方法 @AllArgsConstructor 为实体类生成除了static修饰的字段之外的带有各参数的构造器方法 Mybatis基础操作 删除和新增操作\nMybatisCrudApplicationTests\n@SpringBootTest class MybatisCrudApplicationTests { @Autowired private EmpMapper empMapper; @Test public void testDelete() { int delete = empMapper.delete(17); System.out.println(delete); } @Test public void testInsert(){ Emp emp = new Emp(152, \u0026#34;Tom1\u0026#34;, \u0026#34;0303\u0026#34;, \u0026#34;Tom\u0026#34;, (short)1, \u0026#34;1.jpg\u0026#34;, (short)1, LocalDate.of(2001, 3, 4), 1, LocalDateTime.now(), LocalDateTime.now()); empMapper.insert(emp); System.out.println(emp.getId()); } } application.properties\nspring.datasource.driver-class-name=com.mysql.cj.jdbc.Driver spring.datasource.url=jdbc:mysql://localhost:3306/mybatis spring.datasource.username=root spring.datasource.password=20230205.ken #配置mybatis的日志, 指定输出到控制台 mybatis.configuration.log-impl=org.apache.ibatis.logging.stdout.StdOutImpl #开启mybatis的驼峰命名自动映射开关 a_column ------\u0026gt; aCloumn mybatis.configuration.map-underscore-to-camel-case=true Emp.java\npackage com.showguan.pojo; import lombok.AllArgsConstructor; import lombok.Data; import lombok.NoArgsConstructor; import java.time.LocalDate; import java.time.LocalDateTime; @Data @NoArgsConstructor @AllArgsConstructor public class Emp { private Integer id; private String username; private String password; private String name; private Short gender; private String image; private Short job; private LocalDate entrydate; private Integer deptId; private LocalDateTime createTime; private LocalDateTime updateTime; } MybatisCrudApplication.java\npackage com.showguan.mybatiscrud; import org.mybatis.spring.annotation.MapperScan; import org.springframework.boot.SpringApplication; import org.springframework.boot.autoconfigure.SpringBootApplication; @SpringBootApplication @MapperScan(\u0026#34;com.showguan.mapper\u0026#34;) // 添加这一行 public class MybatisCrudApplication { public static void main(String[] args) { SpringApplication.run(MybatisCrudApplication.class, args); } } EmpMapper.java(定义为接口)\npackage com.showguan.mapper; import com.showguan.pojo.Emp; import org.apache.ibatis.annotations.*; @Mapper public interface EmpMapper { @Delete(\u0026#34;delete from emp where id = #{id}\u0026#34;) // public void delete(Integer id); public int delete(Integer id); // 定义为int返回值, 获取删除的个数信息 @Insert(\u0026#34;insert into emp(id, username, password, name, gender, image, job, entrydate, dept_id, create_time, update_time)\\n\u0026#34; + \u0026#34; values (#{id}, #{username}, #{password}, #{name}, #{gender}, #{image}, #{job}, #{entrydate}, #{deptId}, #{createTime}, #{updateTime});\u0026#34;) public void insert(Emp emp); } 注意事项\n如果mapper接口方法形参中只有一个普通类型的参数， #{ }里面的属性名可以随便写， 如 ： #{id}, #{xxx} (推荐保持一致) 预编译SQL\n优势：\n性能更高 更安全（放置SQL注入） SQL注入 SQL注入是通过操作输入的数据来修改事先定义好的SQL语句， 以达到执行代码对服务器进行攻击的方法。 面试题 : 参数占位符 #{\u0026hellip;} 执行SQL时， 会将#{\u0026hellip;}替换为?, 生成预编译SQL， 会自动设置参数值 使用时机：参数传递， 都使用{\u0026hellip;} ${\u0026hellip;} 拼接SQL。直接将参数拼接再SQL语句中，存在SQL注入问题 使用时机：如果对表名，列表进行动态设置时使用 数据封装 起别名：在SQL语句中，对不一样的列名起别名，别名和实体类属性名一样 @Select(\u0026#34;select id, username, password, name, gender, image, job, entrydate, dept_id deptId, create_time createTime, update_time updateTime from emp where id = #{id}\u0026#34;) public Emp getById(Integer id); 手动结果映射：通过 @Results 及 @Result 进行手动结果映射 @Select(\u0026#34;select * from emp where id = #{id}\u0026#34;) @Results({ @Result(column = \u0026#34;dept_id\u0026#34;, property = \u0026#34;deptId\u0026#34;), @Result(column = \u0026#34;create_time\u0026#34;, property = \u0026#34;createTime\u0026#34;), @Result(column = \u0026#34;update_time\u0026#34;, property = \u0026#34;updateTime\u0026#34;) }) public Emp getById(Integer id); 开启驼峰命名：如果字段名和属性名称符合驼峰命名规则， mybatis会自动通过驼峰命名规则映射\n#开启mybatis的驼峰命名自动映射开关 a_column ------\u0026gt; aCloumn mybatis.configuration.map-underscore-to-camel-case=true mybatis 查询 @Select(\u0026#34;select * from emp where id = #{id}\u0026#34;) public Emp getById(Integer id); // @Select(\u0026#34;select id, username, password, name, gender, image, job, entrydate, dept_id deptId, create_time createTime, update_time updateTime from emp where id = #{id}\u0026#34;) // public Emp getById(Integer id); // @Select(\u0026#34;select * from emp where id = #{id}\u0026#34;) // @Results({ // @Result(column = \u0026#34;dept_id\u0026#34;, property = \u0026#34;deptId\u0026#34;), // @Result(column = \u0026#34;create_time\u0026#34;, property = \u0026#34;createTime\u0026#34;), // @Result(column = \u0026#34;update_time\u0026#34;, property = \u0026#34;updateTime\u0026#34;) // }) // public Emp getById(Integer id); // 使用${} // @Select(\u0026#34;select *\\n\u0026#34; + // \u0026#34;from emp\\n\u0026#34; + // \u0026#34;where name like \u0026#39;%${name}%\u0026#39;\\n\u0026#34; + // \u0026#34; and gender = #{gender}\\n\u0026#34; + // \u0026#34; and entrydate between #{begin}\\n\u0026#34; + // \u0026#34; and #{end}\\n\u0026#34; + // \u0026#34;order by update_time\u0026#34;) // public List\u0026lt;Emp\u0026gt; list(String name, Short gender, LocalDate begin, LocalDate end); //解决上面的 #{}出现在引号之内 @Select(\u0026#34;select *\\n\u0026#34; + \u0026#34;from emp\\n\u0026#34; + \u0026#34;where name like concat(\u0026#39;%\u0026#39;, #{name}, \u0026#39;%\u0026#39;)\\n\u0026#34; + \u0026#34; and gender = #{gender}\\n\u0026#34; + \u0026#34; and entrydate between #{begin}\\n\u0026#34; + \u0026#34; and #{end}\\n\u0026#34; + \u0026#34;order by update_time\u0026#34;) public List\u0026lt;Emp\u0026gt; list(String name, Short gender, LocalDate begin, LocalDate end); 参数名说明\n在SpringBoot的 1.x 版本中单独使用mybatis XML映射文件 规范\nXML映射文件的名称与Mapper接口名称一致，并且将XML文件和Mapper接口放置在相同包下（同包同名） XML映射文件的 namespace 属性为Mapper接口全限定名一致 XML映射文件SQL语句的id和Mapper接口的方法名一致，并保持返回类型一致。 \u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;UTF-8\u0026#34; ?\u0026gt; \u0026lt;!DOCTYPE mapper PUBLIC \u0026#34;-//mybatis.org//DTD Mapper 3.0//EN\u0026#34; \u0026#34;http://mybatis.org/dtd/mybatis-3-mapper.dtd\u0026#34;\u0026gt; \u0026lt;mapper namespace=\u0026#34;com.showguan.mapper.EmpMapper\u0026#34;\u0026gt; \u0026lt;select id=\u0026#34;list\u0026#34; resultType=\u0026#34;com.showguan.pojo.Emp\u0026#34;\u0026gt; select * from emp where name like concat(\u0026#39;%\u0026#39;, \u0026#39;张\u0026#39;, \u0026#39;%\u0026#39;) and gender = 1 and entrydate between \u0026#39;2000-01-01\u0026#39; and \u0026#39;2030-01-01\u0026#39; order by update_time; \u0026lt;/select\u0026gt; \u0026lt;/mapper\u0026gt; Mybatis动态SQL 查询\u0026lt;if\u0026gt; \u0026lt;where\u0026gt;(可以删除多余的and和or)\n\u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;UTF-8\u0026#34; ?\u0026gt; \u0026lt;!DOCTYPE mapper PUBLIC \u0026#34;-//mybatis.org//DTD Mapper 3.0//EN\u0026#34; \u0026#34;http://mybatis.org/dtd/mybatis-3-mapper.dtd\u0026#34;\u0026gt; \u0026lt;mapper namespace=\u0026#34;com.showguan.mapper.EmpMapper\u0026#34;\u0026gt; \u0026lt;select id=\u0026#34;list\u0026#34; resultType=\u0026#34;com.showguan.pojo.Emp\u0026#34;\u0026gt; select * from emp \u0026lt;where\u0026gt; \u0026lt;if test=\u0026#34;name != null\u0026#34;\u0026gt; name like concat(\u0026#39;%\u0026#39;, \u0026#39;张\u0026#39;, \u0026#39;%\u0026#39;) \u0026lt;/if\u0026gt; \u0026lt;if test=\u0026#34;gender != null\u0026#34;\u0026gt; and gender = 1 \u0026lt;/if\u0026gt; \u0026lt;if test=\u0026#34;begin != null and end != null\u0026#34;\u0026gt; and entrydate between \u0026#39;2000-01-01\u0026#39; and \u0026#39;2030-01-01\u0026#39; \u0026lt;/if\u0026gt; \u0026lt;/where\u0026gt; order by update_time desc; \u0026lt;/select\u0026gt; \u0026lt;/mapper\u0026gt; 更新\u0026lt;set\u0026gt;（可以删除多余的,）\n\u0026lt;update id=\u0026#34;update2\u0026#34;\u0026gt; update emp \u0026lt;set\u0026gt; \u0026lt;if test=\u0026#34;username != null\u0026#34;\u0026gt; username = #{username}, \u0026lt;/if\u0026gt; \u0026lt;if test=\u0026#34;password != null\u0026#34;\u0026gt; password = #{password}, \u0026lt;/if\u0026gt; \u0026lt;if test=\u0026#34;name != null\u0026#34;\u0026gt; name = #{name}, \u0026lt;/if\u0026gt; \u0026lt;if test=\u0026#34;gender != null\u0026#34;\u0026gt; gender = #{gender}, \u0026lt;/if\u0026gt; \u0026lt;if test=\u0026#34;image != null\u0026#34;\u0026gt; image = #{image}, \u0026lt;/if\u0026gt; \u0026lt;if test=\u0026#34;job != null\u0026#34;\u0026gt; job = #{job}, \u0026lt;/if\u0026gt; \u0026lt;if test=\u0026#34;deptId != null\u0026#34;\u0026gt; dept_id = #{deptId}, \u0026lt;/if\u0026gt; \u0026lt;if test=\u0026#34;createTime != null\u0026#34;\u0026gt; create_time = #{createTime}, \u0026lt;/if\u0026gt; \u0026lt;if test=\u0026#34;updateTime != null\u0026#34;\u0026gt; update_time = #{updateTime} \u0026lt;/if\u0026gt; \u0026lt;/set\u0026gt; where id = #{id}; \u0026lt;/update\u0026gt; \u0026lt;foreach\u0026gt;\n\u0026lt;delete id=\u0026#34;deleteByIds\u0026#34;\u0026gt; delete from emp where id in \u0026lt;foreach collection=\u0026#34;ids\u0026#34; item=\u0026#34;id\u0026#34; separator=\u0026#34;,\u0026#34; open=\u0026#34;(\u0026#34; close=\u0026#34;)\u0026#34;\u0026gt; #{id} \u0026lt;/foreach\u0026gt;; \u0026lt;/delete\u0026gt; 开发规范-Restful\nREST(REPresentational State Transfer), 表述性状态转换， 它是一种软件架构风格 注意事项：\nREST是风格， 是约定方式，约定不是规定，可以打破 描述模块的功能通常使用复数， 也就是加s的格式来描述，表示此类资源，而非单个资源。如：users, emps, books, 接口开发流程 明确需求 接口文档 思路分析 接口开发\n接口测试 postman测试 前后端联调\n日志小技巧 使用logback记录日志\n@Slf4j // 接口 @RestController 查询部门 /** * 查询部分数据 * @return */ // @RequestMapping(value = \u0026#34;/depts\u0026#34;, method = RequestMethod.GET) @GetMapping(\u0026#34;/depts\u0026#34;) public Result list(){ log.info(\u0026#34;查询全部\u0026#34;); List\u0026lt;Dept\u0026gt; deptList = deptService.list(); return Result.success(deptList); } 删除部门 /** * 删除部门数据 */ @DeleteMapping(\u0026#34;/depts/{id}\u0026#34;) public Result delete(@PathVariable Integer id){ log.info(\u0026#34;根据id删除部分：{}\u0026#34;, id); deptService.delete(id); return Result.success(); } 员工查询 易错点：\n一定要加@AutoWired\nPostMan请求，从第一页开始，如果是第0则返回的是查询的数量\n@Autowired private EmpMapper empMapper; // @Override // public PageBean page(Integer page, Integer pageSize) { // Long count = empMapper.count(); // // Integer start = (page - 1) * pageSize; // List\u0026lt;Emp\u0026gt; empList = empMapper.page(start, pageSize); // PageBean pageBean = new PageBean(count, empList); // return pageBean; // } @Override public PageBean page(Integer page, Integer pageSize,String name, Short gender,LocalDate begin,LocalDate end) { //1. 设置分页参数 PageHelper.startPage(page,pageSize); //2. 执行查询 List\u0026lt;Emp\u0026gt; empList = empMapper.list(name, gender, begin, end); Page\u0026lt;Emp\u0026gt; p = (Page\u0026lt;Emp\u0026gt;) empList; //3. 封装PageBean对象 PageBean pageBean = new PageBean(p.getTotal(), p.getResult()); return pageBean; } @Override public void delete(List\u0026lt;Integer\u0026gt; ids) { empMapper.delete(ids); } @Override public void save(Emp emp) { emp.setCreateTime(LocalDateTime.now()); emp.setUpdateTime(LocalDateTime.now()); empMapper.insert(emp); } /** * 根据id查询员工 * @param id * @return */ @Override public Emp getById(Integer id) { Emp emp = empMapper.getById(id); return emp; } @Override public void modify(Emp emp) { emp.setUpdateTime(LocalDateTime.now()); empMapper.modify(emp); } PageHelper 分页查询时使用PageHelper\n\u0026lt;!-- PageHelper依赖--\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;com.github.pagehelper\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;pagehelper-spring-boot-starter\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;1.4.7\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; 文件上传 前端：\n必须要一个表单项type=\u0026quot;file\u0026quot; 必须是POST请求 method=\u0026quot;post\u0026quot; 编码格式enctype=\u0026quot;multipart/form-data\u0026quot; \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html lang=\u0026#34;en\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;UTF-8\u0026#34;\u0026gt; \u0026lt;title\u0026gt;上传文件\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;form action=\u0026#34;/upload\u0026#34; method=\u0026#34;post\u0026#34; enctype=\u0026#34;multipart/form-data\u0026#34;\u0026gt; 姓名: \u0026lt;input type=\u0026#34;text\u0026#34; name=\u0026#34;username\u0026#34;\u0026gt;\u0026lt;br\u0026gt; 年龄: \u0026lt;input type=\u0026#34;text\u0026#34; name=\u0026#34;age\u0026#34;\u0026gt;\u0026lt;br\u0026gt; 头像: \u0026lt;input type=\u0026#34;file\u0026#34; name=\u0026#34;image\u0026#34;\u0026gt;\u0026lt;br\u0026gt; \u0026lt;input type=\u0026#34;submit\u0026#34; value=\u0026#34;提交\u0026#34;\u0026gt; \u0026lt;/form\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; 阿里云OSS 阿里云对象存储OSS（Object Storage Service）\n在utils文件夹内编写 AliOSSUtils\npackage com.showguan.utils; import com.aliyun.oss.OSS; import com.aliyun.oss.OSSClientBuilder; import org.springframework.beans.factory.annotation.Value; import org.springframework.stereotype.Component; import org.springframework.web.multipart.MultipartFile; import java.io.*; import java.util.UUID; /** * 阿里云 OSS 工具类 */ @Component public class AliOSSUtils { @Value(\u0026#34;${aiyun.oss.endpoint}\u0026#34;) private String endpoint; @Value(\u0026#34;${aiyun.oss.accessKeyId}\u0026#34;) private String accessKeyId ; @Value(\u0026#34;${aiyun.oss.accessKeySecret}\u0026#34;) private String accessKeySecret; @Value(\u0026#34;${aiyun.oss.bucketName}\u0026#34;) private String bucketName; /** * 实现上传图片到OSS */ public String upload(MultipartFile file) throws IOException { // 获取上传的文件的输入流 InputStream inputStream = file.getInputStream(); // 避免文件覆盖 String originalFilename = file.getOriginalFilename(); String fileName = UUID.randomUUID().toString() + originalFilename.substring(originalFilename.lastIndexOf(\u0026#34;.\u0026#34;)); //上传文件到 OSS OSS ossClient = new OSSClientBuilder().build(endpoint, accessKeyId, accessKeySecret); ossClient.putObject(bucketName, fileName, inputStream); //文件访问路径 String url = endpoint.split(\u0026#34;//\u0026#34;)[0] + \u0026#34;//\u0026#34; + bucketName + \u0026#34;.\u0026#34; + endpoint.split(\u0026#34;//\u0026#34;)[1] + \u0026#34;/\u0026#34; + fileName; // 关闭ossClient ossClient.shutdown(); return url;// 把上传到oss的路径返回 } } 配置文件均配置到properties文件中， 而在AliOSSUtils中用@Value注入\n配置文件 SpringBoot提供了多种属性配置方式\napplication.properties\nserver.port=8080 server.address=127.0.0.1 yml/yaml 简洁，数据为中心\nserver: port: 8080 address: 127.0.0.1 基本语法\n大小写敏感 数值前必须有空格，作为分隔符 使用缩进表示层级关系，缩进时，不允许使用tab键，只能用空格（idea会自动将Tab转换为空格） 空格的数目不重要，只要相同层级的元素左侧对齐即可 # 表示注释， 从这个字符一直到结尾，都会被解释器忽略。 @ConfigurationProperties 在utils中新建文件AliOSSUtilsProperties.java， 编写下面的程序\n@Data @Component @ConfigurationProperties(prefix = \u0026#34;aliyun.oss\u0026#34;) public class AliOSSUtilsProperties { private String endpoint; private String accessKeyId; private String accessKeySecret; private String bucketName; } 在AliOssutils.java中只需要编写下面的程序即可\n@Autowired private AliOSSUtilsProperties aliOSSUtilsProperties; /** * 实现上传图片到OSS */ String endpoint = aliOSSUtilsProperties.getEndpoint(); String accessKeyId = aliOSSUtilsProperties.getAccessKeyId(); String accessKeySecret = aliOSSUtilsProperties.getAccessKeySecret(); String bucketName = aliOSSUtilsProperties.getBucketName(); 和@Value对比\n相同点 都是用来注入外部配置的属性的 不同点 @Value注解只能一个一个的进行外部属性的注入。 @ConfigurationProperties可以批量的将外部的属性配置注入到bean对象的属性中。 统一拦截 会话技术 会话：用户打开浏览器，访问web服务器的资源，会话建立，知道有一方断开连接，会话结束，在一次会话中可以包含多次请求和响应\n会话跟踪：一种维护浏览器状态的方法，服务器需要识别多次请求是否来自于同一浏览器，以便在同一次会话的多次请求间共享数据\n会话跟踪技术方案：\n客户端会话跟踪技术：Cookie 服务端会话跟踪技术：Session 令牌技术 Cookie 优点：\nHTTP协议中支持的技术 缺点：\n移动端APP无法使用Cookie 不安全， 用户可以自己禁用Cookie Cookie不能跨域 跨域区分三个维度：协议，IP/域名，端口 @GetMapping(\u0026#34;/cookie1\u0026#34;) public Result cookie1(HttpServletResponse response){ response.addCookie(new Cookie(\u0026#34;login_username\u0026#34;, \u0026#34;Kennem\u0026#34;)); return Result.success(); } @GetMapping(\u0026#34;/cookie2\u0026#34;) public Result cookie2(HttpServletRequest request){ Cookie[] cookies = request.getCookies(); for(Cookie cookie : cookies){ if(cookie.getName().equals(\u0026#34;login_username\u0026#34;)){ System.out.println(\u0026#34;login_username: \u0026#34; + cookie.getValue()); } } return Result.success(); } Session 优点：\n存储在服务端，安全 服务器集群环境下无法直接使用Session Cookie的缺点 @GetMapping(\u0026#34;/session1\u0026#34;) public Result session1(HttpSession httpSession){ log.info(\u0026#34;HttpSession-s1 {}\u0026#34;, httpSession.hashCode()); httpSession.setAttribute(\u0026#34;loginUser\u0026#34;, \u0026#34;Kennem\u0026#34;); return Result.success(); } @GetMapping(\u0026#34;/session2\u0026#34;) public Result session2(HttpServletRequest request){ HttpSession session = request.getSession(); log.info(\u0026#34;HttpSession-s2 {}\u0026#34;, session.hashCode()); Object loginUser = session.getAttribute(\u0026#34;loginUser\u0026#34;); log.info(\u0026#34;loginUser {}\u0026#34;, loginUser); return Result.success(loginUser); } 令牌技术 优点：\n支持PC端，移动端 解决集群环境下的认证问题 减轻服务端存储压力 缺点：\n需要自己实现 JWT JSON Web Token 定义了一种简洁的，自包含的格式，用于在通信双方以json数据格式安全的传输信息。由于数字签名的存在，这些信息时可靠的。 组成： 第一部分：Header（头），记录令牌类型，签名算法等。例如：{\u0026ldquo;alg\u0026rdquo;:\u0026ldquo;HS256\u0026rdquo;, \u0026ldquo;\u0026rdquo;} 第二部分：Payload（有效载荷），携带一些自定义信息，默认信息等。例如：{‘\u0026ldquo;id\u0026rdquo;:\u0026ldquo;1\u0026rdquo;, \u0026ldquo;username\u0026rdquo;:\u0026ldquo;Tom\u0026rdquo;} 第三部分：Signature（签名），放置Token被篡改，确保安全性。将header，payload, 并加入指定密钥，同过指定签名算法而来。 Base64：是一种基于64个可打印字符（A-Z, a-z, 0-9, + /)来表示二进制数据的编码方式\n场景：登录认证 登录成功后，生成令牌 后续的每个请求，都要携带JWT令牌，系统在每次请求处理之前，先校验灵摆，通过后，再处理。 @Test public void testGenJwt(){ Map\u0026lt;String, Object\u0026gt; claims = new HashMap\u0026lt;\u0026gt;(); claims.put(\u0026#34;id\u0026#34;, 1); claims.put(\u0026#34;name\u0026#34;, 2); claims.put(\u0026#34;company\u0026#34;, \u0026#34;xiaomi\u0026#34;); String jwt = Jwts.builder() .signWith(SignatureAlgorithm.HS256, \u0026#34;Kennem\u0026#34;) .setClaims(claims) .setExpiration(new Date(System.currentTimeMillis())) // 设置有效期为一个小时 .compact(); System.out.println(jwt); } @Test public void parseJwt(){ Claims claims = Jwts.parser() .setSigningKey(\u0026#34;Kennem\u0026#34;) .parseClaimsJws(\u0026#34;eyJhbGciOiJIUzI1NiJ9.eyJuYW1lIjoyLCJjb21wYW55IjoieGlhb21pIiwiaWQiOjEsImV4cCI6MTcxODAwMzMwM30.raK4huIfzd9RY0T3U2a9DGsxHFYLRGYbzTrbqXJabaA\u0026#34;) .getBody(); System.out.println(claims); } 注意事项：\nJWT校验时使用的签名密钥，必须和生成JWT令牌时使用的密钥时配套的。 如果JWT令牌解析校验时报错，则说明JWT令牌被篡改或失效了，令牌非法。 过滤器Filter Filter过滤器，时Java web三大组件（Servlet, Filter, Listener）之一 过滤器可以把对资源的请求拦截下来，从而实现一些特殊的功能 过滤器一般完成一些通用的操作，比如：登录校验、统一编码处理，敏感字符处理等。 //@WebFilter(urlPatterns = \u0026#34;/*\u0026#34;) //@WebFilter(urlPatterns = \u0026#34;/login\u0026#34;) @WebFilter(urlPatterns = \u0026#34;/depts/*\u0026#34;) public class DemoFilter implements Filter { @Override public void init(FilterConfig filterConfig) throws ServletException { System.out.println(\u0026#34;Init!\u0026#34;); } @Override public void doFilter(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain chain) throws IOException, ServletException { System.out.println(\u0026#34;Do Fileter!\u0026#34;); chain.doFilter(servletRequest, servletResponse); } @Override public void destroy() { System.out.println(\u0026#34;Destroy!\u0026#34;); } } 执行流程：\n请求 -\u0026gt; 放行前逻辑 -\u0026gt;放行 -\u0026gt;资源 -\u0026gt;放行后逻辑 过滤器链 一个Web应用中，可以配置多个过滤器，这多个过滤器形成一个过滤器链\n顺序：注解配置的Filter，优先级时按照过滤器类名（字符串）的自然排序(字典序)\n登录校验 @Slf4j @WebFilter(urlPatterns = \u0026#34;/*\u0026#34;) public class LoginCheckFilter implements Filter { @Override public void doFilter(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain filterChain) throws IOException, ServletException { HttpServletRequest req = (HttpServletRequest) servletRequest; HttpServletResponse resp = (HttpServletResponse) servletResponse; String url = req.getRequestURI().toString(); log.info(\u0026#34;请求的url {}\u0026#34;, url); if(url.contains(\u0026#34;login\u0026#34;)){ log.info(\u0026#34;登录操作， 放行...\u0026#34;); filterChain.doFilter(servletRequest, servletResponse); return; } String jwt = req.getHeader(\u0026#34;token\u0026#34;); if(!StringUtils.hasLength(jwt)){ log.info(\u0026#34;请求头token为空， 返回未登录的信息\u0026#34;); Result error = Result.error(\u0026#34;NOT_LOGIN\u0026#34;); String notLogin = JSONObject.toJSONString(error); resp.getWriter().write(notLogin); return ; } try{ JwtUtils.parseJWT(jwt); }catch (Exception e){ e.printStackTrace(); log.info(\u0026#34;解析令牌失败，返回未登录错误信息\u0026#34;); Result error = Result.error(\u0026#34;NOT_LOGIN\u0026#34;); // 前端收到NOT_LOGIN 会返回到登录界面 String notLogin = JSONObject.toJSONString(error); resp.getWriter().write(notLogin); return ; } log.info(\u0026#34;成功登录\u0026#34;); filterChain.doFilter(servletRequest, servletResponse); } } 拦截器 Interceptor Spring 提供的， 只能拦截Spring环境中的资源\n用来动态拦截控制器方法的执行\n拦截请求，再指定的方法调用前后，根据业务需要执行预先设定的代码 /* 表示一级路径\n/** 表示任意级别的路径\n配置需要拦截的路径和不需要拦截的路径\n@Override public void addInterceptors(InterceptorRegistry registry) { registry.addInterceptor(loginCheckinterceptor).addPathPatterns(\u0026#34;/**\u0026#34;).excludePathPatterns(\u0026#34;/login\u0026#34;); } Filter 和 Interceptor\n接口规范不同：过滤器需要实现Filter接口，而拦截器需要实现HandlerInterceptor接口 拦截范围不同：过滤器Filter会拦截所有的资源，而Interceptor只会拦截Spring环境中的资源。 @Override // 目标资源方法运行前运行， true:放行 false:不放行 public boolean preHandle(HttpServletRequest req, HttpServletResponse resp, Object handler) throws Exception { String url = req.getRequestURI().toString(); log.info(\u0026#34;请求的url {}\u0026#34;, url); if(url.contains(\u0026#34;login\u0026#34;)){ log.info(\u0026#34;登录操作， 放行...\u0026#34;); return true; } String jwt = req.getHeader(\u0026#34;token\u0026#34;); if(!StringUtils.hasLength(jwt)){ log.info(\u0026#34;请求头token为空， 返回未登录的信息\u0026#34;); Result error = Result.error(\u0026#34;NOT_LOGIN\u0026#34;); String notLogin = JSONObject.toJSONString(error); resp.getWriter().write(notLogin); return false; } try{ JwtUtils.parseJWT(jwt); }catch (Exception e){ e.printStackTrace(); log.info(\u0026#34;解析令牌失败，返回未登录错误信息\u0026#34;); Result error = Result.error(\u0026#34;NOT_LOGIN\u0026#34;); // 前端收到NOT_LOGIN 会返回到登录界面 String notLogin = JSONObject.toJSONString(error); resp.getWriter().write(notLogin); return false; } log.info(\u0026#34;成功登录\u0026#34;); return true; } @Override // 目标资源方法运行后运行 public void postHandle(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView) throws Exception { System.out.println(\u0026#34;postHandle ...\u0026#34;); } @Override // 视图渲染完毕后运行，最后运行 public void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex) throws Exception { System.out.println(\u0026#34;afterCompletion ...\u0026#34;); } 异常处理 全局异常处理器\nexception/GlobalExceptionHandler\n/** * 全局异常处理器 */ @RestControllerAdvice public class GlobalExceptionHandler{ @ExceptionHandler(Exception.class) public Result ex(Exception ex){ ex.printStackTrace(); return Result.error(\u0026#34;操作错误！可能的原因：名称重复\u0026#34;); } } ","permalink":"https://kennems.github.io/posts/tech/java-web%E5%BC%80%E5%8F%915/","summary":"Java Web开发(5) MyBatis MyBatis是一款优秀的持久层框架，用于简化JDBC的开发。 使用Mybatis查询所有用户数据 创建SpringBoot","title":"Java Web开发(5)"},{"content":"双周赛131(240525) AK的第二场😝， 第四题是用C++ 找网上模板，套用查找最长的连0串过的， 最后两分钟才过，很惊险。赛后发现做法并不优秀，但是不需要平衡树。\n3161. 物块放置查询 题目大意：\n有一条无限长的数轴，原点在 0 处，沿着 x 轴正方向无限延伸。给定一个二维数组 queries 包含两种操作：\n操作类型 1：在距离原点 x 处建一个障碍物。 操作类型 2：判断在数轴范围 [0, x] 内是否可以放置一个长度为 sz 的物块，该物块需要完全放置在范围 [0, x] 内。如果物块与任何障碍物有重合，则该物块不能被放置，但物块可以与障碍物刚好接触。 对于操作类型 2 的查询，若可以放置物块，则返回 true，否则返回 false。\n实现思路：\n线段树的构建和维护：\n使用一个数组 tr 来表示线段树，初始化为全零。数组的长度可以通过查询中的最大范围确定，即 m = max(q[1] for q in queries)。 定义 pushup 函数用于更新线段树中的节点信息，每当修改线段树中某个节点的值时调用。 定义 modify 函数用于修改线段树中的值，将某个位置的值更新为新值，并根据需要递归更新父节点的信息。 定义 query 函数用于查询线段树中某个区间内的最大值。 Sorted List 的维护：\n使用 SortedList 结构来维护障碍物的位置信息，SortedSet 是一个有序的集合数据结构。 在操作类型 1 中，即添加障碍物时，使用 bisect_left 找到应该插入的位置，并在相应的位置插入新的障碍物位置，并更新线段树的信息。 查询操作类型 2：\n对于每一个操作类型 2 的查询，先找到该位置之前最近的障碍物的位置 pre，然后通过线段树查询该区间内的最大值。 如果该值大于等于所需放置物块的大小，则说明可以放置物块，否则不行。 from sortedcontainers import SortedList class Solution: def getResults(self, queries: List[List[int]]) -\u0026gt; List[bool]: m = max(q[1] for q in queries) tr = [0]*(1\u0026lt;\u0026lt;m.bit_length() + 1) def pushup(u): tr[u] = max(tr[u\u0026lt;\u0026lt;1], tr[u\u0026lt;\u0026lt;1|1]) def modify(u, l, r, x, val): if l==r: tr[u] = val else: mid = l+r\u0026gt;\u0026gt;1 if x\u0026lt;=mid: modify(u\u0026lt;\u0026lt;1, l, mid, x, val) else: modify(u\u0026lt;\u0026lt;1|1, mid+1, r, x, val) pushup(u) def query(u, l, r, ql, qr): if ql\u0026lt;=l and r\u0026lt;=qr: return tr[u] mid = l+r\u0026gt;\u0026gt;1 res = 0 if ql\u0026lt;=mid: res = query(u\u0026lt;\u0026lt;1, l, mid, ql, qr) if qr\u0026gt;mid: res = max(res, query(u\u0026lt;\u0026lt;1|1, mid+1, r, ql, qr)) return res sl = SortedList([0, m]) res = [] for q in queries: x = q[1] i = sl.bisect_left(x) pre = sl[i-1] if q[0]==1: nxt = sl[i] sl.add(x) modify(1, 0, m, x, x-pre) modify(1, 0, m, nxt, nxt-x) else: sz = q[2] ans = max(x-pre, query(1, 0, m, 0, pre)) res.append(ans \u0026gt;= sz) return res 比赛时的做法，本来是C++，转成了python\nclass Node: def __init__(self): self.l = 0 self.r = 0 self.d = 0 self.ld = 0 self.rd = 0 self.low = -1 class Solution: def getResults(self, queries): def build(u, l, r): tr[u].l = l tr[u].r = r tr[u].d = r - l + 1 tr[u].ld = r - l + 1 tr[u].rd = r - l + 1 tr[u].low = -1 if l != r: mid = (l + r) \u0026gt;\u0026gt; 1 build(u \u0026lt;\u0026lt; 1, l, mid) build(u \u0026lt;\u0026lt; 1 | 1, mid + 1, r) def pushup(u): tr[u].ld = tr[u \u0026lt;\u0026lt; 1].ld if tr[u \u0026lt;\u0026lt; 1].ld == tr[u \u0026lt;\u0026lt; 1].r - tr[u \u0026lt;\u0026lt; 1].l + 1: tr[u].ld += tr[u \u0026lt;\u0026lt; 1 | 1].ld tr[u].rd = tr[u \u0026lt;\u0026lt; 1 | 1].rd if tr[u \u0026lt;\u0026lt; 1 | 1].rd == tr[u \u0026lt;\u0026lt; 1 | 1].r - tr[u \u0026lt;\u0026lt; 1 | 1].l + 1: tr[u].rd += tr[u \u0026lt;\u0026lt; 1].rd tr[u].d = max(max(tr[u \u0026lt;\u0026lt; 1].d, tr[u \u0026lt;\u0026lt; 1 | 1].d), tr[u \u0026lt;\u0026lt; 1].rd + tr[u \u0026lt;\u0026lt; 1 | 1].ld) def pushdown(u): if tr[u].low == -1: return tr[u \u0026lt;\u0026lt; 1].low = tr[u \u0026lt;\u0026lt; 1 | 1].low = tr[u].low if tr[u].low: tr[u \u0026lt;\u0026lt; 1].d = tr[u \u0026lt;\u0026lt; 1].ld = tr[u \u0026lt;\u0026lt; 1].rd = 0 tr[u \u0026lt;\u0026lt; 1 | 1].d = tr[u \u0026lt;\u0026lt; 1 | 1].ld = tr[u \u0026lt;\u0026lt; 1 | 1].rd = 0 else: tr[u \u0026lt;\u0026lt; 1].d = tr[u \u0026lt;\u0026lt; 1].ld = tr[u \u0026lt;\u0026lt; 1].rd = tr[u \u0026lt;\u0026lt; 1].r - tr[u \u0026lt;\u0026lt; 1].l + 1 tr[u \u0026lt;\u0026lt; 1 | 1].d = tr[u \u0026lt;\u0026lt; 1 | 1].ld = tr[u \u0026lt;\u0026lt; 1 | 1].rd = tr[u \u0026lt;\u0026lt; 1 | 1].r - tr[u \u0026lt;\u0026lt; 1 | 1].l + 1 tr[u].low = -1 def query(u, ql, qr): if tr[u].l \u0026gt; qr or tr[u].r \u0026lt; ql: return 0 if tr[u].l \u0026gt;= ql and tr[u].r \u0026lt;= qr: return tr[u].d pushdown(u) mid = (tr[u].l + tr[u].r) \u0026gt;\u0026gt; 1 res = 0 if ql \u0026lt;= mid: res = max(res, query(u \u0026lt;\u0026lt; 1, ql, qr)) if qr \u0026gt; mid: res = max(res, query(u \u0026lt;\u0026lt; 1 | 1, ql, qr)) # Cross left and right subintervals handling if ql \u0026lt;= mid and qr \u0026gt; mid: left_suffix = min(tr[u \u0026lt;\u0026lt; 1].rd, mid - ql + 1) right_prefix = min(tr[u \u0026lt;\u0026lt; 1 | 1].ld, qr - mid) res = max(res, left_suffix + right_prefix) return res def modify(u, l, r, d): if tr[u].l \u0026gt;= l and tr[u].r \u0026lt;= r: if d: tr[u].d = tr[u].ld = tr[u].rd = 0 tr[u].low = 1 else: tr[u].d = tr[u].ld = tr[u].rd = tr[u].r - tr[u].l + 1 tr[u].low = 0 return pushdown(u) mid = (tr[u].l + tr[u].r) \u0026gt;\u0026gt; 1 if l \u0026lt;= mid: modify(u \u0026lt;\u0026lt; 1, l, r, d) if r \u0026gt; mid: modify(u \u0026lt;\u0026lt; 1 | 1, l, r, d) pushup(u) n = max(q[1] for q in queries) tr = [Node() for _ in range(1\u0026lt;\u0026lt;n.bit_length() + 1)] build(1, 0, n) res = [] modify(1, 0, 0, 1) mp = {} for q in queries: if q[0] == 1: x = q[1] modify(1, x, x, 1) mp[x] = 1 else: x = q[1] sz = q[2] if x \u0026lt; sz: res.append(False) continue if mp.get(x) != 1: modify(1, x, x, 1) ans = query(1, 0, x) if mp.get(x) != 1: modify(1, x, x, 0) res.append(ans \u0026gt;= sz-1) return res ","permalink":"https://kennems.github.io/posts/tech/%E5%8F%8C%E5%91%A8%E8%B5%9B131240525/","summary":"双周赛131(240525) AK的第二场😝， 第四题是用C++ 找网上模板，套用查找最长的连0串过的， 最后两分钟才过，很惊险。赛后发现做法并不优","title":"LeetCode双周赛131(240525)"},{"content":"周赛399(240526) 这场掉分了，第四题没思路，而且罚时太多了😥\n第三题3164. 优质数对的总数 II 题目大意： 给定两个整数数组nums1和nums2，以及一个正整数k。如果nums1[i]可以被nums2[j]*k整除，则称数对(i, j)为优质数对。要求计算优质数对的总数。\n实现思路：\n首先，使用Counter统计nums1中可以被k整除的数除以k的结果，得到c1。 然后，找到c1中的最大值mx，如果c1为空，则mx为0。 使用Counter统计nums2中各个数出现的次数，得到c2。 初始化结果res为0。 遍历c2中的每个数nm和其出现的次数c，对于每个数nm，从nm开始递增到mx，步长为nm，计算c * c1[j]并累加到res中。 最终返回res作为优质数对的总数。 class Solution: def numberOfPairs(self, nums1: List[int], nums2: List[int], k: int) -\u0026gt; int: c1 = Counter(nm//k for nm in nums1 if nm%k==0) mx = max(nm for nm, _ in c1.items()) if c1 else 0 c2 = Counter(nums2) res = 0 for nm, c in c2.items(): for j in range(nm, mx+1, nm): res += c * c1[j] return res 第四题3165. 不包含相邻元素的子序列的最大和 题目大意 给定一个整数数组 nums 和一个二维数组 queries，其中 queries[i] = [posi, xi] 表示对于每个查询 i，首先将 nums[posi] 设置为 xi，然后计算查询 i 的答案。答案为 nums 中不包含相邻元素的子序列的最大和。最终返回所有查询的答案之和。\n实现思路 构建线段树：使用线段树维护区间的最大和。 线段树节点 tr[u] 存储了四个值，分别表示： 不跨越区间的最大和（无相邻元素）。 区间左端点为起点的最大和（无相邻元素）。 区间右端点为起点的最大和（无相邻元素）。 区间的最大和。 定义 pushup 函数更新节点值，定义 build 函数构建线段树。 更新操作：更新线段树中的节点值。 定义 update 函数更新线段树中的节点值。 遍历查询：对每个查询，更新 nums 中对应位置的值，并计算当前的最大和。 最终返回所有查询的答案之和，记得对结果取模。 class Solution: def maximumSumSubsequence(self, nums: List[int], queries: List[List[int]]) -\u0026gt; int: def pushup(u): l, r = tr[u\u0026lt;\u0026lt;1], tr[u\u0026lt;\u0026lt;1|1] tr[u][0] = max(l[1]+r[0], l[0]+r[2]) tr[u][1] = max(l[0]+r[3], l[1]+r[1]) tr[u][2] = max(l[2]+r[2], l[3]+r[0]) tr[u][3] = max(l[2]+r[3], l[3]+r[1]) def build(u, l, r): if l==r: tr[u][3] = max(nums[l], 0) else: mid = l+r\u0026gt;\u0026gt;1 build(u\u0026lt;\u0026lt;1, l, mid) build(u\u0026lt;\u0026lt;1|1, mid+1, r) pushup(u) def update(u, l, r, x, val): if l==r: tr[u][3] = max(0, val) return mid = l+r\u0026gt;\u0026gt;1 if x\u0026lt;=mid: update(u\u0026lt;\u0026lt;1, l, mid, x, val) else: update(u\u0026lt;\u0026lt;1|1, mid+1, r, x, val) pushup(u) n = len(nums) tr = [[0]*4 for _ in range(1\u0026lt;\u0026lt;n.bit_length() + 1)] mod = int(1e9) + 7 res = 0 build(1, 0, n-1) for pos, x in queries: update(1, 0, n-1, pos, x) res = (res + tr[1][3])%mod return res ","permalink":"https://kennems.github.io/posts/tech/%E5%91%A8%E8%B5%9B399240526/","summary":"周赛399(240526) 这场掉分了，第四题没思路，而且罚时太多了😥 第三题3164. 优质数对的总数 II 题目大意： 给定两个整数数组nums1和n","title":"LeetCode周赛399(240526)"},{"content":"Python库 程序易错点 ：\n变量未声明 i,j,k变量写错了 变量名一定要看清楚 函数体内变量和外部变量分不清，变量名相近的一定要看清楚 11+12+16+15+12+12 = 78\n七夕祭 题目大意： TYVJ 七夕祭的会场是一个 N 行 M 列的矩形，共有 N×M 个摊点。Vani 邀请 cl 同学来参加，但 cl 只对其中的一部分摊点感兴趣。Vani 希望能够通过调整摊点的布置，使得每行和每列中 cl 感兴趣的摊点数相等。现在需要判断是否能满足这两个要求，并计算最少需要交换的摊点数。\n实现思路：\n定义函数 get(a, n)，用于计算数组 a 中使得每个元素都等于其中位数所需的最少操作次数。该函数首先计算数组 a 的均值，然后计算数组中每个元素与均值的差值，取差值的中位数作为目标中位数。接着计算每个元素与目标中位数的差值的绝对值之和，即为最少操作次数。 解析输入，统计每行和每列中 cl 感兴趣的摊点数，并保存在数组 r 和 c 中。 根据 cl 感兴趣的摊点数是否能被行数和列数整除，分情况讨论： 如果不能同时整除行数和列数，则输出 \u0026ldquo;impossible\u0026rdquo;。 如果能同时整除行数和列数，即 t % n == 0 且 t % m == 0，则说明可以通过调整摊点使得每行和每列中 cl 感兴趣的摊点数相等。输出 \u0026ldquo;both\u0026rdquo;，并调用 get 函数计算最少交换次数。 如果只能整除行数或者列数，而不能同时整除，则说明只能使每行或者每列中 cl 感兴趣的摊点数相等。分别输出 \u0026ldquo;row\u0026rdquo; 或者 \u0026ldquo;column\u0026rdquo;，并调用 get 函数计算最少交换次数。 $p[i] : i给i+1 \\enspace p[i]个糖果$ $则 ans = \\sum_{i=1}^n|p[i]| $ $\tp[1]=a[1]-avg $ $递推 \\enspace p[2]=p[1]+a[2]-avg $ $p[3]=p[2]+a[3]-avg = p[1]+a[2]-avg+a[3]-avg $ $p[4]=p[3]+a[4]-avg = p[2]+p[3]-avg+a[4]-avg = p[1]+a[2]-avg+a[3]-avg+a[4]-avg $ $=\\sum_{i=2}^4{(a[i]-avg)} - p[1] $\nfrom collections import defaultdict r = defaultdict(int) c = defaultdict(int) s = defaultdict(int) def get_ans(a, n): ans = 0 avg = sum(a.values()) // n for i in a: a[i] -= avg s[1] = 0 prev_sum = 0 sorted_values = sorted(a.values()) mid = sorted_values[n // 2] for i in range(2, n + 1): prev_sum += a[i] s[i] = prev_sum for i in s.values(): ans += abs(i - mid) return ans n, m, t = map(int, input().split()) for _ in range(t): x, y = map(int, input().split()) r[x] += 1 c[y] += 1 if t % n != 0 and t % m != 0: print(\u0026#34;impossible\u0026#34;) elif t % n == 0 and t % m == 0: print(\u0026#34;both\u0026#34;, get_ans(r, n) + get_ans(c, m)) elif t % n == 0: print(\u0026#34;row\u0026#34;, get_ans(r, n)) else: print(\u0026#34;column\u0026#34;, get_ans(c, m)) 线段树 #include \u0026lt;iostream\u0026gt; #include \u0026lt;vector\u0026gt; #include \u0026lt;cmath\u0026gt; using namespace std; const int mod = 998244353; vector\u0026lt;int\u0026gt; tr; void pushup(int u) { tr[u] = (1LL * tr[u\u0026lt;\u0026lt;1] * tr[u\u0026lt;\u0026lt;1|1]) % mod; } void build(int u, int l, int r, vector\u0026lt;int\u0026gt;\u0026amp; a) { if (l == r) { tr[u] = a[l]; return; } int mid = (l + r) \u0026gt;\u0026gt; 1; build(u\u0026lt;\u0026lt;1, l, mid, a); build(u\u0026lt;\u0026lt;1|1, mid+1, r, a); pushup(u); } void modify(int u, int l, int r, int x, int v) { if (l == r) { tr[u] = v; return; } int mid = (l + r) \u0026gt;\u0026gt; 1; if (x \u0026lt;= mid) { modify(u\u0026lt;\u0026lt;1, l, mid, x, v); } else { modify(u\u0026lt;\u0026lt;1|1, mid+1, r, x, v); } pushup(u); } int query(int u, int l, int r, int ql, int qr) { if (ql \u0026lt;= l \u0026amp;\u0026amp; r \u0026lt;= qr) { return tr[u]; } int mid = (l + r) \u0026gt;\u0026gt; 1; int res = 1; if (ql \u0026lt;= mid) { res = 1LL * res * query(u\u0026lt;\u0026lt;1, l, mid, ql, qr) % mod; } if (qr \u0026gt; mid) { res = 1LL * res * query(u\u0026lt;\u0026lt;1|1, mid+1, r, ql, qr) % mod; } return res; } int main() { ios::sync_with_stdio(false); cin.tie(0); cout.tie(0); int n, m; cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; m; tr.resize(1 \u0026lt;\u0026lt; (int)ceil(log2(n)) + 1); vector\u0026lt;int\u0026gt; a(n + 1); for (int i = 1; i \u0026lt;= n; ++i) { cin \u0026gt;\u0026gt; a[i]; } build(1, 1, n, a); for (int i = 0; i \u0026lt; m; ++i) { int op; cin \u0026gt;\u0026gt; op; if (op == 1) { int l, r, x; cin \u0026gt;\u0026gt; l \u0026gt;\u0026gt; r \u0026gt;\u0026gt; x; for (int pos = l; pos \u0026lt;= r; ++pos) { if (a[pos] \u0026lt;= x) { modify(1, 1, n, pos, x); a[pos] = x; } } } else { int l, r; cin \u0026gt;\u0026gt; l \u0026gt;\u0026gt; r; cout \u0026lt;\u0026lt; query(1, 1, n, l, r) \u0026lt;\u0026lt; endl; } } return 0; } from sys import stdin input = lambda:stdin.readline().strip() def pushup(u): tr[u] = tr[u\u0026lt;\u0026lt;1] * tr[u\u0026lt;\u0026lt;1|1] % mod def build(u, l, r): if l==r: tr[u] = a[l] return mid = l+r\u0026gt;\u0026gt;1 build(u\u0026lt;\u0026lt;1, l, mid) build(u\u0026lt;\u0026lt;1|1, mid+1, r) pushup(u) def modify(u, l, r, x, v): if l==r: tr[u] = v return mid = l+r\u0026gt;\u0026gt;1 if x\u0026lt;=mid: modify(u\u0026lt;\u0026lt;1, l, mid, x, v) else: modify(u\u0026lt;\u0026lt;1|1, mid+1, r, x, v) pushup(u) def query(u, l, r, ql, qr): if ql\u0026lt;=l and r\u0026lt;=qr: return tr[u]%mod mid = l+r\u0026gt;\u0026gt;1 res = 1 if ql\u0026lt;=mid: res = res*query(u\u0026lt;\u0026lt;1, l, mid, ql, qr)%mod if qr\u0026gt;mid: res = res*query(u\u0026lt;\u0026lt;1|1, mid+1, r, ql, qr)%mod return res n, m = map(int, input().split()) tr = [1]*(1\u0026lt;\u0026lt;n.bit_length() + 1) a = [0] + list(map(int, input().split())) mod = 998244353 build(1, 1, n) for i in range(m): q = list(map(int, input().split())) if q[0]==1: _, l, r, x = q for pos in range(l, r+1): if a[i]\u0026lt;=x: modify(1, 1, n, pos, x) a[i] = x else: _, l, r = q print(query(1, 1, n, l, r)) 题目 日期差值 mm = [0, 31, 28, 31, 30, 31, 30, 31, 31, 30,31, 30, 31] def day(x): y = int(x/10000) m = int((x/100)%100) d = x%100 mm[2]=29 if (y%4==0 and y%100!=0) or y%400==0 else 28 for i in range(1, m): d+=mm[i] for i in range(1, y): d+=366 if (i%4==0 and i%100!=0) or i%400==0 else 365 return d while True: try: x=int(input()) y=int(input()) print( abs(day(x)-day(y))+1 ) except: break 特殊排序 # Forward declaration of compare API. # def compare(a, b): # @param a, b int # @return bool # return bool means whether a is less than b. class Solution(object): def specialSort(self, N): \u0026#34;\u0026#34;\u0026#34; :type N: int :rtype: List[int] \u0026#34;\u0026#34;\u0026#34; a = [1] for i in range(2, N+1): l, r = 0, len(a)-1 while l\u0026lt;r: mid = (l+r)\u0026gt;\u0026gt;1 if compare(i, a[mid]): r=mid else: l=mid+1 a[r+1:]=a[r:] a[r]=i if compare(a[r+1],a[r]): a[r], a[r+1] = a[r+1], a[r] return a 线段树 # 定义树节点，l,r, val表示该节点记录的是区间[l, r]的最大值是val class Tree(): def __init__(self): self.l = 0 self.r = 0 self.lazy = 0 self.val = 0 # 二叉树是堆形式，可以用一维数组存储，注意数组长度要开4倍空间 tree = [Tree() for i in range(10*4)] # 建树，用cur\u0026lt;\u0026lt;1访问左子树，cur\u0026lt;\u0026lt;1|1访问右子树，位运算操作很方便 def build(cur, l, r): tree[cur].l, tree[cur].r, tree[cur].lazy, tree[cur].val = l, r, 0, 0 # 当l==r的时候结束递归 if l \u0026lt; r: mid = l + r \u0026gt;\u0026gt; 1 build(cur\u0026lt;\u0026lt;1, l, mid) build(cur\u0026lt;\u0026lt;1|1, mid+1, r) # 当子节点计算完成后，用子节点的值来更新自己的值 def pushup(cur): tree[cur].val = max(tree[cur\u0026lt;\u0026lt;1].val, tree[cur\u0026lt;\u0026lt;1|1].val) # 单点更新 def add(cur, x, v): if tree[cur].l == tree[cur].r: tree[cur].val += v else: mid = tree[cur].r + tree[cur].l \u0026gt;\u0026gt; 1 if x \u0026gt; mid: add(cur\u0026gt;\u0026gt;1|1, x, v) else: add(cur\u0026lt;\u0026lt;1, x, v) pushup(cur) # 将lazy标记向下传递一层 def pushdown(cur): if tree[cur].lazy: lazy = tree[cur].lazy tree[cur\u0026lt;\u0026lt;1].lazy += lazy tree[cur\u0026lt;\u0026lt;1|1].lazy += lazy tree[cur\u0026lt;\u0026lt;1].val += lazy tree[cur\u0026lt;\u0026lt;1|1].val += lazy tree[cur].lazy = 0 # 区间更新 def update(cur, l, r, v): if l \u0026lt;= tree[cur].l and tree[cur].r \u0026lt;= r: tree[cur].lazy += v tree[cur].val += v return if r \u0026lt; tree[cur].l or l \u0026gt; tree[cur].r: return if tree[cur].lazy: pushdown(cur) update(cur\u0026lt;\u0026lt;1, l, r, v) update(cur\u0026lt;\u0026lt;1|1, l, r, v) pushup(cur) # 区间查询 def query(cur, l, r): if l \u0026lt;= tree[cur].l and tree[cur].r \u0026lt;= r: return tree[cur].val if tree[cur].l \u0026gt; r or tree[cur].r \u0026lt; l: return 0 if tree[cur].lazy: pushdown(cur) return max(query(cur\u0026lt;\u0026lt;1, l, r), query(cur\u0026lt;\u0026lt;1|1)) # 测试 # ----- # --- # ------- # -- # -- build(1, 1, 10) update(1, 1, 5, 1) update(1, 7, 10, 1) update(1, 2, 8, 1) update(1, 3, 4, 1) update(1, 9, 10, 1) print(query(1, 1, 10)) def pushup(u): tr[u] = tr[u \u0026lt;\u0026lt; 1] + tr[u \u0026lt;\u0026lt; 1 | 1] def build(u, l, r): if l == r: tr[u] = 0 else: mid = (l + r) \u0026gt;\u0026gt; 1 build(u \u0026lt;\u0026lt; 1, l, mid) build(u \u0026lt;\u0026lt; 1 | 1, mid + 1, r) pushup(u) def query(u, l, r, ql, qr): if l \u0026gt;= ql and r \u0026lt;= qr: return tr[u] mid = (l + r) \u0026gt;\u0026gt; 1 if mid==l and mid==r: return 0 res = 0 if ql \u0026lt;= mid: res = query(u \u0026lt;\u0026lt; 1, l, mid, ql, qr) if qr \u0026gt; mid: res += query(u \u0026lt;\u0026lt; 1 | 1, mid + 1, r, ql, qr) return res def modify(u, x, l, r, val): if l == r: tr[u] += val else: mid = (l + r) \u0026gt;\u0026gt; 1 if x \u0026lt;= mid: modify(u \u0026lt;\u0026lt; 1, x, l, mid, val) else: modify(u \u0026lt;\u0026lt; 1 | 1, x, mid + 1, r, val) pushup(u) Python特点 IDLE 使用 设置字体，行号，和使用docs\n快捷键：\n快捷键 功能 可用窗口 F1 打开 Python 帮助文档 Python 文件窗口和 Shell Alt+P 浏览历史命令（上一条） 仅 Python Shell 窗口 Alt+N 浏览历史命令（下一条） 仅 Python Shell 窗口 Alt+/ 自动补全前面曾经出现过的单词，如果之前有多个单词具有相同前缀，可以连续按下该快捷键，在多个单词中间循环选择 Python 文件窗口和 Shell Alt+3 注释代码块 仅 Python 文件窗口 Alt+4 取消代码块注释 仅 Python 文件窗口 Alt+g 转到某一行 仅 Python 文件窗口 Ctrl+Z 撤销一步操作 Python 文件窗口和 Shell Ctrl+Shift+Z 恢复上—次的撤销操作 Python 文件窗口和 Shell Ctrl+S 保存文件 Python 文件窗口和 Shell Ctrl+] 缩进代码块 仅 Python 文件窗口 Ctrl+[ 取消代码块缩进 仅 Python 文件窗口 Ctrl+F6 重新启动 Python Shell 仅 Python Shell 窗口 输入输出 输出列表：\nprint(*a) # 输出列表中的所有数，用空格分隔 print(*a, sep=\u0026#34;\\n\u0026#34;) #每个数单独放一行 *运算符 解包运算符： 当*运算符用于可迭代对象（如列表、元组、集合等）前面时，它可以将可迭代对象解包为多个元素。例如：\na = [1, 2, 3] print(*a) # 解包并打印出每个元素：1 2 3 可变参数： 当*运算符用于函数定义时，它表示接受任意数量的参数，并将它们作为元组传递给函数。这种用法通常称为可变参数。例如：\ndef my_func(*args): for arg in args: print(arg) my_func(1, 2, 3) # 打印出每个参数：1 2 3 扩展运算符： 当*运算符用于可迭代对象前面时，它可以将可迭代对象的元素扩展到另一个可迭代对象中。这种用法通常称为扩展运算符。例如：\na = [1, 2, 3] b = [4, 5, 6 c = [*a, *b] # 扩展a和b的元素到c中 print(c) # 输出：[1, 2, 3, 4, 5, 6] 乘法运算符： 当*运算符用于数字和可迭代对象之间时，它表示重复该可迭代对象的元素。例如：\na = [1, 2, 3] b = a * 3 # 重复a的元素3次 print(b) # 输出：[1, 2, 3, 1, 2, 3, 1, 2, 3] 和* *和**在函数定义中的使用： *args用于接收任意数量的位置参数，并将它们作为元组传递给函数。 **kwargs用于接收任意数量的关键字参数，并将它们作为字典传递给函数。 *和**在函数调用中的使用： 在函数调用时，*用于解包可迭代对象，并将其作为位置参数传递给函数。 在函数调用时，**用于解包字典，并将其作为关键字参数传递给函数。 栈模拟递归 from collections import deque def dfs(idx,p): q = deque() q.append((idx,p)) while q: idx,p = q.pop() D[idx] = D[p] + V[idx] for u in A[idx]: if u == p: continue q.append((u,idx)) 引用赋值、浅拷贝和深拷贝 Python赋值、浅拷贝、深拷贝的区别 [:]和.copy()都属于“浅拷贝”，只拷贝最外层元素，外层元素是独立内存；内层嵌套元素则通过引用方式共享，而非独立分配内存。使用 copy 模块的 copy.copy（ 浅拷贝 ）和 copy.deepcopy（深拷贝），其中deepcopy是构建了一个完全独立的对象。\n1、b = a: 赋值引用，a 和 b 都指向同一个对象。\n2、b = a.copy(): 浅拷贝, a 和 b 是一个独立的对象，但他们的子对象（内层嵌套对象）还是指向统一对象（是引用）。\n3、b = copy.deepcopy(a): 深度拷贝, a 和 b 完全拷贝了父对象及其子对象，两者是完全独立的。\n例子： 引用赋值 \u0026gt;\u0026gt;\u0026gt;a = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9] \u0026gt;\u0026gt;\u0026gt;b = a[:] \u0026gt;\u0026gt;\u0026gt;print(b) [0, 1, 2, 3, 4, 5, 6, 7, 8, 9] \u0026gt;\u0026gt;\u0026gt;print(id(a)) #41946376 \u0026gt;\u0026gt;\u0026gt;print(id(b)) #41921864 或 \u0026gt;\u0026gt;\u0026gt;b = a.copy() \u0026gt;\u0026gt;\u0026gt;print(b) [0, 1, 2, 3, 4, 5, 6, 7, 8, 9] \u0026gt;\u0026gt;\u0026gt;print(id(a)) #39783752 \u0026gt;\u0026gt;\u0026gt;print(id(b)) #39759176 浅拷贝 \u0026gt;\u0026gt;\u0026gt;a = [1,2,[\u0026#39;A\u0026#39;,\u0026#39;B\u0026#39;]] \u0026gt;\u0026gt;\u0026gt;print(\u0026#39;a={}\u0026#39;.format(a)) \u0026gt;\u0026gt;\u0026gt;b = a[:] \u0026gt;\u0026gt;\u0026gt;b[0] = 9 #修改b的最外层元素，将1变成9 \u0026gt;\u0026gt;\u0026gt;b[2][0] = \u0026#39;D\u0026#39; #修改b的内嵌层元素 \u0026gt;\u0026gt;\u0026gt;print(\u0026#39;a={}\u0026#39;.format(a)) \u0026gt;\u0026gt;\u0026gt;print(\u0026#39;b={}\u0026#39;.format(b)) \u0026gt;\u0026gt;\u0026gt;print(\u0026#39;id(a)={}\u0026#39;.format(id(a))) \u0026gt;\u0026gt;\u0026gt;print(\u0026#39;id(b)={}\u0026#39;.format(id(b))) a=[1, 2, [\u0026#39;A\u0026#39;, \u0026#39;B\u0026#39;]] #原始a a=[1, 2, [\u0026#39;D\u0026#39;, \u0026#39;B\u0026#39;]] #b修改内部元素A为D后，a中的A也变成了D，说明共享内部嵌套元素，但外部元素1没变。 b=[9, 2, [\u0026#39;D\u0026#39;, \u0026#39;B\u0026#39;]] #修改后的b id(a)=38669128 id(b)=38669192 深拷贝 import copy a = [1, 2, 3, 4, [\u0026#39;a\u0026#39;, \u0026#39;b\u0026#39;]] #原始对象 b = a #赋值，传对象的引用 c = copy.copy(a) #对象拷贝，浅拷贝 d = copy.deepcopy(a) #对象拷贝，深拷贝 a.append(5) #修改对象a a[4].append(\u0026#39;c\u0026#39;) #修改对象a中的[\u0026#39;a\u0026#39;, \u0026#39;b\u0026#39;]数组对象 print( \u0026#39;a = \u0026#39;, a ) print( \u0026#39;b = \u0026#39;, b ) print( \u0026#39;c = \u0026#39;, c ) print( \u0026#39;d = \u0026#39;, d ) #输出： \u0026#39;a = \u0026#39;, [1, 2, 3, 4, [\u0026#39;a\u0026#39;, \u0026#39;b\u0026#39;, \u0026#39;c\u0026#39;], 5] \u0026#39;b = \u0026#39;, [1, 2, 3, 4, [\u0026#39;a\u0026#39;, \u0026#39;b\u0026#39;, \u0026#39;c\u0026#39;], 5] \u0026#39;c = \u0026#39;, [1, 2, 3, 4, [\u0026#39;a\u0026#39;, \u0026#39;b\u0026#39;, \u0026#39;c\u0026#39;]] \u0026#39;d = \u0026#39;, [1, 2, 3, 4, [\u0026#39;a\u0026#39;, \u0026#39;b\u0026#39;]] 栈代替递归 增加递归深度 import sys sys.setrecursionlimit(150000000) print(sys.getrecursionlimit()) 迭代加深搜索 s = input() l = len(s) s = \u0026#34;0\u0026#34; + s # 1~l ans = set() st = {} def dfs(curlen, last): global ans, st stack = [(curlen, last)] while stack: curlen, last = stack.pop() if curlen - 2 \u0026gt; 4 and last != s[curlen - 1:curlen + 1]: if (curlen - 1, curlen) not in st: st[(curlen - 1, curlen)] = 1 ans.add(s[curlen - 1:curlen + 1]) stack.append((curlen - 2, s[curlen - 1:curlen + 1])) if curlen - 3 \u0026gt; 4 and last != s[curlen - 2:curlen + 1]: if (curlen - 2, curlen) not in st: st[(curlen - 2, curlen)] = 1 ans.add(s[curlen - 2:curlen + 1]) stack.append((curlen - 3, s[curlen - 2:curlen + 1])) dfs(l, \u0026#34;\u0026#34;) ans = sorted(ans) # 将集合转换为列表并排序 print(len(ans)) for si in ans: print(si) 加速读入 import sys input = lambda:sys.stdin.readline().strip() a = int(input()) print(a) 队列 Queue中有FIFO（先入先出）队列Queue，LIFO（后入先出）栈LifoQueue，和优先级队列PriorityQueue，但速度较慢，且不能不出栈地访问头部元素，想要访问头部元素，只能用get方法出栈首部获取方法返回值的来进行访问，非常不方便。\n可以用deque()模拟\nimport collections q=collections.deque() m=int(input()) for i in range(m): s = input().split() if s[0]==\u0026#39;push\u0026#39;: q.append(s[1]) elif s[0]==\u0026#39;pop\u0026#39;: q.popleft() elif s[0]==\u0026#39;empty\u0026#39;: if len(q)==0: print(\u0026#39;YES\u0026#39;) else: print(\u0026#39;NO\u0026#39;) else: print(q[0]) 栈 列表模拟\nm=int(input()) stk=[] for i in range(m): s = input().split() if s[0]==\u0026#39;push\u0026#39;: stk.append(int(s[1])) elif s[0]==\u0026#39;pop\u0026#39;: stk.pop() elif s[0]==\u0026#39;empty\u0026#39;: if len(stk)==0: print(\u0026#39;YES\u0026#39;) else: print(\u0026#39;NO\u0026#39;) else: print(stk[-1]) deque模拟\nimport collections stk = collections.deque() m=int(input()) for i in range(m): s = input().split() if s[0]==\u0026#39;push\u0026#39;: stk.appendleft( int(s[1]) ) elif s[0]==\u0026#39;pop\u0026#39;: stk.popleft() elif s[0]==\u0026#39;empty\u0026#39;: if len(stk)==0: print(\u0026#39;YES\u0026#39;) else: print(\u0026#39;NO\u0026#39;) else: print(stk[0]) Python 常用内置库 array 定长数组 argparse 命令行参数处理 bisect 二分查找 collections 有序字典、双端队列等数据结构 fractions 有理数 heapq 基于堆的优先级队列 io 文件流、内存流 itertools 迭代器 math 数学函数 os.path 系统路径等 random 随机数 re 正则表达式 struct 转换结构体和二进制数据 sys 系统信息 defaultdict() from collections import defaultdict # 创建一个 defaultdict，指定默认值为 int 类型的 0 d = defaultdict() # 修改默认值为 100 d.default_factory = lambda: 100 g = defaultdict(lambda:defaultdict(lambda:INF)) #同样的效果 邻接矩阵 Counter() from collections import Counter # 定义一个列表 lst = [1, 2, 2, 3, 3, 3, 4, 4, 4, 4] s = \u0026#39;abcdgsaa\u0026#39; # 使用 Counter 统计列表中元素的出现次数 c1 = Counter(lst) c2 = Counter(s) print(c1,c2, sep=\u0026#39;\\n\u0026#39;) # 使用 most_common() 方法按照元素的出现次数进行排序 sorted_items = c1.most_common() for x,y in enumerate(sorted_items): print(y[0]) c.elements() c.update(b) #将两个Counter合并， 对应元素数目相加 c.subtract(b) # 对应元素数目相减 heapq 建堆 ( 小根堆 )\na = [1, 5, 20, 18, 10, 200] heapq.heapify(a) print(a) 建大根堆\na = [] for i in [1, 5, 20, 18, 10, 200]: heapq.heappush(a,-i) print( list( map(lambda x:-x,a) ) ) heap_sort(heappush)\nimport heapq def heap_sort(arr): if not arr: return [] h = [] #建立空堆 for i in arr: heapq.heappush(h,i) #heappush自动建立小根堆 return [heapq.heappop(h) for i in range(len(h))] #heappop每次删除并返回列表中最小的值 # 堆排序取最小的m个数字 import heapq def heap_sort(arr, k): if not arr: return [] h=[] for i in arr: heapq.heappush(h, i) return [heapq.heappop(h) for _ in range(k)] n,m = map(int, input().split()) arr = list(map(int, input().split())) ans = heap_sort(arr, m) print(\u0026#39; \u0026#39;.join(map(str, ans))) heappushpop\npop弹出堆顶元素\n先push再pop\n[1, 18, 5, 20, 90, 10, 200] h [1, 18, 5, 20, 90, 10, 200] heapq.heappushpop(h, 300) 1 h [5, 18, 10, 20, 90, 300, 200] heapreplace\n先pop再push\nh [5, 18, 10, 20, 90, 300, 200] heapq.heapreplace(h, -1) 5 h [-1, 18, 10, 20, 90, 300, 200] heapq.merge\nimport heapq h1 = [90, 1, 5, 20, 18, 10, 200] h2 = [4,2,3,4,1000] heapq.heapify(h1) heapq.heapify(h2) print(list(heapq.merge(h1, h2))) heap.nlargest\nh1 [1, 18, 5, 20, 90, 10, 200] heapq.nlargest(2,h1,key=lambda x:-x) heapq.nsmallest() [1, 5] list() del list[1] 删除列表元素 列表比较 import operator operator.eq(a,b) len(list) max(list) min(list) list(seq) 将元组转换为列表 list.append(obj) list.count(obj) list.extend(seq) list.index(obj) list.insert(index, obj) list.pop([index=-1]) 删除列表中一个元素 list.remove(obj) 删除第一个匹配项 list.reverse() list.sort(key=None, reverse=False) list.clear() list.copy() tuple() 元素组合 类似list\nSortedList() from sortedcontainers import SortedList sl = SortedList() sl.add(1) print(sl[-1]) print(sl[0]) sl.update([3,2,1]) print(sl) sl.update([9,8,7]) print(sl) ##sl.clear() sl.discard(5) sl.remove(9) print(sl) sl.pop() print(sl) sl.pop(-2) print(sl) print(sl.bisect_left(12)) #返回需要插入的位置，如有存在则返回左侧的位置 print(sl.bisect_right(2)) print(sl.count(1)) print(sl.index(1)) it = sl.islice(2,4) print(list(it)) dict() 键值必须不可变\nd = {\u0026#39;1\u0026#39;:\u0026#39;a\u0026#39;, \u0026#39;2\u0026#39;:\u0026#39;b\u0026#39;, \u0026#39;99\u0026#39;:\u0026#39;xycz\u0026#39;} print(d) if \u0026#39;0\u0026#39; in d :del d[\u0026#39;0\u0026#39;] del d[\u0026#39;1\u0026#39;] print(d) {\u0026#39;1\u0026#39;: \u0026#39;a\u0026#39;, \u0026#39;2\u0026#39;: \u0026#39;b\u0026#39;, \u0026#39;99\u0026#39;: \u0026#39;xycz\u0026#39;} {\u0026#39;2\u0026#39;: \u0026#39;b\u0026#39;, \u0026#39;99\u0026#39;: \u0026#39;xycz\u0026#39;} 内置方法 len str type dict.clear() dict.copy() dict.fromkeys(seq) 将seq作为字典的键值， 字典中val为默认 dict.get(key, default=None) # 不需要写default key in dict dict.items() dict.keys() dict.setdefault(key, default = None) # 用于在字典中查找指定键（key）。如果键存在，则返回对应的值；如果键不存在，则在字典中设置该键，并将默认值（default）作为其值，并返回该默认值。 dict.update(dict2) #把dict2添加到dict中 dict.values() #返回值 pop(key[,default]) #删除字典中key所对应的值并返回 popitem() #返回并删除字典中最后一对键值 set() 空集合用set() 支持 -, |, \u0026amp;, ^(不同时包含于两个集合) difference() #返回新集合 difference_update() #在原集合上修改，无返回值 s1.difference_update(s2) union() #并集 intersection() #交集 intersection_update() #返回交集 isdisjoint() #判断两个集合是否包含相同的元素 issubset() #判断指定参数的集合是否为该调用方法的集合的子集 issuperset() #用于确定一个集合是否为另一个集合的超集, 它用于检查一个集合是否包含另一个集合的所有元素 symmetric_difference() #返回两个集合中不重复的元素集合 symmetric_difference_update() #移除相同的元素，并插入没有的元素 s.add(x) 添加元素 s.update(x) #可以添加多个元素，并且可以是列表元组字典 s.remove(x) #将元素从集合中移除， 如果不存在则报错 s.discard(x) #移除元素，但是不报错 s.pop() #设置随机删除结合中的一个元素（无序集合的第一个元素） len(s) s.clear() x in s s.copy() deque() append() appendleft() extend() extendleft() pop() popleft() count() insert(index, obj) #与list相同，在index位置插入obj， 本来在index上的元素往后移动 rotate(n) # 从右侧翻转n步（后n个元素放到前面），如果为负数，则从左边翻转 clear() remove() maxlen q = deque(maxlen = 2) #如果超过长度，则在另一侧删除 bisect from bisect import * idx = bisect(ls, x) # bisect 和 bisect_right等同 idx = bisect_left(ls, x) # 如果列表内没有此元素，那么返回合适的插入点索引 insort_left(ls, x)#插入元素并保持有序 insort(ls, x) # 等价于insort_right(ls, x) import bisect my_list = [1, 3, 5, 7, 9, 11, 13] i = bisect.bisect_left(my_list, -1) #0 i = bisect.bisect_left(my_list, 8, lo=3, hi=6) #4 bisect.insort_right(my_list, 8, lo=3, hi=6) #[1, 3, 5, 7, 8, 9, 11, 13] str s = \u0026#34;hello world\u0026#34; print(s.capitalize()) # Output: \u0026#34;Hello world\u0026#34; print(s.upper()) # Output: \u0026#34;HELLO WORLD\u0026#34; print(s.lower()) # Output: \u0026#34;hello world\u0026#34; print(s.title()) # Output: \u0026#34;Hello World\u0026#34; s = \u0026#34;Hello World\u0026#34; print(s.swapcase()) # Output: \u0026#34;hELLO wORLD\u0026#34; s = \u0026#34; hello world \u0026#34; print(s.strip()) # Output: \u0026#34;hello world\u0026#34; s = \u0026#34;hello world\u0026#34; print(s.replace(\u0026#34;world\u0026#34;, \u0026#34;python\u0026#34;)) # Output: \u0026#34;hello python\u0026#34; s = \u0026#34;hello world\u0026#34; print(s.split()) # Output: [\u0026#39;hello\u0026#39;, \u0026#39;world\u0026#39;] words = [\u0026#34;hello\u0026#34;, \u0026#34;world\u0026#34;] separator = \u0026#34;, \u0026#34; print(separator.join(words)) # Output: \u0026#34;hello, world\u0026#34; s = \u0026#34;hello world\u0026#34; print(s.startswith(\u0026#34;hello\u0026#34;)) # Output: True s = \u0026#34;hello world\u0026#34; print(s.endswith(\u0026#34;world\u0026#34;)) # Output: True s = \u0026#34;hello world\u0026#34; print(s.find(\u0026#34;world\u0026#34;)) # Output: 6 s = \u0026#34;hello world\u0026#34; print(s.count(\u0026#34;l\u0026#34;)) # Output: 3 自定义比较参数 from functools import cmp_to_key def compare(s1, s2): if len(s1) == len(s2): for c1, c2 in zip(s1, s2): if c1 \u0026gt; c2: return 1 elif c1 \u0026lt; c2: return -1 return 0 else: if len(s1) \u0026gt; len(s2): return 1 else: return -1 things = input().split() # 使用 cmp_to_key 将比较函数转换为 key 函数 things.sort(key=cmp_to_key(compare)) print(things) __init__魔术方法 class Fib(object): def __init__(self): pass def __call__(self, num): # 将对象作为函数调用时触发 a, b = 0, 1 self.l = [] for i in range(num): self.l.append(a) a, b = b, a+b return self.l def __str__(self): # 使用print(对象）或者str (对象)的时候触发 return str(self.l) # 必须返回字符串类型 __rept__=__str__ # 使用repr(对象) f = Fib() print(f(10)) from itertools import combinations, permutations from copy import deepcopy from functools import lru_cache from sys import stdin from collections import defaultdict, deque, Counter from heapq import * import operator from functools import cmp_to_key ls = [1, 2, 3] ls2 = [1, 2, 3] print(operator.eq(ls, ls2)) for j in permutations(ls, 1): print(j) for j in combinations(ls, 2): print(j) len(ls) max(ls) min(ls) list(s) ls.append() ls.count() ls.index() ls.extend() ls.insert(index, obj) ls.pop(index) ls.remove() ls.reverse() ls.sort(key = lambda x:-x, reverse = True) ls.clear() ls.copy print(s.capitalize()) print(s.capitalize()) print(s.capitalize()) print(s.lower()) print(s.upper()) print(s.title()) ","permalink":"https://kennems.github.io/posts/tech/python%E5%BA%93/","summary":"Python库 程序易错点 ： 变量未声明 i,j,k变量写错了 变量名一定要看清楚 函数体内变量和外部变量分不清，变量名相近的一定要看清楚 11+12+16+15+12+12 = 78 七夕祭","title":"Python库"},{"content":"周赛250519 终于终于AK了一场😆\n第四题100298. 到达第 K 级台阶的方案数 题目大意\n给定一个非负整数 k，表示目标台阶的编号。虎老师从台阶 1 开始，通过一系列操作到达台阶 k。操作分为两种：\n向下走一级到 i - 1，但该操作不能连续使用，如果在台阶 0 也不能使用。 向上走到台阶 i + 2^jump 处，然后 jump 变为 jump + 1。 目标是计算虎老师到达台阶 k 的总方案数。\n实现思路\n定义递归函数：定义一个递归函数 dfs(p, j, f)，其中 p 表示当前所在的台阶，j 表示当前 jump 的次数，f 表示上一次操作是否是向下走一级的标志。 递归终止条件： 当 p == k 时，表示已经到达目标台阶，返回 1 表示找到一种方案。 当 p \u0026lt; 0 时，表示超出范围，返回 0。 当 p - 1 \u0026gt; k 或者 p - 1 == k 且 f == 1 时，表示向下走超过目标或在目标时无法向下走，返回 0。 递归计算： up：计算向上走到 p + 2^j 的方案数，并将 j 加 1，表示使用了一次向上跳跃。 down：计算向下走到 p - 1 的方案数，当 p \u0026gt; 0 且 f == 0 时才可以向下走。 返回 up + down + more 的和，其中 more 表示当前正好在目标台阶的情况。 记忆化搜索：使用 @cache 修饰递归函数，避免重复计算。 class Solution: def waysToReachStair(self, k: int) -\u0026gt; int: @cache def dfs(p, j, f): # flag 1: 上一次是下移， 0：上一次不是 more = 0 if p == k: more = 1 if p \u0026lt; 0: return 0 if p-1\u0026gt;k or (p-1==k and f==1): return 0 up = dfs(p + (1 \u0026lt;\u0026lt; j), j + 1, 0) if p \u0026gt; 0 and f==0: down = dfs(p - 1, j, 1) else: down = 0 return up + down + more return dfs(1, 0, 0) ","permalink":"https://kennems.github.io/posts/tech/%E5%91%A8%E8%B5%9B250519/","summary":"周赛250519 终于终于AK了一场😆 第四题100298. 到达第 K 级台阶的方案数 题目大意 给定一个非负整数 k，表示目标台阶的编号。虎老师从台阶 1","title":"LeetCode周赛398(240519)"},{"content":"周赛20240505 第四题 100288. 使数组中所有元素相等的最小开销 题目大意：给定一个整数数组 nums 和两个整数 cost1 和 cost2，可以执行两种操作来使数组中所有元素相等：1. 选择某个元素增加1，开销为cost1；2. 选择两个不同的元素同时增加1，开销为cost2。目标是使数组中所有元素相等，返回需要的最小开销之和。\n实现思路：首先计算数组中最大值mx和最小值mn，然后计算基础开销base，即将最大值变为最小值所需的开销。然后根据两种操作的开销比较，若cost1*2 \u0026lt;= cost2，则只需考虑将最大值变为最小值的开销，直接返回即可。若cost1*2 \u0026gt; cost2，则需要考虑两种操作的比较，通过二分搜索找到使得总开销最小的情况。具体实现中，定义了函数f(x)，表示将最大值变为x时的总开销，然后在mx的范围内进行二分搜索找到最小总开销。\nclass Solution: def minCostToEqualizeArray(self, nums: List[int], c1: int, c2: int) -\u0026gt; int: mod = int(1e9) + 7 mx = max(nums); mn = min(nums) n = len(nums) base = mx*n - sum(nums) if c1*2 \u0026lt;= c2: return base * c1 % mod def f(x): d = x - mn s = base + (x-mx) * n if d \u0026lt;= s-d: return s//2 * c2 + s%2*c1 return (s-d) * c2 + (d-(s-d)) * c1 ans = inf if mx\u0026amp;1: ans = f(mx) mx += 1 base += n k0 = bisect_left( range(mx), True, mx//2, key = lambda m: f(m*2) \u0026lt; f((m+1)*2) ) k1 = bisect_left( range(mx), True, mx//2, key = lambda m: f(m*2+1) \u0026lt; f((m+1)*2 + 1) ) ans = min(ans, f(k0*2), f(k1*2 + 1)) return ans%mod ","permalink":"https://kennems.github.io/posts/tech/%E5%91%A8%E8%B5%9B20240505/","summary":"周赛20240505 第四题 100288. 使数组中所有元素相等的最小开销 题目大意：给定一个整数数组 nums 和两个整数 cost1 和 cost2，可以执行两种操作来使数组中所","title":"LeetCode周赛396(240505)"},{"content":"LeetCode每日一题(2405) 1235. 规划兼职工作 题目大意：给定n份兼职工作，每份工作都有开始时间、结束时间和报酬。任务是选择一些工作，使得在不重叠的情况下能够获得最大报酬。\n实现思路：首先对工作按照结束时间进行排序，然后使用动态规划来求解最大报酬。在动态规划的过程中，维护一个数组f，其中f[i]表示在考虑前i个工作时可以获得的最大报酬。遍历每个工作，对于第i个工作，找到在其开始时间之前且结束时间最接近的工作j，然后更新f[i]为f[j] + 第i个工作的报酬。最终返回f[n]即为所求的最大报酬。\nclass Solution: def jobScheduling(self, startTime: List[int], endTime: List[int], profit: List[int]) -\u0026gt; int: # 兵贵神速，现在能领先一秒，以后就能按照复利一直领先 n = len(startTime) job = [(0, 0, 0)] + sorted(zip(endTime, startTime, profit)) f = [0]*(n+1) for i, (_, st, p) in enumerate(job[1:], start = 1): # l, r = 0, i-1 # while l\u0026lt;r: # mid = (l+r+1)\u0026gt;\u0026gt;1 # if job[mid][0] \u0026gt; st: # r = mid-1 # else: # l = mid # f[i] = max(f[i-1], f[l] + p) l = bisect_left(job, (st+1, ), hi = i, lo = 0) # 内置库只能查找 严格 \u0026gt; \u0026lt; 的值 # 无法找到 \u0026gt;= \u0026lt;=的值，但是可以在找到最大的 \u0026lt;目标值的 i, i-1即为\u0026lt;=目标值的下标 f[i] = max(f[i-1], f[l-1] + p) return f[n] 741. 摘樱桃 题目大意：给定一个网格，其中包含空格、樱桃和荆棘，要求从左上角到右下角，然后返回左上角，按照规定的走法，最多能摘到的樱桃数量。\n记忆化搜索 实现思路：这是一个动态规划问题。定义一个递归函数dfs(t, j, l)，表示在时刻t，第一个人位于(j, t-j)，第二个人位于(l, t-l)时，能够得到的最大樱桃数量。递归终止条件是当其中一个人走到了边界之外或者碰到了荆棘时，返回负无穷。然后递归地计算四种可能的移动方向：向下走、向右走、向下和向右走、向左走，同时更新樱桃数量。最后返回经过路径能够摘到的最多樱桃数量。\nclass Solution: def cherryPickup(self, g: List[List[int]]) -\u0026gt; int: @cache def dfs(t, j, l): if j\u0026lt;0 or l\u0026lt;0 or t-j\u0026lt;0 or t-l\u0026lt;0 or g[t-j][j]==-1 or g[t-l][l]==-1: return -inf if t==0: return g[0][0] return max(dfs(t-1, j, l), dfs(t-1, j-1, l), dfs(t-1, j, l-1), dfs(t-1, j-1, l-1)) \\ + g[t-j][j] + (g[t-l][l] if j!=l else 0) n = len(g) return max(0, dfs(2*n-2, n-1, n-1)) 递推 实现思路：\n使用动态规划来解决。定义一个三维数组 f，其中 f[t][i][j] 表示在 t 步中，第一个人位于 (i-1, t-i)、第二个人位于 (j-1, t-j) 时所能摘到的最大樱桃数。 初始条件为 f[0][1][1] = grid[0][0]，表示开始时第一个人和第二个人都在左上角，第一个格子上的樱桃数。 然后进行状态转移，对于每一步 t，遍历两个人可能的位置 (i, t-i)，(j, t-j)： 如果该位置不是荆棘，则计算能从上一步到达当前位置的最大樱桃数。状态转移方程为：f[t][i][j] = max(f[t-1][i][j], f[t-1][i-1][j], f[t-1][i][j-1], f[t-1][i-1][j-1]) + 当前格子上的樱桃数。 最后返回 f[2*n-2][n][n]，表示在返回过程中最多能摘到的樱桃数。 class Solution: def cherryPickup(self, grid: List[List[int]]) -\u0026gt; int: n = len(grid) f = [[[-inf]*(n+1) for _ in range(n+1)] for _ in range(2*n-1)] f[0][1][1] = grid[0][0] for t in range(1, 2*n-1): for j in range(max(t-n+1, 0), min(n, t+1)): if grid[t-j][j]==-1: continue for k in range(j, min(n, t+1)): if grid[t-k][k]==-1: continue f[t][j+1][k+1] = max(f[t-1][j+1][k+1], f[t-1][j][k+1], f[t-1][j+1][k], f[t-1][j][k]) \\ + grid[t-j][j] + (grid[t-k][k] if j!=k else 0) return max(0, f[2*n-2][n][n]) 463. 摘樱桃 II 题目大意：给定一个矩阵表示樱桃地，两个机器人分别从左上角和右上角出发，每个机器人只能向下一行的左下、下方和右下方移动，当机器人到达一个格子时，会摘取该格子内所有的樱桃并将其置空。两个机器人不能同时摘取同一个格子的樱桃，求两个机器人能够摘取的最大樱桃总数。\n记忆化搜索 实现思路：可以使用动态规划来解决。定义一个递归函数 dfs(i, j, k) 表示机器人1位于第i行第j列，机器人2位于第i行第k列时，能够摘取的最大樱桃总数。递归过程中，对于每个机器人，都有三种移动方式，即向下一行的左下、下方和右下方移动。递归终止条件为机器人到达最后一行。使用缓存装饰器 @cache 可以避免重复计算。最后，返回dfs(0, 0, m-1)，其中m为矩阵的列数。\nclass Solution: def cherryPickup(self, grid: List[List[int]]) -\u0026gt; int: n, m = len(grid), len(grid[0]) @cache def dfs(i, j, k): if i==n or j\u0026lt;0 or j\u0026gt;=m or k\u0026lt;0 or k\u0026gt;=m: return 0 return max(dfs(i+1, nj, nk) for nj in range(j-1, j+2) for nk in range(k-1, k+2)) \\ + grid[i][j] + (grid[i][k] if j!=k else 0) return dfs(0, 0, m-1) 递推 实现思路：使用动态规划进行解决。定义一个三维数组 f，其中 f[i][j+1][k+1] 表示机器人1位于第i行第j列，机器人2位于第i行第k列时，能够摘取的最大樱桃总数。通过三重循环，依次遍历每一行和每一列，更新 f[i][j+1][k+1] 的值，其中 i 表示当前行，j 表示机器人1的列数，k 表示机器人2的列数。在更新 f[i][j+1][k+1] 的过程中，通过遍历机器人1和机器人2的位置，计算能够摘取的最大樱桃总数。最后返回 f[0][1][m]，其中 m 为矩阵的列数。\nclass Solution: def cherryPickup(self, grid: List[List[int]]) -\u0026gt; int: n, m = len(grid), len(grid[0]) f = [[[0]*(m+2) for _ in range(m+2)] for _ in range(n+1)] for i in range(n-1, -1, -1): for j in range(min(i+1, m)): for k in range(max(j+1, m-1-i), m): t = 0 for nj in range(j, j+3): for nk in range(k, k+3): t = max(t, f[i+1][nj][nk]) f[i][j+1][k+1] = t + grid[i][j] + grid[i][k] return f[0][1][m] ","permalink":"https://kennems.github.io/posts/tech/leetcode%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98202405/","summary":"LeetCode每日一题(2405) 1235. 规划兼职工作 题目大意：给定n份兼职工作，每份工作都有开始时间、结束时间和报酬。任务是选择一些工作，使得","title":"LeetCode每日一题(202405)"},{"content":"双周赛20230427 第三/四题3130. 找出所有稳定的二进制数组 II 题目大意：给定三个正整数 zero、one 和 limit，定义一个二进制数组 arr，要求满足以下条件：数组中 0 出现的次数为 zero，1 出现的次数为 one，并且数组中每个长度超过 limit 的子数组都同时包含 0 和 1。求稳定二进制数组的总数目。\n实现思路：这是一个典型的动态规划问题。我们可以使用递归函数 dfs(i, j, k) 来表示以 i 个 0 和 j 个 1 开头，并且最后一个元素为 k 的稳定二进制数组的个数。其中，k 取值为 0 或 1，表示最后一个元素为 0 或 1。递归的边界条件是当 i 或 j 为 0 时，返回 1 或 0，表示当前情况下有 1 个或 0 个稳定数组。在递归过程中，我们需要考虑当前元素添加为 0 或 1 时的情况，并且根据 limit 来控制子数组的长度，避免不稳定的情况。最后，我们可以通过递归计算得到所有满足条件的稳定二进制数组的个数，并取模返回。\nclass Solution: def numberOfStableArrays(self, zero: int, one: int, limit: int) -\u0026gt; int: mod = int(1e9)+7 @cache def dfs(i, j, k): if i==0: return 1 if k==1 and j\u0026lt;=limit else 0 if j==0: return 1 if k==0 and i\u0026lt;=limit else 0 if k==0: return ( dfs(i-1, j, 0) + dfs(i-1, j, 1) - (dfs(i-limit-1, j, 1) if i\u0026gt;limit else 0) ) %mod else: return ( dfs(i, j-1, 0) + dfs(i, j-1, 1) - (dfs(i, j-limit-1, 0) if j\u0026gt;limit else 0) ) %mod ans = (dfs(zero, one, 1) + dfs(zero, one, 0))%mod dfs.cache_clear() # 防止爆内存 return ans ","permalink":"https://kennems.github.io/posts/tech/%E5%8F%8C%E5%91%A8%E8%B5%9B20230427/","summary":"双周赛20230427 第三/四题3130. 找出所有稳定的二进制数组 II 题目大意：给定三个正整数 zero、one 和 limit，定义一个二进制数组","title":"LeetCode双周赛129(240427)"},{"content":"周赛20230428 第四题134. 找出唯一性数组的中位数 题目大意：给定一个整数数组nums，唯一性数组是一个按元素从小到大排序的数组，包含了nums的所有非空子数组中不同元素的个数。要求返回nums唯一性数组的中位数，即有序唯一性数组的中间元素。\n实现思路：首先，我们需要明确唯一性数组的生成方式，即通过遍历所有非空子数组，计算其中不同元素的个数。然后，我们可以使用二分查找的方法确定唯一性数组的中位数。在二分查找的过程中，我们需要一个辅助函数来判断给定的中位数是否满足条件，即唯一性数组中不同元素的个数大于等于中位数。如果满足条件，我们更新右边界，否则更新左边界，直到左右边界相遇，即找到了唯一性数组的中位数。\nclass Solution: def medianOfUniquenessArray(self, nums: List[int]) -\u0026gt; int: n = len(nums) k = (n * (n + 1) // 2 + 1) // 2 def check(mid): j, cnt = 0, 0 fre = Counter() for i, num in enumerate(nums): fre[num] += 1 while len(fre) \u0026gt; mid: fre[nums[j]] -= 1 if fre[nums[j]] == 0: del fre[nums[j]] j += 1 cnt += i - j + 1 return cnt \u0026gt;= k l, r = 1, len(set(nums)) while l \u0026lt; r: mid = l + r \u0026gt;\u0026gt; 1 if check(mid): r = mid else: l = mid + 1 return l ","permalink":"https://kennems.github.io/posts/tech/%E5%91%A8%E8%B5%9B240428/","summary":"周赛20230428 第四题134. 找出唯一性数组的中位数 题目大意：给定一个整数数组nums，唯一性数组是一个按元素从小到大排序的数组，包含了","title":"LeetCode周赛395(240428)"},{"content":"Java Web开发(3) Maven Maven是一款管理和构建java项目的工具\n依赖管理 统一的项目结构 项目构建 \u0026lt;maven.compiler.source\u0026gt;11\u0026lt;/maven.compiler.source\u0026gt; \u0026lt;maven.compiler.target\u0026gt;11\u0026lt;/maven.compiler.target\u0026gt; MVN坐标 Maven中的坐标是资源的唯一标识，通过该坐标可以唯一定位资源位置 使用坐标来定义项目或引入项目中所需要的依赖 Maven的坐标主要组成\ngroupid:定义当前Maven项目隶属组织名称（通常是域名反写） artifactId：定义当前Maven项目名称（通常是模块名称，例如 order-service, goods-service） version：定义当前项目版本号 导入maven工程：\nMaven中项目依赖配置 在\u0026lt;dependencies\u0026gt;中添加\n\u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;ch.qos.logback\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;logback-classic\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;1.2.3\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; 如果所引入的依赖，在本地仓库不存在，将会连接远程仓库/中央仓库，然后下载依赖 如果不知道依赖的坐标信息，到https://mvnrepository.com/中搜索。 Maven依赖管理 依赖具有传递性 直接依赖：在当前项目中通过依赖配置建立的依赖关系 间接依赖：被依赖的资源如果依赖其他资源，当前项目间接依赖其他资源 排除依赖 \u0026lt;!-- 排除依赖--\u0026gt; \u0026lt;exclusions\u0026gt; \u0026lt;exclusion\u0026gt; \u0026lt;groupId\u0026gt;junit\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;junit\u0026lt;/artifactId\u0026gt; \u0026lt;/exclusion\u0026gt; \u0026lt;/exclusions\u0026gt; 依赖范围 依赖的jar包，默认情况下，可以在任何地方使用，可以通过\u0026lt;scope\u0026gt;...\u0026lt;/scope\u0026gt;设置其作用范围\n作用范围： 主程序范围有效。（main文件夹范围内） 测试程序范围有效。（test文件夹范围内） 是否参与打包运行。（package指令范围内） scope值 提供库 编译时 运行时 范例 compile Y Y Y log4j test - Y - junit provided Y Y - servlet-api runtime - Y Y jdbc驱动 Maven生命周期 每套生命周期包含一些阶段（phase），阶段是有顺序的，后面的阶段依赖于前面的阶段\nclean : 移除上一次构建生成的文件 compile : 编译项目源代码 test : 使用合适的单元测试框架运行测试（junit） package ： 将编译后的文件打包，如：jar, war等 install ： 安装项目到本地仓库 同一套生命周期中，当运行后面的阶段时，前面的阶段都会运行。\nSpringBoot开发 创建SpringWeb工程\npackage com.showguan; import org.springframework.web.bind.annotation.RequestMapping; import org.springframework.web.bind.annotation.RestController; @RestController public class HelloController { @RequestMapping(\u0026#34;/hello\u0026#34;) public String hello() { System.out.println(\u0026#34;hello world\u0026#34;); return \u0026#34;hello world!\u0026#34;; } } HTTP协议 Hyper Text Transfer Protocol, 超文本传输协议，规定了浏览器和服务器之间的数据传输的规则 特点：\n基于TCP协议：面向连接，安全 基于请求-响应模型的：一次请求对应一次响应 HTTP协议是无状态的协议：对于事物处理没有记忆能力。每次请求-响应都是独立的。 缺点：多次请求间不能共享数据 优点：速度快 HTTP请求协议 请求行（请求方式，资源路径, 协议） GET /hello HTTP/1.1\rPOST /hello HTTP/1.1 请求头：第二行开始，格式 ： key:value 名称 值 Host 请填写您的网站域名 User-Agent 用户代理，标识发出请求的浏览器和操作系统，例如Mozilla/5.0 (Windows NT\u0026hellip;) like Gecko Accept 可接受的响应内容类型，例如text/*, image/*等 Accept-Language 可接受的响应内容语言，例如zh-CN,zh;q=0.8 Accept-Encoding 可接受的响应内容编码方式，例如gzip, deflate等 Content-Type 请求体的媒体类型 Content-Length 请求体的长度（单位：字节） 请求体：POST请求，存放请求参数 请求方式-GET：请求参数在请求行中，没有请求体 请求方式-POST：请求参数在请求体中，POST请求大小是没有限制的 HTTP响应协议 响应格式 响应行：响应数据第一行（协议，状态码，描述） 状态码分类 说明 1xx 响应中 \u0026mdash; 临时状态码。表示请求已经接受，告诉客户端应该继续请求或者如果已经完成则忽略 2xx 成功 \u0026mdash; 表示请求已经被成功接收，处理已完成 3xx 重定向 \u0026mdash; 重定向到其它地方，让客户端再发起一个请求以完成整个处理 4xx 客户端错误 \u0026mdash; 处理发生错误，责任在客户端，如：客户端的请求一个不存在的资源，客户端未被授权，禁止访问等 5xx 服务器端错误 \u0026mdash; 处理发生错误，责任在服务端，如：服务端抛出异常，路由出错，HTTP版本不支持等 一、状态码大类 状态码分类 说明 1xx 响应中——临时状态码，表示请求已经接受，告诉客户端应该继续请求或者如果它已经完成则忽略它 2xx 成功——表示请求已经被成功接收，处理已完成 3xx 重定向——重定向到其它地方：它让客户端再发起一个请求以完成整个处理。 4xx 客户端错误——处理发生错误，责任在客户端，如：客户端的请求一个不存在的资源，客户端未被授权，禁止访问等 5xx 服务器端错误——处理发生错误，责任在服务端，如：服务端抛出异常，路由出错，HTTP版本不支持等 二、常见的响应状态码 状态码 英文描述 解释 ==200== OK 客户端请求成功，即处理成功，这是我们最想看到的状态码 302 Found 指示所请求的资源已移动到由Location响应头给定的 URL，浏览器会自动重新访问到这个页面 304 Not Modified 告诉客户端，你请求的资源至上次取得后，服务端并未更改，你直接用你本地缓存吧。隐式重定向 400 Bad Request 客户端请求有语法错误，不能被服务器所理解 403 Forbidden 服务器收到请求，但是拒绝提供服务，比如：没有权限访问相关资源 ==404== Not Found 请求资源不存在，一般是URL输入有误，或者网站资源被删除了 405 Method Not Allowed 请求方式有误，比如应该用GET请求方式的资源，用了POST 428 Precondition Required 服务器要求有条件的请求，告诉客户端要想访问该资源，必须携带特定的请求头 429 Too Many Requests 指示用户在给定时间内发送了太多请求（“限速”），配合 Retry-After(多长时间后可以请求)响应头一起使用 431 Request Header Fields Too Large 请求头太大，服务器不愿意处理请求，因为它的头部字段太大。请求可以在减少请求头域的大小后重新提交。 ==500== Internal Server Error 服务器发生不可预期的错误。服务器出异常了，赶紧看日志去吧 503 Service Unavailable 服务器尚未准备好处理请求，服务器刚刚启动，还未初始化好 状态码大全：https://cloud.tencent.com/developer/chapter/13553\n响应头：第二行开始，格式 key:value 响应体：最后一部分，存放响应数据 Web服务器 Web服务器是一个软件程序，对HTTP协议的操作进行封装，使得程序员不必直接对协议进行操作，让Web开发更加便捷。主要功能是“提供网上信息浏览服务”。\nTomCat Apache软件基金会一个核心小木，是一个开源免费的轻量级Web服务器，支持Servlet/JSP少量JavaEE规范 TomCat也被称为Web容器，Servlet容器。Servlet程序需要依赖于TomCat才能运行 启动方式：bin/startup.bat\n修改TomCat端口号\nconf/server.xml\nLocalhost默认端口号就是80\n用tomcat部署，将html文件复制到webapps文件夹中\n起步依赖：\n基于SpringBoot开发的web应用程序，内置了tomcat服务器，当启动类运行时，会自动启动内嵌的tomcat服务器 请求 前后端分离开发\nPostMan\n实体参数 实体对象参数：请求参数名与形参对象属性名相同， 即可直接通过POJO接受\n数组集合参数 数组参数：请求参数名与形参数组名称相同且请求参数为多个，定义数组类型形参即可接受参数 路径参数 通过请求URL直接传递参数，使用{...}来标识该路径参数，使用@PathVariable获取路径参数 响应 ResponseBody\n类型：方法注解，类注解 位置：Controller方法上/类上 作用：将方法返回值直接响应，如果返回值类型时 实体类型/集合，将会转换为JSON格式响应 说明：@RestController = @Controller + @ResponseBody 统一响应结果 Result(code, msg, data) public class Result { private Integer code ;//1 成功 , 0 失败 private String msg; //提示信息 private Object data; //数据 data } 分层解耦 三层架构\ncontroller:控制层，接受前端发送的请求，对请求进行处理，并响应数据 service:业务逻辑层，处理具体的业务逻辑 dao:数据访问层（Data Access Object）（持久层），负责数据访问操作，包括数据的增、删、改、查。 内聚：软件中各个功能模块内部的功能联系\n耦合：衡量软件中各个层/模块之间的依赖、关联的程度\n软件设计原则：高内聚低耦合\n控制反转：Inversion Of Control（IOC）。对象的创建控制权由车光绪自身转移到外部(容器)， 这种思想称为控制反转。\n依赖注入：Dependency Injection, 简称DI。 容器为应用程序提供运行时，所以来的组员，称之为依赖注入。\nBean对象：IOC容器中创建、管理的对象，称之为bean。\n用@Component标识容器\nIOC控制反转 除了@Component之外还有@Service, @Repository， @Controller\n注意事项：\n声明bean的时候，可以通过value属性指定bean的名字，如果没有指定，默认为类名首字母小写 使用以上四个注解都可以声明bean， 但是在springboot继承web开发中，声明控制器bean只能用@Controller Bean组件扫描：\n声明bean若要想生效，需要被组件扫描注解@ComponentScan扫描 @ComponentScan注解虽然没有显式配置，但是实际上已经包含在了启动类声明注解@SpringBootApplication中，默认扫描的范围时启动类所在包及其子包 Bean注入 @Autowired注解，默认时按照类型进行，如果存在多个相同类型的bean， 将会报出如下错误：\n如果同类型的bean存在多个：\n@Primary @Autowired + @Qualifier(\u0026quot;bean的名称\u0026quot;) @Resource(name = \u0026quot;bean的名称\u0026quot;) 面试题\n@Resource和@Autowired的区别： @Autowired是spring框架提供的注解，而@Resource是JDK提供的注解。 @Autowired默认是按照类型注入，而@Resource默认是按照名称注入的。 ","permalink":"https://kennems.github.io/posts/tech/java-web%E5%BC%80%E5%8F%913/","summary":"Java Web开发(3) Maven Maven是一款管理和构建java项目的工具 依赖管理 统一的项目结构 项目构建 \u0026lt;maven.compiler.source\u0026gt;11\u0026lt;/maven.compiler.source\u0026gt; \u0026lt;maven.compiler.target\u0026gt;11\u0026lt;/maven.compiler.target\u0026gt; MVN坐标 Maven中的坐标是资源的唯一标","title":"Java Web开发(3)"},{"content":"Java Web开发(4) 数据库 数据库：DataBase(DB) ， 是存储和管理数据的仓库 DBMS， SQL MySql登录，首先在服务中启动mysql\nmysql -uroot -p\u0026#34;password\u0026#34; 或者\nmysql -uroot -p 之后输入密码\n连接远程数据库\nmysql -h192.168.88.130 -P3306 -utopeet -p\u0026#34;password\u0026#34; 查看当前的数据库\nselect database(); 关系型数据库（RDBMS）：建立在关系模型基础上，由多张相互连接的二维表组成的数据库\nSQL：一门操作关系型数据库的编程语言，定义操作所有关系型数据库的统一标准\nSQL语句可以单行或多行书写，以分号结尾 SQL语句可以使用空格/缩进来增强语句的可读性 MySQL数据库的SQL语句不区分大小写 注释： 单行注释： \u0026ndash; 注释内容 或者 #注释内容（MySQL特有） 多行注释：/* 注释内容 */ create database db02; DDL， DML， DQL， DCL\ncreate database if not exists db02; drop database if exists db03; show databases; select database(); show schemas; DDL 创建表 约束：\n非空约束 not null 唯一约束 unique 主键约束 primary key （auto_increment自增） 默认约束 default 外键约束 foreign key (至少有两张表) 数据类型 主要分为三类：数值类型，字符串类型，日期时间类型\n数值类型：\n类型 大小 有符号范围 无符号范围 描述 tinyint 1 （-128， 127） （0， 255） 小整数值 smallint 2 （-32768, 32767) （0, 65535) 大整数值 mediumint 3 （-8388608， 8388607） （0， 16777215） 大整数值 int 4 （-2147483647， 2147483648） （0， 4294967295） 大整数值 bigint 8 （-2^63, 2^63-1) （0， 2^64-1) 极大整数值 float 4 单精度浮点值 float(5, 2)表示整个数字长度为5， 小数位数为2 double 8 双精度浮点值 decimal 小数值（精度更高） 金额计算 查询当前数据库的所有表：\nshow tables; 查询表结构：\ndesc 表名 查询建表语句：\nshow create table 表名 -- 员工管理(带约束) create table tb_emp ( id int unsigned primary key auto_increment comment \u0026#39;ID\u0026#39;, username varchar(20) not null unique comment \u0026#39;用户名\u0026#39;, password varchar(32) default \u0026#39;123456\u0026#39; comment \u0026#39;密码\u0026#39;, name varchar(10) not null comment \u0026#39;姓名\u0026#39;, gender tinyint unsigned not null comment \u0026#39;性别, 说明: 1 男, 2 女\u0026#39;, image varchar(300) comment \u0026#39;图像\u0026#39;, job tinyint unsigned comment \u0026#39;职位, 说明: 1 班主任,2 讲师, 3 学工主管, 4 教研主管\u0026#39;, entrydate date comment \u0026#39;入职时间\u0026#39;, create_time datetime not null comment \u0026#39;创建时间\u0026#39;, update_time datetime not null comment \u0026#39;修改时间\u0026#39; ) comment \u0026#39;员工表\u0026#39;; alter table tb_emp add qq varchar(11) comment \u0026#39;QQ\u0026#39;; alter table tb_emp modify qq varchar(13) comment \u0026#39;QQ\u0026#39;; alter table tb_emp change qq qq_num varchar(13) comment \u0026#39;QQ\u0026#39;; alter table tb_emp drop column qq_num; rename table tb_emp to emp; drop table if exists tb_emp; DML Data Manipulation Language(数据操作语言)， 用来对数据库中表的数据记录进行增，删，改操作。\ninsert into tb_emp(username,name,gender,create_time,update_time) values (\u0026#39;Kennem\u0026#39;, \u0026#39;张无忌\u0026#39;, \u0026#39;1\u0026#39;,now(),now()); # 插入的内容包含所有字段（可以省略所有字段） insert into tb_emp(id, username, password, name, gender, image, job, entrydate, create_time, update_time) values (null, \u0026#39;zhiruo\u0026#39;, \u0026#39;123\u0026#39;, \u0026#39;kdkd\u0026#39;, 2, \u0026#39;1.jpg\u0026#39;, 1, \u0026#39;2021-01-20\u0026#39;,now(), now()); # 插入多组数据 insert into tb_emp(username, password, name, gender, image, job, entrydate, create_time, update_time) values (\u0026#39;Oliver\u0026#39;, \u0026#39;123\u0026#39;, \u0026#39;kdkd\u0026#39;, 2, \u0026#39;1.jpg\u0026#39;, 1, \u0026#39;2021-01-20\u0026#39;,now(), now()),(\u0026#39;Linux\u0026#39;, \u0026#39;123\u0026#39;, \u0026#39;kdkd\u0026#39;, 2, \u0026#39;1.jpg\u0026#39;, 1, \u0026#39;2021-01-20\u0026#39;,now(), now()); # 更新数据 update tb_emp set name = \u0026#39;张三\u0026#39;, update_time = now() where id = 1; # 更新所有数据的此字段 update tb_emp set entrydate = \u0026#39;2010-01-01\u0026#39;, update_time = now(); # 更新所有行 # 删除id=1的数据 delete from emp where id=1; # 删除所有数据 delete from emp; # delete不能删除某一字段的值，可以用update将这一字段设置为NULL DQL Data Query Language（数据查询语言）， 用来查询数据库表中的记录 关键字：SELECT select from where group by having order by limit 聚合函数：\ncount max min avg sum select name, entrydate from tb_emp; select tb_emp.id, tb_emp.username, tb_emp.password, tb_emp.name, tb_emp.gender, tb_emp.image, tb_emp.job, tb_emp.entrydate, tb_emp.create_time, tb_emp.update_time from tb_emp; select * from tb_emp; select name as 姓名, entrydate as 入职日期 from tb_emp; select name as \u0026#39;姓 名\u0026#39;, entrydate as 入职日期 from tb_emp; select distinct job from tb_emp; -- 选择tb_emp表中的name和entrydate字段 select name, entrydate from tb_emp; -- 选择tb_emp表中的所有字段，并且显式列出它们 select tb_emp.id, tb_emp.username, tb_emp.password, tb_emp.name, tb_emp.gender, tb_emp.image, tb_emp.job, tb_emp.entrydate, tb_emp.create_time, tb_emp.update_time from tb_emp; -- 选择tb_emp表中的所有字段（不直观，性能较低） select * from tb_emp; -- 选择tb_emp表中的name和entrydate字段，并将它们重命名为“姓名”和“入职日期” select name as 姓名, entrydate as 入职日期 from tb_emp; -- 选择tb_emp表中的name和entrydate字段，并将它们重命名为“姓 名”和“入职日期” select name \u0026#39;姓 名\u0026#39;, entrydate 入职日期 from tb_emp; -- 选择tb_emp表中不同的job字段值 select distinct job from tb_emp; -- 从tb_emp表中选择name为“杨逍”的记录 select * from tb_emp where name = \u0026#39;杨逍\u0026#39;; -- 从tb_emp表中选择id小于等于5的记录 select * from tb_emp where id \u0026lt;= 5; -- 从tb_emp表中选择job字段为null的记录 select * from tb_emp where job is null; -- 从tb_emp表中选择job字段不为null的记录 select * from tb_emp where job is not null; -- 从tb_emp表中选择password字段不等于“123456”的记录 select * from tb_emp where password != \u0026#39;123456\u0026#39;; -- 从tb_emp表中选择password字段不等于“123456”的记录（另一种写法） select * from tb_emp where password \u0026lt;\u0026gt; \u0026#39;123456\u0026#39;; -- 从tb_emp表中选择entrydate在2000-01-01到2010-01-01之间的记录 select * from tb_emp where entrydate \u0026gt;= \u0026#39;2000-01-01\u0026#39; and entrydate \u0026lt;= \u0026#39;2010-01-01\u0026#39;; -- 从tb_emp表中选择entrydate在2000-01-01到2010-01-01之间的记录（使用between） select * from tb_emp where entrydate between \u0026#39;2000-01-01\u0026#39; and \u0026#39;2010-01-01\u0026#39;; -- 重复的语句，选择entrydate在2000-01-01到2010-01-01之间的记录（使用between） select * from tb_emp where entrydate between \u0026#39;2000-01-01\u0026#39; and \u0026#39;2010-01-01\u0026#39;; -- 重复的语句，选择entrydate在2000-01-01到2010-01-01之间的记录 select * from tb_emp where entrydate \u0026gt;= \u0026#39;2000-01-01\u0026#39; and entrydate \u0026lt;= \u0026#39;2010-01-01\u0026#39;; -- 从tb_emp表中选择entrydate在2000-01-01到2010-01-01之间，且gender为2的记录 select * from tb_emp where entrydate \u0026gt;= \u0026#39;2000-01-01\u0026#39; and entrydate \u0026lt;= \u0026#39;2010-01-01\u0026#39; and gender = 2; -- 从tb_emp表中选择job为2、3或4的记录 select * from tb_emp where job = 2 or job = 3 or job = 4; -- 从tb_emp表中选择job在2, 3, 4中的记录（使用in） select * from tb_emp where job in (2, 3, 4); -- 使用通配符_表示单个字符，选择name字段长度为2的记录 select * from tb_emp where name like \u0026#39;__\u0026#39;; -- 使用通配符_表示单个字符，选择name字段长度为3的记录 select * from tb_emp where name like \u0026#39;___\u0026#39;; -- 使用通配符%表示任意个字符，选择name以“张”开头的记录 select * from tb_emp where name like \u0026#39;张%\u0026#39;; -- 计数id字段的非空值 select count(id) from tb_emp; -- 计数表中的记录数，常量\u0026#39;A\u0026#39;对计数没有影响 select count(\u0026#39;A\u0026#39;) from tb_emp; -- 推荐的计数表中记录数的写法 select count(*) from tb_emp; -- 选择tb_emp表中entrydate的最小值 select min(entrydate) from tb_emp; -- 选择tb_emp表中entry -- 选择tb_emp表中entrydate的最大值 select max(entrydate) from tb_emp; -- 计算tb_emp表中id字段的平均值 select avg(id) from tb_emp; -- 计算tb_emp表中id字段的总和 select sum(id) from tb_emp; -- 按gender字段分组，并计数每个性别的记录数 select gender, count(*) from tb_emp group by gender; -- 按job字段分组，并选择entrydate小于等于2015-01-01的记录 -- 只包括记录数大于等于2的组 select job, count(*) from tb_emp where entrydate \u0026lt;= \u0026#39;2015-01-01\u0026#39; group by job having count(*) \u0026gt;= 2; -- 从tb_emp表中选择所有字段，并按entrydate字段升序排序 select * from tb_emp order by entrydate; -- 从tb_emp表中选择所有字段，并按entrydate字段降序排序 select * from tb_emp order by entrydate DESC; -- 从tb_emp表中选择所有字段，先按entrydate字段升序排序， -- 对于相同entrydate的记录，再按update_time字段降序排序 select * from tb_emp order by entrydate, update_time DESC; -- 从tb_emp表中选择所有字段，分页显示 -- 第二页的记录，每页显示5条记录 -- 起始索引为5，即从第6条记录开始（索引从0开始） select * from tb_emp limit 5, 5; -- 从tb_emp表中选择所有字段，分页显示 -- 第三页的记录，每页显示5条记录 -- 起始索引为10，即从第11条记录开始（索引从0开始） select * from tb_emp limit 10, 5; 面试题 DQL-分组查询， where与having区别\n执行时机不同：where是分组之前进行过滤，不满足where条件，不参与分组，而having是分组之后对结果进行过滤 判断条件不同：where不能对聚合函数进行判断，而having可以 注意事项：\n分组之后，查询的字段一般为聚合函数和分组字段，查询其他字段没有意义 执行顺序： where \u0026gt; 聚合函数 \u0026gt; having 案例 -- 从tb_emp表中选择指定字段，满足以下条件： -- name包含“张”，gender为1，entrydate在2000-01-01到2015-12-31之间 -- 结果按update_time降序排序，并分页显示 -- 显示第2页的记录，每页10条记录，即从第11条到第20条记录 select tb_emp.id, tb_emp.username, tb_emp.password, tb_emp.name, tb_emp.gender, tb_emp.image, tb_emp.job, tb_emp.entrydate, tb_emp.create_time, tb_emp.update_time from tb_emp where name like \u0026#39;%张%\u0026#39; and gender = 1 and entrydate between \u0026#39;2000-01-01\u0026#39; and \u0026#39;2015-12-31\u0026#39; order by update_time DESC limit 10, 10; -- 使用IF函数，根据gender字段的值判断性别，并计数每个性别的记录数 -- 使用IF函数：如果gender为1，则显示“男性员工”；否则显示“女性员工” select if(gender = 1, \u0026#39;男性员工\u0026#39;, \u0026#39;女性员工\u0026#39;) 性别, count(*) 人数 from tb_emp group by gender; -- 使用CASE语句，根据job字段的值确定职位名称，并计数每个职位的记录数 -- 使用CASE语句：当job为1时，显示“班主任”；当job为2时，显示“讲师”； -- 当job为3时，显示“学工主管”；当job为4时，显示“教研主管”；否则显示“未分配职位” select (case job when 1 then \u0026#39;班主任\u0026#39; when 2 then \u0026#39;讲师\u0026#39; when 3 then \u0026#39;学工主管\u0026#39; when 4 then \u0026#39;教研主管\u0026#39; else \u0026#39;未分配职位\u0026#39; end) 职位, count(*) 人数 from tb_emp group by job; 多表设计 项目开发中，在进行数据表结构设计时，会根据业务需求及业务模块之间的关系，分析并设计表结构，由于业务之间相互关联，所以各个表结构之间也存在着各种联系\n一对多(多对一) 多对多 一对一 一对多 部门和员工 物理外键\n概念：使用foreign key定义外键关联另外一张表。 缺点： 影响增，删，改的效率（需要检查外键关系） 仅用于单节点数据库，不适用与分布式，集群场景 容易引发数据库的死锁问题，消耗性能 alter table tb_emp add constraint tb_emp___fk_dept_id foreign key (dept_id) references tb_dept (id); 逻辑外键\n概念：在业务逻辑中，解决外键关联 通过逻辑外键，就可以很方便的解决上述问题 一对一 案例：用户与身份证信息的关系\n关系：一对一关系，多用于单表拆分，将一张表的基础字段放在一张表中，其他字段放在另一张表中，以提升操作效率\n实现：在任意一方加入外键，关联另外一方，并且设置外键为唯一的（UNIQUE）\n-- 创建用户信息表 tb_user create table tb_user ( id int unsigned primary key auto_increment comment \u0026#39;ID\u0026#39;, -- 自增主键ID name varchar(10) not null comment \u0026#39;姓名\u0026#39;, -- 用户姓名 gender tinyint unsigned not null comment \u0026#39;性别, 1 男 2 女\u0026#39;, -- 性别，1表示男，2表示女 phone char(11) comment \u0026#39;手机号\u0026#39;, -- 手机号 degree varchar(10) comment \u0026#39;学历\u0026#39; -- 学历 ) comment \u0026#39;用户信息表\u0026#39;; -- 表注释 -- 插入用户信息表 tb_user 的数据 insert into tb_user values (1, \u0026#39;白眉鹰王\u0026#39;, 1, \u0026#39;18812340001\u0026#39;, \u0026#39;初中\u0026#39;), (2, \u0026#39;青翼蝠王\u0026#39;, 1, \u0026#39;18812340002\u0026#39;, \u0026#39;大专\u0026#39;), (3, \u0026#39;金毛狮王\u0026#39;, 1, \u0026#39;18812340003\u0026#39;, \u0026#39;初中\u0026#39;), (4, \u0026#39;紫衫龙王\u0026#39;, 2, \u0026#39;18812340004\u0026#39;, \u0026#39;硕士\u0026#39;); -- 创建用户详细信息表 tb_user_card create table tb_user_card ( id int unsigned primary key auto_increment comment \u0026#39;ID\u0026#39;, -- 自增主键ID nationality varchar(10) not null comment \u0026#39;民族\u0026#39;, -- 民族 birthday date not null comment \u0026#39;生日\u0026#39;, -- 生日 idcard char(18) not null comment \u0026#39;身份证号\u0026#39;, -- 身份证号 issued varchar(20) not null comment \u0026#39;签发机关\u0026#39;, -- 签发机关 expire_begin date not null comment \u0026#39;有效期限-开始\u0026#39;, -- 有效期限开始日期 expire_end date comment \u0026#39;有效期限-结束\u0026#39;, -- 有效期限结束日期 user_id int unsigned not null unique comment \u0026#39;用户ID\u0026#39;, -- 用户ID，唯一且非空 constraint fk_user_id foreign key (user_id) references tb_user (id) -- 外键约束，引用 tb_user 表的 id 字段 ) comment \u0026#39;用户信息表\u0026#39;; -- 表注释 -- 插入用户详细信息表 tb_user_card 的数据 insert into tb_user_card values (1, \u0026#39;汉\u0026#39;, \u0026#39;1960-11-06\u0026#39;, \u0026#39;100000100000100001\u0026#39;, \u0026#39;朝阳区公安局\u0026#39;, \u0026#39;2000-06-10\u0026#39;, null, 1), (2, \u0026#39;汉\u0026#39;, \u0026#39;1971-11-06\u0026#39;, \u0026#39;100000100000100002\u0026#39;, \u0026#39;静安区公安局\u0026#39;, \u0026#39;2005-06-10\u0026#39;, \u0026#39;2025-06-10\u0026#39;, 2), (3, \u0026#39;汉\u0026#39;, \u0026#39;1963-11-06\u0026#39;, \u0026#39;100000100000100003\u0026#39;, \u0026#39;昌平区公安局\u0026#39;, \u0026#39;2006-06-10\u0026#39;, null, 3), (4, \u0026#39;回\u0026#39;, \u0026#39;1980-11-06\u0026#39;, \u0026#39;100000100000100004\u0026#39;, \u0026#39;海淀区公安局\u0026#39;, \u0026#39;2008-06-10\u0026#39;, \u0026#39;2028-06-10\u0026#39;, 4); 多对多 案例：学生与课程的关系\n关系：一个学生可以选修多门课程，一门课程也可以供多个学生选择\n使用中间表来对应多对多的关系\n-- 创建学生表 tb_student create table tb_student ( id int auto_increment primary key comment \u0026#39;主键ID\u0026#39;, -- 自增主键ID name varchar(10) comment \u0026#39;姓名\u0026#39;, -- 学生姓名 no varchar(10) comment \u0026#39;学号\u0026#39; -- 学生学号 ) comment \u0026#39;学生表\u0026#39;; -- 表注释 -- 插入学生表 tb_student 的数据 insert into tb_student (name, no) values (\u0026#39;黛绮丝\u0026#39;, \u0026#39;2000100101\u0026#39;), (\u0026#39;谢逊\u0026#39;, \u0026#39;2000100102\u0026#39;), (\u0026#39;殷天正\u0026#39;, \u0026#39;2000100103\u0026#39;), (\u0026#39;韦一笑\u0026#39;, \u0026#39;2000100104\u0026#39;); -- 创建课程表 tb_course create table tb_course ( id int auto_increment primary key comment \u0026#39;主键ID\u0026#39;, -- 自增主键ID name varchar(10) comment \u0026#39;课程名称\u0026#39; -- 课程名称 ) comment \u0026#39;课程表\u0026#39;; -- 表注释 -- 插入课程表 tb_course 的数据 insert into tb_course (name) values (\u0026#39;Java\u0026#39;), (\u0026#39;PHP\u0026#39;), (\u0026#39;MySQL\u0026#39;), (\u0026#39;Hadoop\u0026#39;); -- 创建学生课程中间表 tb_student_course，用于表示学生和课程的多对多关系 create table tb_student_course ( id int auto_increment comment \u0026#39;主键\u0026#39; primary key, -- 自增主键ID student_id int not null comment \u0026#39;学生ID\u0026#39;, -- 学生ID，非空 course_id int not null comment \u0026#39;课程ID\u0026#39;, -- 课程ID，非空 constraint fk_courseid foreign key (course_id) references tb_course (id), -- 外键约束，引用 tb_course 表的 id 字段 constraint fk_studentid foreign key (student_id) references tb_student (id) -- 外键约束，引用 tb_student 表的 id 字段 ) comment \u0026#39;学生课程中间表\u0026#39;; -- 表注释 -- 插入学生课程中间表 tb_student_course 的数据，表示学生选择的课程 insert into tb_student_course (student_id, course_id) values (1, 1), -- 学生 ID 1 选择了课程 ID 1 (Java) (1, 2), -- 学生 ID 1 选择了课程 ID 2 (PHP) (1, 3), -- 学生 ID 1 选择了课程 ID 3 (MySQL) (2, 2), -- 学生 ID 2 选择了课程 ID 2 (PHP) (2, 3), -- 学生 ID 2 选择了课程 ID 3 (MySQL) (3, 4); -- 学生 ID 3 选择了课程 ID 4 (Hadoop) 案例 参考页面原型及需求，设计合理的表结构\n阅读页面原型及需求文档，分析各个模块涉及到的表结构，及表结构之间的关系 根据页面原型及需求文档，分析各个表结构中具体的字段及约束 总结 一对多\n在多的一方添加外键，关联另外一方的主键\n一对一\n任意一方，添加外键，关联另外一方的主键\n多对多\n通过中间表来维护，中间表的两个外键，分别关联另外两个表的主键\n多表查询 从多张表中查询数据\n分类\n连接查询 内连接：相当于查询A， B交集部分数据 -- 这是一个笛卡尔积查询，返回tb_emp和tb_dept表的所有组合。 select * from tb_emp, -- tb_emp 表（员工表） tb_dept; -- tb_dept 表（部门表） -- 这是一个内连接查询，返回tb_emp和tb_dept表中满足连接条件的所有记录。 select * from tb_emp, -- tb_emp 表（员工表） tb_dept -- tb_dept 表（部门表） where tb_emp.dept_id = tb_dept.id; -- 连接条件：tb_emp表中的dept_id等于tb_dept表中的id -- 这是一个内连接查询，只返回员工的姓名和所属部门的名称。 select tb_emp.name, -- tb_emp 表中的 name 列（员工姓名） tb_dept.name -- tb_dept 表中的 name 列（部门名称） from tb_emp, -- tb_emp 表（员工表） tb_dept -- tb_dept 表（部门表） where tb_emp.dept_id = tb_dept.id; -- 连接条件：tb_emp表中的dept_id等于tb_dept表中的id -- 这是一个使用INNER JOIN关键字的内连接查询，返回员工的姓名和所属部门的名称。 select tb_emp.name, -- tb_emp 表中的 name 列（员工姓名） tb_dept.name -- tb_dept 表中的 name 列（部门名称） from tb_emp -- tb_emp 表（员工表） inner join tb_dept -- tb_dept 表（部门表），使用INNER JOIN关键字进行连接 on tb_emp.dept_id = tb_dept.id; -- 连接条件：tb_emp表中的dept_id等于tb_dept表中的id -- 这是一个使用JOIN关键字的内连接查询，返回员工的姓名和所属部门的名称。 select tb_emp.name, -- tb_emp 表中的 name 列（员工姓名） tb_dept.name -- tb_dept 表中的 name 列（部门名称） from tb_emp -- tb_emp 表（员工表） join tb_dept -- tb_dept 表（部门表），使用JOIN关键字进行连接 on tb_emp.dept_id = tb_dept.id; -- 连接条件：tb_emp表中的dept_id等于tb_dept表中的id -- 这是一个使用表别名的内连接查询，返回员工的姓名和所属部门的名称。 select e.name, -- e 表（tb_emp 表的别名）中的 name 列（员工姓名） p.name -- p 表（tb_dept 表的别名）中的 name 列（部门名称） from tb_emp e, -- tb_emp 表（员工表），起别名为 e tb_dept p -- tb_dept 表（部门表），起别名为 p where e.dept_id = p.id; -- 连接条件：e 表（tb_emp 表）的 dept_id 等于 p 表（tb_dept 表）的 id 外连接： 左外连接：查询左表所有数据（包括两张表交集部分数据 右外连接：查询右表所有数据（包括两张表交集部分数据） -- 左连接：查询所有员工及其所属部门的名称，包含没有部门的员工 select e.name, -- e 表（tb_emp 表的别名）中的 name 列（员工姓名） p.name -- p 表（tb_dept 表的别名）中的 name 列（部门名称） from tb_emp e -- tb_emp 表（员工表），起别名为 e left join tb_dept p on e.dept_id = p.id; -- 左连接：tb_emp表中的dept_id等于tb_dept表中的id -- 右连接：查询所有部门及其员工的姓名，包含没有员工的部门 select e.name, -- e 表（tb_emp 表的别名）中的 name 列（员工姓名） p.name -- p 表（tb_dept 表的别名）中的 name 列（部门名称） from tb_emp e -- tb_emp 表（员工表），起别名为 e right join tb_dept p on e.dept_id = p.id; -- 右连接：tb_emp表中的dept_id等于tb_dept表中的id -- 左连接：查询所有部门及其员工的姓名，包含没有员工的部门（和上面的右连接查询结果相同） select e.name, -- e 表（tb_emp 表的别名）中的 name 列（员工姓名） p.name -- p 表（tb_dept 表的别名）中的 name 列（部门名称） from tb_dept p -- tb_dept 表（部门表），起别名为 p left join tb_emp e on p.id = e.dept_id; -- 左连接：tb_dept表中的id等于tb_emp表中的dept_id 子查询 -- 子查询：查询id等于教研部的部门id的员工信息 select * from tb_emp -- tb_emp 表（员工表） where id = (select id from tb_dept where tb_dept.name = \u0026#39;教研部\u0026#39;); -- 子查询：从tb_dept表中选择名称为\u0026#39;教研部\u0026#39;的部门id -- 标量子查询：查询入职日期晚于方东白的员工信息 select * from tb_emp -- tb_emp 表（员工表） where entrydate \u0026gt; (select tb_emp.entrydate from tb_emp where name = \u0026#39;方东白\u0026#39;); -- 子查询：从tb_emp表中选择名称为\u0026#39;方东白\u0026#39;的员工入职日期 -- 列子查询：查询部门为教研部或咨询部的员工信息 select * from tb_emp -- tb_emp 表（员工表） where dept_id in (select id from tb_dept where name in (\u0026#39;教研部\u0026#39;, \u0026#39;咨询部\u0026#39;)); -- 子查询：从tb_dept表中选择名称为\u0026#39;教研部\u0026#39;或\u0026#39;咨询部\u0026#39;的部门id -- 行子查询：查询入职日期和职位均与韦一笑相同的员工信息 select * from tb_emp -- tb_emp 表（员工表） where entrydate = (select entrydate from tb_emp where name = \u0026#39;韦一笑\u0026#39;) -- 子查询：从tb_emp表中选择名称为\u0026#39;韦一笑\u0026#39;的员工入职日期 and job = (select job from tb_emp where name = \u0026#39;韦一笑\u0026#39;); -- 子查询：从tb_emp表中选择名称为\u0026#39;韦一笑\u0026#39;的员工职位 -- 行子查询的另一种写法：查询入职日期和职位均与韦一笑相同的员工信息 select * from tb_emp -- tb_emp 表（员工表） where (entrydate, job) = (select entrydate, job from tb_emp where name = \u0026#39;韦一笑\u0026#39;); -- 子查询：从tb_emp表中选择名称为\u0026#39;韦一笑\u0026#39;的员工入职日期和职位 -- 表子查询：查询入职日期在2006-01-01之后的员工信息 select * from tb_emp -- tb_emp 表（员工表） where entrydate \u0026gt; \u0026#39;2006-01-01\u0026#39;; -- 条件：入职日期在2006-01-01之后 -- 表子查询的另一种写法：查询入职日期在2006-01-01之后的员工及其所属部门信息 select * from (select * from tb_emp where entrydate \u0026gt; \u0026#39;2006-01-01\u0026#39;) e, -- 子查询：从tb_emp表中选择入职日期在2006-01-01之后的员工，并起别名为 e tb_dept p -- tb_dept 表（部门表），起别名为 p where e.dept_id = p.id; -- 连接条件：子查询结果的dept_id等于tb_dept表中的id 案例 对菜品(dish)， 套餐(setmeal)，类别(category)，菜品和套餐(setmeal_dish)对应关系表进行多表查询\n-- 查询价格低于10元的菜品的名称和价格 SELECT d.name, d.price FROM dish d WHERE d.price \u0026lt; 10; -- 查询价格低于10元的菜品的名称、价格以及所属分类的名称 SELECT d.name, d.price, c.name FROM dish d, category c WHERE d.category_id = c.id -- 使用category_id连接菜品和分类 AND d.price \u0026lt; 10; -- 过滤价格低于10元的菜品 -- 查询价格在10到50元之间且状态为1的菜品的名称、价格以及所属分类的名称 SELECT d.name, d.price, c.name FROM dish d LEFT JOIN category c ON d.category_id = c.id -- 左连接，包含所有菜品，即使它们没有分类 WHERE d.price BETWEEN 10 AND 50 -- 过滤价格在10到50元之间的菜品 AND d.status = 1; -- 过滤状态为1的菜品 -- 查询所有有菜品的分类的名称，按分类名称分组 SELECT c.name FROM dish d, category c WHERE d.category_id = c.id -- 使用category_id连接菜品和分类 GROUP BY c.name; -- 按分类名称分组，获取唯一的分类名称 -- 查询有3个或更多菜品的分类的名称及其菜品数量 SELECT c.name, COUNT(*) FROM dish d, category c WHERE d.category_id = c.id -- 使用category_id连接菜品和分类 GROUP BY c.name -- 按分类名称分组，计算每个分类的菜品数量 HAVING COUNT(*) \u0026gt;= 3; -- 仅包含菜品数量大于或等于3的分类 -- 查询每个分类的名称及其菜品的最高价格 SELECT c.name, MAX(d.price) FROM dish d, category c WHERE d.category_id = c.id -- 使用category_id连接菜品和分类 GROUP BY c.name; -- 按分类名称分组，获取每个分类的最高价格 -- 查询名为\u0026#39;商务套餐A\u0026#39;的套餐及其菜品的名称、价格和份数 SELECT s.name, s.price, d.name, d.price, sd.copies FROM setmeal s, setmeal_dish sd, dish d WHERE s.id = sd.setmeal_id -- 使用setmeal_id连接套餐和套餐菜品 AND sd.dish_id = d.id -- 使用dish_id连接套餐菜品和菜品 AND s.name = \u0026#39;商务套餐A\u0026#39;; -- 过滤出名称为\u0026#39;商务套餐A\u0026#39;的套餐 -- 查询价格低于所有菜品平均价格的菜品的所有列 SELECT * FROM dish WHERE price \u0026lt; (SELECT AVG(d.price) FROM dish d); -- 子查询获取所有菜品的平均价格 事物 事物是一组操作的集合，它是一个不可分割的工作单位， 事物会把所有的操作作为一个整体一起向系统提交或撤销操作请求，即这些操作要么同时成功， 要么同时失败。\nstart transaction; delete from tb_dept where id = 2; delete from tb_emp where dept_id = 2; commit; -- 如果在事务中的语句出现了问题， 则不能直接提交，需要回滚保证所有语句都没有问题 rollback; 四大特性 ACID\n原子性（Atomicity）：事务是不可分割的最小单元，要么全部成功，要么全部失败 一致性（Consistency）：事物完成后， 必须使所有的数据都保持一致状态 隔离性（Isolation）：数据库系统提供的隔离机制，保证事物在不受外部并发操作影响的独立环境下运行 持久性（Durability）：事物一旦提交或回滚，它对数据库中的数据的改变就是永久的 数据库优化 索引（index）：是帮助数据库高效获取数据的数据结构\n索引优缺点： 优点：\n提高数据查询的效率，降低数据库的IO成本 通过索引列对数据进行排序，降低数据排序的成本，降低CPU消耗 缺点：\n索引会占用存储空间 索引大大提高了查询效率，同时也降低了insert, update, delete的效率 索引的数据结构 MySQL数据库支持的索引结构有很多， 如：Hash索引， B+Tree索引， Full-Test索引等。如果没有特别指明，都是指默认的B+Tree结构组织的索引。\n页是数据库存储的最小单位，一个页为16KB\nB+Tree(多路平衡搜索树) 每个节点可以存储多个Key， 所有的Key都会在叶子节点中出现\n每个节点，可以存储多个key（有n个key， 就有n个指针）。 所有的数据都存储在叶子节点内，非叶子节点仅用于索引数据。 叶子节点形成了一颗双向链表，便于数据的排序及区间范围查询。 索引创建的SQL -- 在tb_emp表的name列上创建索引idx_tb_emp_name CREATE INDEX idx_tb_emp_name ON tb_emp(name); -- 显示tb_emp表中的所有索引 SHOW INDEX FROM tb_emp; -- 删除tb_emp表上的索引idx_tb_emp_name DROP INDEX idx_tb_emp_name ON tb_emp; ","permalink":"https://kennems.github.io/posts/tech/java-web%E5%BC%80%E5%8F%914/","summary":"Java Web开发(4) 数据库 数据库：DataBase(DB) ， 是存储和管理数据的仓库 DBMS， SQL MySql登录，首先在服务中启动mysql mysql -uroot -p\u0026#34;password\u0026#34;","title":"Java Web开发(4)"},{"content":"Java Web开发(1) 什么是Web？ Web：全球广域网，也成为万维网（World Wide Web)，能够通过浏览器访问的网站 CRM OA ERP\n不谋全局者不足以谋一域\n前后端分离开发\n混合开发\nWeb标准也成为网页标准，有一系列的标准组成，大部分由W3C（万维网联盟）负责制定\n三个部分 HTML：负责网页的结果（页面元素和内容） CSS：负责网页的表现（页面元素的外观，位置等页面样式，如：颜色，大小等） JavaScript：负责网页的行为（交互效果） 什么是HTML，CSS？ HTML（HyperTextMarkupLanguage):超文本标记语言。 超文本：超越了文本的限制，比普通文本更强大。 标记语言：由标签构成的语言 HTML标签都是预定义号的。例如：使用\u0026lt;a\u0026gt;展示超链接，使用\u0026lt;img\u0026gt;展示图片，\u0026lt;video\u0026gt;展示视频。 HTML代码直接在浏览器中允许，HTML标签由浏览器解析。 标签不区分大小，单双引号都可以，语法结构比较松散\nCSS CSS（Cascading Style Sheet）：层叠样式表，用于控制页面的样式（表现） CSS引入方式： 行内样式：写在标签的style属性中（不推荐） 内嵌样式：写在style标签中（可以写在页面任何位置，但通常约定写在head标签中） 外联样式，写在一个单独的.css文件中（需要通过link标签在网页中引入） 颜色标识法： 关键字：预定义的颜色名（red, green, blue) rgb表示法：红绿蓝三原色，每项取值范围：0~255 十六进制表示法：#开头，将数字转换成十六进制表示，#000000， #ff0000, #cccccc， 简写为#000， #ccc \u0026lt;span\u0026gt;标签\n大量使用没有语义的布局标签 特点：一行可以显示多个（组合行内元素），宽度和高度默认由内容撑开 CSS选择器 元素选择器：标签名{\u0026hellip;} id选择器：#id属性值{\u0026hellip;} 类选择器：.class属性值{\u0026hellip;} 优先级：id选择器 \u0026gt; 类选择器 \u0026gt; 元素选择器 CSS属性 color， font-size(单位px) 超链接\n标签：\u0026lt;a\u0026gt; 属性：href：制定资源访问url target:指定在何处打开资源链接 _self：默认值，在当前页面打开 _blank：在空白页面打开 CSS属性\ntext-decoration:规定添加到文本的修饰，none表示定义标准的文本 color：定义文本的颜色 音频，视频标签\n\u0026lt;audio\u0026gt; \u0026lt;video\u0026gt; 换行，段落标签\n\u0026lt;br\u0026gt;, \u0026lt;p\u0026gt; 文本加粗标签\n\u0026lt;b\u0026gt;, \u0026lt;strong\u0026gt; CSS样式 line-height: 设置行高\ntext-indent: 定义第一个行内容的缩进\ntext-align:规定元素中的文本的水平对齐方式\nhtml中的空格占位符 \u0026amp;nbsp;\n页面布局 盒子：页面中的所有元素（标签），都可以看成一个盒子， 由盒子将页面中的元素包含在一个矩形区域内，通过盒子的视角更方便的进行页面布局\n盒子模型组成：内容区域（content）， 内边距区域（padding），边框区域（border），外边距区域(margin)\n布局标签：实际开发网页中，会大量频繁的使用div和span这两个没有语义的布局标签\n标签：\u0026lt;div\u0026gt;``\u0026lt;span\u0026gt;\n特点：\ndiv标签： 一行只显示一个（独占一行） 宽度默认是父元素的宽度，高度默认由内容撑开 可以设置宽高（width, height) span标签 一行可以显示多个 宽度和高度默认由内容撑开 不可设置宽高（width, height) 注意：如果只需要设置某一个方位的边框，内边距，外边距，可以在属性后米娜加上-位置， 例如：padding-top, padding-left, padding-right。\n表格标签 场景：在网页中以表格（行、列）形式整齐展示数据 标签 \u0026lt;table\u0026gt; 定义表格整体，可以包裹多个\u0026lt;tr\u0026gt; border:规定表格边框的宽度 width：规定表格的宽度 cellspacing：规定单元之间的空间 \u0026lt;tr\u0026gt;表格的行，可以包裹多个\u0026lt;td\u0026gt; \u0026lt;td\u0026gt;表格单元格（普通）， 可以包裹内容 \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html lang=\u0026#34;en\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;UTF-8\u0026#34;\u0026gt; \u0026lt;meta http-equiv=\u0026#34;X-UA-Compatible\u0026#34; content=\u0026#34;IE=edge\u0026#34;\u0026gt; \u0026lt;meta name=\u0026#34;viewport\u0026#34; content=\u0026#34;width=device-width, initial-scale=1.0\u0026#34;\u0026gt; \u0026lt;title\u0026gt;HTML-表格\u0026lt;/title\u0026gt; \u0026lt;style\u0026gt; /* 样式美化 */ td { text-align: center; /* 让单元格内容居中展示 */ } \u0026lt;/style\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;table border=\u0026#34;1px\u0026#34; cellspacing=\u0026#34;0\u0026#34; width=\u0026#34;600px\u0026#34;\u0026gt; \u0026lt;tr\u0026gt; \u0026lt;!-- 表头 --\u0026gt; \u0026lt;th\u0026gt;序号\u0026lt;/th\u0026gt; \u0026lt;th\u0026gt;品牌Logo\u0026lt;/th\u0026gt; \u0026lt;th\u0026gt;品牌名称\u0026lt;/th\u0026gt; \u0026lt;th\u0026gt;企业名称\u0026lt;/th\u0026gt; \u0026lt;/tr\u0026gt; \u0026lt;tr\u0026gt; \u0026lt;!-- 第一行数据 --\u0026gt; \u0026lt;td\u0026gt;1\u0026lt;/td\u0026gt; \u0026lt;td\u0026gt; \u0026lt;img src=\u0026#34;img/huawei.jpg\u0026#34; width=\u0026#34;100px\u0026#34;\u0026gt; \u0026lt;/td\u0026gt; \u0026lt;!-- 插入图片 --\u0026gt; \u0026lt;td\u0026gt;华为\u0026lt;/td\u0026gt; \u0026lt;td\u0026gt;华为技术有限公司\u0026lt;/td\u0026gt; \u0026lt;/tr\u0026gt; \u0026lt;tr\u0026gt; \u0026lt;!-- 第二行数据 --\u0026gt; \u0026lt;td\u0026gt;2\u0026lt;/td\u0026gt; \u0026lt;td\u0026gt; \u0026lt;img src=\u0026#34;img/alibaba.jpg\u0026#34; width=\u0026#34;100px\u0026#34;\u0026gt; \u0026lt;/td\u0026gt; \u0026lt;!-- 插入图片 --\u0026gt; \u0026lt;td\u0026gt;阿里\u0026lt;/td\u0026gt; \u0026lt;td\u0026gt;阿里巴巴集团控股有限公司\u0026lt;/td\u0026gt; \u0026lt;/tr\u0026gt; \u0026lt;/table\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; 表单标签 场景：在网页中主要负责数据采集功能，如 注册，登录等数据采集。\n标签：\u0026lt;form\u0026gt;\n表单项：不同类型的input元素，下俩列表，文本域等\n\u0026lt;input\u0026gt;: 定义表单项，通过type属性控制输入形式\n\u0026lt;select\u0026gt;：定义下拉列表\n\u0026lt;textarea\u0026gt;：定义文本域\n属性：\naction：规定当提交表单时向何处发送表单数据，URL\nmethod：规定用于发送表单数据的方式。\nGET表单数据拼接在url后面， 大小有限制 POST表单数据在请求体中携带，大小没有限制 表单必须由name属性\n\u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html lang=\u0026#34;en\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;UTF-8\u0026#34;\u0026gt; \u0026lt;meta http-equiv=\u0026#34;X-UA-Compatible\u0026#34; content=\u0026#34;IE=edge\u0026#34;\u0026gt; \u0026lt;meta name=\u0026#34;viewport\u0026#34; content=\u0026#34;width=device-width, initial-scale=1.0\u0026#34;\u0026gt; \u0026lt;title\u0026gt;HTML-表单\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;!-- form表单属性: action: 表单提交的URL，数据将会被提交到指定的URL地址。如果未指定，将默认提交到当前页面。 method: 表单的提交方式。 get: 将表单数据附加在URL后面，例如：?username=Tom\u0026amp;age=12。由于URL长度有限制，适合传递少量数据。默认值。 post: 将表单数据包含在消息体（请求体）中传递，没有参数大小限制，适合传递大量数据。 --\u0026gt; \u0026lt;form action=\u0026#34;\u0026#34; method=\u0026#34;post\u0026#34;\u0026gt; \u0026lt;!-- 输入框 --\u0026gt; 用户名: \u0026lt;input type=\u0026#34;text\u0026#34; name=\u0026#34;username\u0026#34;\u0026gt; 年龄: \u0026lt;input type=\u0026#34;text\u0026#34; name=\u0026#34;age\u0026#34;\u0026gt; 性别: \u0026lt;input type=\u0026#34;text\u0026#34; name=\u0026#34;sex\u0026#34;\u0026gt; \u0026lt;!-- 提交按钮 --\u0026gt; \u0026lt;input type=\u0026#34;submit\u0026#34; value=\u0026#34;提交\u0026#34;\u0026gt; \u0026lt;/form\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; 表单项 \u0026lt;input\u0026gt; ：表单项：通过type属性控制输入形式。 \u0026lt;select\u0026gt;：定义下拉列表，\u0026lt;option\u0026gt;定义列表项 \u0026lt;textarea\u0026gt;：文本域 \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html lang=\u0026#34;en\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;UTF-8\u0026#34;\u0026gt; \u0026lt;meta name=\u0026#34;viewport\u0026#34; content=\u0026#34;width=device-width, initial-scale=1.0\u0026#34;\u0026gt; \u0026lt;title\u0026gt;标题\u0026lt;/title\u0026gt; \u0026lt;!-- 内嵌样式 --\u0026gt; \u0026lt;style\u0026gt; /* CSS样式 */ h1 { color: #4d4f53; /* 设置标题颜色 */ } \u0026lt;/style\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;div id=\u0026#34;center\u0026#34;\u0026gt; \u0026lt;!-- 页面内容 --\u0026gt; \u0026lt;h1\u0026gt;标题\u0026lt;/h1\u0026gt; \u0026lt;!-- 标题 --\u0026gt; \u0026lt;hr\u0026gt; \u0026lt;!-- 水平分割线 --\u0026gt; \u0026lt;span id=\u0026#34;time\u0026#34;\u0026gt;2024年04月24日 16:32\u0026lt;/span\u0026gt; \u0026lt;!-- 时间 --\u0026gt; \u0026lt;hr\u0026gt; \u0026lt;!-- 水平分割线 --\u0026gt; \u0026lt;!-- 视频和音频播放器 --\u0026gt; \u0026lt;video src=\u0026#34;video\\1.mp4\u0026#34; controls width=\u0026#34;950px\u0026#34;\u0026gt;\u0026lt;/video\u0026gt; \u0026lt;audio src=\u0026#34;audio\\1.mp3\u0026#34; controls\u0026gt;\u0026lt;/audio\u0026gt; \u0026lt;!-- 文章内容 --\u0026gt; \u0026lt;p\u0026gt; 标题 \u0026lt;!-- 更多内容省略... --\u0026gt; \u0026lt;/p\u0026gt; \u0026lt;!-- 图片 --\u0026gt; \u0026lt;img src=\u0026#34;https://n.sinaimg.cn/sinakd20240424s/66/w554h312/20240424/6365-b8bea506131b4261f579f58304a45baa.png\u0026#34;\u0026gt; \u0026lt;!-- 更多内容省略... --\u0026gt; \u0026lt;!-- 责任编辑 --\u0026gt; \u0026lt;p id=\u0026#34;plast\u0026#34;\u0026gt; 责任编辑：xxx \u0026lt;/p\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; JavaScript JS是一门跨平台，面向对象的脚本语言。用来控制网页行为的，它能使网页可以交互 JavaScript引入方式 内部脚本：将JS代码定义在HTMl页面中\nJavaScript代码必须位于\u0026lt;script\u0026gt;``\u0026lt;/script\u0026gt;标签之间 在HTML文档中，可以在任意地方，放置任意数量的\u0026lt;script\u0026gt; 一般会把脚本置于\u0026lt;body\u0026gt;元素的底部，可改善显示速度 外部脚本：将JS代码定义在外部JS文件中，然后引入到HTML页面中\n外部JS文件中，只包含JS代码，不包含\u0026lt;script\u0026gt;标签 \u0026lt;script\u0026gt;标签不能自闭和 书写语法： 区分大小写 每行结尾的分号可有可无 注释 单行注释：//注释内容 多行注释：/* 注释内容 */ 大括号表示代码块 JS输出 \u0026lt;script\u0026gt; // alert(\u0026#34;H\u0026#34;) // /* 注释*/ // window.alert(\u0026#34;hello js\u0026#34;) document.write(\u0026#34;hi\u0026#34;) console.log(\u0026#34;hello\u0026#34;) \u0026lt;/script\u0026gt; 变量 JS中使用var关键字来声明变量 JS是一门弱类型语言，变量可以存放不同类型的值 变量名需要遵循如下规则： 组成字符可以是任何字母，数字，下划线(_)或者美元符号($) 数字不能开头 建议使用驼峰命名 原始数据类型：\nnumber：数字（整数，小数NaN) string : 字符串， 单双引号皆可 boolean：布尔， true, false null : 对象为空 undefined：为初始化时，默认值时undefined \u0026lt;script\u0026gt; // 注释示例 // 注释可以在代码中加入说明性文字，不会被执行 // 弹出对话框，显示\u0026#34;hello js\u0026#34; window.alert(\u0026#34;hello js\u0026#34;); // 在文档中写入\u0026#34;hi\u0026#34; document.write(\u0026#34;hi\u0026#34;); // 在控制台输出\u0026#34;hello\u0026#34; console.log(\u0026#34;hello\u0026#34;); \u0026lt;/script\u0026gt; \u0026lt;script\u0026gt; // 变量声明和赋值 var a = 10; a = \u0026#34;zs\u0026#34;; // 变量类型可以动态改变 alert(a); // 弹出\u0026#34;zs\u0026#34; // 使用let声明的变量具有块级作用域 { let x = 1; alert(x); // 弹出\u0026#34;1\u0026#34; } // 使用const声明常量，常量值不可修改 const pi = 3.14; pi = 3.15; // 会报错，常量值不可修改 alert(pi); // 弹出\u0026#34;3.14\u0026#34; \u0026lt;/script\u0026gt; \u0026lt;script\u0026gt; // typeof操作符用于检测变量或表达式的数据类型 alert(typeof 3); // 弹出\u0026#34;number\u0026#34; alert(typeof 3.14); // 弹出\u0026#34;number\u0026#34; alert(typeof \u0026#34;A\u0026#34;); // 弹出\u0026#34;string\u0026#34; alert(typeof true); // 弹出\u0026#34;boolean\u0026#34; alert(typeof null); // 弹出\u0026#34;object\u0026#34;，null被误判为object var a; alert(typeof a); // 弹出\u0026#34;undefined\u0026#34; \u0026lt;/script\u0026gt; \u0026lt;script\u0026gt; // 逻辑运算符 \u0026amp;\u0026amp; 和 || 的使用 if (0 \u0026amp;\u0026amp; NaN \u0026amp;\u0026amp; 1) { alert(\u0026#34;ok1\u0026#34;); // 不会执行，因为NaN为假 } if (0 || NaN || 1) { alert(\u0026#34;ok2\u0026#34;); // 执行，因为除了0和NaN外，其他都为真 } // 空字符串和空格字符串为真，null和undefined为假 if (\u0026#34;\u0026#34;) { alert(\u0026#34;字符串为真\u0026#34;); } if (\u0026#34; \u0026#34;) { alert(\u0026#34;字符串为真\u0026#34;); } if (null) { alert(\u0026#34;null为真\u0026#34;); } if (undefined) { alert(\u0026#34;undefined为真\u0026#34;); } \u0026lt;/script\u0026gt; \u0026lt;script\u0026gt; // 函数声明和函数表达式 // function add(a, b) { // return a + b; // } var add = function (a, b) { return a + b; } var res = add(1, 2, 5, 6); // 多余的参数会被忽略 alert(res); // 弹出\u0026#34;3\u0026#34;，因为只计算了前两个参数的和 \u0026lt;/script\u0026gt; JS对象 Array \u0026lt;script\u0026gt; // 创建数组的两种方式：使用Array构造函数和直接使用数组字面量 // var arr = new Array(1, 2, 3, 4); // console.log(arr); // 输出数组[1, 2, 3, 4] // console.log(arr[1]); // 输出数组索引为1的元素值，即2 // 使用数组字面量创建数组，并添加元素 var arr = [1, 2, 3, 4]; arr[10] = 10; // 添加元素到索引为10的位置 // console.log(arr[10]); // 输出数组索引为10的元素值，即10 // console.log(arr[9]); // 输出数组索引为9的元素值，由于未定义，默认为undefined arr[9] = \u0026#34;A\u0026#34;; // 修改索引为9的元素值为\u0026#34;A\u0026#34; arr[8] = \u0026#34;a;dlsfjakldjf\u0026#34;; // 修改索引为8的元素值 // console.log(arr[8]); // 输出数组索引为8的元素值 // console.log(arr[9]); // 输出数组索引为9的元素值 // 遍历数组的方式：for循环、forEach方法 // for (let i = 0; i \u0026lt; arr.length; i++) { // console.log(arr[i]); // 使用for循环遍历数组元素并输出 // } // arr.forEach(function (e) { // console.log(e); // 使用forEach方法遍历数组元素并输出 // }); // arr.forEach(e =\u0026gt; { // console.log(e); // 使用箭头函数和forEach方法遍历数组元素并输出 // }); // 向数组末尾添加元素：push方法 arr.push(7, 8, 9); arr.forEach(e =\u0026gt; { console.log(e); // 输出添加后的数组元素 }); console.log(\u0026#34;-----------\u0026#34;); // 从数组中删除元素：splice方法 arr.splice(1, 3); // 从索引为1的位置开始删除3个元素 arr.forEach(e =\u0026gt; { console.log(e); // 输出删除后的数组元素 }); \u0026lt;/script\u0026gt; String // 创建一个 String 对象并赋值为 \u0026#34;abc\u0026#34; var str1 = new String(\u0026#34;abc\u0026#34;); // 直接创建一个字符串变量并赋值为 \u0026#34; abccba \u0026#34; var str2 = \u0026#34; abccba \u0026#34;; // 打印字符串 str1 和 str2 console.log(str1); console.log(str2); // 输出 str1 的长度，即字符串中字符的个数 console.log(str1.length); // 返回 str1 中索引为 1 的字符，索引从 0 开始 console.log(str1.charAt(1)); // 返回指定字符在 str1 中第一次出现的位置，如果找不到则返回 -1 console.log(str1.indexOf(\u0026#34;c\u0026#34;)); // 去除字符串 str2 开头和结尾的空白字符，并赋值给变量 s var s = str2.trim(); console.log(s); // 返回 str1 中索引从 0 到 4（不包括 4）的子字符串 console.log(str1.substring(0, 4)); JSON Java Script Object Notation, JavaScript对象标记法 JSON是通过JavaScript对象标记法书写的文本 由于其语法简单，层次结构鲜明，现在多用于数据载体，在网络中进行数据传输 // 创建一个名为 user 的对象，包含 name、age、gender 和 intro 方法 var user = { name: \u0026#34;Tom\u0026#34;, age: 10, gender: \u0026#34;male\u0026#34;, intro: function () { alert(\u0026#34;I am \u0026#34; + this.name + \u0026#34; and I am \u0026#34; + this.age + \u0026#34; years old.\u0026#34;); } // 另一种定义方法的方式 // intro() { // alert(\u0026#34;I am \u0026#34; + this.name + \u0026#34; and I am \u0026#34; + this.age + \u0026#34; years old.\u0026#34;); // } } // 弹出 user 对象的 name 属性值 alert(user.name); // 调用 user 对象的 intro 方法，弹出一段介绍信息 user.intro(); // 创建一个 JSON 字符串 var jsonstr = \u0026#39;{\u0026#34;name\u0026#34;:\u0026#34;Tom\u0026#34;, \u0026#34;age\u0026#34;:10, \u0026#34;addr\u0026#34;:[\u0026#34;青岛\u0026#34;, \u0026#34;南京\u0026#34;]}\u0026#39;; // 使用 JSON.parse() 方法解析 JSON 字符串，并将其转换为 JavaScript 对象 var obj = JSON.parse(jsonstr); // 弹出解析后对象的 name 属性值 alert(obj.name); // 使用 JSON.stringify() 方法将 JavaScript 对象转换为 JSON 字符串，并弹出 alert(JSON.stringify(obj)); BOM 概念：Browser Object Model， 浏览器对象模型， 允许JavaScript与浏览器对话，JavaScript将浏览器的各个组成部分封装成对象。 Window 浏览器窗口对象 获取：直接使用window，其中window.可以成略 Location 地址栏对象 获取：使用window.location， 其中window.可以省略 // 弹出一个警告框显示 \u0026#34;Hello BOMWINDOWS\u0026#34; window.alert(\u0026#34;Hello BOMWINDOWS\u0026#34;); // 弹出一个警告框显示 \u0026#34;Hello BOM\u0026#34; alert(\u0026#34;Hello BOM\u0026#34;); // 弹出一个确认框，并根据用户的选择返回一个布尔值，true 表示确认，false 表示取消 var flag = confirm(\u0026#34;你确认删除吗？\u0026#34;); alert(flag); // 设置一个间隔定时器，每隔 2000 毫秒（2 秒）执行一次匿名函数，并在控制台打印执行次数 var i = 0; setInterval(function () { i += 1; console.log(\u0026#34;定时器执行了:\u0026#34; + i + \u0026#34;次\u0026#34;); }, 2000); // 设置一个定时器，在 2000 毫秒后弹出一个警告框显示 \u0026#34;Hello\u0026#34; setTimeout(function () { alert(\u0026#34;Hello\u0026#34;); }, 2000); // 弹出一个警告框显示当前页面的 URL alert(location.href); // 重定向当前页面到指定 URL location.href = \u0026#34;https://www.itcast.cn\u0026#34;; DOM Decument Object Model, 文档对象模型 将标记语言的各个部分封装为对应的对象 // 获取 id 为 \u0026#39;h1\u0026#39; 的元素 var img = document.getElementById(\u0026#39;h1\u0026#39;); alert(img); // 获取所有标签名为 \u0026#39;div\u0026#39; 的元素并弹出 var divs = document.getElementsByTagName(\u0026#39;div\u0026#39;); for (let i = 0; i \u0026lt; divs.length; i++) { alert(divs[i]); } // 获取所有 name 属性为 \u0026#39;hobby\u0026#39; 的元素并弹出 var ins = document.getElementsByName(\u0026#34;hobby\u0026#34;); for (let i = 0; i \u0026lt; ins.length; i++) { alert(ins[i]); } // 获取所有类名为 \u0026#39;cls\u0026#39; 的元素并弹出 var divs = document.getElementsByClassName(\u0026#39;cls\u0026#39;); for (let i = 0; i \u0026lt; divs.length; i++) { alert(divs[i]); } // 重新获取类名为 \u0026#39;cls\u0026#39; 的元素集合，并取第一个元素赋值给 div1，并弹出 var divs = document.getElementsByClassName(\u0026#39;cls\u0026#39;); var div1 = divs[0]; alert(div1); // 修改 div1 的 innerHTML 属性为 \u0026#34;666666\u0026#34; div1.innerHTML = \u0026#34;666666\u0026#34;; // 获取 id 为 \u0026#39;h1\u0026#39; 的元素并修改其 src 属性为 \u0026#34;img/on.gif\u0026#34; var img = document.getElementById(\u0026#39;h1\u0026#39;); img.src = \u0026#34;img/on.gif\u0026#34;; // 给所有标签名为 \u0026#39;div\u0026#39; 的元素追加内容 \u0026#34;\u0026lt;font color=\u0026#39;red\u0026#39;\u0026gt;Very Good\u0026lt;/font\u0026gt;\u0026#34; var divs = document.getElementsByTagName(\u0026#39;div\u0026#39;); for (let i = 0; i \u0026lt; divs.length; i++) { const element = divs[i]; element.innerHTML += \u0026#34;\u0026lt;font color=\u0026#39;red\u0026#39;\u0026gt;Very Good\u0026lt;/font\u0026gt;\u0026#34;; } // 获取所有 name 属性为 \u0026#39;hobby\u0026#39; 的元素，并设置它们的 checked 属性为 true var ins = document.getElementsByName(\u0026#34;hobby\u0026#34;); for (let i = 0; i \u0026lt; ins.length; i++) { const check = ins[i]; check.checked = true; } 小案例 \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html lang=\u0026#34;en\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;UTF-8\u0026#34;\u0026gt; \u0026lt;meta http-equiv=\u0026#34;X-UA-Compatible\u0026#34; content=\u0026#34;IE=edge\u0026#34;\u0026gt; \u0026lt;meta name=\u0026#34;viewport\u0026#34; content=\u0026#34;width=device-width, initial-scale=1.0\u0026#34;\u0026gt; \u0026lt;title\u0026gt;JS-事件-事件绑定\u0026lt;/title\u0026gt; \u0026lt;style\u0026gt; /* 样式美化 */ body { font-family: Arial, sans-serif; text-align: center; } #light { width: 100px; } .button { padding: 8px 16px; margin: 5px; font-size: 16px; cursor: pointer; } .checkbox-label { margin-right: 10px; } \u0026lt;/style\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;!-- 图片标签，用于显示灯的状态 --\u0026gt; \u0026lt;img id=\u0026#34;light\u0026#34; src=\u0026#34;img/off.gif\u0026#34; alt=\u0026#34;灯\u0026#34;\u0026gt; \u0026lt;br\u0026gt; \u0026lt;!-- 两个按钮，分别用于点亮和熄灭灯 --\u0026gt; \u0026lt;button class=\u0026#34;button\u0026#34; id=\u0026#34;btnOn\u0026#34; onclick=\u0026#34;on()\u0026#34;\u0026gt;点亮\u0026lt;/button\u0026gt; \u0026lt;button class=\u0026#34;button\u0026#34; id=\u0026#34;btnOff\u0026#34; onclick=\u0026#34;off()\u0026#34;\u0026gt;熄灭\u0026lt;/button\u0026gt; \u0026lt;!-- 文字标签 --\u0026gt; \u0026lt;div class=\u0026#34;cls\u0026#34;\u0026gt;黑马\u0026lt;/div\u0026gt; \u0026lt;br\u0026gt; \u0026lt;br\u0026gt; \u0026lt;!-- 输入框，输入内容转换为大写或小写 --\u0026gt; \u0026lt;input type=\u0026#34;text\u0026#34; id=\u0026#34;name\u0026#34; value=\u0026#34;itcast\u0026#34; onfocus=\u0026#34;lower()\u0026#34; onblur=\u0026#34;upper()\u0026#34;\u0026gt; \u0026lt;br\u0026gt; \u0026lt;!-- 多个复选框，用于选择爱好 --\u0026gt; \u0026lt;label class=\u0026#34;checkbox-label\u0026#34;\u0026gt;\u0026lt;input type=\u0026#34;checkbox\u0026#34; name=\u0026#34;hobby\u0026#34;\u0026gt; 电影\u0026lt;/label\u0026gt; \u0026lt;label class=\u0026#34;checkbox-label\u0026#34;\u0026gt;\u0026lt;input type=\u0026#34;checkbox\u0026#34; name=\u0026#34;hobby\u0026#34;\u0026gt; 旅游\u0026lt;/label\u0026gt; \u0026lt;label class=\u0026#34;checkbox-label\u0026#34;\u0026gt;\u0026lt;input type=\u0026#34;checkbox\u0026#34; name=\u0026#34;hobby\u0026#34;\u0026gt; 游戏\u0026lt;/label\u0026gt; \u0026lt;br\u0026gt; \u0026lt;!-- 全选和反选按钮 --\u0026gt; \u0026lt;button class=\u0026#34;button\u0026#34; id=\u0026#34;btnCheckAll\u0026#34; onclick=\u0026#34;checkAll()\u0026#34;\u0026gt;全选\u0026lt;/button\u0026gt; \u0026lt;button class=\u0026#34;button\u0026#34; id=\u0026#34;btnReverse\u0026#34; onclick=\u0026#34;reverse()\u0026#34;\u0026gt;反选\u0026lt;/button\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;script\u0026gt; // 点亮灯函数 function on() { var img = document.getElementById(\u0026#34;light\u0026#34;); img.src = \u0026#34;img/on.gif\u0026#34;; } // 熄灭灯函数 function off() { var img = document.getElementById(\u0026#34;light\u0026#34;); img.src = \u0026#34;img/off.gif\u0026#34;; } // 将输入内容转换为大写 function upper() { var input = document.getElementById(\u0026#34;name\u0026#34;); input.value = input.value.toUpperCase(); } // 将输入内容转换为小写 function lower() { var input = document.getElementById(\u0026#34;name\u0026#34;); input.value = input.value.toLowerCase(); } // 全选复选框函数 function checkAll() { var hobbys = document.getElementsByName(\u0026#34;hobby\u0026#34;); for (let i = 0; i \u0026lt; hobbys.length; i++) { const element = hobbys[i]; element.checked = true; } } // 反选复选框函数 function reverse() { var hobbys = document.getElementsByName(\u0026#34;hobby\u0026#34;); for (let i = 0; i \u0026lt; hobbys.length; i++) { const element = hobbys[i]; element.checked = !element.checked; // 切换选中状态 } } \u0026lt;/script\u0026gt; \u0026lt;/html\u0026gt; ","permalink":"https://kennems.github.io/posts/tech/java-web%E5%BC%80%E5%8F%911/","summary":"Java Web开发(1) 什么是Web？ Web：全球广域网，也成为万维网（World Wide Web)，能够通过浏览器访问的网站 CRM OA ERP 不谋全局者不足以谋一域","title":"Java Web开发(1)"},{"content":"Java Web开发(2) Vue Vue是一套前端框架，免除原生的JavaScript中的DOM操作，简化书写。 基于MVVM（Model-View-View-Model）思想，实现数据的双向绑定，将编程的关注点放在数据上。 \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html lang=\u0026#34;en\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;UTF-8\u0026#34;\u0026gt; \u0026lt;meta name=\u0026#34;viewport\u0026#34; content=\u0026#34;width=device-width, initial-scale=1.0\u0026#34;\u0026gt; \u0026lt;title\u0026gt;Vue\u0026lt;/title\u0026gt; \u0026lt;!-- 引入Vue.js库 --\u0026gt; \u0026lt;script src=\u0026#34;../js/vue.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;div id=\u0026#34;app\u0026#34;\u0026gt; \u0026lt;!-- 输入框，使用v-model指令实现双向数据绑定 --\u0026gt; \u0026lt;input type=\u0026#34;text\u0026#34; v-model=\u0026#34;message\u0026#34;\u0026gt; \u0026lt;!-- 使用插值表达式显示message变量的值 --\u0026gt; {{ message }} \u0026lt;/div\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;script\u0026gt; // 创建一个Vue实例 new Vue({ // 将Vue实例挂载到id为\u0026#34;app\u0026#34;的元素上 el: \u0026#34;#app\u0026#34;, // 定义数据对象 data: { message: \u0026#34;Hello Vue\u0026#34; // 初始值为\u0026#34;Hello Vue\u0026#34; } }) \u0026lt;/script\u0026gt; \u0026lt;/html\u0026gt; Vue常用指令 \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html lang=\u0026#34;en\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;UTF-8\u0026#34;\u0026gt; \u0026lt;meta name=\u0026#34;viewport\u0026#34; content=\u0026#34;width=device-width, initial-scale=1.0\u0026#34;\u0026gt; \u0026lt;title\u0026gt;Vue\u0026lt;/title\u0026gt; \u0026lt;!-- 引入 Vue.js 文件 --\u0026gt; \u0026lt;script src=\u0026#34;../js/vue.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;!-- Vue 实例挂载的根节点 --\u0026gt; \u0026lt;div id=\u0026#34;app\u0026#34;\u0026gt; \u0026lt;table border=\u0026#34;1\u0026#34; cellspacing=\u0026#34;0\u0026#34; width=\u0026#34;60%\u0026#34;\u0026gt; \u0026lt;tr\u0026gt; \u0026lt;th\u0026gt;编号\u0026lt;/th\u0026gt; \u0026lt;th\u0026gt;姓名\u0026lt;/th\u0026gt; \u0026lt;th\u0026gt;年龄\u0026lt;/th\u0026gt; \u0026lt;th\u0026gt;性别\u0026lt;/th\u0026gt; \u0026lt;th\u0026gt;成绩\u0026lt;/th\u0026gt; \u0026lt;th\u0026gt;等级\u0026lt;/th\u0026gt; \u0026lt;/tr\u0026gt; \u0026lt;!-- 使用 v-for 循环渲染列表 --\u0026gt; \u0026lt;tr align=\u0026#34;center\u0026#34; v-for=\u0026#34;(user, index) in users\u0026#34;\u0026gt; \u0026lt;td\u0026gt;{{index + 1}}\u0026lt;/td\u0026gt; \u0026lt;td\u0026gt;{{user.name}}\u0026lt;/td\u0026gt; \u0026lt;td\u0026gt;{{user.age}}\u0026lt;/td\u0026gt; \u0026lt;td\u0026gt; \u0026lt;!-- 使用 v-if 条件渲染 --\u0026gt; \u0026lt;span v-if=\u0026#34;user.gender == 1\u0026#34;\u0026gt;男\u0026lt;/span\u0026gt; \u0026lt;span v-if=\u0026#34;user.gender == 2\u0026#34;\u0026gt;女\u0026lt;/span\u0026gt; \u0026lt;/td\u0026gt; \u0026lt;td\u0026gt;{{user.score}}\u0026lt;/td\u0026gt; \u0026lt;td\u0026gt; \u0026lt;!-- 使用 v-if、v-else-if、v-else 实现多条件渲染 --\u0026gt; \u0026lt;span v-if=\u0026#34;user.score \u0026gt;= 60 \u0026amp;\u0026amp; user.score \u0026lt; 85\u0026#34;\u0026gt;优秀\u0026lt;/span\u0026gt; \u0026lt;span v-else-if=\u0026#34;user.score \u0026gt;= 85\u0026#34;\u0026gt;及格\u0026lt;/span\u0026gt; \u0026lt;span style=\u0026#34;color:red\u0026#34; v-else\u0026gt;不及格\u0026lt;/span\u0026gt; \u0026lt;/td\u0026gt; \u0026lt;/tr\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;script\u0026gt; // 创建 Vue 实例 new Vue({ el: \u0026#34;#app\u0026#34;, // 指定实例挂载的根节点 data: { // 用于存储数据的对象 users: [{ name: \u0026#34;Tom\u0026#34;, age: 20, gender: 1, score: 30 }, { name: \u0026#34;Rose\u0026#34;, age: 18, gender: 2, score: 99 }, { name: \u0026#34;Jerry\u0026#34;, age: 16, gender: 1, score: 98 }, { name: \u0026#34;Kennem\u0026#34;, age: 21, gender: 1, score: 100 }] }, }) \u0026lt;/script\u0026gt; \u0026lt;/html\u0026gt; Vue生命周期 new new Vue({ el: \u0026#34;#app\u0026#34;, //接管区域 data: { }, methods: { }, mounted() { alert(\u0026#34;挂载完成!\u0026#34;); }, }) Ajax Asynchronous JavaScript And XML, 异步的JavaScript和XML 作用： 数据交换：通过Ajax可以给服务器发送请求，并获取服务器响应的数据。 异步交互：可以在不重新加载整个页面的情况下，与服务器交换数据并更新部分网页的技术，如：搜索联想，用户名是否可用的校验等。 \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html lang=\u0026#34;en\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;UTF-8\u0026#34;\u0026gt; \u0026lt;meta http-equiv=\u0026#34;X-UA-Compatible\u0026#34; content=\u0026#34;IE=edge\u0026#34;\u0026gt; \u0026lt;meta name=\u0026#34;viewport\u0026#34; content=\u0026#34;width=device-width, initial-scale=1.0\u0026#34;\u0026gt; \u0026lt;title\u0026gt;原生Ajax\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;input type=\u0026#34;button\u0026#34; value=\u0026#34;获取数据\u0026#34; onclick=\u0026#34;getData()\u0026#34;\u0026gt; \u0026lt;div id=\u0026#34;div1\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;script\u0026gt; function getData() { // 创建XMLHttpRequest对象 var xmlHttpRequest = new XMLHttpRequest(); // 发送异步请求 xmlHttpRequest.open(\u0026#39;GET\u0026#39;, \u0026#39;https://xxx/json_demo.json\u0026#39;); xmlHttpRequest.send(); // 发送请求 // 获取服务响应数据 xmlHttpRequest.onreadystatechange = function () { if (xmlHttpRequest.readyState == 4 \u0026amp;\u0026amp; xmlHttpRequest.status == 200) { document.getElementById(\u0026#39;div1\u0026#39;).innerHTML = xmlHttpRequest.responseText; } } } \u0026lt;/script\u0026gt; \u0026lt;/html\u0026gt; Axios Axios对原生的Ajax进行了封装，简化书写，快速开发。 \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html lang=\u0026#34;en\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;UTF-8\u0026#34;\u0026gt; \u0026lt;meta http-equiv=\u0026#34;X-UA-Compatible\u0026#34; content=\u0026#34;IE=edge\u0026#34;\u0026gt; \u0026lt;meta name=\u0026#34;viewport\u0026#34; content=\u0026#34;width=device-width, initial-scale=1.0\u0026#34;\u0026gt; \u0026lt;title\u0026gt;Ajax-Axios-案例\u0026lt;/title\u0026gt; \u0026lt;!-- 引入axios库 --\u0026gt; \u0026lt;script src=\u0026#34;js/axios-0.18.0.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;!-- 引入Vue.js --\u0026gt; \u0026lt;script src=\u0026#34;js/vue.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;div id=\u0026#34;app\u0026#34;\u0026gt; \u0026lt;!-- 数据展示表格 --\u0026gt; \u0026lt;table border=\u0026#34;1\u0026#34; cellspacing=\u0026#34;0\u0026#34; width=\u0026#34;60%\u0026#34;\u0026gt; \u0026lt;!-- 表头 --\u0026gt; \u0026lt;tr\u0026gt; \u0026lt;th\u0026gt;编号\u0026lt;/th\u0026gt; \u0026lt;th\u0026gt;姓名\u0026lt;/th\u0026gt; \u0026lt;th\u0026gt;图像\u0026lt;/th\u0026gt; \u0026lt;th\u0026gt;性别\u0026lt;/th\u0026gt; \u0026lt;th\u0026gt;职位\u0026lt;/th\u0026gt; \u0026lt;th\u0026gt;入职日期\u0026lt;/th\u0026gt; \u0026lt;th\u0026gt;最后操作时间\u0026lt;/th\u0026gt; \u0026lt;/tr\u0026gt; \u0026lt;!-- 数据行，使用Vue.js的v-for指令循环渲染 --\u0026gt; \u0026lt;tr align=\u0026#34;center\u0026#34; v-for=\u0026#34;(emp,index) in emps\u0026#34;\u0026gt; \u0026lt;td\u0026gt;{{index + 1}}\u0026lt;/td\u0026gt; \u0026lt;!-- 显示编号 --\u0026gt; \u0026lt;td\u0026gt;{{emp.name}}\u0026lt;/td\u0026gt; \u0026lt;!-- 显示姓名 --\u0026gt; \u0026lt;td\u0026gt; \u0026lt;img :src=\u0026#34;emp.image\u0026#34; width=\u0026#34;70px\u0026#34; height=\u0026#34;50px\u0026#34;\u0026gt; \u0026lt;!-- 显示图像 --\u0026gt; \u0026lt;/td\u0026gt; \u0026lt;td\u0026gt; \u0026lt;span v-if=\u0026#34;emp.gender == 1\u0026#34;\u0026gt;男\u0026lt;/span\u0026gt; \u0026lt;!-- 根据性别显示男或女 --\u0026gt; \u0026lt;span v-if=\u0026#34;emp.gender == 2\u0026#34;\u0026gt;女\u0026lt;/span\u0026gt; \u0026lt;/td\u0026gt; \u0026lt;td\u0026gt;{{emp.job}}\u0026lt;/td\u0026gt; \u0026lt;!-- 显示职位 --\u0026gt; \u0026lt;td\u0026gt;{{emp.entrydate}}\u0026lt;/td\u0026gt; \u0026lt;!-- 显示入职日期 --\u0026gt; \u0026lt;td\u0026gt;{{emp.updatetime}}\u0026lt;/td\u0026gt; \u0026lt;!-- 显示最后操作时间 --\u0026gt; \u0026lt;/tr\u0026gt; \u0026lt;/table\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;script\u0026gt; new Vue({ el: \u0026#34;#app\u0026#34;, data: { emps: [] // 存储员工数据的数组 }, mounted () { // 在Vue实例mounted生命周期钩子中发送异步请求加载数据 axios.get(\u0026#34;http://yapi.smart-xwork.cn/mock/169327/emp/list\u0026#34;).then(result =\u0026gt; { // 异步请求成功后将数据赋值给emps数组 this.emps = result.data.data; }) } }); \u0026lt;/script\u0026gt; \u0026lt;/html\u0026gt; 接口管理平台 Yapi apifox\n作为测试接口\nVue开发 Vue安装 npm -g install vue/cli vue 项目创建 vue create project-name Vue的组件文件以.vue结尾， 每个组件由三个部分组成\u0026lt;template\u0026gt;, \u0026lt;script\u0026gt;, \u0026lt;style\u0026gt;。 Element UI npm install element-ui@2.15.3 import ElementUI from \u0026#39;element-ui\u0026#39;; import \u0026#39;element-ui/lib/theme-chalk/index.css\u0026#39;; Vue.use(ElementUI); Vue路由 前端路由：URL中的hash(#)与组件之间的对应关系。 https://mock.apifox.cn/m1/3128855-0-default/emp/list Nginx 处理被占用的端口号：\nnetstat -ano | findStr 80 将测试好的前端网页复制到html静态资源中\n然后直接启动nginx即可。\n访问：\nhttp://localhost:80 员工管理项目 main.js // 引入Vue框架 import Vue from \u0026#39;vue\u0026#39; // 引入ElementUI组件库 import ElementUI from \u0026#39;element-ui\u0026#39;; // 引入Vue Router，用于管理页面路由 import router from \u0026#39;./router\u0026#39; // 引入ElementUI的样式文件 import \u0026#39;element-ui/lib/theme-chalk/index.css\u0026#39;; // 引入根组件App.vue import App from \u0026#39;./App.vue\u0026#39; // 在Vue中使用ElementUI Vue.use(ElementUI); // 关闭生产模式下的提示 Vue.config.productionTip = false // 创建Vue实例 new Vue({ // 注入路由 router, // 渲染根组件 render: h =\u0026gt; h(App), }).$mount(\u0026#39;#app\u0026#39;) app.vue \u0026lt;template\u0026gt; \u0026lt;div id=\u0026#34;app\u0026#34;\u0026gt; \u0026lt;!-- \u0026lt;emp-view\u0026gt; \u0026lt;/emp-view\u0026gt; --\u0026gt; \u0026lt;!-- 这是 Vue Router 的视图渲染出口，用于展示当前匹配的视图组件 --\u0026gt; \u0026lt;router-view\u0026gt; \u0026lt;/router-view\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;script\u0026gt; // 导入组件 // import EmpView from \u0026#39;./views/tlias/EmpView.vue\u0026#39; export default { // 注册组件 components: { /*EmpView*/ }, data() { // 组件的数据属性，可以在模板中使用 return { message: \u0026#34;\u0026#34; } }, methods: { // 组件的方法，用于定义各种功能 }, } \u0026lt;/script\u0026gt; \u0026lt;style\u0026gt; /* 组件的样式 */ #app { font-family: Consolas, Helvetica, Arial, sans-serif; -webkit-font-smoothing: antialiased; -moz-osx-font-smoothing: grayscale; text-align: center; color: #2c3e50; margin-top: 60px; } \u0026lt;/style\u0026gt; EmpView.vue \u0026lt;template\u0026gt; \u0026lt;div\u0026gt; \u0026lt;!-- Element UI 布局容器 --\u0026gt; \u0026lt;el-container style=\u0026#34;height: 700px; border: 2px solid #eee\u0026#34;\u0026gt; \u0026lt;!-- 头部区域 --\u0026gt; \u0026lt;el-header style=\u0026#34;font-size: 48px; background-color: rgb(238, 241, 246); text-align: left;\u0026#34;\u0026gt;Tlias智能学习辅助系统\u0026lt;/el-header\u0026gt; \u0026lt;el-container\u0026gt; \u0026lt;!-- 侧边栏区域 --\u0026gt; \u0026lt;el-aside width=\u0026#34;230px\u0026#34; style=\u0026#34; border: 2px solid #eee\u0026#34;\u0026gt; \u0026lt;!-- 侧边栏导航菜单 --\u0026gt; \u0026lt;el-menu :default-openeds=\u0026#34;[\u0026#39;1\u0026#39;, \u0026#39;3\u0026#39;]\u0026#34;\u0026gt; \u0026lt;el-submenu index=\u0026#34;1\u0026#34;\u0026gt; \u0026lt;template slot=\u0026#34;title\u0026#34;\u0026gt;\u0026lt;i class=\u0026#34;el-icon-message\u0026#34;\u0026gt;\u0026lt;/i\u0026gt;系统信息管理\u0026lt;/template\u0026gt; \u0026lt;el-menu-item-group\u0026gt; \u0026lt;!-- 导航链接 --\u0026gt; \u0026lt;el-menu-item index=\u0026#34;1-1\u0026#34;\u0026gt; \u0026lt;router-link to=\u0026#34;/dept\u0026#34;\u0026gt;部门管理\u0026lt;/router-link\u0026gt; \u0026lt;/el-menu-item\u0026gt; \u0026lt;el-menu-item index=\u0026#34;1-2\u0026#34;\u0026gt; \u0026lt;router-link to=\u0026#34;/emp\u0026#34;\u0026gt;员工管理\u0026lt;/router-link\u0026gt; \u0026lt;/el-menu-item\u0026gt; \u0026lt;/el-menu-item-group\u0026gt; \u0026lt;/el-submenu\u0026gt; \u0026lt;/el-menu\u0026gt; \u0026lt;/el-aside\u0026gt; \u0026lt;!-- 主体区域 --\u0026gt; \u0026lt;el-main\u0026gt; \u0026lt;!-- 查询表单 --\u0026gt; \u0026lt;el-form :inline=\u0026#34;true\u0026#34; :model=\u0026#34;searchForm\u0026#34; class=\u0026#34;demo-form-inline\u0026#34;\u0026gt; \u0026lt;el-form-item label=\u0026#34;姓名\u0026#34;\u0026gt; \u0026lt;el-input v-model=\u0026#34;searchForm.name\u0026#34; placeholder=\u0026#34;输入姓名\u0026#34;\u0026gt;\u0026lt;/el-input\u0026gt; \u0026lt;/el-form-item\u0026gt; \u0026lt;el-form-item label=\u0026#34;性别\u0026#34;\u0026gt; \u0026lt;el-select v-model=\u0026#34;searchForm.gender\u0026#34; placeholder=\u0026#34;输入性别\u0026#34;\u0026gt; \u0026lt;el-option label=\u0026#34;男\u0026#34; value=\u0026#34;1\u0026#34;\u0026gt;\u0026lt;/el-option\u0026gt; \u0026lt;el-option label=\u0026#34;女\u0026#34; value=\u0026#34;2\u0026#34;\u0026gt;\u0026lt;/el-option\u0026gt; \u0026lt;/el-select\u0026gt; \u0026lt;/el-form-item\u0026gt; \u0026lt;el-form-item label=\u0026#34;入职时间\u0026#34;\u0026gt; \u0026lt;el-date-picker v-model=\u0026#34;searchForm.entrydate\u0026#34; type=\u0026#34;daterange\u0026#34; range-separator=\u0026#34;至\u0026#34; start-placeholder=\u0026#34;开始日期\u0026#34; end-placeholder=\u0026#34;结束日期\u0026#34;\u0026gt; \u0026lt;/el-date-picker\u0026gt; \u0026lt;/el-form-item\u0026gt; \u0026lt;el-form-item\u0026gt; \u0026lt;el-button type=\u0026#34;primary\u0026#34; @click=\u0026#34;onSubmit\u0026#34;\u0026gt;查询\u0026lt;/el-button\u0026gt; \u0026lt;/el-form-item\u0026gt; \u0026lt;/el-form\u0026gt; \u0026lt;!-- 表格 --\u0026gt; \u0026lt;el-table :data=\u0026#34;tableData\u0026#34; border\u0026gt; \u0026lt;el-table-column prop=\u0026#34;name\u0026#34; label=\u0026#34;姓名\u0026#34; width=\u0026#34;180\u0026#34;\u0026gt; \u0026lt;/el-table-column\u0026gt; \u0026lt;el-table-column prop=\u0026#34;image\u0026#34; label=\u0026#34;图像\u0026#34; width=\u0026#34;180\u0026#34;\u0026gt; \u0026lt;!-- 作用域插槽 --\u0026gt; \u0026lt;template slot-scope=\u0026#34;scope\u0026#34;\u0026gt; \u0026lt;img :src=\u0026#34;scope.row.image\u0026#34; width=\u0026#34;100px\u0026#34; height=\u0026#34;70px\u0026#34;\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;/el-table-column\u0026gt; \u0026lt;el-table-column prop=\u0026#34;gender\u0026#34; label=\u0026#34;性别\u0026#34; width=\u0026#34;140\u0026#34;\u0026gt; \u0026lt;!-- 作用域插槽 --\u0026gt; \u0026lt;template slot-scope=\u0026#34;scope\u0026#34;\u0026gt; {{ scope.row.gender == 1 ? \u0026#34;男\u0026#34; : \u0026#34;女\u0026#34; }} \u0026lt;/template\u0026gt; \u0026lt;/el-table-column\u0026gt; \u0026lt;el-table-column prop=\u0026#34;job\u0026#34; label=\u0026#34;职位\u0026#34; width=\u0026#34;140\u0026#34;\u0026gt; \u0026lt;/el-table-column\u0026gt; \u0026lt;el-table-column prop=\u0026#34;entrydate\u0026#34; label=\u0026#34;入职日期\u0026#34; width=\u0026#34;180\u0026#34;\u0026gt; \u0026lt;/el-table-column\u0026gt; \u0026lt;el-table-column prop=\u0026#34;updatetime\u0026#34; label=\u0026#34;最后操作时间\u0026#34; width=\u0026#34;230\u0026#34;\u0026gt; \u0026lt;/el-table-column\u0026gt; \u0026lt;el-table-column label=\u0026#34;操作\u0026#34;\u0026gt; \u0026lt;el-button type=\u0026#34;primary\u0026#34; size=\u0026#34;mini\u0026#34;\u0026gt;编辑\u0026lt;/el-button\u0026gt; \u0026lt;el-button type=\u0026#34;danger\u0026#34; size=\u0026#34;mini\u0026#34;\u0026gt;删除\u0026lt;/el-button\u0026gt; \u0026lt;/el-table-column\u0026gt; \u0026lt;/el-table\u0026gt; \u0026lt;!-- 分页条 --\u0026gt; \u0026lt;el-pagination background layout=\u0026#34;sizes, prev, pager, next, jumper, total\u0026#34; @size-change=\u0026#34;handleSizeChange\u0026#34; @current-change=\u0026#34;handleCurrentChange\u0026#34; :total=\u0026#34;1000\u0026#34;\u0026gt;\u0026lt;/el-pagination\u0026gt; \u0026lt;/el-main\u0026gt; \u0026lt;/el-container\u0026gt; \u0026lt;/el-container\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;script\u0026gt; import axios from \u0026#39;axios\u0026#39;; export default { data() { return { // 表格数据 tableData: [], // 查询表单数据 searchForm: { name: \u0026#34;\u0026#34;, gender: \u0026#34;\u0026#34; }, // 入职日期范围 entrydate: [] } }, methods: { // 查询按钮点击事件 onsubmit() { alert(\u0026#34;查询数据！\u0026#34;); }, // 分页当前页改变事件 handleCurrentChange() { alert(\u0026#34;CurrentChange\u0026#34;); }, // 分页每页条数改变事件 handleSizeChange() { alert(\u0026#34;SizeChange\u0026#34;); } }, mounted() { // 组件初始化时从接口获取数据 axios.get(\u0026#34;https://mock.apifox.cn/m1/3128855-0-default/emp/list\u0026#34;).then((result) =\u0026gt; { this.tableData = result.data.data; }); }, } \u0026lt;/script\u0026gt; \u0026lt;style\u0026gt;\u0026lt;/style\u0026gt; DeptView.vue \u0026lt;template\u0026gt; \u0026lt;div\u0026gt; \u0026lt;!-- Element UI 布局容器 --\u0026gt; \u0026lt;el-container style=\u0026#34;height: 700px; border: 1px solid #eee\u0026#34;\u0026gt; \u0026lt;!-- 头部区域 --\u0026gt; \u0026lt;el-header style=\u0026#34;font-size:40px; background-color: rgb(238, 241, 246)\u0026#34;\u0026gt;tlias 智能学习辅助系统\u0026lt;/el-header\u0026gt; \u0026lt;el-container\u0026gt; \u0026lt;!-- 侧边栏区域 --\u0026gt; \u0026lt;el-aside width=\u0026#34;230px\u0026#34; style=\u0026#34;border: 1px solid #eee\u0026#34;\u0026gt; \u0026lt;!-- 侧边栏导航菜单 --\u0026gt; \u0026lt;el-menu :default-openeds=\u0026#34;[\u0026#39;1\u0026#39;, \u0026#39;3\u0026#39;]\u0026#34;\u0026gt; \u0026lt;el-submenu index=\u0026#34;1\u0026#34;\u0026gt; \u0026lt;template slot=\u0026#34;title\u0026#34;\u0026gt;\u0026lt;i class=\u0026#34;el-icon-message\u0026#34;\u0026gt;\u0026lt;/i\u0026gt;系统信息管理\u0026lt;/template\u0026gt; \u0026lt;!-- 导航链接 --\u0026gt; \u0026lt;el-menu-item index=\u0026#34;1-1\u0026#34;\u0026gt; \u0026lt;router-link to=\u0026#34;/dept\u0026#34;\u0026gt;部门管理\u0026lt;/router-link\u0026gt; \u0026lt;/el-menu-item\u0026gt; \u0026lt;el-menu-item index=\u0026#34;1-2\u0026#34;\u0026gt; \u0026lt;router-link to=\u0026#34;/emp\u0026#34;\u0026gt;员工管理\u0026lt;/router-link\u0026gt; \u0026lt;/el-menu-item\u0026gt; \u0026lt;/el-submenu\u0026gt; \u0026lt;/el-menu\u0026gt; \u0026lt;/el-aside\u0026gt; \u0026lt;!-- 主体区域 --\u0026gt; \u0026lt;el-main\u0026gt; \u0026lt;!-- 表格 --\u0026gt; \u0026lt;el-table :data=\u0026#34;tableData\u0026#34; border\u0026gt; \u0026lt;el-table-column prop=\u0026#34;name\u0026#34; label=\u0026#34;名称\u0026#34; width=\u0026#34;250\u0026#34;\u0026gt;\u0026lt;/el-table-column\u0026gt; \u0026lt;el-table-column prop=\u0026#34;updatetime\u0026#34; label=\u0026#34;最后操作时间\u0026#34; width=\u0026#34;250\u0026#34;\u0026gt;\u0026lt;/el-table-column\u0026gt; \u0026lt;el-table-column label=\u0026#34;操作\u0026#34;\u0026gt; \u0026lt;el-button type=\u0026#34;primary\u0026#34; size=\u0026#34;mini\u0026#34;\u0026gt;编辑\u0026lt;/el-button\u0026gt; \u0026lt;el-button type=\u0026#34;danger\u0026#34; size=\u0026#34;mini\u0026#34;\u0026gt;删除\u0026lt;/el-button\u0026gt; \u0026lt;/el-table-column\u0026gt; \u0026lt;/el-table\u0026gt; \u0026lt;/el-main\u0026gt; \u0026lt;/el-container\u0026gt; \u0026lt;/el-container\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;script\u0026gt; export default { data() { return { // 表格数据 tableData: [{ id: 1, name: \u0026#34;学工部\u0026#34;, updatetime: \u0026#34;2010-01-01 12:00:00\u0026#34; }, { id: 2, name: \u0026#34;教研部\u0026#34;, updatetime: \u0026#34;2010-01-01 12:00:00\u0026#34; }, { id: 3, name: \u0026#34;就业部\u0026#34;, updatetime: \u0026#34;2010-01-01 12:00:00\u0026#34; }, { id: 4, name: \u0026#34;人事部\u0026#34;, updatetime: \u0026#34;2010-01-01 12:00:00\u0026#34; }, { id: 5, name: \u0026#34;行政部\u0026#34;, updatetime: \u0026#34;2010-01-01 12:00:00\u0026#34; }] } }, methods: { // 可以在这里定义组件的方法 } } \u0026lt;/script\u0026gt; \u0026lt;style\u0026gt;\u0026lt;/style\u0026gt; index.js import Vue from \u0026#39;vue\u0026#39; // 导入 Vue Router import VueRouter from \u0026#39;vue-router\u0026#39; // 使用 Vue Router 插件 Vue.use(VueRouter) // 定义路由规则 const routes = [{ // 路由路径为 /emp path: \u0026#39;/emp\u0026#39;, // 路由名称为 emp name: \u0026#39;emp\u0026#39;, // 使用动态导入延迟加载组件 component: () =\u0026gt; import(\u0026#39;../views/tlias/EmpView.vue\u0026#39;) }, { // 路由路径为 /dept path: \u0026#39;/dept\u0026#39;, // 路由名称为 dept name: \u0026#39;dept\u0026#39;, // 使用动态导入延迟加载组件 component: () =\u0026gt; import(\u0026#39;../views/tlias/DeptView.vue\u0026#39;) }, { // 路由路径为 / path: \u0026#39;/\u0026#39;, // 重定向到 /dept redirect: \u0026#39;/dept\u0026#39; //默认访问dept } ] // 创建路由实例 const router = new VueRouter({ routes }) // 导出路由实例 export default router ","permalink":"https://kennems.github.io/posts/tech/java-web%E5%BC%80%E5%8F%912/","summary":"Java Web开发(2) Vue Vue是一套前端框架，免除原生的JavaScript中的DOM操作，简化书写。 基于MVVM（Model-View-Vie","title":"Java Web开发(2)"},{"content":"Java20天速成——进阶课程(5) 网络编程 可以让设备中的程序与网络上其他设备中的程序进行数据交互（实现网络通信） 基本的通信架构\n基本的通信架构有2中形式：CS架构（Client客户端/Server服务端）、BS架构（Browser浏览器/Server服务器） 无论是CS架构，还是BS架构的软件都必须要依赖网络编程\n网络通信三要素： IP（Internet Protocol）： 设备在网络中的地址，是唯一的标识， 全称 “互联网协议地址”， 是分配给上网设备的唯一标志。\n两种形式：IPv4(32bit), IPv6(128bit) IPv6分成8段表示，每段每四位编码成一个十六进制位标识，数之间用冒号(:)分开。 公网IP， 内网IP\n公网IP：是可以连接互联网的IP地址； 内网IP：也叫局域网IP， 只能组织机构内部使用 192.168. 开头的就是常见的局域网地址，范围即为192.168.0.0--192.168.255.255，专门位组织机构内部使用 127.0.0.1 、localhost : 代表本机IP，只会寻找当前所在的主机 端口： 应用程序在设备中唯一的标识\n标记正在计算机设备上运行的应用程序的，被规定为一个16位的二进制，范围是0~65535 分类： 周知端口：0~1023： 被预先定义的知名应用占用（如：HTTP占用80， FTP占用21） 注册端口：1024~49151，分配给用户进程或某些应用程序 动态端口：49152到65535，之所以被称为动态端口，是因为它一般不固定分配某种进程，而是动态分配 协议： 连接和数据在网络中传输的规则\nInetAddress 代表IP地址 public static void main(String[] args) throws Exception { // 获取本地主机的 InetAddress InetAddress ip1 = InetAddress.getLocalHost(); System.out.println(ip1.getHostName()); // 输出本地主机的主机名 System.out.println(ip1.getHostAddress()); // 输出本地主机的 IP 地址 // 根据域名获取 InetAddress InetAddress ip2 = InetAddress.getByName(\u0026#34;www.baidu.com\u0026#34;); System.out.println(ip2.getHostName()); // 输出百度主机的主机名 System.out.println(ip2.getHostAddress()); // 输出百度主机的 IP 地址 // 检查主机是否可达（ping） System.out.println(ip2.isReachable(6000)); // 输出百度主机是否可达 } 开放式网络互联标准：OSI网络参考模型\nOSI网络参考模型：全球网络互联标准 传输层 UDP（User Datagram Protocol）：用户数据报协议；TCP（Transmission Control Protocol）：传输控制协议 UDP协议 特点：无连接，不可靠通信 不事先建立连接，数据按照包发，一包数据包含：自己的IP，程序端口，目的地IP，程序端口和数据（限制在64KB内）等, 发出去就不管了。 发送方不管对方是否在线，数据在中间丢失也不管，如果接受方收到数据也不返回确认，所以不可靠的 UDP通信 package com.showguan.InternetDemo; import java.net.DatagramPacket; import java.net.DatagramSocket; import java.net.InetAddress; import java.net.SocketException; import java.util.Scanner; public class Client { public static void main(String[] args) throws Exception { DatagramSocket socket = new DatagramSocket(); // 创建客户端 DatagramSocket 实例 Scanner sc = new Scanner(System.in); // 创建 Scanner 对象用于输入消息 while (true) { System.out.println(\u0026#34;请输入你需要发送的消息(exit退出)\u0026#34;); String msg = sc.nextLine(); // 读取用户输入的消息 if (msg.equals(\u0026#34;exit\u0026#34;)) { // 如果输入 exit，则退出循环 System.out.println(\u0026#34;退出成功\u0026#34;); socket.close(); // 关闭客户端 Socket break; } byte[] bytes = msg.getBytes(); // 将消息转换为字节数组 DatagramPacket packet = new DatagramPacket(bytes, bytes.length , InetAddress.getLocalHost(), 6666); // 创建要发送的 DatagramPacket socket.send(packet); // 发送数据报文到服务器 } } } package com.showguan.InternetDemo; import java.net.DatagramPacket; import java.net.DatagramSocket; import java.net.SocketException; public class Server { public static void main(String[] args) throws Exception { DatagramSocket socket = new DatagramSocket(6666); // 创建服务器端 DatagramSocket 实例，监听端口 6666 while (true) { byte[] buffer = new byte[1024*64]; // 创建字节数组用于存储接收的数据 DatagramPacket packet = new DatagramPacket(buffer, buffer.length); // 创建 DatagramPacket 用于接收数据 socket.receive(packet); // 接收客户端发送的数据报文 System.out.println(packet.getAddress()); // 打印客户端的 IP 地址 System.out.println(packet.getPort()); // 打印客户端的端口号 int len = packet.getLength(); // 获取接收到的数据长度 String s = new String(buffer, 0, len); // 将接收到的字节数组转换为字符串 System.out.println(s); // 打印接收到的消息 System.out.println(\u0026#34;--------------------\u0026#34;); } } } TCP协议 特点：面向连接，可靠通信 TCP的最终目的：要保证在不可靠的信道上实现可靠的传输 TCP主要有三个步骤实现可靠传输：三次握手建立连接，传输数据进行确认，四次挥手断开连接 可靠连接：确定通信双方，收发消息都是正常无问题的（全双工）\n三次握手才能确定彼此收发消息都是没问题的。\n传输数据会进行确认，以保证数据传输的可靠性\nTCP通信-支持与多个客户端同时通信 package com.showguan.CaseDemo; import java.io.DataOutputStream; import java.io.OutputStream; import java.net.Socket; import java.util.Scanner; public class Client { public static void main(String[] args) throws Exception { Socket socket = new Socket(\u0026#34;127.0.0.1\u0026#34;, 8888); // 创建客户端 Socket 并连接服务器 OutputStream os = socket.getOutputStream(); // 获取 Socket 的输出流 DataOutputStream dos = new DataOutputStream(os); // 包装输出流为 DataOutputStream Scanner sc = new Scanner(System.in); new ClientReaderThread(socket).start(); // 启动客户端读线程，用于接收服务端消息 while (true) { System.out.println(\u0026#34;请输入你需要发送的消息\u0026#34;); String msg = sc.nextLine(); // 读取用户输入的消息 if(msg.equals(\u0026#34;exit\u0026#34;)){ // 如果输入 exit，则退出循环 socket.close(); // 关闭客户端 Socket System.out.println(\u0026#34;成功退出通信\u0026#34;); dos.close(); // 关闭输出流 break; } dos.writeUTF(msg); // 向服务器发送消息 dos.flush(); // 刷新输出流，确保消息发送 } } } package com.showguan.CaseDemo; import java.io.DataInputStream; import java.io.InputStream; import java.net.Socket; public class ClientReaderThread extends Thread { private Socket socket; public ClientReaderThread(Socket socket) { this.socket = socket; // 初始化 Socket } @Override public void run() { try { InputStream is = socket.getInputStream(); // 获取输入流 DataInputStream dis = new DataInputStream(is); // 包装输入流为 DataInputStream while (true) { try { String msg = dis.readUTF(); // 读取服务端发送的消息 System.out.println(msg); // 打印接收到的消息 } catch (Exception e) { System.out.println(\u0026#34;您成功下线了！\u0026#34;); // 打印客户端下线信息 socket.close(); // 关闭 Socket 连接 dis.close(); // 关闭输入流 break; // 退出循环 } } } catch (Exception e) { e.printStackTrace(); } } } package com.showguan.CaseDemo; import java.io.*; import java.net.ServerSocket; import java.net.Socket; import java.util.ArrayList; import java.util.List; public class Server { public static List\u0026lt;Socket\u0026gt; onLineSockets = new ArrayList\u0026lt;\u0026gt;(); // 存储在线的客户端 Socket public static void main(String[] args) throws Exception { System.out.println(\u0026#34;服务端启动成功！\u0026#34;); ServerSocket serverSocket = new ServerSocket(8888); // 创建服务器端 ServerSocket，监听端口 8888 while (true) { Socket socket = serverSocket.accept(); // 等待客户端连接 onLineSockets.add(socket); // 添加客户端 Socket 到在线列表 System.out.println(\u0026#34;有人上线了！\u0026#34; + socket.getRemoteSocketAddress()); // 打印客户端地址信息 ServerReaderThread serverReaderThread = new ServerReaderThread(socket); // 创建服务器端读线程 serverReaderThread.start(); // 启动服务器端读线程处理客户端消息 } } } package com.showguan.CaseDemo; import java.io.*; import java.net.Socket; public class ServerReaderThread extends Thread { private Socket socket; public ServerReaderThread(Socket socket) { this.socket = socket; // 初始化 Socket } @Override public void run() { try { InputStream is = socket.getInputStream(); // 获取输入流 DataInputStream dis = new DataInputStream(is); // 包装输入流为 DataInputStream while (true) { String msg = null; try { msg = dis.readUTF(); // 读取客户端发送的消息 System.out.println(msg); // 打印接收到的消息 sendMsgToAll(msg); // 将消息发送给所有在线客户端 } catch (Exception e) { System.out.println(\u0026#34;用户： \u0026#34; + socket.getRemoteSocketAddress() + \u0026#34;下线了\u0026#34;); // 打印客户端下线信息 Server.onLineSockets.remove(socket); // 从在线列表中移除客户端 Socket socket.close(); // 关闭 Socket 连接 dis.close(); // 关闭输入流 break; // 退出循环 } } } catch (Exception e) { e.printStackTrace(); } } // 将消息发送给所有在线客户端 private void sendMsgToAll(String msg) throws Exception { for (Socket onLineSocket : Server.onLineSockets) { // 遍历在线客户端列表 if(onLineSocket.equals(socket)){ // 排除当前客户端 continue; } OutputStream os = onLineSocket.getOutputStream(); // 获取客户端的输出流 DataOutputStream dos = new DataOutputStream(os); // 包装输出流为 DataOutputStream dos.writeUTF(msg); // 发送消息给客户端 dos.flush(); // 刷新输出流 } } } BS 架构 import java.io.*; import java.net.*; import java.util.concurrent.*; /** * 一个简单的基于Socket的HTTP服务器示例 */ public class SimpleHttpServer { public static void main(String[] args) throws Exception { // 显示服务端启动成功信息 System.out.println(\u0026#34;服务端启动成功！\u0026#34;); // 创建ServerSocket并监听指定端口 ServerSocket serverSocket = new ServerSocket(8081); // 创建线程池，用于处理客户端请求 ThreadPoolExecutor pool = new ThreadPoolExecutor( 12 * 2, // 核心线程数 12 * 2, // 最大线程数 0, // 线程空闲超时时间 TimeUnit.SECONDS, // 时间单位 new ArrayBlockingQueue\u0026lt;\u0026gt;(8), // 任务队列 Executors.defaultThreadFactory(), // 线程工厂 new ThreadPoolExecutor.AbortPolicy()); // 拒绝策略 // 服务端循环监听客户端请求 while (true) { Socket socket = serverSocket.accept(); // 等待客户端连接 System.out.println(\u0026#34;有人访问网页！\u0026#34; + socket.getRemoteSocketAddress()); // 显示客户端连接信息 pool.execute(new ServerReaderThread(socket)); // 将连接交给线程池处理 } } } /** * 服务器读取线程，用于处理客户端请求 */ class ServerReaderThread extends Thread { private Socket socket; // 与客户端通信的Socket对象 /** * 构造方法，初始化Socket对象 * @param socket 与客户端通信的Socket对象 */ public ServerReaderThread(Socket socket) { this.socket = socket; } /** * 线程运行方法，处理客户端请求 */ @Override public void run() { try { OutputStream os = socket.getOutputStream(); // 获取输出流 PrintStream ps = new PrintStream(os); // 使用PrintStream包装输出流，方便写入响应数据 // HTTP响应头部信息 ps.println(\u0026#34;HTTP/1.1 200 OK\u0026#34;); // 响应状态码及状态信息 ps.println(\u0026#34;Content-Type:text/html;charset=UTF-8\u0026#34;); // 内容类型及编码 ps.println(); // 空行，表示头部信息结束 // HTTP响应体，返回一个简单的HTML页面 ps.println(\u0026#34;\u0026lt;div style=\u0026#39;color:red;font-size:120px;text-align:center\u0026#39;\u0026gt;Kennem\u0026lt;div\u0026gt;\u0026#34;); // 红色文本 ps.println(\u0026#34;\u0026lt;html\u0026gt;\u0026#34;); ps.println(\u0026#34;\u0026lt;head\u0026gt;\u0026#34;); ps.println(\u0026#34;\u0026lt;title\u0026gt;Welcome\u0026lt;/title\u0026gt;\u0026#34;); ps.println(\u0026#34;\u0026lt;/head\u0026gt;\u0026#34;); ps.println(\u0026#34;\u0026lt;body\u0026gt;\u0026#34;); ps.println(\u0026#34;\u0026lt;h1 style=\u0026#39;color:red;text-align:center;\u0026#39;\u0026gt;Welcome to my server!\u0026lt;/h1\u0026gt;\u0026#34;); ps.println(\u0026#34;\u0026lt;p style=\u0026#39;text-align:center;\u0026#39;\u0026gt;Here are some interesting links:\u0026lt;/p\u0026gt;\u0026#34;); ps.println(\u0026#34;\u0026lt;ul\u0026gt;\u0026#34;); ps.println(\u0026#34;\u0026lt;li\u0026gt;\u0026lt;a href=\u0026#39;https://www.example.com\u0026#39;\u0026gt;Example Website\u0026lt;/a\u0026gt;\u0026lt;/li\u0026gt;\u0026#34;); ps.println(\u0026#34;\u0026lt;li\u0026gt;\u0026lt;a href=\u0026#39;https://www.example2.com\u0026#39;\u0026gt;Another Example Website\u0026lt;/a\u0026gt;\u0026lt;/li\u0026gt;\u0026#34;); ps.println(\u0026#34;\u0026lt;/ul\u0026gt;\u0026#34;); ps.println(\u0026#34;\u0026lt;p style=\u0026#39;text-align:center;\u0026#39;\u0026gt;And here\u0026#39;s an image:\u0026lt;/p\u0026gt;\u0026#34;); ps.println(\u0026#34;\u0026lt;div style=\u0026#39;text-align:center;\u0026#39;\u0026gt;\u0026lt;img src=\u0026#39;https://th.bing.com/th/id/OIG3.ryWiFmseYX.jWcO7pmoz?pid=ImgGn\u0026#39; alt=\u0026#39;Example Image\u0026#39;\u0026gt;\u0026lt;/div\u0026gt;\u0026#34;); ps.println(\u0026#34;\u0026lt;/body\u0026gt;\u0026#34;); ps.println(\u0026#34;\u0026lt;/html\u0026gt;\u0026#34;); ps.close(); // 关闭输出流 } catch (Exception e) { e.printStackTrace(); // 输出异常信息 } } } 单元测试 就是针对最小的功能单元（方法），编写测试代码对其进行正确性测试。 Junit单元测试框架\n可以用来对方法进行测试，是第三方公司开源出来的 优点\n可以灵活的编写测试代码，可以针对某个方法执行测试，也支持一键完成对全部方法的自动化测试，且各自独立 不需要程序员去分析测试的结果，会自动生成测试报告 /** * StringUtilTest 类是用于测试 StringUtil 类中各个方法的测试类。 * 主要测试了 StringUtil 类中 printNumber() 和 getMaxIndex() 方法的功能和正确性。 * * 测试方法说明： * - testprintNumber(): 测试 printNumber() 方法，验证其对输入字符串的处理是否正确。 * - testGetMaxIndex(): 测试 getMaxIndex() 方法，验证其返回字符串中最大字母的索引是否正确。 * * 测试生命周期注解说明： * - @BeforeClass: 在该测试类的所有测试方法执行之前执行，用于初始化静态资源或执行一次性设置。 * - test11(): 测试 BeforeClass 生命周期方法，用于打印 BeforeClass 执行信息。 * * - @Before: 在每个测试方法执行之前执行，用于准备测试环境或执行某些预处理操作。 * - test1(): 测试 Before 生命周期方法，用于打印 Before 执行信息。 * * - @Test: 表示该方法是一个测试方法。 * - testprintNumber(): 测试 printNumber() 方法，验证其功能是否正确。 * - testGetMaxIndex(): 测试 getMaxIndex() 方法，验证其功能和返回值是否正确。 * * - @After: 在每个测试方法执行之后执行，用于清理测试环境或执行某些收尾操作。 * - test2(): 测试 After 生命周期方法，用于打印 After 执行信息。 * * - @AfterClass: 在该测试类的所有测试方法执行之后执行，用于执行清理操作或释放资源。 * - test22(): 测试 AfterClass 生命周期方法，用于打印 AfterClass 执行信息。 * * 其他说明： * - 使用断言机制验证 getMaxIndex() 方法的正确性。 * - 在 testGetMaxIndex() 方法中，使用 Assert.assertEquals() 断言方法，对比预期返回值和实际返回值是否相等。 */ public class StringUtilTest { /** * 在所有测试方法执行之前执行的静态方法，用于初始化静态资源或执行一次性设置。 */ @BeforeClass public static void test11() { System.out.println(\u0026#34;---test11 beforeClass 执行了---\u0026#34;); } /** * 在每个测试方法执行之前执行的方法，用于准备测试环境或执行某些预处理操作。 */ @Before public void test1() { System.out.println(\u0026#34;---test1 before 执行了---\u0026#34;); } /** * 测试 printNumber() 方法，验证其对输入字符串的处理是否正确。 */ @Test public void testprintNumber() { StringUtil.printNumber(\u0026#34;abcdefg\u0026#34;); StringUtil.printNumber(null); } /** * 测试 getMaxIndex() 方法，验证其返回字符串中最大字母的索引是否正确。 */ @Test public void testGetMaxIndex() { int idx1 = StringUtil.getMaxIndex(\u0026#34;abcdefg\u0026#34;); System.out.println(idx1); int idx2 = StringUtil.getMaxIndex(null); System.out.println(idx2); // 断言机制 Assert.assertEquals(\u0026#34;方法内部有bug\u0026#34;, 6, idx1); } /** * 在每个测试方法执行之后执行的方法，用于清理测试环境或执行某些收尾操作。 */ @After public void test2() { System.out.println(\u0026#34;---test2 after 执行了---\u0026#34;); } /** * 在所有测试方法执行之后执行的静态方法，用于执行清理操作或释放资源。 */ @AfterClass public static void test22() { System.out.println(\u0026#34;---test22 afterClass 执行了---\u0026#34;); } } 在测试方法执行前执行的方法：常用于：初始化资源 在测试方法执行完后再执行的方法，常用于：释放资源 在Junit 5.xxxx版本\n@Before-\u0026gt;@BeforeEach @After-\u0026gt;@AfterEach @BeforeClass-\u0026gt;@BeforeAll @AfterClass-\u0026gt;@AfterAll 反射(Reflection) 反射：加载类，并允许以编程的方式解剖类中的各种成分（成员变量，方法，构造器等） 1.加载类 public class Test1Class { public static void main(String[] args) throws Exception { // 1. 直接通过类名获取 Class 对象 Class c1 = String.class; System.out.println(c1.getName()); System.out.println(c1.getSimpleName()); // 2. 通过 Class.forName() 方法根据类的全限定名获取 Class 对象 Class c2 = Class.forName(\u0026#34;com.showguan.reflect_demo.Student\u0026#34;); System.out.println(c1 == c2); // 3. 通过实例对象的 getClass() 方法获取 Class 对象 Student s = new Student(); Class c3 = s.getClass(); System.out.println(c1 == c3); } } 2.获取构造器 public class Test2Constructor { /** * 获取类的所有公共构造方法并输出构造方法的名称和参数个数。 */ @Test public void testGetConstructors(){ Class c = Cat.class; Constructor[] constructors = c.getConstructors(); for (Constructor constructor : constructors) { System.out.println(constructor.getName() + \u0026#34;---\u0026gt;\u0026#34; + constructor.getParameterCount()); } } /** * 获取指定构造方法并通过 newInstance() 方法创建对象。 * 使用 setAccessible(true) 方法解除私有构造方法的访问限制。 */ @Test public void testGetConstructor() throws Exception { Class c = Cat.class; // 获取无参构造方法 Constructor constructor = c.getDeclaredConstructor(); System.out.println(constructor.getName() + \u0026#34; \u0026#34; + constructor.getParameterCount()); constructor.setAccessible(true); Cat cat = (Cat) constructor.newInstance(); System.out.println(cat); // 获取带参数的构造方法 Constructor constructor1 = c.getDeclaredConstructor(String.class, int.class); System.out.println(constructor1.getName() + \u0026#34; \u0026#34; + constructor1.getParameterCount()); constructor1.setAccessible(true); Cat cat1 = (Cat) constructor1.newInstance(\u0026#34;奶牛猫\u0026#34;, 3); System.out.println(cat1); } } 3.获取成员变量 public class Test4Field { /** * 获取类的所有字段信息，并演示了如何操作类的字段。 */ @Test public void testGetFields() throws Exception { Class c = Cat.class; // 获取类的所有字段信息并输出字段名和类型 Field[] fields = c.getDeclaredFields(); for (Field field : fields) { System.out.println(field.getName() + \u0026#34;---\u0026gt;\u0026#34; + field.getType()); } // 定位到特定成员变量 Field fAge = c.getDeclaredField(\u0026#34;age\u0026#34;); System.out.println(fAge.getName() + \u0026#34;---\u0026gt;\u0026#34; + fAge.getType()); Field fName = c.getDeclaredField(\u0026#34;name\u0026#34;); System.out.println(fName.getName() + \u0026#34;---\u0026gt;\u0026#34; + fName.getType()); // 创建 Cat 对象，并通过反射操作字段 Cat cat = new Cat(); fName.setAccessible(true); // 设置私有字段可访问 fName.set(cat, \u0026#34;奶牛猫\u0026#34;); // 设置字段值 String name = (String) fName.get(cat); // 获取字段值 System.out.println(name); } } 4.获取类方法 public class Test4Method { /** * 获取类的所有方法信息，并演示了如何通过反射调用类的方法。 */ @Test public void testGetMethods() throws Exception { Class c = Cat.class; // 获取类的所有方法信息并输出方法名、参数个数和返回类型 Method[] methods = c.getDeclaredMethods(); for (Method method : methods) { System.out.println(method.getName() + \u0026#34;---\u0026gt;\u0026#34; + method.getParameterCount() + \u0026#34;---\u0026gt;\u0026#34; + method.getReturnType()); } // 获取特定方法信息并输出 Method run = c.getDeclaredMethod(\u0026#34;run\u0026#34;); System.out.println(run.getName() + \u0026#34;---\u0026gt;\u0026#34; + run.getParameterCount() + \u0026#34;---\u0026gt;\u0026#34; + run.getReturnType()); Method eat = c.getDeclaredMethod(\u0026#34;eat\u0026#34;, String.class); System.out.println(eat.getName() + \u0026#34;---\u0026gt;\u0026#34; + eat.getParameterCount() + \u0026#34;---\u0026gt;\u0026#34; + eat.getReturnType()); // 创建 Cat 对象，并通过反射调用方法 Cat cat = new Cat(); run.setAccessible(true); // 设置私有方法可访问 Object invoke = run.invoke(cat); // 调用方法 System.out.println(invoke); eat.setAccessible(true); // 设置私有方法可访问 Object invoke1 = eat.invoke(cat, \u0026#34;鱼饼干\u0026#34;); // 调用方法 System.out.println(invoke1); } } 案例 public class ObjectFrame { /** * 将对象信息保存到文件。 * * @param obj 要保存信息的对象 * @throws Exception 可能抛出的异常 */ public static void saveObject(Object obj) throws Exception { // 创建 PrintStream 对象，用于写入文件 PrintStream ps = new PrintStream(new FileOutputStream(\u0026#34;junit-reflect-annotation-proxy-app\\\\src\\\\com\\\\showguan\\\\reflect_demo\\\\data.txt\u0026#34;, true)); Class c = obj.getClass(); String cName = c.getSimpleName(); ps.println(\u0026#34;--------------\u0026#34; + cName + \u0026#34;-----------------\u0026#34;); // 获取对象的所有字段信息，并写入文件 Field[] fields = c.getDeclaredFields(); for (Field field : fields) { String name = field.getName(); field.setAccessible(true); // 设置字段可访问 String value = field.get(obj) + \u0026#34;\u0026#34;; // 获取字段值 ps.println(name + \u0026#34; \u0026#34; + value); } ps.close(); // 关闭流 } } /** * Test5 类是一个用于测试 ObjectFrame 类的主程序。 * 主要创建了一个 Student 对象和一个 Teacher 对象，并将它们的信息保存到文件中。 */ package com.showguan.reflect_demo; public class Test5 { public static void main(String[] args) throws Exception{ // 创建 Student 对象和 Teacher 对象 Student s1 = new Student(\u0026#34;Kennem\u0026#34;, \u0026#39;男\u0026#39;, 21, 181.2, \u0026#34;lelele\u0026#34;); Teacher t1 = new Teacher(\u0026#34;tytytyt\u0026#34;, 21000); // 将对象信息保存到文件中 ObjectFrame.saveObject(s1); ObjectFrame.saveObject(t1); } } 注解（Annotation） 就是Java代码里的特殊标记，比如@Override, @Test等，作用是：让其他程序根据注解信息来决定怎么执行该程序 注意：注解可以用在类上，构造器上，方法上，成员变量上，参数上，等位置 自定义注解 /** * MyTest1 注解是一个自定义注解，具有三个属性： * - a：字符串类型属性。 * - b：布尔类型属性，默认值为 true。 * - c：字符串数组类型属性。 */ package com.showguan.annotation_demo; public @interface MyTest1 { String a(); boolean b() default true; String[] c(); } /** * MyTest2 注解是一个自定义注解，具有两个属性： * - value：字符串类型属性。 * - age：整数类型属性，默认值为 23。 * 如果注解中只有一个 value 属性，使用注解时，value 名称可以不写。 */ package com.showguan.annotation_demo; public @interface MyTest2 { // 特殊属性名 // 如果注解中只有一个value属性，使用注解时，value名称可以不写 String value(); int age() default 23; } /** * AnnotationTest1 类是一个演示注解的使用的示例程序。 * 使用了 MyTest1 和 MyTest2 两个自定义注解。 */ package com.showguan.annotation_demo; @MyTest1(a=\u0026#34;Kennem\u0026#34;, c={\u0026#34;HTML\u0026#34;, \u0026#34;CSS\u0026#34;}) public class AnnotationTest1 { /** * 使用了 MyTest1 注解，并指定了各属性的值。 */ @MyTest1(a=\u0026#34;tytyt\u0026#34;, b=false, c={\u0026#34;python\u0026#34;, \u0026#34;c++\u0026#34;}) public static void main(String[] args) { } /** * 使用了 MyTest2 注解，并指定了 value 属性的值。 */ @MyTest2(\u0026#34;value\u0026#34;) public static void test1(){ } } 元注解 修饰注解的注解 /** * MyTest3 注解是一个自定义注解，用于标记类、方法和字段。 * 它具有以下特性： * - @Target({ElementType.TYPE, ElementType.METHOD, ElementType.FIELD})：指定该注解可以用于类、方法和字段上。 * - @Retention(RetentionPolicy.RUNTIME)：声明注解的保留周期为运行时，使得该注解在运行时可以通过反射获取到。 */ package com.showguan.annotation_demo; import java.lang.annotation.ElementType; import java.lang.annotation.Retention; import java.lang.annotation.RetentionPolicy; import java.lang.annotation.Target; @Target({ElementType.TYPE, ElementType.METHOD, ElementType.FIELD}) @Retention(RetentionPolicy.RUNTIME) public @interface MyTest3 { } /** * AnnotationTest2 类是一个演示注解的使用的示例程序。 * 使用了 MyTest3 注解，并标记了类、字段和方法。 */ package com.showguan.annotation_demo; import org.junit.Test; @MyTest3 public class AnnotationTest2 { /** * 使用了 MyTest3 注解，标记了字段。 */ @MyTest3 private int test; /** * 使用了 MyTest3 注解，标记了方法。 */ @MyTest3 @Test public void m() { } } 注解的解析\n就是判断类上，方法上，成员变量上是否存在注解，并把注解里的内容给解析出来 解析注解 package com.showguan.annotation_demo; import java.lang.annotation.ElementType; import java.lang.annotation.Retention; import java.lang.annotation.RetentionPolicy; import java.lang.annotation.Target; // 定义一个自定义注解 MyTest4 @Target({ElementType.TYPE, ElementType.METHOD}) // 可以标记在类和方法上 @Retention(RetentionPolicy.RUNTIME) // 注解信息在运行时保留 public @interface MyTest4 { String value(); // 声明一个属性 value，类型为 String double aaa() default 100; // 声明一个属性 aaa，类型为 double，默认值为 100 String[] bbb(); // 声明一个属性 bbb，类型为 String 数组 } package com.showguan.annotation_demo; // 使用自定义注解 MyTest4 标记类和方法 @MyTest4(value = \u0026#34;Kennem\u0026#34;, aaa = 10.0, bbb = {\u0026#34;至尊宝\u0026#34;, \u0026#34;tytt\u0026#34;}) public class Demo { // 使用自定义注解 MyTest4 标记方法 @MyTest4(value = \u0026#34;yl\u0026#34;, aaa = 199.2, bbb = {\u0026#34;best\u0026#34;, \u0026#34;牛夫人\u0026#34;}) public void test1(){ } } package com.showguan.annotation_demo; import org.junit.Test; import java.lang.annotation.Annotation; import java.lang.reflect.Method; import java.util.Arrays; // 测试解析自定义注解 MyTest4 public class AnnotationTest3 { // 解析类上的自定义注解 @Test public void parseClass(){ Class c = Demo.class; if(c.isAnnotationPresent(MyTest4.class)){ MyTest4 myTest4 = (MyTest4) c.getDeclaredAnnotation(MyTest4.class); System.out.println(myTest4.value()); System.out.println(myTest4.aaa()); System.out.println(Arrays.toString(myTest4.bbb())); } } // 解析方法上的自定义注解 @Test public void parseMethod() throws Exception{ Class c = Demo.class; Method m = c.getDeclaredMethod(\u0026#34;test1\u0026#34;); if(m.isAnnotationPresent(MyTest4.class)){ MyTest4 myTest4 = (MyTest4) m.getDeclaredAnnotation(MyTest4.class); System.out.println(myTest4.value()); System.out.println(myTest4.aaa()); System.out.println(Arrays.toString(myTest4.bbb())); } } } 模拟Junit框架 package com.showguan.annotation_demo; import java.lang.annotation.ElementType; import java.lang.annotation.Retention; import java.lang.annotation.RetentionPolicy; import java.lang.annotation.Target; // 定义一个自定义注解 MyTest，用于标记方法 @Target(ElementType.METHOD) // 可以标记在方法上 @Retention(RetentionPolicy.RUNTIME) // 注解信息在运行时保留 public @interface MyTest { } package com.showguan.annotation_demo; import org.junit.Test; import java.lang.reflect.InvocationTargetException; import java.lang.reflect.Method; // 测试自定义注解 MyTest public class AnnotationTest4 { // 标记为 MyTest 的方法 @MyTest public void test1(){ System.out.println(\u0026#34;---test1---\u0026#34;); } // 标记为 MyTest 的方法 @MyTest public void test2(){ System.out.println(\u0026#34;---test2---\u0026#34;); } // 没有标记为 MyTest 的方法 public void test3(){ System.out.println(\u0026#34;---test3---\u0026#34;); } // 没有标记为 MyTest 的方法 public void test4(){ System.out.println(\u0026#34;---test4---\u0026#34;); } // 主方法用于运行测试标记为 MyTest 的方法 public static void main(String[] args) throws Exception{ AnnotationTest4 a = new AnnotationTest4(); Class c = AnnotationTest4.class; Method[] methods = c.getDeclaredMethods(); for (Method method : methods) { if(method.isAnnotationPresent(MyTest.class)){ method.invoke(a); // 调用标记为 MyTest 的方法 } } } } 动态代理 Proxy类 package com.showguan.proxy_demo; import java.lang.reflect.InvocationHandler; import java.lang.reflect.Method; import java.lang.reflect.Proxy; // 代理模式示例 public class ProxyUtil { // 创建代理对象的方法 public static Star createProxy(BigStar bigStar) { // 使用Java的动态代理创建代理对象 Star starProxy = (Star) Proxy.newProxyInstance( ProxyUtil.class.getClassLoader(), // 使用当前类的类加载器加载代理类 new Class[]{Star.class}, // 指定代理对象实现的接口，这里是Star接口 new InvocationHandler() { // 设置代理对象的调用处理器，即InvocationHandler @Override public Object invoke(Object proxy, Method method, Object[] args) throws Throwable { /** * Object proxy：代理对象，用于调用被代理对象的方法或执行其他操作。 * Method method：表示被调用的方法，允许获取方法的相关信息或调用该方法。 * Object[] args：方法的参数数组，包含了被调用方法的参数列表，允许获取和处理参数。 */ // 对代理对象的方法进行拦截和增强 if (method.getName().equals(\u0026#34;sing\u0026#34;)) { // 如果是sing方法 System.out.println(\u0026#34;准备话筒，收钱20万\u0026#34;); // 增强处理：准备话筒 return method.invoke(bigStar, args); // 调用原始对象的方法 } else if (method.getName().equals(\u0026#34;dance\u0026#34;)) { // 如果是dance方法 System.out.println(\u0026#34;准备场地，收钱1000万\u0026#34;); // 增强处理：准备场地 return method.invoke(bigStar, args); // 调用原始对象的方法 } return method.invoke(bigStar, args); // 对于其他方法，直接调用原始对象的方法 } }); return starProxy; // 返回创建的代理对象 } } Star接口 package com.showguan.proxy_demo; // 明星接口，定义了唱歌和跳舞的方法 public interface Star { String sing(String name); // 唱歌方法，传入歌曲名字，返回感谢信息 void dance(); // 跳舞方法 } BigStar类 package com.showguan.proxy_demo; // 具体的明星类，实现了Star接口 public class BigStar implements Star { private String name; // 明星的姓名 // 构造方法，传入明星的姓名 public BigStar(String name) { this.name = name; } // 获取明星姓名的方法 public String getName() { return name; } // 设置明星姓名的方法 public void setName(String name) { this.name = name; } // 实现唱歌方法，传入歌曲名字，打印出歌手名字和歌曲名字，并返回感谢信息 @Override public String sing(String name) { System.out.println(this.name + \u0026#34;正在唱歌:\u0026#34; + name); return \u0026#34;感谢大家\u0026#34;; } // 实现跳舞方法，打印出歌手名字并提示正在跳舞 @Override public void dance() { System.out.println(this.name + \u0026#34;正在优美的跳舞\u0026#34;); } } Test类 package com.showguan.proxy_demo; // 测试类 public class Test { public static void main(String[] args) { BigStar s = new BigStar(\u0026#34;ycy\u0026#34;); // 创建一个具体的明星对象 Star starProxy = ProxyUtil.createProxy(s); // 使用代理工具类创建代理对象 String rs = starProxy.sing(\u0026#34;卡路里\u0026#34;); // 调用代理对象的唱歌方法 System.out.println(rs); // 打印唱歌方法的返回值 starProxy.dance(); // 调用代理对象的跳舞方法 } } 使用案例 接口 package com.showguan.proxy_demo2; // 用户服务接口，定义了登录、删除用户和查询用户的方法 public interface UserService { void login(String loginName, String passWrod) throws Exception; // 登录方法，传入登录名和密码 void deleteUsers() throws Exception; // 删除用户方法 String[] selectUsers() throws Exception; // 查询用户方法，返回用户数组 } 接口实现 package com.showguan.proxy_demo2; // 用户服务实现类，实现了UserService接口 public class UserServiceImpl implements UserService { // 实现登录方法，验证用户名密码并输出登录成功或失败信息 @Override public void login(String loginName, String passWrod) throws Exception { if (\u0026#34;admin\u0026#34;.equals(loginName) \u0026amp;\u0026amp; passWrod.equals(\u0026#34;123456\u0026#34;)) { System.out.println(\u0026#34;登录成功！\u0026#34;); } else { System.out.println(\u0026#34;用户名或密码错误！\u0026#34;); } Thread.sleep(1000); // 模拟登录操作耗时 } // 实现删除用户方法，输出删除成功信息 @Override public void deleteUsers() throws Exception { System.out.println(\u0026#34;成功删除了10000个用户\u0026#34;); Thread.sleep(1000); // 模拟删除操作耗时 } // 实现查询用户方法，输出查询结果并返回用户数组 @Override public String[] selectUsers() throws Exception { System.out.println(\u0026#34;查询出三个用户：\u0026#34;); String[] names = {\u0026#34;kenene\u0026#34;, \u0026#34;Kennem\u0026#34;, \u0026#34;kkk\u0026#34;}; Thread.sleep(1000); // 模拟查询操作耗时 return names; } } 代理工具类 package com.showguan.proxy_demo2; import java.lang.reflect.InvocationHandler; import java.lang.reflect.Method; import java.lang.reflect.Proxy; // 代理工具类，用于创建代理对象 public class ProxyUtil { // 创建代理对象的方法 public static UserService createProxy(UserService userService) { UserService userServiceProxy = (UserService) Proxy.newProxyInstance( ProxyUtil.class.getClassLoader(), // 使用当前类的类加载器加载代理类 new Class[]{UserService.class}, // 指定代理对象实现的接口，这里是UserService接口 new InvocationHandler() { // 设置代理对象的调用处理器，即InvocationHandler @Override public Object invoke(Object proxy, Method method, Object[] args) throws Throwable { if (method.getName().equals(\u0026#34;login\u0026#34;) || method.getName().equals(\u0026#34;deleteUsers\u0026#34;) || method.getName().equals(\u0026#34;selectUsers\u0026#34;)) { // 如果是登录、删除用户或查询用户方法 long startTime = System.currentTimeMillis(); // 记录方法调用开始时间 Object rs = method.invoke(userService, args); // 调用原始对象的方法 long endTime = System.currentTimeMillis(); // 记录方法调用结束时间 System.out.println(method.getName() + \u0026#34;方法执行耗时:\u0026#34; + (endTime - startTime) / (1000.0) + \u0026#34;s\u0026#34;); // 输出方法执行耗时 return rs; // 返回方法调用结果 } else { // 对于其他方法，直接调用原始对象的方法 Object rs = method.invoke(userService, args); return rs; } } }); return userServiceProxy; // 返回创建的代理对象 } } 测试类 package com.showguan.proxy_demo2; // 测试类 public class Test { public static void main(String[] args) throws Exception { UserService us = ProxyUtil.createProxy(new UserServiceImpl()); // 使用代理工具类创建代理对象 us.login(\u0026#34;admin\u0026#34;, \u0026#34;123456\u0026#34;); // 调用代理对象的登录方法 System.out.println(\u0026#34;---------------\u0026#34;); us.deleteUsers(); // 调用代理对象的删除用户方法 System.out.println(\u0026#34;---------------\u0026#34;); us.selectUsers(); // 调用代理对象的查询用户方法 System.out.println(\u0026#34;---------------\u0026#34;); } } ","permalink":"https://kennems.github.io/posts/tech/java20%E5%A4%A9%E9%80%9F%E6%88%90%E8%BF%9B%E9%98%B6%E8%AF%BE%E7%A8%8B5/","summary":"Java20天速成——进阶课程(5) 网络编程 可以让设备中的程序与网络上其他设备中的程序进行数据交互（实现网络通信） 基本的通信架构 基本的通信架","title":"Java20天速成——进阶课程(5)"},{"content":"力扣周赛394(20240421) 第三题100290. 使矩阵满足条件的最少操作次数 题目大意：给定一个大小为 m x n 的二维矩形 grid，每次操作可以将任意格子的值修改为任意非负整数。完成所有操作后，需要确保每个格子 grid[i][j] 的值满足以下条件：如果下面相邻格子存在的话，它们的值相等；如果右边相邻格子存在的话，它们的值不相等。返回需要的最少操作次数。 记忆化 实现思路：首先，统计每一列中各个数字的出现次数。然后，使用动态规划的方法，定义函数dfs(i, pre)，表示处理到第i列时，前一列的值为pre时的最大操作次数。在dfs中，对于当前列的每个数字，考虑是否修改当前列的值，然后递归处理下一列。利用缓存来避免重复计算。最后返回总的操作次数。 class Solution: # 如果你想不出来，1、你不知道这个知识点 2、 你知道这个知识点但是方向错了 def minimumOperations(self, g: List[List[int]]) -\u0026gt; int: n, m = len(g), len(g[0]) cnt = [[0]*10 for _ in range(m)] for row in g: for k, v in enumerate(row): cnt[k][v]+=1 @cache def dfs(i, pre): if i\u0026lt;0: return 0 res = 0 for v in range(10): if v!=pre: res = max(res, dfs(i-1, v) + cnt[i][v]) return res return m*n - dfs(m-1, -1) 递推 实现思路：首先，对每一列进行遍历，并统计每列中每个数字的出现次数。然后，通过动态规划的方法，使用两个变量f0和f1分别表示当前列处理时，前一列最大能保留的个数和次大能够保留的个数。接着，通过遍历每列中的每个数字，计算当前列的最大操作次数，并更新f0和f1。最后返回总的操作次数。 class Solution: def minimumOperations(self, grid: List[List[int]]) -\u0026gt; int: n, m = len(grid), len(grid[0]) f0, f1, pre = 0, 0, -1 for col in zip(*grid): mx, mx2, x = f0, f1, -1 for v, c in Counter(col).items(): res = (f0 if v!=pre else f1) + c if res \u0026gt; mx: mx, mx2, x = res, mx, v elif res \u0026gt; mx2: mx2 = res f0, f1, pre = mx, mx2, x return m*n - f0 第四题100276. 最短路径中的边 题目大意：给定一个包含n个节点的无向带权图，节点编号从0到n-1，总共有m条边。对于节点0为出发点，节点n-1为结束点的所有最短路，需要返回一个长度为m的布尔数组，如果edges[i]至少在其中一条最短路上，则answer[i]为true，否则为false。\n实现思路：首先构建图的邻接表表示。然后使用Dijkstra算法求解最短路径，并记录最短路径的长度。接着，从结束点开始反向遍历最短路径，标记经过的边。最后返回标记结果。\nclass Solution: # 多动脑子，把外界的干扰降到最低，人生永远充满着干扰 def findAnswer(self, n: int, edges: List[List[int]]) -\u0026gt; List[bool]: m = len(edges) g = defaultdict(list) INF = 0x3f3f3f3f dis, st = [INF]*(n+5), [False]*(n+5) for i, val in enumerate(edges): x, y, w = val g[x].append((y, w, i)) g[y].append((x, w, i)) def dijkstra(): dis[0]=0 h=[] heappush(h, (0, 0)) while h: dist, ver = heappop(h) if st[ver]: continue st[ver]=True for y, w, _ in g[ver]: if dis[y]\u0026gt;dis[ver]+w: dis[y]=dis[ver]+w heappush(h, (dis[y], y)) if dis[n-1]==INF: return -1 else: return dis[n-1] res = [False]*m dn = dijkstra() if dn==-1: return res q = deque() q.append(n-1) while q: f = q.popleft() for y, w, i in g[f]: if dis[y]+w == dis[f]: res[i]=True q.append(y) return res ","permalink":"https://kennems.github.io/posts/tech/%E5%8A%9B%E6%89%A3%E5%91%A8%E8%B5%9B39420240421/","summary":"力扣周赛394(20240421) 第三题100290. 使矩阵满足条件的最少操作次数 题目大意：给定一个大小为 m x n 的二维矩形 grid，每次操作","title":"LeetCode周赛240421"},{"content":"Java20天速成——进阶课程(4) 特殊文件 properties, xml\n为什么要用这些特殊文件？\n存储多个用户的：用户名， 密码， 家乡， 性别\n日志技术\n把程序运行的信息，记录到文件中，方便程序员定位bug， 并了解程序的执行情况等。\nProperties 是一个Map集合（键值对集合）， 但是一般不会当集合使用 核心作用：Properties是用来代表属性文件的，通过Properties可以读写属性文件里面的内容 public static void main(String[] args) throws IOException { // 创建一个Properties对象 Properties properties = new Properties(); // 输出初始的Properties对象，此时为空 System.out.println(properties); // 从文件加载Properties数据 properties.load(new FileReader(\u0026#34;file-io-app\\\\properties-xml-log-app\\\\src\\\\users.properties\u0026#34;)); // 输出加载后的Properties对象，包含从文件中读取的键值对 System.out.println(properties); // 根据指定键取得对应的值 System.out.println(properties.get(\u0026#34;ken\u0026#34;)); // 获取Properties对象中所有的键，并遍历输出每个键值对 Set\u0026lt;String\u0026gt; keys = properties.stringPropertyNames(); for (String key : keys) { String val = properties.getProperty(key); System.out.println(key + \u0026#34;----\u0026gt;\u0026#34; + val); } } XML 本质是一种数据的格式，可以用来存储复杂的数据结构，和数据关系 XML特点\nXML中的\u0026lt;标签名\u0026gt;称为一个标签或一个元素，一般是成对出现的 xml解析(dom4j) public static void main(String[] args) throws DocumentException { // 创建SAXReader对象 SAXReader saxReader = new SAXReader(); // 使用SAXReader解析XML文件并生成Document对象 Document document = saxReader.read(\u0026#34;file-io-app\\\\properties-xml-log-app\\\\src\\\\helloworld.xml\u0026#34;); // 获取XML文档的根元素并输出其名称 Element root = document.getRootElement(); System.out.println(root.getName()); // 获取根元素下名为\u0026#34;user\u0026#34;的所有子元素并输出它们的名称 List\u0026lt;Element\u0026gt; elements = root.elements(\u0026#34;user\u0026#34;); for (Element element : elements) { System.out.println(element.getName()); } // 获取名为\u0026#34;people\u0026#34;的元素的文本内容并输出 Element people = root.element(\u0026#34;people\u0026#34;); System.out.println(people.getText()); // 获取名为\u0026#34;user\u0026#34;的元素下名为\u0026#34;user\u0026#34;的子元素的文本内容并输出 Element user = root.element(\u0026#34;user\u0026#34;); System.out.println(user.elementText(\u0026#34;user\u0026#34;)); // 获取名为\u0026#34;user\u0026#34;的元素的名为\u0026#34;id\u0026#34;的属性值并输出 System.out.println(user.attributeValue(\u0026#34;id\u0026#34;)); // 获取名为\u0026#34;user\u0026#34;的元素的名为\u0026#34;id\u0026#34;的属性，并输出属性名和属性值 Attribute id = user.attribute(\u0026#34;id\u0026#34;); System.out.println(id.getName()); System.out.println(id.getValue()); // 获取名为\u0026#34;user\u0026#34;的元素的所有属性，并输出它们的名和值 List\u0026lt;Attribute\u0026gt; attributes = user.attributes(); for (Attribute attribute : attributes) { System.out.println(attribute.getName() + attribute.getValue()); } // 输出名为\u0026#34;user\u0026#34;的元素下名为\u0026#34;name\u0026#34;、\u0026#34;地址\u0026#34;和\u0026#34;password\u0026#34;的子元素的文本内容 System.out.println(user.elementText(\u0026#34;name\u0026#34;)); System.out.println(user.elementText(\u0026#34;地址\u0026#34;)); System.out.println(user.elementText(\u0026#34;password\u0026#34;)); // 获取名为\u0026#34;user\u0026#34;的元素下名为\u0026#34;data\u0026#34;的子元素的文本内容，并输出包括前后空格的文本和去除前后空格的文本 Element data = user.element(\u0026#34;data\u0026#34;); System.out.println(data.getText()); System.out.println(data.getTextTrim()); //去除前后空格 } 写入XML文件 使用程序把数据写出到xml中\n不建议使用dom4j， 推荐直接把程序里的数据拼接成xml格式\npublic static void main(String[] args) throws IOException { // 创建一个StringBuilder对象，用于构建XML内容 StringBuilder sb = new StringBuilder(); // 构建XML头部信息和根元素 sb.append(\u0026#34;\u0026lt;?xml version=\\\u0026#34;1.0\\\u0026#34; encoding=\\\u0026#34;utf-8\\\u0026#34; ?\u0026gt;\u0026#34;); sb.append(\u0026#34;\u0026lt;book\u0026gt;\\r\\n\u0026#34;); // 添加书名、作者和价格信息作为子元素 sb.append(\u0026#34;\u0026lt;name\u0026gt;\u0026#34;).append(\u0026#34;从入门到删库\u0026#34;).append(\u0026#34;\u0026lt;/name\u0026gt;\\r\\n\u0026#34;); sb.append(\u0026#34;\u0026lt;author\u0026gt;\u0026#34;).append(\u0026#34;ai\u0026#34;).append(\u0026#34;\u0026lt;/author\u0026gt;\\r\\n\u0026#34;); sb.append(\u0026#34;\u0026lt;price\u0026gt;\u0026#34;).append(999.999).append(\u0026#34;\u0026lt;/price\u0026gt;\\r\\n\u0026#34;); // 关闭根元素 sb.append(\u0026#34;\u0026lt;/book\u0026gt;\\r\\n\u0026#34;); try ( // 使用try-with-resources语法创建BufferedWriter对象，将内容写入到文件中 BufferedWriter bw = new BufferedWriter(new FileWriter(\u0026#34;file-io-app\\\\properties-xml-log-app\\\\src\\\\test.xml\u0026#34;)); ){ bw.write(sb.toString()); // 将StringBuilder对象中的内容写入到文件中 } catch (Exception e) { e.printStackTrace(); // 打印异常信息 } } 约束XML文件的书写 就是限制XML文件只能按照某种格式进行书写 约束文档：\n专门用来显示xml书写格式的文档，比如：限制标签，属性该怎么写 约束文档的分类\nDTD文档 Schema文档 XML文档结束-DTD的使用 需求：利用DTD约束文档，约束一个XML文件的编写。\nDTD(约束文档)\n\u0026lt;!ELEMENT 书架 (书+)\u0026gt; \u0026lt;!ELEMENT 书 (书名,作者,售价)\u0026gt; \u0026lt;!ELEMENT 书名 (#PCDATA)\u0026gt; \u0026lt;!ELEMENT 作者 (#PCDATA)\u0026gt; \u0026lt;!ELEMENT 售价 (#PCDATA)\u0026gt; XML文档\n\u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;UTF-8\u0026#34; ?\u0026gt; \u0026lt;!DOCTYPE 书架 SYSTEM \u0026#34;data.dtd\u0026#34;\u0026gt; \u0026lt;书架\u0026gt; \u0026lt;书\u0026gt; \u0026lt;书名\u0026gt;从删库到跑路\u0026lt;/书名\u0026gt; \u0026lt;作者\u0026gt;Kenn\u0026lt;/作者\u0026gt; \u0026lt;售价\u0026gt;0.3\u0026lt;/售价\u0026gt; \u0026lt;/书\u0026gt; \u0026lt;/书架\u0026gt; XML文档结束-schema的使用 可以约束XML文件的编写、和数据类型 \u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;UTF-8\u0026#34; ?\u0026gt; \u0026lt;schema xmlns=\u0026#34;http://www.w3.org/2001/XMLSchema\u0026#34; targetNamespace=\u0026#34;http://www.itcast.cn\u0026#34; elementFormDefault=\u0026#34;qualified\u0026#34; \u0026gt; \u0026lt;!-- targetNamespace:申明约束文档的地址（命名空间）--\u0026gt; \u0026lt;element name=\u0026#39;书架\u0026#39;\u0026gt; \u0026lt;!-- 写子元素 --\u0026gt; \u0026lt;complexType\u0026gt; \u0026lt;!-- maxOccurs=\u0026#39;unbounded\u0026#39;: 书架下的子元素可以有任意多个！--\u0026gt; \u0026lt;sequence maxOccurs=\u0026#39;unbounded\u0026#39;\u0026gt; \u0026lt;element name=\u0026#39;书\u0026#39;\u0026gt; \u0026lt;!-- 写子元素 --\u0026gt; \u0026lt;complexType\u0026gt; \u0026lt;sequence\u0026gt; \u0026lt;element name=\u0026#39;书名\u0026#39; type=\u0026#39;string\u0026#39;/\u0026gt; \u0026lt;element name=\u0026#39;作者\u0026#39; type=\u0026#39;string\u0026#39;/\u0026gt; \u0026lt;element name=\u0026#39;售价\u0026#39; type=\u0026#39;double\u0026#39;/\u0026gt; \u0026lt;/sequence\u0026gt; \u0026lt;/complexType\u0026gt; \u0026lt;/element\u0026gt; \u0026lt;/sequence\u0026gt; \u0026lt;/complexType\u0026gt; \u0026lt;/element\u0026gt; \u0026lt;/schema\u0026gt; XML\n\u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;UTF-8\u0026#34; ?\u0026gt; \u0026lt;书架 xmlns=\u0026#34;http://www.itcast.cn\u0026#34; xmlns:xsi=\u0026#34;http://www.w3.org/2001/XMLSchema-instance\u0026#34; xsi:schemaLocation=\u0026#34;http://www.itcast.cn data.xsd\u0026#34;\u0026gt; \u0026lt;!-- xmlns=\u0026#34;http://www.itcast.cn\u0026#34; 基本位置 xsi:schemaLocation=\u0026#34;http://www.itcast.cn books02.xsd\u0026#34; 具体的位置 --\u0026gt; \u0026lt;书\u0026gt; \u0026lt;书名\u0026gt;从入门到删除\u0026lt;/书名\u0026gt; \u0026lt;作者\u0026gt;dlei\u0026lt;/作者\u0026gt; \u0026lt;售价\u0026gt;0.03\u0026lt;/售价\u0026gt; \u0026lt;/书\u0026gt; \u0026lt;书\u0026gt; \u0026lt;书名\u0026gt;从入门到删除\u0026lt;/书名\u0026gt; \u0026lt;作者\u0026gt;dlei\u0026lt;/作者\u0026gt; \u0026lt;售价\u0026gt;0.9\u0026lt;/售价\u0026gt; \u0026lt;/书\u0026gt; \u0026lt;/书架\u0026gt; Logback快速入门 需求：\n使用Logback日志框架，记录系统的运行信息 实现步骤\n导入Logback框架到项目中去\nslf4j-api：日志接口 logback-core logback-classic 将Logback框架的核心配置文件logback.xml直接拷贝到src目录下（必须是src下）\n创建Logback框架提供的Logger对象，然后用Logger对象调用其提供的方法就可记录系统的日志信息。\npublic static final Logger LOGGER = LoggerFactory.getLogger(\u0026#34;LogBackTest\u0026#34;); 核心配置文件logback.xml\n对Logback日志框架进行控制 Logback设置日志级别\n日志级别指的是日志信息的类型，日志都会分级别，常见的日志级别如下（优先级依次升高） 日志级别 说明 trace 追踪，指明程序运行轨迹 debug 调试，实际应用中一般将其作为最低级别 info 输出重要的运行信息，数据连接，网络连接，IO操作等等，使用较多 warn 警告信息，可能会发生问题，使用较多 error 错误信息，使用较多 配置文件配置如下：\n\u0026lt;root level=\u0026#34;debug\u0026#34;\u0026gt; \u0026lt;appender-ref ref=\u0026#34;CONSOLE\u0026#34;/\u0026gt; \u0026lt;appender-ref ref=\u0026#34;FILE\u0026#34; /\u0026gt; \u0026lt;/root\u0026gt; 只有日志的级别是大于或等于核心配置文件配值的日志级别，才会被记录，否则不记录。 多线程 线程（Thread）是一个程序内部的一条执行流程 程序中如果只有一条执行流程，那这个程序就是单线程的程序 多线程\n多线程是指从软硬件上实现的多条执行流程的技术（多条线程由CPU负责调度执行） 方式一：继承Thread类 public class MyThread extends Thread{ @Override public void run() { for (int i = 0; i \u0026lt; 100; i++) { System.out.println(\u0026#34;子线程MyThread\u0026#34; + i); } } } public static void main(String[] args) { MyThread t = new MyThread(); t.start(); for (int i = 0; i \u0026lt; 100; i++) { System.out.println(\u0026#34;主线程main输出：\u0026#34; + i); } } 优缺点：\n优点：编码简单 缺点：线程类已经继承Thread, 无法继承其他类，不利于功能的扩展 注意事项：\n调用的是start而不是run 不要把主线程任务放在启动子线程之前 方式二：实现Runnable接口 public class Demo2 { public static void main(String[] args) { MyRunnable target = new MyRunnable(); new Thread(target).start(); for (int i = 0; i \u0026lt; 1000; i++) { System.out.println(\u0026#34;===主线程输出\u0026#34; + i); } } } public class MyRunnable implements Runnable{ @Override public void run() { for (int i = 0; i \u0026lt; 1000; i++) { System.out.println(\u0026#34;子线程输出===\u0026#34; + i); } } } 定义一个线程任务类MyRunnable实现Runnable接口， 重写run()方法 创建MyRunnable任务对象 把MyRunnbale任务对象交给Thread处理 优缺点：\n优点：实现Runnable接口后，可以继续继承其他类，实现其他接口，扩展性强 缺点：需要多一个Runnable对象 public static void main(String[] args) { // 创建并启动第一个子线程 Runnable target1 = new Runnable() { @Override public void run() { for (int i = 0; i \u0026lt; 100; i++) { System.out.println(\u0026#34;子线程输出:\u0026#34; + i); } } }; new Thread(target1).start(); // 主线程执行 for (int i = 0; i \u0026lt; 100; i++) { System.out.println(\u0026#34;主线程:\u0026#34; + i); } // 创建并启动第二个子线程，使用Lambda表达式 new Thread(() -\u0026gt; { for (int i = 0; i \u0026lt; 100; i++) { System.out.println(\u0026#34;子线程2:\u0026#34; + i); } }).start(); // 主线程继续执行 for (int i = 0; i \u0026lt; 100; i++) { System.out.println(\u0026#34;主线程:\u0026#34; + i); } } 方式三：利用Callable接口，FutureTask类来实现 MyCallable\npackage com.showguan.ThreadDemo; import java.util.concurrent.Callable; public class MyCallable implements Callable\u0026lt;String\u0026gt; { private int n; public MyCallable() { } public MyCallable(int n) { this.n = n; } @Override public String call() throws Exception { int sum = 0; for (int i = 0; i \u0026lt; n; i++) { sum += i; } return \u0026#34;线程求和结果为\u0026#34; + sum; } } package com.showguan.ThreadDemo; import java.util.concurrent.Callable; import java.util.concurrent.ExecutionException; import java.util.concurrent.FutureTask; public class Demo4 { public static void main(String[] args) throws ExecutionException, InterruptedException { Callable\u0026lt;String\u0026gt; call = new MyCallable(100); FutureTask\u0026lt;String\u0026gt; ft = new FutureTask\u0026lt;\u0026gt;(call); new Thread(ft).start(); Callable\u0026lt;String\u0026gt; call2 = new MyCallable(200); FutureTask\u0026lt;String\u0026gt; ft2 = new FutureTask\u0026lt;\u0026gt;(call2); new Thread(ft2).start(); String rs = ft.get(); System.out.println(rs); //线程求和结果为4950 String rs2 = ft2.get(); System.out.println(rs2); //线程求和结果为19900 } } 优点：\n线程任务类只是实现接口，可以继续继承类和实现接口，扩展性强；可以在线程执行完毕后去获取线程执行的结果。 线程常用方法 为线程设置名称 public class Main { public static void main(String[] args) { // 创建并启动线程 t1 Thread t1 = new MyThread(\u0026#34;线程一号\u0026#34;); t1.start(); System.out.println(t1.getName()); // 打印线程 t1 的名称 // 创建并启动线程 t2 Thread t2 = new MyThread(\u0026#34;线程二号\u0026#34;); t2.start(); System.out.println(t2.getName()); // 打印线程 t2 的名称 // 获取当前线程，并将其名称设置为 \u0026#34;max线程\u0026#34; Thread m = Thread.currentThread(); m.setName(\u0026#34;max线程\u0026#34;); System.out.println(m.getName()); // 打印当前线程的名称 // 在当前线程中执行一个简单的 for 循环，打印输出当前线程的名称和循环变量 i for (int i = 0; i \u0026lt; 100; i++) { System.out.println(m.getName() + \u0026#34;线程输出\u0026#34; + i); } } } // 自定义线程类 MyThread package com.showguan.ThreadDemo; public class MyThread extends Thread { public MyThread() { } public MyThread(String name) { super(name); } @Override public void run() { for (int i = 0; i \u0026lt; 100; i++) { System.out.println(Thread.currentThread().getName() + \u0026#34;开始执行。\u0026#34;); System.out.println(\u0026#34;子线程MyThread\u0026#34; + i); } } } 使用线程的 join() 方法来实现线程的顺序执行，在循环中使用 sleep() 方法来控制线程的执行 public static void main(String[] args) throws InterruptedException { // 循环遍历整数 0 到 5 for (int i = 0; i \u0026lt;= 5; i++) { System.out.println(i); // 打印当前整数值 // 如果当前整数值等于 3，则让当前线程休眠 5 秒钟 if (i == 3) { Thread.sleep(5000); } } // 创建并启动线程 t1，并在主线程中等待 t1 线程执行完成 Thread t1 = new MyThread(\u0026#34;1号线程\u0026#34;); t1.start(); t1.join(); // 创建并启动线程 t2，并在主线程中等待 t2 线程执行完成 Thread t2 = new MyThread(\u0026#34;2号线程\u0026#34;); t2.start(); t2.join(); // 创建并启动线程 t3，并在主线程中等待 t3 线程执行完成 Thread t3 = new MyThread(\u0026#34;3号线程\u0026#34;); t3.start(); t3.join(); } yield, interrupt, 守护线程，线程优先级等\u0026hellip;\n线程安全 什么是线程安全问题？\n多个线程，同时操作同一个共享资源的时候，可能会出现业务安全问题 package com.showguan.ThreadSafeDemo; public class Account { private String cardId; private double money; public Account() { } public Account(String cardId, double money) { this.cardId = cardId; this.money = money; } public String getCardId() { return cardId; } public void setCardId(String cardId) { this.cardId = cardId; } public double getMoney() { return money; } public void setMoney(double money) { this.money = money; } // 使用 synchronized 关键字确保线程安全 public synchronized void drawMoney(double money) { String name = Thread.currentThread().getName(); if(this.money\u0026gt;=money){ System.out.println(name + \u0026#34;来取钱\u0026#34; + money + \u0026#34;成功！\u0026#34;); this.money -= money; System.out.println(name + \u0026#34;取钱之后，余额剩余: \u0026#34; + this.money); }else{ System.out.println(name + \u0026#34;来取钱， 余额不足！\u0026#34;); } } } package com.showguan.ThreadSafeDemo; public class DrawThread extends Thread{ private Account acc; public DrawThread(Account acc, String name) { super(name); this.acc = acc; } @Override public void run() { acc.drawMoney(10000.0); } } public class Demo1 { public static void main(String[] args) { Account acc = new Account(\u0026#34;ICBC-10101\u0026#34;, 10000); new DrawThread(acc, \u0026#34;小红\u0026#34;).start(); new DrawThread(acc, \u0026#34;小明\u0026#34;).start(); /**输出结果 * 小红来取钱10000.0成功！ * 小明来取钱， 余额不足！ * 小红取钱之后，余额剩余: 0.0 */ } } 线程同步的常见方案 加锁：每次只允许一个线程加锁，加锁后才能进入访问，访问完毕后自动解锁，然后其他线程才能再加锁进来 (1) 同步代码块 作用：把访问共享资源的核心代码给上锁，依次保证线程安全。\n原理：每次只允许一个线程加锁后进入，执行完毕后自动结果，其他线程才可以进来执行。\n注意事项：\n对于当前同时执行的线程来说，同步锁必须同一把（同一个对象），否则会出bug 锁对象的使用规范：\n建议使用共享资源作为锁对象，对于实例方法建议使用this作为锁对象 对于静态方法建议使用字节码（类名.class）对象作为锁对象 public void drawMoney(double money) { String name = Thread.currentThread().getName(); synchronized (this) { if(this.money\u0026gt;=money){ System.out.println(name + \u0026#34;来取钱\u0026#34; + money + \u0026#34;成功！\u0026#34;); this.money -= money; System.out.println(name + \u0026#34;取钱之后，余额剩余: \u0026#34; + this.money); }else{ System.out.println(name + \u0026#34;来取钱， 余额不足！\u0026#34;); } } } public static void test(){ synchronized(Account.class){ } } (2) 同步方法 使用synchronized修饰方法\npublic synchronized void drawMoney(double money) { String name = Thread.currentThread().getName(); if(this.money\u0026gt;=money){ System.out.println(name + \u0026#34;来取钱\u0026#34; + money + \u0026#34;成功！\u0026#34;); this.money -= money; System.out.println(name + \u0026#34;取钱之后，余额剩余: \u0026#34; + this.money); }else{ System.out.println(name + \u0026#34;来取钱， 余额不足！\u0026#34;); } } 同步方法底层原理\n同步方法其实底层也是有隐式对象的， 只是锁的范围是整个方法代码 同样，如果是实例方法：同步方法默认用this作为锁对象；如果是静态方法：同步方法默认用类名.class作为锁对象 (3) Lock锁 private final Lock lk = new ReentrantLock(); public void drawMoney(double money) { String name = Thread.currentThread().getName(); try { lk.lock(); if(this.money\u0026gt;=money){ System.out.println(name + \u0026#34;来取钱\u0026#34; + money + \u0026#34;成功！\u0026#34;); this.money -= money; System.out.println(name + \u0026#34;取钱之后，余额剩余: \u0026#34; + this.money); }else{ System.out.println(name + \u0026#34;来取钱， 余额不足！\u0026#34;); } } catch (Exception e) { e.printStackTrace(); } finally { lk.unlock(); } } 线程间通信 /** * 这个程序演示了使用 wait() 和 notify() 方法来实现多线程间的消息传递和同步。 * * 主要知识点： * 1. wait() 方法：使当前线程等待并释放所占锁，直到另一个线程调用 notify() 方法或 notifyAll() 方法来唤醒它。 * 2. notify() 方法：唤醒正在等待的单个线程。 * 3. notifyAll() 方法：唤醒正在等待的所有线程。 * 4. 生产者-消费者模型：多个生产者线程向共享资源中生产物品，多个消费者线程从共享资源中消费物品。 * 5. 使用 synchronized 关键字来确保线程安全，避免多个线程同时访问共享资源引起的数据不一致性问题。 * */ package com.showguan.ThreadMessageDemo; import java.util.ArrayList; import java.util.List; public class Desk { private List\u0026lt;String\u0026gt; list = new ArrayList\u0026lt;\u0026gt;(); /** * 生产食物的方法 */ public synchronized void put() { try { String name = Thread.currentThread().getName(); // 如果桌子上没有食物，则生产一个食物 if (list.size() == 0) { list.add(name + \u0026#34;做的肉包子\u0026#34;); System.out.println(name + \u0026#34;做了一个肉包子\u0026#34;); Thread.sleep(2000); // 模拟制作时间 this.notifyAll(); // 唤醒所有等待线程 this.wait(); // 等待被唤醒 } else { this.notifyAll(); // 唤醒所有等待线程 this.wait(); // 等待被唤醒 } } catch (Exception e) { e.printStackTrace(); } } /** * 消费食物的方法 */ public synchronized void get() { try { String name = Thread.currentThread().getName(); // 如果桌子上有食物，则消费一个食物 if (list.size() == 1) { System.out.println(name + \u0026#34;吃了\u0026#34; + list.get(0)); list.clear(); // 清空桌子上的食物 Thread.sleep(1000); // 模拟吃的时间 this.notifyAll(); // 唤醒所有等待线程 this.wait(); // 等待被唤醒 } else { this.notifyAll(); // 唤醒所有等待线程 this.wait(); // 等待被唤醒 } } catch (Exception e) { e.printStackTrace(); } } } 线程池 线程池就是一个可以复用线程的技术 ThreadPoolExecutor构造器\npublic ThreadPoolExecutor(int corePoolSize, int maximumPoolSize, long keepAliveTime, TimeUnit unit, BlockingQueue\u0026lt;Runnable\u0026gt; workQueue) 参数一：corePoolSize：指定线程池的核心线程的数量 参数二：maximumPoolSize：指定线程池的最大线程数量 参数三：keepAliveTime：指定临时线程的存活时间 参数四：unit:指定临时线程存活的时间单位（秒，分，时，天） 参数五：workQueue：指定线程池的任务队列 参数六：threadFactory：指定线程池的线程工厂 参数七：handler：指定线程池的任务拒绝策略（线程都在忙，任务队列也满了的时候，新任务来了该怎么处理） 注意事项\n临时线程什么时候创建？ 新任务提交时发现核心线程都在忙，任务队列也满了，并且还可以创建临时线程，此时才会创建临时线程 什么时候会开始拒绝新任务？ 核心线程和临时线程都在忙，任务队列也满了，新的任务过来的时候才会开始拒绝新任务 新任务拒绝策略 策略 解释 ThreadPoolExecutor.AbortPolicy 当任务添加到线程池中被拒绝时，抛出RejectedExecutionException异常。（默认策略） ThreadPoolExecutor.DiscardPolicy 丢弃任务，但是不抛出异常，不推荐 ThreadPoolExecutor.DiscardOldestPolicy 抛弃队列中等待最久的任务，然后把当前任务加入队列中 ThreadPoolExecutor.CallerRunsPolicy 由主线程负责调用任务的run()方法从而绕过线程池直接执行 ExecutorService的常用方法 方法、描述 说明 execute(Runnable command) 执行Runnable任务 submit(Callable\u0026lt;T\u0026gt; task) 执行Callable任务，返回未来任务对象，用于获取线程返回的结果 shutdown() 等全部任务执行完毕后，再关闭线程池！ List\u0026lt;Runnable\u0026gt; shutdownNow() 立刻关闭线程池，停止正在执行的任务，并返回队列中未执行的任务 执行Runnable任务 import java.util.concurrent.*; public class Main { public static void main(String[] args) { // 创建线程池 // 使用 ThreadPoolExecutor 构造方法自定义线程池 ExecutorService pool = new ThreadPoolExecutor( 3, // 核心线程数 5, // 最大线程数 8, // 线程空闲时间 TimeUnit.SECONDS, // 时间单位 new ArrayBlockingQueue\u0026lt;\u0026gt;(4), // 工作队列 Executors.defaultThreadFactory(), // 线程工厂， 用于创建新线程的实例。 new ThreadPoolExecutor.CallerRunsPolicy() // 拒绝策略 ); // 创建任务 Runnable target = new MyRunnable(); // 提交任务给线程池执行 pool.execute(target); // 使用核心线程执行任务 pool.execute(target); // 使用核心线程执行任务 pool.execute(target); // 使用核心线程执行任务 pool.execute(target); // 复用前面的核心线程执行任务 pool.execute(target); // 复用前面的核心线程执行任务 pool.execute(target); // 复用前面的核心线程执行任务 pool.execute(target); // 复用前面的核心线程执行任务 pool.execute(target); // 使用临时线程执行任务 pool.execute(target); // 使用临时线程执行任务 pool.execute(target); // 执行任务被拒绝（拒绝策略决定） pool.execute(target); // 执行任务被拒绝（拒绝策略决定） // 关闭线程池 // pool.shutdown(); // pool.shutdownNow(); } } // 自定义任务 class MyRunnable implements Runnable { @Override public void run() { // 任务逻辑 } } 执行Callable任务 import java.util.concurrent.*; public class Main { public static void main(String[] args) throws ExecutionException, InterruptedException { // 创建线程池 ExecutorService pool = new ThreadPoolExecutor( 3, // 核心线程数 5, // 最大线程数 8, // 线程空闲时间 TimeUnit.SECONDS, // 时间单位 new ArrayBlockingQueue\u0026lt;\u0026gt;(4), // 工作队列 Executors.defaultThreadFactory(), // 线程工厂 new ThreadPoolExecutor.CallerRunsPolicy() // 拒绝策略 ); // 提交可调用任务给线程池执行 Future\u0026lt;String\u0026gt; f1 = pool.submit(new MyCallable(100)); // 提交任务并获取 Future 对象 Future\u0026lt;String\u0026gt; f2 = pool.submit(new MyCallable(200)); // 提交任务并获取 Future 对象 Future\u0026lt;String\u0026gt; f3 = pool.submit(new MyCallable(300)); // 提交任务并获取 Future 对象 Future\u0026lt;String\u0026gt; f4 = pool.submit(new MyCallable(400)); // 提交任务并获取 Future 对象 // 获取任务执行结果并输出 System.out.println(f1.get()); // 阻塞等待任务执行完成，并获取结果 System.out.println(f2.get()); // 阻塞等待任务执行完成，并获取结果 System.out.println(f3.get()); // 阻塞等待任务执行完成，并获取结果 System.out.println(f4.get()); // 阻塞等待任务执行完成，并获取结果 // 关闭线程池 pool.shutdown(); } } // 自定义可调用任务 class MyCallable implements Callable\u0026lt;String\u0026gt; { private int value; public MyCallable(int value) { this.value = value; } @Override public String call() throws Exception { // 任务逻辑 return \u0026#34;Result: \u0026#34; + value; } } Executors 是一个线程池的工具类，提供里很多静态方法用于返回不同特点的线程池对象 Executors使用可能存在的陷进\n大型并发系统环境中使用Executors如果不注意可能会出现系统风险 【强制】线程池不允许使用 Executors 去创建，而是通过 ThreadPoolExecutor 的方式，这 样的处理方式让写的同学更加明确线程池的运行规则，规避资源耗尽的风险。 说明：Executors 返回的线程池对象的弊端如下： 1） FixedThreadPool 和 SingleThreadPool： 允许的请求队列长度为 Integer.MAX_VALUE，可能会堆积大量的请求，从而导致 OOM(OutOfMemoryError)。 2） CachedThreadPool： 允许的创建线程数量为 Integer.MAX_VALUE，可能会创建大量的线程，从而导致 OOM。 volatile 关键字 作用: 可见性保证 ： 当多个线程访问同一个变量时，如果使用不同的同步机制，线程可能会缓存变量的值，并不会立即从主内存中读取或写回，使用volatile修饰的变量，能够保证对该变量的所有写操作都会立即被刷新到主内存中，所有对它的读取操作也会直接从主内存中读取，而不是从线程的本地缓存中读取。即一个线程对volatile变量所做的写操作，对其他线程来说是立即可见的。 防止指令重排：Java编译器，JVM，和CPU在执行代码时，可能会为了提高性能而对指令进行重排序，这回导致某些操作的执行顺序和代码中的顺序不一样。volatile保证在读取或写入变量时，之前的操作一定已经完成，之后的操作一定不会被重排序到它之前。 注意点： 不能保证原子性：volatile仅仅保证了可见性和禁止指令重排，但它并不能保证操作的原子性。例如，对于volatile int变量进行自增操作 count ++ , 并不是线程安全的，因为自增操作实际上分为三步（读取，加一，写回），这些步骤可能被多个线程同时执行而互相干扰。 适用场景：适用于哪些需要简单读写操作的共享变量，比如标志位，状态变量等。如果需要更复杂的操作，最好使用synchronized或其他锁机制。 并发、并行 进程\n正在运行的程序（软件）就是一个独立的进程 线程是属于进程的，一个进程中可以同时运行多个线程 进程中的多个线程其实是并发和并行执行的 并发的含义\n进程中的线程是由CPU负责调度执行的，但CPU能同时处理线程的数量有限，为了保证全部线程都能往前执行， CPU会轮询为系统的每个线程服务，由于CPU切换的速度很快，给我们的感觉这些线程在同时执行，这就是并发 并行的理解\n在同一个时刻上，同时有多个线程在被CPU调度执行 线程的生命周期 线程的6种状态总结 状态名称 说明 NEW(新建) 线程刚被创建，但是并未启动 Runnable(可运行) 线程已经调用了start()， 等待CPU调度 Blocked(被阻塞) 线程在执行的时候未竞争到锁对象，则该线程进入Blocked状态 Waiting(等待) 一个线程进入Waiting状态，另一个线程需要Notify或者notifyAll才能够唤醒。 Timed Waiting (计时等待) 同Waiting状态类似，有几个方法（sleep， wait）有超时参数，调用他们将进入Timed Waiting状态 Terminated (被终止) 因为run方法正常退出而死亡，或者因为没有捕获的异常终止了run方法而死亡. 悲观锁、乐观锁原理 悲观锁：一上来就加锁，没有安全感，每次只能一个线程进入访问完毕后，再解锁，线程安全，性能较差 乐观锁：一开始不上锁，认为是没有问题的，大家一起跑，等要出现线程安全问题的时候才开始控制。线程安全，性能较好 CAS算法 package com.showguan.ExtendDemo; import java.util.concurrent.atomic.AtomicInteger; /** * 这个程序演示了乐观锁的使用。 * * 乐观锁是一种并发控制机制，它假设对数据的读取操作不会造成数据冲突，因此不需要对数据进行加锁操作。 * 相反，它在更新数据时检查是否有其他线程已经修改了数据，如果没有则进行更新，如果有则进行相应的处理，比如重试或者放弃更新。 * * 在这个程序中，我们比较了两种实现方式： * 1. 使用 synchronized 关键字实现的悲观锁（MyRunnable 类） * 2. 使用 AtomicInteger 实现的乐观锁（MyRunnable2 类） * * MyRunnable 类中使用了 synchronized 关键字来保证多线程环境下对 count 变量的安全访问，它是一种悲观锁的实现方式， * 每个线程在访问 count 变量时都需要获得对象锁，因此只有一个线程能够执行临界区代码，其他线程需要等待释放锁才能执行。 * * MyRunnable2 类中使用了 AtomicInteger 来实现乐观锁。AtomicInteger 提供了一种原子性的更新操作，保证了在多线程环境下的安全访问。 * 在这种实现方式中，线程不需要获取锁，而是直接通过原子性的操作来更新 count 变量，因此可以实现更高的并发性能。 * * 在实际应用中，选择合适的锁机制取决于具体的场景和性能需求。如果对数据的更新操作比较频繁，且竞争不是很激烈，可以选择乐观锁来提升性能； * 如果竞争比较激烈，或者对数据的一致性要求较高，则可以选择悲观锁来保证数据的正确性。 */ public class Demo1 { public static void main(String[] args) { // Runnable target = new MyRunnable(); // for (int i = 1; i \u0026lt;= 100; i++) { // new Thread(target).start(); // } Runnable target = new MyRunnable2(); for (int i = 1; i \u0026lt;= 100; i++) { new Thread(target).start(); } } } package com.showguan.ExtendDemo; /** * 实现了 Runnable 接口的类，使用 synchronized 关键字实现的悲观锁。 */ public class MyRunnable implements Runnable{ private int count; @Override public void run() { synchronized (this) { for (int i = 1; i \u0026lt;= 100; i++) { // System.out.println(this); System.out.println(Thread.currentThread().getName() + \u0026#34; Count: \u0026#34; + (++count)); } } } } package com.showguan.ExtendDemo; import java.util.concurrent.atomic.AtomicInteger; /** * 实现了 Runnable 接口的类，使用 AtomicInteger 实现的乐观锁。 */ public class MyRunnable2 implements Runnable{ private AtomicInteger count = new AtomicInteger(); @Override public void run() { for (int i = 1; i \u0026lt;= 100; i++) { // System.out.println(this); System.out.println(Thread.currentThread().getName() + \u0026#34; Count: \u0026#34; + (count.incrementAndGet())); } } } 案例 package com.showguan.Test; import java.util.ArrayList; import java.util.List; import java.util.Random; public class Demo1 { public static void main(String[] args) throws InterruptedException { // 创建礼物列表 List\u0026lt;String\u0026gt; gift = new ArrayList\u0026lt;\u0026gt;(); // 定义礼物名称数组 String[] names = {\u0026#34;口红\u0026#34;, \u0026#34;爱马仕\u0026#34;, \u0026#34;iphone\u0026#34;, \u0026#34;手表\u0026#34;, \u0026#34;mac\u0026#34;}; // 随机数生成器 Random r = new Random(); // 循环添加礼物到列表中 for (int i = 1; i \u0026lt;= 1000; i++) { gift.add(names[r.nextInt(names.length)] + \u0026#34; \u0026#34; + (i+1)); // 在礼物列表中添加随机选取的礼物 } System.out.println(gift); // 打印礼物列表 System.out.println(\u0026#34;-------------\u0026#34;); // 创建两个发送线程，分别代表小红和小明 SendThread xh = new SendThread(gift, \u0026#34;小红\u0026#34;); xh.start(); SendThread xm = new SendThread(gift, \u0026#34;小明\u0026#34;); xm.start(); // 等待两个发送线程结束 xm.join(); xh.join(); // 打印两个发送线程发送的礼物数量 System.out.println(\u0026#34;小明发出了：\u0026#34; + xm.getCount()); System.out.println(\u0026#34;小红发出了：\u0026#34; + xh.getCount()); } } package com.showguan.Test; import java.util.List; import java.util.Random; public class SendThread extends Thread { private List\u0026lt;String\u0026gt; gift; // 礼物列表 private int count; // 发送的礼物数量 // 构造方法 public SendThread(List\u0026lt;String\u0026gt; gift, String name) { super(name); // 调用父类构造方法，设置线程名 this.gift = gift; // 初始化礼物列表 } @Override public void run() { Random r = new Random(); // 随机数生成器 String name = Thread.currentThread().getName(); // 获取当前线程名 while (true) { synchronized (gift){ // 同步块，确保礼物列表的线程安全 if(gift.size()\u0026lt;10){ // 当礼物列表数量小于10时，结束循环 break; } String rs = gift.remove(r.nextInt(gift.size())); // 从礼物列表中随机选择一个礼物，并移除 System.out.println(name + \u0026#34; 发出了礼品： \u0026#34; + rs); // 打印发送的礼物信息 count++; // 记录发送的礼物数量 } } } // 获取发送的礼物数量 public int getCount() { return count; } // 设置发送的礼物数量 public void setCount(int count) { this.count = count; } } ","permalink":"https://kennems.github.io/posts/tech/java20%E5%A4%A9%E9%80%9F%E6%88%90%E8%BF%9B%E9%98%B6%E8%AF%BE%E7%A8%8B4/","summary":"Java20天速成——进阶课程(4) 特殊文件 properties, xml 为什么要用这些特殊文件？ 存储多个用户的：用户名， 密码， 家乡， 性别 日志技术 把程序运行的信息，记","title":"Java20天速成——进阶课程(4)"},{"content":"Java20天速成——进阶课程(3) 文件操作 File对象 常用方法 public static void main(String[] args) { // 创建File对象，表示文件test.txt的绝对路径 File f1 = new File(\u0026#34;D:/JAVA/JavaSeProMax/file-io-app/src/com/showguan/FileDemo/test.txt\u0026#34;); // 创建File对象，表示文件夹JavaSeProMax的绝对路径 File f2 = new File(\u0026#34;D:/JAVA\u0026#34;); // 创建File对象，表示不存在的文件路径t.txt File f3 = new File(\u0026#34;D:/JAVA/t.txt\u0026#34;); // 输出文件f1的长度（字节数） System.out.println(f1.length()); // 输出文件夹f2的长度，由于f2表示文件夹，而不是文件，因此返回值没有意义 System.out.println(f2.length()); // 输出文件f3的长度，由于文件路径不存在，因此返回0 System.out.println(f3.length()); // 检查文件f3是否存在，返回false，因为文件路径不存在 System.out.println(f3.exists()); // 创建File对象，表示相对路径下的文件test.txt // 相对路径默认从当前工程的根目录开始寻找，因此文件路径不存在 File f4 = new File(\u0026#34;file-io-app\\\\src\\\\com\\\\showguan\\\\FileDemo\\\\test.txt\u0026#34;); // 检查文件f4是否存在，返回false，因为文件路径不存在 System.out.println(f4.exists()); // 输出文件f4的长度，由于文件路径不存在，因此返回0 System.out.println(f4.length()); } public static void main(String[] args) { // 创建File对象，表示相对路径下的文件test.txt File f1 = new File(\u0026#34;file-io-app\\\\src\\\\com\\\\showguan\\\\FileDemo\\\\test.txt\u0026#34;); // 创建File对象，表示文件夹file-io-app的路径 File f2 = new File(\u0026#34;file-io-app\u0026#34;); // 检查文件f1是否存在，返回true，因为文件路径存在 System.out.println(f1.exists()); // 检查f1是否表示一个文件，返回true System.out.println(f1.isFile()); // 检查f1是否表示一个文件夹，返回false System.out.println(f1.isDirectory()); // 检查f2是否表示一个文件夹，返回true System.out.println(f2.isDirectory()); // 获取文件f1的名称，输出test.txt System.out.println(f1.getName()); // 获取文件f1的长度（字节数） System.out.println(f1.length()); // 获取文件f1最后修改时间 long time = f1.lastModified(); // 格式化最后修改时间并输出 SimpleDateFormat sdf = new SimpleDateFormat(\u0026#34;yyyy/MM/dd HH:mm:ss\u0026#34;); System.out.println(sdf.format(time)); // 获取文件f1的路径（创建时使用的路径），输出相对路径file-io-app\\src\\com\\showguan\\FileDemo\\test.txt System.out.println(f1.getPath()); // 获取文件f1的绝对路径，输出完整的绝对路径 System.out.println(f1.getAbsolutePath()); } 创建文件、目录 import java.io.File; import java.io.IOException; public static void main(String[] args) throws IOException { // 创建File对象，表示新文件test2.txt的路径 File f1 = new File(\u0026#34;file-io-app\\\\src\\\\com\\\\showguan\\\\FileDemo\\\\test2.txt\u0026#34;); // 创建新文件test2.txt，如果文件不存在则创建并返回true，否则返回false System.out.println(f1.createNewFile()); // 创建File对象，表示新文件夹aaa的路径 File f2 = new File(\u0026#34;file-io-app\\\\src\\\\com\\\\showguan\\\\FileDemo\\\\aaa\u0026#34;); // 创建新文件夹aaa，如果文件夹不存在则创建并返回true，否则返回false System.out.println(f2.mkdir()); // 创建File对象，表示新文件夹路径a\\b\\c File f3 = new File(\u0026#34;file-io-app\\\\src\\\\com\\\\showguan\\\\FileDemo\\\\a\\\\b\\\\c\u0026#34;); // 创建新文件夹路径a\\b\\c，如果路径中的文件夹不存在则递归创建，创建成功返回true，否则返回false System.out.println(f3.mkdirs()); // 删除文件test2.txt，删除成功返回true，否则返回false System.out.println(f1.delete()); // 删除文件夹a，由于文件夹非空，因此删除失败返回false File f4 = new File(\u0026#34;file-io-app\\\\src\\\\com\\\\showguan\\\\FileDemo\\\\a\u0026#34;); System.out.println(f4.delete()); } public static void main(String[] args) { // 遍历方法，只能遍历一级文件 File f1 = new File(\u0026#34;D:\\\\JAVA\u0026#34;); // 获取D:\\JAVA目录下的所有一级文件名 String[] names = f1.list(); // 遍历打印所有一级文件名 for (String name : names) { System.out.println(name); } // 获取D:\\JAVA目录下的所有一级文件对象 File f2 = new File(\u0026#34;D:\\\\JAVA\u0026#34;); // 获取D:\\JAVA目录下的所有一级文件对象 File[] files = f2.listFiles(); // 遍历打印所有一级文件对象的绝对路径 for (File file : files) { System.out.println(file.getAbsoluteFile()); } // 尝试获取不存在的目录的一级文件对象，返回null File f3 = new File(\u0026#34;D:\\\\JAVA1\u0026#34;); System.out.println(f3.listFiles()); // null // 尝试获取非文件夹的一级文件对象，返回null File f4 = new File(\u0026#34;D:\\\\JAVA\\\\test1\u0026#34;); // 因为f4代表的路径不是文件夹，因此listFiles()返回null File[] files4 = f4.listFiles(); System.out.println(Arrays.toString(files4)); // null } 递归查找 public static void main(String[] args) throws IOException { searchFile(new File(\u0026#34;D:\\\\文档\u0026#34;), \u0026#34;23暑期青训营笔记\u0026#34;); // 调用搜索文件的方法 } /** * 递归搜索指定目录下的文件，并打印找到的文件的绝对路径，并使用系统默认程序打开该文件。 * @param dir 要搜索的目录 * @param fileName 要搜索的文件名 * @throws IOException 如果发生I/O错误 */ public static void searchFile(File dir, String fileName) throws IOException { // 如果目录为空、不存在或者是文件，则直接返回 if(dir==null || !dir.exists() || dir.isFile()){ return ; } // 获取目录下的所有文件和子目录 File[] files = dir.listFiles(); // 如果目录下存在文件 if(files!=null \u0026amp;\u0026amp; files.length\u0026gt;0){ // 遍历目录下的所有文件和子目录 for (File file : files) { // 如果是文件 if(file.isFile()){ // 判断文件名是否包含指定的文件名 if(file.getName().contains(fileName)){ System.out.println(\u0026#34;找到了！\u0026#34; + file.getAbsoluteFile()); // 打印找到的文件的绝对路径 Runtime runtime = Runtime.getRuntime(); runtime.exec(file.getAbsolutePath()); // 使用系统默认程序打开该文件 return; // 找到文件后直接返回 } }else{ // 如果是目录，则递归调用搜索文件的方法 searchFile(file, fileName); } } } } 递归删除 public static void main(String[] args) throws IOException { File file = new File(\u0026#34;D:\\\\JAVA\\\\test1\\\\test\u0026#34;); // 要删除的目录的路径 deleteDir(file); // 调用删除目录的方法 } /** * 递归删除目录及其所有子目录和文件。 * @param dir 要删除的目录 */ public static void deleteDir(File dir){ // 如果目录为空或者不存在，则直接返回 if(dir==null || !dir.exists()){ return ; } // 如果是文件，则直接删除并返回 if(dir.isFile()){ dir.delete(); return; } // 获取目录下的所有文件和子目录 File[] files = dir.listFiles(); // 如果目录为空，则直接返回 if(files==null){ return; } // 遍历目录下的所有文件和子目录 for (File file : files) { if(file.isFile()){ // 如果是文件，则直接删除 file.delete(); } deleteDir(file); // 递归删除子目录 } dir.delete(); // 删除当前目录 } 字符集 UTF-32\n每个字符占4个字节，存储空间太大，没有普及 UTF-8\n是Unicode字符集的一种编码方案，采取可变长编码方案，共分为四个长度区：一个字节，两个字节，三个字节，四个字节 英文字符，数字等只占一个字节（兼容标准ASCII编码），汉字字符占用3个字节。 ASCII字符集：只有英文、数字、符号等，占1个字节 GBK字符集：汉字占2两个字节，英文，数字占1个字节 UTF-8字符集：汉字占3个字节，英文，数字占1个字节 import java.io.UnsupportedEncodingException; import java.util.Arrays; public static void main(String[] args) throws UnsupportedEncodingException { String data = \u0026#34;a啊a\u0026#34;; // 使用默认字符集（通常是UTF-8）将字符串转换为字节数组 byte[] bytes = data.getBytes(); System.out.println(Arrays.toString(bytes)); // 使用指定字符集（例如GBK）将字符串转换为字节数组 byte[] bytes1 = data.getBytes(\u0026#34;GBK\u0026#34;); System.out.println(Arrays.toString(bytes1)); // 将字节数组转换为字符串，使用默认字符集进行解码 String s = new String(bytes); System.out.println(s); // 将字节数组转换为字符串，使用指定字符集进行解码 String s1 = new String(bytes1, \u0026#34;GBK\u0026#34;); System.out.println(s1); } IO流 按流的方向分为\n输入流 输出流 按流中数据的最小单位，分为：\n字节流 适合操作所有类型的文件 比如：音频，视频，图片，文本文件的复制，转移等 字符流 适合操作纯文本文件 比如：读写txt, java文件等 FileInputStream(文件字节输入流) 作用：以内存为基准，可以把磁盘文件中的数据以字节的形式读入到内存中去 public static void main(String[] args) throws IOException { // 用多态的形式创建文件输入流 InputStream is = new FileInputStream(\u0026#34;file-io-app\\\\src\\\\com\\\\showguan\\\\ByteStreamDemo\\\\test.txt\u0026#34;); int b; // 读取文件内容，直到遇到文件末尾(-1) while((b = is.read()) != -1){ System.out.print((char) b); // 将读取到的字节转换为字符并打印到控制台 } is.close(); // 关闭文件输入流 } public static void main(String[] args) throws IOException { InputStream is = new FileInputStream(\u0026#34;file-io-app\\\\src\\\\com\\\\showguan\\\\ByteStreamDemo\\\\test.txt\u0026#34;); // 创建文件输入流 byte[] buffer = new byte[3]; // 创建缓冲区 int len1 = is.read(buffer); // 从文件中读取字节到缓冲区中 System.out.println(\u0026#34;当前读取的长度:\u0026#34; + len1); // 打印当前读取的长度 String s = new String(buffer); // 将缓冲区中的字节转换为字符串 System.out.println(s); // 打印字符串 } 文件字节输入流：一次读完全部字节\n方式一：定义一个字节数组与被读取的文件大小一样大，然后使用该字节数组，一次读完文件的全部字节。\n方法二：Java官方为InputStream提供了readAllBytes()方法， 可以直接把文件的全部字节读取到一个字节数组中返回。\npublic static void main(String[] args) throws IOException { // 从文件读取数据的两种方法：使用 InputStream 读取和使用 readAllBytes() 方法读取 // 方法一：使用 InputStream 读取文件数据 InputStream is = new FileInputStream(\u0026#34;file-io-app\\\\src\\\\com\\\\showguan\\\\ByteStreamDemo\\\\test.txt\u0026#34;); // 创建文件输入流 File f = new File(\u0026#34;file-io-app\\\\src\\\\com\\\\showguan\\\\ByteStreamDemo\\\\test.txt\u0026#34;); // 创建文件对象 long size = f.length(); // 获取文件大小 byte[] buffer = new byte[(int) size]; // 创建字节数组，用于存储文件内容，长度为文件大小（需要将 long 类型强制转换为 int 类型） int len = is.read(buffer); // 读取文件内容到字节数组，返回实际读取的字节数 System.out.println(new String(buffer)); // 将字节数组转换为字符串并打印输出 System.out.println(size); // 打印文件大小 System.out.println(len); // 打印实际读取的字节数 // 方法二：使用 readAllBytes() 方法读取文件数据 InputStream is1 = new FileInputStream(\u0026#34;file-io-app\\\\src\\\\com\\\\showguan\\\\ByteStreamDemo\\\\test.txt\u0026#34;); // 创建新的文件输入流 byte[] buffer1 = is1.readAllBytes(); // 使用 readAllBytes() 方法读取文件内容到字节数组 System.out.println(new String(buffer1)); // 将字节数组转换为字符串并打印输出 is.close(); // 关闭文件输入流 } FileOutputStream(文件字节输出流) 作用：以内存为基准，把内存中的数据以字节的形式写出到文件中去 public static void main(String[] args) throws IOException { // 创建文件输出流，指定文件路径，并设置为追加模式（true） FileOutputStream os = new FileOutputStream(\u0026#34;file-io-app\\\\src\\\\com\\\\showguan\\\\ByteStreamDemo\\\\test2.txt\u0026#34;, true); os.write(97); // 向文件中写入一个字节 os.write(\u0026#39;a\u0026#39;); // 向文件中写入一个字符 byte[] bytes = \u0026#34;今天是20240419\u0026#34;.getBytes(); // 将字符串转换为字节数组 // 向文件中写入字节数组的一部分内容 os.write(bytes, 0, 15); // 从字节数组的索引0开始，写入长度为15的字节数据 os.write(\u0026#34;\\r\\n\u0026#34;.getBytes()); // 向文件中写入换行符 os.close(); // 关闭文件输出流 } 文件复制 public class FileCopyDemo { /** * 程序入口点，复制一个文件的内容到另一个文件。 * @param args 命令行参数 * @throws IOException 如果发生I/O错误 */ public static void main(String[] args) throws IOException { InputStream is = new FileInputStream(\u0026#34;file-io-app\\\\src\\\\com\\\\showguan\\\\ByteStreamDemo\\\\test.jpg\u0026#34;); // 创建文件输入流，读取源文件 OutputStream os = new FileOutputStream(\u0026#34;D:\\\\JAVA\\\\test1\\\\img2.jpg\u0026#34;); // 创建文件输出流，写入目标文件 byte[] buffer = new byte[1024]; // 创建缓冲区 int len; // 定义变量用于保存读取的字节数 // 循环读取源文件内容，并写入目标文件 while((len = is.read(buffer)) != -1){ os.write(buffer, 0, len); // 将缓冲区中的字节写入目标文件 } os.close(); // 关闭文件输出流 is.close(); // 关闭文件输入流 System.out.println(\u0026#34;复制完成！\u0026#34;); // 打印复制完成的消息 } } 释放资源的方式 try-catch-finally finally代码区的特点：无论try中的程序是否正常执行了， 还是出现了异常，最后都一定会执行finally区， 除非JVM终止 作用：一般用于在程序执行完成后进行资源的释放操作(专业级做法) public static void main(String[] args) { // 声明输入和输出流对象为null，以确保在try块中可以访问这些对象 InputStream is = null; OutputStream os = null; try{ // 故意产生的异常，用于演示异常捕捉 System.out.println(10/0); // 创建一个FileInputStream来读取文件 is = new FileInputStream(\u0026#34;file-io-app\\\\src\\\\com\\\\showguan\\\\ResourceDemo\\\\test.txt\u0026#34;); // 创建一个FileOutputStream来写入文件 os = new FileOutputStream(\u0026#34;file-io-app\\\\src\\\\com\\\\showguan\\\\ResourceDemo\\\\test1.txt\u0026#34;); System.out.println(10/0); // 创建一个字节数组用于暂存从文件读取的数据 byte[] buffer = new byte[1024]; int len; // 循环读取并写入文件，直到文件结束 while((len=is.read(buffer))!=-1){ os.write(buffer, 0, len); } System.out.println(\u0026#34;复制完成！\u0026#34;); }catch (IOException e){ // 捕捉并处理IO异常 e.printStackTrace(); }finally { // 在finally块中释放资源，确保无论是否有异常发生，资源都被释放 try { // 关闭输出流资源 if(os!=null) os.close(); } catch (IOException e) { throw new RuntimeException(e); } try { // 关闭输入流资源 if(is!=null) is.close(); } catch (IOException e) { throw new RuntimeException(e); } } } try-with-resource public static void main(String[] args) { // 使用try-with-resources语法，自动关闭输入流和输出流 try ( InputStream is = new FileInputStream(\u0026#34;file-io-app\\\\src\\\\com\\\\showguan\\\\ResourceDemo\\\\test.txt\u0026#34;); // 创建文件输入流，读取源文件 OutputStream os = new FileOutputStream(\u0026#34;file-io-app\\\\src\\\\com\\\\showguan\\\\ResourceDemo\\\\test1.txt\u0026#34;); // 创建文件输出流，写入目标文件 ) { byte[] buffer = new byte[1024]; // 创建缓冲区 int len; // 定义变量用于保存读取的字节数 // 循环读取源文件内容，并写入目标文件 while ((len = is.read(buffer)) != -1) { os.write(buffer, 0, len); // 将缓冲区中的字节写入目标文件 } System.out.println(\u0026#34;复制完成！\u0026#34;); // 打印复制完成的消息 } catch (Exception e) { // 捕获可能发生的异常 e.printStackTrace(); // 打印异常信息 } } 注意：()里面只能放置资源对象，资源都会实现AutoCloseable接口\n资源用完之后，会自动调用close方法。\nIO字符流 FileReader public static void main(String[] args) throws FileNotFoundException { // 使用try-with-resources语法，自动关闭字符流 try ( Reader fr = new FileReader(\u0026#34;file-io-app\\\\src\\\\com\\\\showguan\\\\ResourceDemo\\\\test.txt\u0026#34;); // 创建字符输入流，读取文件 ) { // int c; // while((c=fr.read())!=-1){ // System.out.println((char) c); // } char[] buffer = new char[3]; // 创建缓冲区 int len; // 定义变量用于保存读取的字符数 // 循环读取文件内容，并打印到控制台 while((len=fr.read(buffer))!=-1){ System.out.print(new String(buffer, 0, len)); // 将缓冲区中的字符转换为字符串并打印 } } catch (Exception e) { // 捕获可能发生的异常 e.printStackTrace(); // 打印异常信息 } } FileWriter public static void main(String[] args) { // 使用try-with-resources语法，自动关闭字符流 try ( FileWriter fw = new FileWriter(\u0026#34;file-io-app\\\\src\\\\com\\\\showguan\\\\CharStreamDemo\\\\test.txt\u0026#34;, true); // 创建字符输出流，写入文件 ){ fw.write(\u0026#34;\\r\\n\u0026#34;); // 向文件中写入换行符 fw.write(\u0026#39;a\u0026#39;); // 向文件中写入字符 fw.write(\u0026#34;\\r\\n\u0026#34;); // 向文件中写入换行符 fw.write(98); // 向文件中写入字符对应的ASCII码 fw.write(\u0026#39;英\u0026#39;); // 向文件中写入字符 fw.write(\u0026#34;\\r\\n\u0026#34;); // 向文件中写入换行符 fw.write(\u0026#34;\\r\\n\u0026#34;); // 向文件中写入换行符 fw.write(\u0026#34;我是的话\u0026#34;); // 向文件中写入字符串 fw.write(\u0026#34;\\r\\n\u0026#34;); // 向文件中写入换行符 fw.write(\u0026#34;fw.write\u0026#34;); // 向文件中写入字符串 char[] buffer = {\u0026#39;黑\u0026#39;, \u0026#39;马\u0026#39;, \u0026#39;a\u0026#39;}; // 创建字符数组 fw.write(buffer); // 向文件中写入字符数组的内容 fw.write(buffer, 0, 2); // 向文件中写入字符数组的一部分内容 } catch (Exception e) { // 捕获可能发生的异常 e.printStackTrace(); // 打印异常信息 } } flush() public static void main(String[] args) throws IOException { Writer fw = new FileWriter(\u0026#34;file-io-app\\\\src\\\\com\\\\showguan\\\\CharStreamDemo\\\\test1.txt\u0026#34;); // 创建字符输出流，写入文件 fw.write(\u0026#39;a\u0026#39;); // 向文件中写入字符 \u0026#39;a\u0026#39; fw.write(\u0026#39;b\u0026#39;); // 向文件中写入字符 \u0026#39;b\u0026#39; fw.write(\u0026#39;c\u0026#39;); // 向文件中写入字符 \u0026#39;c\u0026#39; fw.flush(); // 手动刷新缓冲区，将缓冲区中的数据写入文件 fw.write(\u0026#39;a\u0026#39;); // 向文件中写入字符 \u0026#39;a\u0026#39; fw.close(); // 关闭字符输出流，会自动刷新 } 缓冲流 缓冲流：提高流读写数据的性能\n字节缓冲流 原理：字节缓冲输入流自带了8KB缓冲池，字节缓冲输出流也自带了8KB缓冲池 public static void main(String[] args) throws IOException { // 使用缓冲流进行文件复制操作 File f = new File(\u0026#34;file-io-app\\\\src\\\\com\\\\showguan\\\\BufferedStream\\\\test1.txt\u0026#34;); // 创建要复制到的新文件 f.createNewFile(); // 如果文件不存在，则创建新文件 try ( // 创建文件输入流和缓冲输入流，用于读取原始文件内容 InputStream is = new FileInputStream(\u0026#34;file-io-app\\\\src\\\\com\\\\showguan\\\\BufferedStream\\\\test.txt\u0026#34;); InputStream bis = new BufferedInputStream(is, 8192 * 2); // 使用 BufferedInputStream 进行缓冲 // 创建文件输出流和缓冲输出流，用于写入复制后的内容到新文件 OutputStream os = new FileOutputStream(\u0026#34;file-io-app\\\\src\\\\com\\\\showguan\\\\BufferedStream\\\\test1.txt\u0026#34;); OutputStream bos = new BufferedOutputStream(os, 8192 * 2); // 使用 BufferedOutputStream 进行缓冲 ) { byte[] buffer = new byte[1024]; // 创建字节数组作为缓冲区 int len; while ((len = bis.read(buffer)) != -1) { // 循环读取原文件内容到缓冲区 bos.write(buffer, 0, len); // 将缓冲区的内容写入到新文件中 System.out.println(\u0026#34;复制完成\u0026#34;); // 输出提示信息，表示复制完成 } } catch (Exception e) { e.printStackTrace(); // 打印异常信息 } } 字符缓冲流 输入流 import java.io.*; public class Main { public static void main(String[] args) { // 两种方式读取文件内容并逐行打印： try ( Reader fr = new FileReader(\u0026#34;file-io-app\\\\src\\\\com\\\\showguan\\\\BufferedStream\\\\test.txt\u0026#34;); // 创建 FileReader 对象以打开文件输入流 BufferedReader br = new BufferedReader(fr); // 创建 BufferedReader 对象，并将 FileReader 对象传递给它，用于缓冲读取操作 ) { // 普通方式 // char[] buffer = new char[3]; // int len; // while((len=br.read(buffer))!=-1){ // System.out.println(new String(buffer, 0, len)); // } // 使用 readLine() 方法逐行读取文件内容，并将每行内容打印输出 String line; while ((line = br.readLine()) != null) { System.out.println(line); // 打印每行内容 } } catch (Exception e) { e.printStackTrace(); // 打印异常信息 } } } 输出流 public static void main(String[] args) throws IOException { // 从一个文件读取数据，排序后写入到另一个文件 File f = new File(\u0026#34;file-io-app\\\\src\\\\com\\\\showguan\\\\BufferedStream\\\\test3.txt\u0026#34;); f.createNewFile(); // 如果文件不存在，则创建新文件 try ( // 创建 BufferedReader 读取原文件内容，创建 BufferedWriter 写入到新文件 BufferedReader br = new BufferedReader(new FileReader(\u0026#34;file-io-app\\\\src\\\\com\\\\showguan\\\\BufferedStream\\\\test2.txt\u0026#34;)); BufferedWriter bw = new BufferedWriter(new FileWriter(\u0026#34;file-io-app\\\\src\\\\com\\\\showguan\\\\BufferedStream\\\\test3.txt\u0026#34;)); ) { List\u0026lt;String\u0026gt; data = new ArrayList\u0026lt;\u0026gt;(); // 创建 List 用于存储文件内容 String line; while ((line = br.readLine()) != null) { // 逐行读取原文件内容并添加到 List 中 data.add(line); } Collections.sort(data); // 对 List 中的数据进行排序 for (String ln : data) { // 遍历排序后的数据 System.out.println(ln); // 打印每行内容 bw.write(ln); // 将每行内容写入到新文件 bw.newLine(); // 写入换行符 } } catch (Exception e) { e.printStackTrace(); // 打印异常信息 } } 不同流之间的性能差异 public class Main { public static final String SRC_FILE = \u0026#34;D:\\\\JAVA\\\\test1\\\\video.mp4\u0026#34;; public static final String DEST_FILE = \u0026#34;D:\\\\JAVA\\\\Test\\\\t\u0026#34;; public static void main(String[] args) { // try { // File f = new File(DEST_FILE + \u0026#34;\u0026#34;); // f.createNewFile(); // } catch (Exception e) { // e.printStackTrace(); // } // copy1(); copy2(); // copy3(); copy4(); } public static void copy1() { // 使用一个一个字节的方式复制文件 long startTime = System.currentTimeMillis(); try ( InputStream is = new FileInputStream(SRC_FILE); OutputStream os = new FileOutputStream(DEST_FILE + \u0026#34;1.mp4\u0026#34;); ) { int b; while ((b = is.read()) != -1) { os.write(b); } } catch (Exception e) { e.printStackTrace(); } long endTime = System.currentTimeMillis(); System.out.println(\u0026#34;一个一个字节流的形式耗时:\u0026#34; + (endTime-startTime) + \u0026#34;ms\u0026#34;); } public static void copy2() { // 使用字节数组的方式复制文件 long startTime = System.currentTimeMillis(); try ( InputStream is = new FileInputStream(SRC_FILE); OutputStream os = new FileOutputStream(DEST_FILE + \u0026#34;2.mp4\u0026#34;); ) { int len; byte[] buffer = new byte[1024]; while ((len = is.read(buffer)) != -1) { os.write(buffer, 0, len); } } catch (Exception e) { e.printStackTrace(); } long endTime = System.currentTimeMillis(); System.out.println(\u0026#34;1kb字节流的形式耗时:\u0026#34; + (endTime-startTime)+ \u0026#34;ms\u0026#34;); //1kb字节流的形式耗时:141 } public static void copy3() { // 使用缓冲流一个一个字节的方式复制文件 long startTime = System.currentTimeMillis(); try ( FileInputStream is = new FileInputStream(SRC_FILE); BufferedInputStream bis = new BufferedInputStream(is); FileOutputStream os = new FileOutputStream(DEST_FILE + \u0026#34;3.mp4\u0026#34;); BufferedOutputStream bos = new BufferedOutputStream(os); ) { int b; while ((b = bis.read()) != -1) { bos.write(b); } } catch (Exception e) { e.printStackTrace(); } long endTime = System.currentTimeMillis(); System.out.println(\u0026#34;缓冲流使用一个一个字节复制耗时:\u0026#34; + (endTime-startTime)+ \u0026#34;ms\u0026#34;); } public static void copy4() { // 使用缓冲流字节数组的方式复制文件 long startTime = System.currentTimeMillis(); try ( FileInputStream is = new FileInputStream(SRC_FILE); BufferedInputStream bis = new BufferedInputStream(is); FileOutputStream os = new FileOutputStream(DEST_FILE + \u0026#34;4.mp4\u0026#34;); BufferedOutputStream bos = new BufferedOutputStream(os); ) { byte[] buffer = new byte[1024]; int len; while ((len = bis.read(buffer)) != -1) { bos.write(buffer, 0, len); } } catch (Exception e) { e.printStackTrace(); } long endTime = System.currentTimeMillis(); System.out.println(\u0026#34;缓冲流使用字节数组复制耗时:\u0026#34; + (endTime-startTime) + \u0026#34;ms\u0026#34;); //缓冲流使用字节数组复制耗时:45 } } 转换流 字符输入转换流 public static void main(String[] args) { try ( InputStream is = new FileInputStream((\u0026#34;file-io-app\\\\src\\\\com\\\\showguan\\\\BufferedStream\\\\test2.txt\u0026#34;)); // 创建文件输入流 Reader isr = new InputStreamReader(is, \u0026#34;GBK\u0026#34;); // 创建 InputStreamReader 对象，指定字符编码为 GBK BufferedReader br = new BufferedReader(isr); // 创建 BufferedReader 对象，用于缓冲读取操作 ) { // 使用 BufferedReader 逐行读取文件内容，并打印输出 String line; while ((line = br.readLine()) != null) { System.out.println(line); } } catch (Exception e) { e.printStackTrace(); // 打印异常信息 } } 字符输出转换流 public static void main(String[] args) { try( OutputStream os = new FileOutputStream(\u0026#34;file-io-app\\\\src\\\\com\\\\showguan\\\\BufferedStream\\\\test6.txt\u0026#34;,true); // 创建文件输出流，指定追加模式为 true Writer osw = new OutputStreamWriter(os, \u0026#34;GBK\u0026#34;); // 创建 OutputStreamWriter 对象，指定字符编码为 GBK BufferedWriter bw = new BufferedWriter(osw); // 创建 BufferedWriter 对象，用于缓冲写入操作 ){ bw.write(\u0026#34;美好\u0026#34;); // 写入字符串到文件 bw.write(\u0026#34;真美好\u0026#34;); // 再次写入字符串到文件 } catch (Exception e) { e.printStackTrace(); // 打印异常信息 } } PrintStream/PrintWriter(打印流) 作用：打印流可以实现更方便， 更高效的打印数据出去，能实现答应什么出去就是什么 PrintStream public static void main(String[] args) { // 使用 PrintStream 向文件写入内容，并指定字符编码为 GBK try ( // 创建 PrintStream 对象，指定字符编码为 GBK PrintStream ps = new PrintStream(\u0026#34;file-io-app\\\\src\\\\com\\\\showguan\\\\PrintDemo\\\\test.txt\u0026#34;, Charset.forName(\u0026#34;GBK\u0026#34;)); ) { // 使用 println 方法写入字符和字符串 ps.println(\u0026#39;3\u0026#39;); ps.println(\u0026#39;a\u0026#39;); ps.println(\u0026#34;你好啊\u0026#34;); // 使用 write 方法写入字符 ps.write(\u0026#39;z\u0026#39;); } catch (Exception e) { e.printStackTrace(); // 打印异常信息 } } PrintWriter public static void main(String[] args) { // 使用 PrintWriter 向文件写入内容，并指定字符编码为 GBK try ( // 创建 PrintWriter 对象，指定字符编码为 GBK PrintWriter pw = new PrintWriter(\u0026#34;file-io-app\\\\src\\\\com\\\\showguan\\\\PrintDemo\\\\test.txt\u0026#34;, \u0026#34;GBK\u0026#34;); // 创建 PrintWriter 对象，通过 OutputStreamWriter 包装 FileOutputStream，并指定字符编码为 GBK PrintWriter pw1 = new PrintWriter(new OutputStreamWriter(new FileOutputStream(\u0026#34;file-io-app\\\\src\\\\com\\\\showguan\\\\PrintDemo\\\\test.txt\u0026#34;, true), \u0026#34;GBK\u0026#34;)); ) { // 使用 println 方法写入字符和字符串 pw.println(\u0026#39;3\u0026#39;); pw.println(\u0026#39;a\u0026#39;); pw.println(\u0026#34;你好啊\u0026#34;); // 使用 write 方法写入字符和字符串 pw.write(\u0026#39;z\u0026#39;); pw.write(\u0026#34;abcdefghijklim\u0026#34;); } catch (Exception e) { e.printStackTrace(); // 打印异常信息 } } 对比：\n打印数据的功能上是一模一样的：都是使用方便，性能高效（核心优势） PrintStream继承自字节输出流OutputStream， 因此支持写字节数据的方法 PrintWriter继承自字符输出流Writer， 因此支持写字符数据出去 输出重定向 public static void main(String[] args) { // 将输出重定向到文件 System.out.println(\u0026#34;你好\u0026#34;); // 在控制台打印输出 System.out.println(\u0026#34;志在千里\u0026#34;); // 在控制台打印输出 try ( // 创建 PrintStream 对象，将输出重定向到文件 PrintStream ps = new PrintStream(\u0026#34;file-io-app\\\\src\\\\com\\\\showguan\\\\PrintDemo\\\\test.txt\u0026#34;); ) { System.setOut(ps); // 将标准输出流重定向到 PrintStream 对象 System.out.println(\u0026#34;烈士暮年\u0026#34;); // 将输出重定向到文件中 } catch (FileNotFoundException e) { throw new RuntimeException(e); } } 数据流 数据输出流 public static void main(String[] args) { // 使用 DataOutputStream 写入不同类型的数据到文件 try ( // 创建 DataOutputStream 对象，用于写入数据到文件 DataOutputStream dos = new DataOutputStream(new FileOutputStream(\u0026#34;file-io-app\\\\src\\\\com\\\\showguan\\\\DataStreamDemo\\\\test.txt\u0026#34;)); ){ // 写入不同类型的数据到文件 dos.write(91); // 写入一个字节 dos.writeInt(10); // 写入一个整数 dos.writeDouble(99.8); // 写入一个双精度浮点数 dos.writeBoolean(true); // 写入一个布尔值 dos.writeUTF(\u0026#34;999黑马程序员\u0026#34;); // 写入一个 UTF-8 编码的字符串 } catch (Exception e) { e.printStackTrace(); // 打印异常信息 } } 数据输入流 public static void main(String[] args) { // 使用 DataInputStream 读取不同类型的数据 try ( // 创建 DataInputStream 对象，用于读取数据 DataInputStream dis = new DataInputStream(new FileInputStream(\u0026#34;file-io-app\\\\src\\\\com\\\\showguan\\\\DataStreamDemo\\\\test.txt\u0026#34;)); ) { // 依次读取不同类型的数据并打印输出 int b = dis.read(); System.out.println(b); int i = dis.readInt(); System.out.println(i); double d = dis.readDouble(); System.out.println(d); boolean bool = dis.readBoolean(); System.out.println(bool); String rs = dis.readUTF(); System.out.println(rs); } catch (Exception e) { e.printStackTrace(); // 打印异常信息 } } 序列化流 ObjectOutputStream/ObjectInputStream对象字节输出流\n可以把Java对象进行序列化：把java对象存入到文件中去 序列化 //User public class User implements Serializable { private String loginName; private String userName; private int age; private transient String passWord; } public static void main(String[] args) { // 使用 ObjectOutputStream 将对象序列化到文件 try ( // 创建 ObjectOutputStream 对象，用于将对象序列化到文件 ObjectOutputStream oos = new ObjectOutputStream(new FileOutputStream(\u0026#34;file-io-app\\\\src\\\\com\\\\showguan\\\\ObjectStreamDemo\\\\test1.txt\u0026#34;)); ) { // 创建 User 对象并初始化 User u = new User(\u0026#34;admin\u0026#34;, \u0026#34;K\u0026#34;, 18, \u0026#34;1919\u0026#34;); // 打印 User 对象的字符串表示 System.out.println(u.toString()); // 将 User 对象序列化到文件 oos.writeObject(u); System.out.println(\u0026#34;序列化成功！\u0026#34;); // 打印序列化成功消息 } catch (IOException e) { throw new RuntimeException(e); // 抛出运行时异常并打印异常信息 } } 反序列化 public static void main(String[] args) { // 使用 ObjectInputStream 从文件反序列化对象 try ( // 创建 ObjectInputStream 对象，用于从文件读取对象并反序列化 ObjectInputStream ois = new ObjectInputStream(new FileInputStream(\u0026#34;file-io-app\\\\src\\\\com\\\\showguan\\\\ObjectStreamDemo\\\\test1.txt\u0026#34;)); ){ // 从文件中读取对象并强制转换为 User 类型 User u = (User) ois.readObject(); // 打印反序列化得到的 User 对象的字符串表示 System.out.println(u.toString()); } catch (Exception e) { e.printStackTrace(); // 打印异常信息 } } 如何序列化多个对象？\n用一个ArrayList集合存储多个对象， 然后直接对集合进行序列化即可（ArrayList集合已经实现了序列化接口）\n序列化：\npublic static void main(String[] args) { try ( ObjectOutputStream oos = new ObjectOutputStream(new FileOutputStream(\u0026#34;file-io-app\\\\src\\\\com\\\\showguan\\\\ObjectStreamDemo\\\\test1.txt\u0026#34;)); ) { List\u0026lt;User\u0026gt; users = new ArrayList\u0026lt;\u0026gt;(); for (int i = 0; i \u0026lt; 100; i++) { User u = new User(\u0026#34;admin\u0026#34; + i, \u0026#34;K\u0026#34; + i, 18, \u0026#34;1919\u0026#34; + i); users.add(u); } // 使用循环逐个打印每个用户对象的字符串表示 for (User user : users) { System.out.println(user.toString()); } oos.writeObject(users); System.out.println(\u0026#34;序列化成功！\u0026#34;); } catch (IOException e) { throw new RuntimeException(e); } } 反序列化\npublic static void main(String[] args) { try ( ObjectInputStream ois = new ObjectInputStream(new FileInputStream(\u0026#34;file-io-app\\\\src\\\\com\\\\showguan\\\\ObjectStreamDemo\\\\test1.txt\u0026#34;)); ){ List\u0026lt;User\u0026gt; users = (ArrayList\u0026lt;User\u0026gt;) ois.readObject(); users.forEach( user -\u0026gt; { System.out.print(user.getUserName() + \u0026#34; \u0026#34;); System.out.print(user.getLoginName() + \u0026#34; \u0026#34;); System.out.print(user.getAge() + \u0026#34; \u0026#34;); System.out.print(user.getPassWord() + \u0026#34; \u0026#34;); }); } catch (Exception e) { e.printStackTrace(); } } IO框架 框架\n解决某类问题，编写的一套类、接口等，可以理解成一个半成品，大多框架都是第三方研发的 好处：在框架的基础上开发，可以得到优秀的软件架构，并能提高开发效率 IO框架\n封装了Java提供的对文件、数据进行操作的代码，对外提供了更简单的方式来对文件进行操作，对数据进行读写。 框架的导入：(Commons-IO)\n在项目中创建一个文件夹 ：lib 将xxx.jar文件复制到lib文件夹 在jar文件夹上点击右键，选择Add as Library 在类中导包使用 使用Commons-IO public static void main(String[] args) throws IOException { // 复制文件 FileUtils.copyFile(new File(\u0026#34;D:\\\\JAVA\\\\Test\\\\t3.mp4\u0026#34;), new File(\u0026#34;file-io-app\\\\src\\\\com\\\\showguan\\\\CommonsIODemo\\\\VideoTest.mp4\u0026#34;)); // 复制目录及其内容 FileUtils.copyDirectory(new File(\u0026#34;D:\\\\JAVA\\\\test1\u0026#34;), new File(\u0026#34;file-io-app\\\\src\\\\com\\\\showguan\\\\CommonsIODemo\\\\test\\\\t\u0026#34;)); // 删除目录及其内容 FileUtils.deleteDirectory(new File(\u0026#34;file-io-app\\\\src\\\\com\\\\showguan\\\\CommonsIODemo\\\\test\\\\t\u0026#34;)); // 读取文件内容为字符串 String rs = FileUtils.readFileToString(new File(\u0026#34;file-io-app\\\\src\\\\com\\\\showguan\\\\CommonsIODemo\\\\test1.txt\u0026#34;)); System.out.println(rs); // 向文件写入字符串数据，追加到文件末尾 FileUtils.writeStringToFile(new File(\u0026#34;file-io-app\\\\src\\\\com\\\\showguan\\\\CommonsIODemo\\\\test.txt\u0026#34;), \u0026#34;data\u0026#34;, true); } Files也能做到同样的效果，但是功能不够强大。\npublic static void main(String[] args) throws IOException { // 复制文件 Files.copy(Path.of(\u0026#34;file-io-app\\\\src\\\\com\\\\showguan\\\\CommonsIODemo\\\\test.txt\u0026#34;), Path.of(\u0026#34;file-io-app\\\\src\\\\com\\\\showguan\\\\CommonsIODemo\\\\test2.txt\u0026#34;)); } ","permalink":"https://kennems.github.io/posts/tech/java20%E5%A4%A9%E9%80%9F%E6%88%90%E8%BF%9B%E9%98%B6%E8%AF%BE%E7%A8%8B3/","summary":"Java20天速成——进阶课程(3) 文件操作 File对象 常用方法 public static void main(String[] args) { // 创建File对象，表示文件test.txt的绝对路径 File f1 = new File(\u0026#34;D:/JAVA/JavaSeProMax/file-io-app/src/com/showguan/FileDemo/test.txt\u0026#34;);","title":"Java20天速成——进阶课程(3)"},{"content":"LeetCode笔记 目标：2500分\nHOT100 301. 删除无效的括号 题目大意：\n给你一个由若干括号和字母组成的字符串 s ，删除最小数量的无效括号，使得输入的字符串有效。\n返回所有可能的结果。答案可以按 任意顺序 返回。\n回溯 实现思路：\n统计无效括号数量：\n首先遍历字符串s，统计左括号和右括号的数量l和r，其中l表示未匹配的左括号数量，r表示需要删除的右括号数量。 回溯算法：\n编写回溯算法来尝试删除不同位置的括号，使得字符串有效。 回溯过程中需要注意以下情况： 已经匹配的括号数量ln和rn，以及当前位置i。 遍历字符串s的每个字符，当遇到重复的字符时跳过，以避免重复结果。 如果当前字符为左括号并且ln不为0，则递归调用删除当前左括号的情况，ln减一，否则继续。 如果当前字符为右括号并且rn不为0，则递归调用删除当前右括号的情况，rn减一，否则继续。 检查字符串有效性：\n编写辅助函数check来检查字符串是否有效，即左右括号数量是否匹配。 返回结果：\n将所有有效的字符串结果添加到结果列表ret中，并返回。 class Solution: def removeInvalidParentheses(self, s: str) -\u0026gt; List[str]: l, r = 0, 0 ret = [] n = len(s) for c in s: if c==\u0026#39;(\u0026#39;: l+=1 elif c==\u0026#39;)\u0026#39;: if l==0: r+=1 else: l-=1 def check(st): cnt=0 for c in st: if c==\u0026#39;(\u0026#39;: cnt+=1 elif c==\u0026#39;)\u0026#39;: cnt-=1 if cnt\u0026lt;0: return False return (cnt==0) def backtrace(st, start, ln, rn): if ln==0 and rn==0 and check(st): ret.append(st[:]) return for i in range(start, len(st)): if i\u0026gt;start and st[i]==st[i-1]: continue if ln+rn\u0026gt;n-1-i+1: break if ln and st[i]==\u0026#39;(\u0026#39;: backtrace(st[:i]+st[i+1:], i, ln-1, rn) elif rn and st[i]==\u0026#39;)\u0026#39;: backtrace(st[:i]+st[i+1:], i, ln, rn-1) backtrace(s, 0, l, r) return ret 广搜 这个实现使用了广度优先搜索（BFS）的思路来解决问题。\nBFS搜索：\n使用一个集合cur来存储当前层的所有字符串，初始时将输入的字符串s加入集合cur中。 在每一轮循环中，遍历当前集合cur中的所有字符串，如果其中有字符串是有效的，则将其加入结果列表ret中。 如果结果列表ret不为空，则跳出循环，表示已经找到了所有有效的字符串。 如果结果列表ret为空，则需要继续进行下一轮搜索，将当前集合cur中的每个字符串，通过删除一个括号的方式，生成所有可能的下一层字符串，加入到集合nxt中。 更新当前集合cur为nxt，继续下一轮搜索。 检查字符串有效性：\n定义一个辅助函数check，用于检查字符串是否有效。 遍历字符串中的每个字符，遇到左括号时增加计数器cnt，遇到右括号时如果cnt为0则返回False（表示右括号没有匹配的左括号），否则减少cnt。 最终判断cnt是否为0，如果为0表示字符串有效。 返回结果：\n返回结果列表ret，其中存储了所有有效的字符串。 class Solution: def removeInvalidParentheses(self, s: str) -\u0026gt; List[str]: ret = [] def check(st): cnt=0 for c in st: if c==\u0026#39;(\u0026#39;: cnt+=1 elif c==\u0026#39;)\u0026#39;: if cnt==0: return False cnt-=1 return cnt==0 cur = set([s]) while True: for st in cur: if check(st): ret.append(st) if len(ret): break nxt = set() for st in cur: for i in range(len(st)): if i\u0026gt;0 and st[i]==st[i-1]: continue if st[i]==\u0026#39;(\u0026#39; or st[i]==\u0026#39;)\u0026#39;: nxt.add(st[:i]+st[i+1:]) cur = nxt return ret 297. 二叉树的序列化与反序列化 不止第一次遇到了。\n题目大意：序列化是将一个数据结构或对象转换为连续的比特位的操作，从而可以存储在文件或内存中，并且通过网络传输到另一个计算机环境中。本题要求设计一个算法来实现二叉树的序列化和反序列化，即将二叉树转换为字符串并将字符串转换回原始的二叉树结构。\n实现思路：\n序列化：使用递归将二叉树转换为字符串，根节点值与左右子树序列化结果之间使用空格分隔，空节点用 \u0026lsquo;#\u0026rsquo; 表示。 反序列化：使用递归将字符串转换为二叉树。首先定义一个辅助函数 DerWork()，用于递归构建二叉树。在该函数中，按照前序遍历的顺序，依次提取字符串中的节点值，并根据节点值构建二叉树节点。如果节点值为 \u0026lsquo;#\u0026rsquo;，表示空节点，返回 None。否则，创建节点并递归构建其左右子树。 在反序列化过程中，使用一个全局变量 self.s 来记录当前待处理的字符串，每次递归处理后，将字符串中已经处理过的部分剔除，继续处理剩余部分。 最终返回根节点即可。 # Definition for a binary tree node. # class TreeNode(object): # def __init__(self, x): # self.val = x # self.left = None # self.right = None class Codec: def serialize(self, root): \u0026#34;\u0026#34;\u0026#34;Encodes a tree to a single string. :type root: TreeNode :rtype: str \u0026#34;\u0026#34;\u0026#34; if not root: return \u0026#39;#\u0026#39; return str(root.val)+\u0026#39; \u0026#39;+self.serialize(root.left)+\u0026#39; \u0026#39;+self.serialize(root.right) def deserialize(self, data): \u0026#34;\u0026#34;\u0026#34;Decodes your encoded data to tree. :type data: str :rtype: TreeNode \u0026#34;\u0026#34;\u0026#34; self.s = data return self.DerWork() def DerWork(self): if len(self.s)==0: return None try: idx = self.s.index(\u0026#39; \u0026#39;) except: idx = -1 node = self.s if idx==-1 else self.s[:idx] self.s = \u0026#39;\u0026#39; if idx==-1 else self.s[idx+1:] if node==\u0026#39;#\u0026#39;: return None t = TreeNode(int(node)) t.left = self.DerWork() t.right = self.DerWork() return t # Your Codec object will be instantiated and called as such: # ser = Codec() # deser = Codec() # ans = deser.deserialize(ser.serialize(root)) 84. 柱状图中最大的矩形 题目大意：给定 n 个非负整数，表示柱状图中各个柱子的高度。每个柱子彼此相邻，且宽度为 1。求在该柱状图中，能够勾勒出的矩形的最大面积。\n实现思路：\n使用单调栈解决问题。创建两个数组 l 和 r，分别记录每个柱子向左和向右第一个比其高度小的柱子的索引位置。 初始化一个空栈 stk。 遍历柱子的高度列表 heights： 若栈不为空且当前柱子的高度小于栈顶柱子的高度，则将栈顶元素弹出，并更新栈顶元素对应的 r 值为当前柱子的索引。 若栈为空或者当前柱子的高度大于栈顶柱子的高度，则将当前柱子的索引入栈。 在更新 r 值的同时，若栈不为空，则更新当前柱子的 l 值为栈顶元素的索引。 遍历完成后，对于每个柱子 i，计算以该柱子为高度的矩形面积为 (r[i] - l[i] - 1) * heights[i]，取最大值即为所求的最大矩形面积。 若柱状图为空，则返回 0。 class Solution: def largestRectangleArea(self, heights: List[int]) -\u0026gt; int: n=len(heights) l, r = [-1]*(n+5), [n]*(n+5) stk = list() for i in range(n): while stk and heights[stk[-1]]\u0026gt;=heights[i]: r[stk[-1]]=i stk.pop() if stk: l[i]=stk[-1] stk.append(i) return max( (r[i]-l[i]-1)*heights[i] for i in range(n) ) if n\u0026gt;0 else 0 85. 最大矩形 题目大意：给定一个仅包含 0 和 1、大小为 rows x cols 的二维二进制矩阵，找出只包含 1 的最大矩形，并返回其面积。\n实现思路：\n将问题转化为矩形最大面积问题。 定义变量 area 用于记录最大矩形的面积。 创建二维数组 left，用于记录每个位置 (i, j) 左侧连续 1 的个数。 遍历二维矩阵，初始化 left 数组： 若当前位置为 \u0026lsquo;1\u0026rsquo;，则 left[i][j] 等于 left[i][j-1] + 1，否则为 0。 遍历矩阵的每一列，对于每一列 j，使用单调栈来计算以当前列为底边的最大矩形的面积： 初始化一个空栈 stk。 定义两个数组 up 和 down，分别记录当前位置上方第一个小于等于其高度的位置和下方第一个小于等于其高度的位置。 遍历矩阵的每一行 i，进行以下操作： 当栈不为空且栈顶位置对应的 left 值大于等于当前位置的 left 值时，弹出栈顶位置，并更新 down 值。 如果栈为空，则当前位置的 up 值为 -1，否则为栈顶位置。 将当前行索引入栈。 在计算当前列的矩形面积时，height 为 down[i] - up[i] - 1，宽度为 left[i][j]，计算当前列的最大面积并更新 area。 返回最大面积 area。 class Solution: def maximalRectangle(self, matrix: List[List[str]]) -\u0026gt; int: # 转化为矩形最大面积问题 n, m = len(matrix), len(matrix[0]) area = 0 left = [[0]*m for _ in range(n)] for i in range(n): for j in range(m): if matrix[i][j]==\u0026#39;1\u0026#39;: left[i][j] += left[i][j-1]+1 if j else 1 for j in range(m): stk = [] up, down = [-1]*n, [n]*n for i in range(n): #行 while stk and left[ stk[-1] ][j]\u0026gt;=left[i][j]: down[stk[-1]] = i stk.pop() up[i] = stk[-1] if stk else -1 stk.append(i) for i in range(n): height = down[i]-up[i]-1 area = max(area, height*left[i][j]) return area 76. 最小覆盖子串 题目大意：给定字符串 s 和字符串 t，返回 s 中涵盖 t 所有字符的最小子串。如果 s 中不存在涵盖 t 所有字符的子串，则返回空字符串 \u0026ldquo;\u0026quot;。\n注意：\n对于 t 中重复字符，子字符串中该字符数量必须不少于 t 中该字符数量。\n如果 s 中存在这样的子串，保证它是唯一的答案。\n实现思路：\n使用双指针滑动窗口解决问题。 初始化 need 字典，用于记录字符串 t 中每个字符的出现次数。 初始化 needCnt 为 t 的长度 m，表示还需要的字符数量。 初始化左指针 left 为 0，并初始化结果变量 res 为一个长度为 n 的区间，初始值为 (0, n)。 遍历字符串 t，统计每个字符的出现次数并存储在 need 字典中。 遍历字符串 s，使用右指针 right 遍历每个字符： 若当前字符在 t 中出现，则 needCnt 减 1。 更新 need 字典中当前字符的出现次数。 若 needCnt 为 0，表示当前窗口包含了 t 中所有字符，进入内部循环： 移动左指针 left，直到当前窗口不再满足条件（即 need 字典中某个字符的出现次数大于 0）。 更新结果变量 res。 恢复左指针 left 和 needCnt。 返回结果字符串，若结果区间超出 s 的范围，则返回空字符串。 class Solution: def minWindow(self, s: str, t: str) -\u0026gt; str: n, m = len(s), len(t) need = defaultdict(int) needCnt = m left = 0 res = (0, n) for ch in t: need[ch]+=1 for right, ch in enumerate(s): if need[ch]\u0026gt;0: needCnt-=1 need[ch]-=1 if needCnt==0: while need[s[left]]!=0: need[s[left]]+=1 left+=1 if right-left \u0026lt; res[1]-res[0]: res = (left, right) need[s[left]]+=1 needCnt+=1 left+=1 return \u0026#39;\u0026#39; if res[1]\u0026gt;n-1 else s[res[0]:res[1]+1] 312. 戳气球 题意：给定n个数字num[0~n-1],每次戳破一个气球可以获得nums[i-1]*nums[i]*nums[i+1]个硬币，最两旁默认为1，问最终获得的最大硬币数量。 思路：区间DP，逆向思维, 思考如何放气球能使硬币最大，f[i][j]代表开区间i~j可以获得的最大硬币， 先枚举小区间，再枚举大区间，枚举区间内每个数字，状态转移有：f[i][j] = max(f[i][j], f[i][k]+f[k][j]+nums[i]*nums[k]*nums[j])。最终输出f[0][n+1] class Solution: def maxCoins(self, nums: List[int]) -\u0026gt; int: n = len(nums) nums = [1]+nums+[1] f = [[0]*(n+5) for _ in range(n+5)] # 开区间 (left, right) 区间内能获得的最大硬币 for l in range(2,n+2): # len:2~n+1 for i in range(n+1-l+1): # left:0~n+1-len j=i+l # right = left + len for k in range(i+1, j): # 开区间(i,j) 即[i+1, j-1] f[i][j] = max(f[i][j], f[i][k]+f[k][j]+nums[i]*nums[k]*nums[j]) return f[0][n+1] 301. 删除无效的括号 题目大意：给定一个由字母和括号组成的字符串s，要求删除最小数量的括号，使得字符串成为有效的括号组合，并返回所有可能的结果。\n实现思路：\n首先定义一个辅助函数check(st)，用于检查字符串st是否为有效的括号组合。遍历字符串中的每个字符，维护一个计数器cnt，遇到左括号增加计数，遇到右括号减少计数，若出现cnt为负数，或者遍历结束后cnt不为0，则说明括号不匹配，返回False，否则返回True。\n初始化一个空列表ret，用于存储结果。\n初始化一个集合cur，初始时将输入字符串s作为唯一元素加入其中。\n使用while循环，直到找到符合条件的结果为止：\n遍历集合cur中的每个字符串，检查其是否为有效括号组合，若是则将其加入结果列表ret。\n若结果列表ret不为空，则说明已找到符合条件的结果，结束循环。\n否则，初始化一个空集合nxt，用于存储下一轮迭代的候选字符串集合。\n遍历集合cur中的每个字符串，对于每个字符串，尝试删除一个字符（括号），生成新的字符串，并将其加入nxt中。\n更新cur为nxt，继续下一轮迭代。\n返回结果列表ret。\nclass Solution: def removeInvalidParentheses(self, s: str) -\u0026gt; List[str]: ret = [] def check(st): cnt=0 for c in st: if c==\u0026#39;(\u0026#39;: cnt+=1 elif c==\u0026#39;)\u0026#39;: if cnt==0: return False cnt-=1 return cnt==0 cur = set([s]) while True: for st in cur: if check(st): ret.append(st) if len(ret): break nxt = set() for st in cur: for i in range(len(st)): if i\u0026gt;0 and st[i]==st[i-1]: continue if st[i]==\u0026#39;(\u0026#39; or st[i]==\u0026#39;)\u0026#39;: nxt.add(st[:i]+st[i+1:]) cur = nxt return ret 11. 盛最多水的容器 题目大意：给定一个长度为n的整数数组height，数组中的每个元素代表一条垂直线的高度。找出其中的两条线，使得它们与x轴构成的容器可以容纳最多的水。\n实现思路：使用双指针法。初始化左指针l指向数组的起始位置，右指针r指向数组的末尾位置。设置变量ret用于记录当前最大容量，初始化为0。在每一轮循环中，计算当前容器的容量，即min(height[l], height[r])乘以r和l之间的距离，更新ret。然后根据指针所指向的高度的大小，移动指针，如果height[l]\u0026lt;height[r]，则移动左指针l向右一步，否则移动右指针r向左一步。直到左右指针相遇，循环结束，返回ret即可。\n正确性证明： 对于左右端点 $ l, r$， 两点之间的距离为$len = r-l+1-1$(因为两个点之间算一段，所以长度要减一)，$ ret = (r-l)*min(height[l], height[r])$,假设 $height[l]\u0026lt;height[r]$, 对于左端点，其作为柱子能容纳的最多的水的数量已经为最大值，任意的 $l\u0026lt;x\u0026lt;r$ 作为右端点一定比$r$做端点更差，所以可以排除左端点$l$，计算下一点即$l+1$。从左右端点开始，对于每次排除的点，已经找到这个端点可能的最大值， 所以可以保证结果的正确性。 class Solution: def maxArea(self, height: List[int]) -\u0026gt; int: l, r = 0, len(height)-1 ret = 0 while l\u0026lt;r: ret = max( ret, (r-l)*min(height[l], height[r]) ) if height[l]\u0026lt;height[r]: l+=1 elif height[l]\u0026gt;height[r]: r-=1 else: l+=1 r-=1 return ret 647. 回文子串 题目大意：给定一个字符串s，统计并返回该字符串中回文子串的数目。回文字符串是指正着读和倒过来读一样的字符串。子字符串是字符串中的由连续字符组成的一个序列。即使是由相同字符组成的不同开始位置或结束位置的子串，也会被视作不同的子串。\n实现思路：遍历字符串s的所有可能的中心位置，对于每个中心位置，向两边扩展，判断是否是回文串。在扩展的过程中，每当发现一个回文子串，就将计数器加1。最终返回计数器的值即可。\nclass Solution: def countSubstrings(self, s: str) -\u0026gt; int: n = len(s) ans = 0 for i in range(2*n - 1): l, r = i//2, i//2 + (i\u0026amp;1) while l\u0026gt;=0 and r\u0026lt;n and s[l]==s[r]: l-=1; r+=1 ans+=1 return ans 93. 复原 IP 地址 题目大意：给定一个只包含数字的字符串s，表示一个IP地址，要求返回所有可能的有效IP地址，即每个IP地址由四个整数组成（每个整数位于0到255之间，且不能含有前导0），整数之间用\u0026rsquo;.\u0026lsquo;分隔。不能重新排序或删除s中的任何数字，可以按任何顺序返回答案。\n实现思路：使用深度优先搜索（DFS）算法，递归地搜索所有可能的IP地址组合。在搜索过程中，首先确定每个整数的范围，然后遍历可能的数字组合，逐步构建IP地址。递归的终止条件是已经找到了四个整数并且已经遍历完了整个字符串s。\nclass Solution: def restoreIpAddresses(self, s: str) -\u0026gt; List[str]: n = len(s) res, addr = [], [\u0026#39;0\u0026#39;]*4 def dfs(i, start): if i==4 or start==n: if i==4 and start==n: res.append(\u0026#39;.\u0026#39;.join(addr)) return if s[start]==\u0026#39;0\u0026#39;: addr[i] = \u0026#39;0\u0026#39; dfs(i+1, start+1) return num = 0 for end in range(start, n): num = num*10 + int(s[end]) if num in range(256): addr[i] = str(num) dfs(i+1, end+1) dfs(0, 0) return res 538. 把二叉搜索树转换为累加树 题目大意：给定一个二叉搜索树的根节点，需要将其转换为累加树，即每个节点的新值等于原树中大于或等于该节点值的节点值之和。\nclass Solution: def convertBST(self, root: Optional[TreeNode]) -\u0026gt; Optional[TreeNode]: s = 0 def dfs(r): nonlocal s if not r: return 0 dfs(r.right) s += r.val r.val = s dfs(r.left) dfs(root) return root 实现思路：**(Morris 遍历)**从根节点开始，采用反向中序遍历（右-根-左）的方式进行遍历。利用一个变量 s 记录累加和，初始值为 0。对于每个节点，首先判断其是否存在右子节点，如果不存在，则将其值加上累加和并更新累加和，然后将当前节点指向其左子节点；如果存在右子节点，则找到其中序遍历的后继节点，即右子树中最左边的节点。如果后继节点的左子节点为空，说明还未处理过该节点，则将后继节点的左子节点指向当前节点，并将当前节点指向其右子节点；如果后继节点的左子节点为当前节点，则说明已经处理过该节点，则将后继节点的左子节点置为空，将当前节点的值加上累加和并更新累加和，并将当前节点指向其左子节点。最后返回根节点。\nclass Solution: def convertBST(self, root: Optional[TreeNode]) -\u0026gt; Optional[TreeNode]: def getSucc(node): succ = node.right while succ.left and succ.left!=node: succ = succ.left return succ newRoot = root s = 0 while root: if not root.right: s += root.val root.val = s root = root.left else: succ = getSucc(root) if not succ.left: succ.left = root root = root.right else: succ.left = None s += root.val root.val = s root = root.left return newRoot 15. 三数之和 题目大意：给定一个整数数组 nums，判断是否存在三元组 [nums[i], nums[j], nums[k]] 满足 i != j、i != k 且 j != k，同时还满足 nums[i] + nums[j] + nums[k] == 0。返回所有满足条件的不重复的三元组。\n实现思路：首先对数组 nums 进行排序。然后遍历数组，对于每个元素 nums[i]，设定两个指针 l 和 r 分别指向 i+1 和数组末尾。在 l 和 r 之间寻找和为 0 的两个数。具体地，如果当前元素与前一个元素相同，跳过；如果当前元素与 l+1 处的元素相同，跳过；在 l 和 r 之间利用双指针的方式找到满足条件的两个数，如果找到了满足条件的三元组，则添加到结果中。最后返回结果列表 res。\nclass Solution: def threeSum(self, nums: List[int]) -\u0026gt; List[List[int]]: n = len(nums) nums.sort() res = [] for i in range(n): l = i r = n-1 if i and nums[i]==nums[i-1]: continue for m in range(l+1, n): if m\u0026gt;l+1 and nums[m]==nums[m-1]: continue while r\u0026gt;m and nums[r]+nums[m]+nums[l]\u0026gt;0: r-=1 if m==r: break if nums[r]+nums[m]+nums[l]==0: res.append([nums[l], nums[m], nums[r]]) return res 实现思路：首先，利用 Counter 函数统计每个数出现的次数，并检查是否有 0 出现至少三次，如果是则将 [0, 0, 0] 添加到结果中。然后，对不重复的数进行排序。遍历排序后的数，对于每个数 num，如果 num 不等于 0 且 num 出现次数大于 1 且 -num*2 也在 Counter 中，则将 [num, num, -num*2] 添加到结果中。然后，在负数部分，利用双指针的方式寻找满足条件的两个数。最后返回结果列表 res。\nclass Solution: def threeSum(self, nums: List[int]) -\u0026gt; List[List[int]]: res = [] c = Counter(nums) if 0 in c and c[0] \u0026gt;= 3: res.append([0,0,0]) no_repeat_nums = sorted(c.keys()) for i,num in enumerate(no_repeat_nums): if num != 0 and c[num] \u0026gt; 1 and -num*2 in c: res.append([num,num,-num*2]) if num \u0026lt; 0: for num3 in no_repeat_nums[ bisect_left(no_repeat_nums,((-num+1)/2)) : bisect_right(no_repeat_nums,-num*2-1) ]: num2 = -num-num3 if num2 in c: res.append([num,num2,num3]) return res 494. 目标和 题目大意：给定一个非负整数数组 nums 和一个目标整数 target，通过给数组中的每个整数前添加 \u0026lsquo;+\u0026rsquo; 或 \u0026lsquo;-\u0026rsquo;，然后串联起来构造表达式，返回可以构造的表达式数目，使其运算结果等于目标数。\n记忆化搜索 实现思路：这个问题可以转化为一个背包问题。我们可以将问题转化为在数组中选取一些数，使得它们的和等于 target。定义一个递归函数 dfs(i, s)，表示在数组 nums 中考虑第 i 个数，使得目前的和为 s 的表达式数目。递归的终止条件是遍历完所有数，如果 s 等于 0，表示找到了一种构造方式，返回 1，否则返回 0。递归过程中，如果 s 小于当前数 nums[i]，说明无法选取当前数，直接跳过；否则，递归考虑选取当前数和不选取当前数两种情况。利用缓存装饰器 @cache 可以将重复计算的结果进行缓存，提高计算效率。最后返回 dfs(0, target) 即可得到结果。\nclass Solution: def findTargetSumWays(self, nums: List[int], target: int) -\u0026gt; int: target += sum(nums) if target\u0026lt;0 or target\u0026amp;1: return 0 target//=2 @cache def dfs(i, s): if i==len(nums): return 1 if s==0 else 0 if s\u0026lt;nums[i]: return dfs(i+1, s) else: return dfs(i+1, s) + dfs(i+1, s-nums[i]) return dfs(0, target) 动态规划 实现思路：这里采用动态规划来解决。首先将目标数 target 加上数组 nums 的总和，如果总和为负数或者是奇数，则无法通过调整符号得到目标数，直接返回 0。否则，将目标数除以 2，然后定义一个二维数组 f，其中 f[i][j] 表示在考虑前 i 个数时，构造和为 j 的表达式的数目。初始化 f[0][0] = 1。然后，遍历数组 nums，并且更新 f[i][j]。当 j 小于当前数 nums[i-1] 时，表示无法选取当前数，则 f[i][j] 等于上一个状态的值；当 j 大于等于当前数 nums[i-1] 时，可以选择加上或减去当前数，则 f[i][j] 等于上一个状态加上不选取当前数的值以及上一个状态加上选取当前数的值。最后返回 f[n][target]，其中 n 是数组 nums 的长度。\nclass Solution: def findTargetSumWays(self, nums: List[int], target: int) -\u0026gt; int: target+=sum(nums) if target\u0026lt;0 or target%2: return 0 target//=2 n = len(nums) f = [[0]*(target+1) for _ in range(n+1)] f[0][0] = 1 for i in range(1, n+1): for j in range(target+1): if j\u0026lt;nums[i-1]: f[i][j] = f[i-1][j] else: f[i][j] = f[i-1][j] + f[i-1][j-nums[i-1]] return f[n][target] 581. 最短无序连续子数组 题目大意：给定一个整数数组 nums，找出一个连续子数组，使得对该子数组进行升序排序后，整个数组都变为升序排序。要求找出符合题意的最短子数组，并输出其长度。\n实现思路：使用两个指针left和right，初始化为-1，遍历数组nums。首先，从左到右找到第一个无序的元素，即当前元素小于前面已遍历过的最大元素，此时更新right指针为当前位置i；然后，从右到左找到第一个无序的元素，即当前元素大于后面已遍历过的最小元素，此时更新left指针为当前位置n-i-1。最终返回right-left+1即为最短无序连续子数组的长度。\nclass Solution: def findUnsortedSubarray(self, nums: List[int]) -\u0026gt; int: n = len(nums) ma, right = -inf, -1 mi, left = inf, -1 for i in range(n): if ma\u0026gt;nums[i]: right = i else: ma = nums[i] if mi\u0026lt;nums[n-i-1]: left = n-i-1 else: mi = nums[n-i-1] return 0 if right==-1 else right-left+1 416. 分割等和子集 题目大意：给定一个非空数组 nums，数组中只包含正整数。要求判断是否能将该数组分割成两个子集，使得这两个子集的元素和相等。\n实现思路：\n首先计算数组 nums 的总和 s。 如果总和 s 为奇数，那么无法分割成两个和相等的子集，直接返回 False。 如果数组中的最大值大于总和的一半，则无法分割成两个和相等的子集，直接返回 False。 初始化一个大小为总和一半加一的布尔数组 f，f[i] 表示是否存在子集的和为 i。 将 f[0] 初始化为 True，表示子集的和为 0。 遍历数组 nums，对于每个正整数 num，从总和一半开始向前遍历，更新数组 f，如果 f[j-num] 为 True，则说明存在一个子集的和为 j-num，加上当前的 num 后，和为 j，因此 f[j] 也为 True。 最终返回 f[s//2]，表示是否存在一个子集的和为总和一半，即是否能分割成两个和相等的子集。 class Solution: def canPartition(self, nums: List[int]) -\u0026gt; bool: s = sum(nums) if s\u0026amp;1: return False ma = max(nums) t = s//2 if ma\u0026gt;t: return False n = len(nums) f = [False]*(t+1) f[0] = True for i, num in enumerate(nums): for j in range(t, num-1, -1): f[j] |= f[j-num] return f[t] 394. 字符串解码 题目大意：给定一个经过编码的字符串，其中编码规则为k[encoded_string]，表示encoded_string中的内容重复k次。要求解码该字符串。\n实现思路：使用递归来解码字符串。遍历输入字符串，根据不同情况进行处理：\n若遇到数字，则累加数字直至遇到非数字字符。 若遇到字母，则直接加入当前解码的字符串中。 若遇到左括号\u0026rsquo;[\u0026rsquo;，则递归调用解码函数，处理括号内的内容，直至遇到右括号\u0026rsquo;]\u0026rsquo;。将括号内的解码结果乘以前面累积的数字，并加入当前解码的字符串中。 若遇到右括号\u0026rsquo;]\u0026rsquo;，则返回当前解码的字符串和当前索引。 返回最终解码结果。 class Solution: def decodeString(self, s: str) -\u0026gt; str: def decode(i, n): cur = \u0026#34;\u0026#34;; num = 0 while i\u0026lt;len(s): if s[i].isdigit(): num = num*10 + int(s[i]) elif s[i].isalpha(): cur += s[i] elif s[i] == \u0026#39;[\u0026#39;: ns, ni = decode(i+1, num) # next str, next index cur += ns; i = ni num = 0 elif s[i]==\u0026#39;]\u0026#39;: return cur*n, i i += 1 return cur*n, i res, _ = decode(0, 1) return res 72. 编辑距离 题目大意： 给定两个单词 word1 和 word2，求通过插入、删除或替换字符，将 word1 转换成 word2 所需的最少操作数。\n记忆化搜索 这段代码使用了递归的方式求解，其中 dfs 函数表示将 s 的前 i 个字符转换为 t 的前 j 个字符所需的最少操作数。递归的基本情况是当 i 小于 0 时，表示 s 已经遍历完，需要插入 t 的前 j+1 个字符；当 j 小于 0 时，表示 t 已经遍历完，需要删除 s 的前 i+1 个字符；当 s[i] 等于 t[j] 时，不需要额外操作，直接递归处理 i-1 和 j-1；当 s[i] 不等于 t[j] 时，可以选择插入、删除或替换操作，选择操作数最小的方案。递归的过程中利用了缓存装饰器 @cache 来提高效率。\nclass Solution: def minDistance(self, s: str, t: str) -\u0026gt; int: n, m = len(s), len(t) @cache def dfs(i, j): if i\u0026lt;0: return j+1 if j\u0026lt;0: return i+1 if s[i]==t[j]: return dfs(i-1, j-1) return min(dfs(i-1, j), dfs(i, j-1), dfs(i-1, j-1)) + 1 return dfs(n-1, m-1) 递推 实现思路： 可以使用动态规划来解决这个问题。定义一个二维数组 f，其中 f[i][j] 表示将 word1 的前 i 个字符转换为 word2 的前 j 个字符所需的最少操作数。初始时，f[i][0] 表示将 word1 的前 i 个字符全部删除，需要的操作数为 i，而 f[0][j] 表示将 word2 的前 j 个字符全部插入到 word1 中，需要的操作数为 j。 然后，根据动态规划的状态转移方程，逐步计算 f[i][j] 的值。若 word1[i] 等于 word2[j]，则 f[i][j] 等于 f[i-1][j-1]，即不需要额外操作；若不相等，则可以考虑插入、删除或替换操作，选择操作数最小的方案。最终，返回 f[n][m]，其中 n 和 m 分别为 word1 和 word2 的长度。\nclass Solution: def minDistance(self, s: str, t: str) -\u0026gt; int: n, m = len(s), len(t) f = [[0]*(m+1) for _ in range(n+1)] f[0] = list(range(m+1)) # f[0][j] = j for i in range(n): f[i+1][0] = i+1 for j in range(m): if s[i]==t[j]: f[i+1][j+1] = f[i][j] else: f[i+1][j+1] = min(f[i][j+1], f[i+1][j], f[i][j]) + 1 return f[n][m] 96. 不同的二叉搜索树 class Solution: def numTrees(self, n: int) -\u0026gt; int: f = [0]*(n+1) f[0] = 1; f[1] = 1 for i in range(2, n+1): for j in range(1, i+1): f[i] += f[i-j]*f[j-1] return f[n] 160. 相交链表 class Solution: def getIntersectionNode(self, headA: ListNode, headB: ListNode) -\u0026gt; Optional[ListNode]: l1, l2 = headA, headB while l1 != l2: l1 = headB if not l1 else l1.next l2 = headA if not l2 else l2.next return l1 31. 下一个排列 题目大意：给定一个整数数组，要求找出这个数组的下一个排列，即比当前排列大的下一个排列，如果不存在则返回字典序最小的排列。\n实现思路：要找到下一个排列，可以遵循以下步骤：\n从数组末尾开始，找到第一个相邻的两个数，满足 nums[i] \u0026lt; nums[i+1]。 如果找到了这样的一对数，说明当前排列还不是最大的排列，可以进行下一步操作。 在从右往左找到的第一个位置记为 i，再从数组末尾开始，找到第一个大于 nums[i] 的数，记为 j。 交换 nums[i] 和 nums[j]。 将从 i+1 位置开始到数组末尾的数逆序排列，以得到字典序最小的排列。 如果步骤1中没有找到相邻的两个数，则说明当前排列已经是最大的排列，直接将整个数组逆序排列即可。 class Solution: def nextPermutation(self, nums: List[int]) -\u0026gt; None: \u0026#34;\u0026#34;\u0026#34; Do not return anything, modify nums in-place instead. \u0026#34;\u0026#34;\u0026#34; n = len(nums) i = n-2 while i\u0026gt;=0 and nums[i] \u0026gt;= nums[i+1]: i-=1 if i\u0026gt;=0: j = n-1 while j\u0026gt;=i and nums[j] \u0026lt;= nums[i]: j-=1 nums[i], nums[j] = nums[j], nums[i] nums[i+1:] = reversed(nums[i+1:]) 33. 搜索旋转排序数组 题目大意： 给定一个按升序排列的整数数组 nums，数组中的值互不相同。该数组经过未知的某个下标旋转，即原本排在数组开头的一部分元素被移动到数组末尾。给定一个目标值 target，如果该目标值存在于旋转后的数组中，则返回其下标，否则返回 -1。要求设计一个时间复杂度为 O(log n) 的算法解决此问题。\n实现思路：\n使用二分查找算法来解决此问题，以满足 O(log n) 的时间复杂度要求。 初始化左右指针 l 和 r 分别指向数组的首尾元素。 在循环中，计算中间位置 mid，判断 nums[mid] 是否等于目标值 target，若是则直接返回 mid。 若 nums[0] \u0026lt;= nums[mid]，说明左半段是有序的，此时判断目标值是否在左半段范围内，若是则将右指针移到 mid-1，否则将左指针移到 mid+1。 若 nums[0] \u0026gt; nums[mid]，说明右半段是有序的，此时判断目标值是否在右半段范围内，若是则将左指针移到 mid+1，否则将右指针移到 mid-1。 若循环结束仍未找到目标值，则返回 -1。 class Solution: def search(self, nums: List[int], target: int) -\u0026gt; int: if not nums: return -1 n = len(nums) l, r = 0, n-1 while l\u0026lt;=r: mid = l+r\u0026gt;\u0026gt;1 if nums[mid]==target: return mid if nums[0]\u0026lt;=nums[mid]: if nums[0] \u0026lt;= target \u0026lt; nums[mid]: r = mid-1 else: l = mid+1 else: if nums[mid] \u0026lt; target \u0026lt;= nums[n-1]: l = mid+1 else: r = mid-1 return -1 19. 删除链表的倒数第 N 个结点 题目大意：给定一个链表，要求删除倒数第n个节点，并返回链表的头结点。\n实现思路：使用双指针，首先让第一个指针从头节点开始向后移动n步，然后同时移动第一个指针和第二个指针，直到第一个指针到达链表末尾。这样第二个指针所指的位置就是倒数第n个节点的前一个节点，然后进行删除操作即可。需要注意的是要考虑边界情况，比如链表长度为1，删除头节点等情况。\n# Definition for singly-linked list. # class ListNode: # def __init__(self, val=0, next=None): # self.val = val # self.next = next class Solution: def removeNthFromEnd(self, head: Optional[ListNode], n: int) -\u0026gt; Optional[ListNode]: if not head.next: return None p1 = head n-=1 while n: p1 = p1.next n-=1 pre = p2 = head while p1.next: p1 = p1.next pre = p2 p2 = p2.next if p2==head: head = head.next else: pre.next = pre.next.next return head 148. 排序链表 题目大意：给定一个链表的头结点head，要求将链表按升序排列，并返回排序后的链表。\n实现思路：\n使用归并排序的思想对链表进行排序。 编写递归函数sortFun(head, tail)，其中head表示当前待排序的子链表的头结点，tail表示当前待排序的子链表的尾结点的下一个结点（即尾结点的后继结点）。 在sortFun函数中，使用快慢指针找到当前待排序子链表的中间结点mid，并将链表分为两部分，左边部分由head到mid-1，右边部分由mid到tail-1。 递归调用sortFun函数对左右两部分进行排序，直至排序完成。 编写merge函数，将已经排好序的左右两部分链表进行合并，合并过程中按照结点的值大小进行比较，将较小的结点连接到结果链表中。 返回合并后的链表。 # Definition for singly-linked list. # class ListNode: # def __init__(self, val=0, next=None): # self.val = val # self.next = next class Solution: def sortList(self, head: Optional[ListNode]) -\u0026gt; Optional[ListNode]: def sortFun(head, tail): if not head: return head if head.next == tail: head.next = None return head slow = fast = head while fast != tail: fast = fast.next slow = slow.next if fast != tail: fast = fast.next mid = slow return merge(sortFun(head, mid), sortFun(mid, tail)) def merge(h1, h2): dummy = ListNode(-1) cur = dummy while h1 and h2: if h1.val\u0026lt;=h2.val: cur.next = h1 h1 = h1.next else: cur.next = h2 h2 = h2.next cur = cur.next if h1: cur.next = h1 if h2: cur.next = h2 return dummy.next return sortFun(head, None) 581. 最短无序连续子数组 题目大意：给定一个整数数组nums，找出一个连续子数组，使得对该子数组进行升序排序后，整个数组都变为升序排序。要求找出符合条件的最短子数组，并输出其长度。\n实现思路：\n首先初始化最大值mx为负无穷，最小值mn为正无穷，以及最短子数组的左右边界left和right分别为-1。 遍历数组nums，从左向右寻找右边界right，如果当前元素小于前面的最大值mx，则更新right为当前索引；否则更新最大值mx为当前元素。 同时，从右向左寻找左边界left，如果当前元素大于后面的最小值mn，则更新left为当前索引；否则更新最小值mn为当前元素。 最后返回右边界和左边界的差加1，即为最短子数组的长度。如果左边界仍为初始值-1，则返回0表示整个数组已经有序。 class Solution: def findUnsortedSubarray(self, nums: List[int]) -\u0026gt; int: n = len(nums) mx, right = -inf, -1 mn, left = inf, -1 for i in range(n): if mx\u0026gt;nums[i]: right = i else: mx = nums[i] if mn\u0026lt;nums[n-1-i]: left = n-1-i else: mn = nums[n-1-i] return 0 if left==-1 else right-left+1 线段树 729. 我的日程安排表 I 题目大意：这个题目是关于设计一个日程安排类 MyCalendar，它能够存储日程，并判断是否会有重复预订。日程以半开区间 [start, end) 表示，当两个日程时间有交叠时就会产生重复预订。 实现思路：\n使用线段树：\n我们可以使用线段树来表示时间段的预订情况。每个节点代表一个时间段，节点值表示这个时间段是否被预订。 对于每个节点，我们维护两个集合，self.tree 表示已经预订的节点，self.lazy 表示已经被标记为预订但尚未被更新的节点。 查询功能：\n当需要查询某个时间段是否被预订时，我们可以在线段树上进行查询。如果查询到某个节点被标记为已预订（包括被标记为预订但尚未更新的节点），则返回预订；否则返回未预订。 更新功能：\n当要预订某个时间段时，我们在线段树上进行更新操作。首先从根节点开始，递归地向下更新，将该时间段的节点标记为已预订，并将经过的节点加入 self.tree 中。 同时，如果该节点的两个子节点都被标记为已预订，则将该节点也标记为已预订，同时加入 self.lazy 中，表示其下的所有节点都已经被预订但尚未更新。 book 方法：\n在 book 方法中，首先判断要预订的时间段是否已经被预订，如果是，则返回 False；否则，调用 update 方法进行更新，并返回 True。 class MyCalendar: def __init__(self): self.tree = set() self.lazy = set() def query(self, start: int, end: int, l: int, r: int, idx: int) -\u0026gt; bool: if r \u0026lt; start or end \u0026lt; l: return False if idx in self.lazy: # 如果该区间已被预订，则直接返回 return True if start \u0026lt;= l and r \u0026lt;= end: return idx in self.tree mid = (l + r) // 2 return self.query(start, end, l, mid, 2 * idx) or \\ self.query(start, end, mid + 1, r, 2 * idx + 1) def update(self, start, end, l, r, idx): if start\u0026gt;r or end\u0026lt;l: return False if start\u0026lt;=l and r\u0026lt;=end: self.tree.add(idx) self.lazy.add(idx) else: mid = (l+r)\u0026gt;\u0026gt;1 self.update(start, end, l, mid, idx*2) self.update(start, end, mid+1, r, idx*2+1) self.tree.add(idx) if 2*idx in self.lazy and 2*idx+1 in self.lazy: self.lazy.add(idx) def book(self, start: int, end: int) -\u0026gt; bool: if self.query(start, end-1, 0, 10**9, 1): return False self.update(start, end-1, 0, 10**9, 1) return True 2286. 以组为单位订音乐会的门票 题目大意： 设计一个买票系统，针对音乐会的座位安排。音乐会总共有n排座位，每排有m个座椅。系统需要处理两种情况：\ngather(k, maxRow): 返回长度为2的数组，表示k个成员中第一个座位的排数和座位编号，这k位成员必须坐在同一排座位，且座位连续。如果无法安排座位，返回空数组。 scatter(k, maxRow): 如果组里所有k个成员不一定要坐在一起的前提下，都能在第0排到第maxRow排之间找到座位，返回true；否则返回false。这种情况下，每个成员都优先找排数最小，然后是座位编号最小的座位。 实现思路：\n对于gather(k, maxRow)，可以利用线段树来实现。 线段树节点维护最小值和总和，用于查找最小值以及查询总和。 使用二分查找确定符合条件的最小排数，并更新座位信息。 对于scatter(k, maxRow)，同样使用线段树来维护座位信息。 遍历排数，根据当前排的剩余座位数量和需求k进行判断。 若当前排剩余座位数足够，安排k个座位并返回true；若不足够，继续向下一排尝试。 class BookMyShow: def __init__(self, n: int, m: int): self.n, self.m = n, m N = 1 \u0026lt;\u0026lt; n.bit_length() + 1 self.mn = [0] * N # min self.sm = [0] * N # sum def modify(self, u, l, r, x, v): if l == r: self.mn[u] += v self.sm[u] += v else: mid = l + r \u0026gt;\u0026gt; 1 if x \u0026lt;= mid: self.modify(u \u0026lt;\u0026lt; 1, l, mid, x, v) else: self.modify(u \u0026lt;\u0026lt; 1 | 1, mid + 1, r, x, v) self.mn[u] = min(self.mn[u \u0026lt;\u0026lt; 1], self.mn[u \u0026lt;\u0026lt; 1 | 1]) self.sm[u] = self.sm[u \u0026lt;\u0026lt; 1] + self.sm[u \u0026lt;\u0026lt; 1 | 1] def query(self, u, l, r, ql, qr): if l \u0026gt;= ql and r \u0026lt;= qr: return self.sm[u] mid = l + r \u0026gt;\u0026gt; 1 res = 0 if ql \u0026lt;= mid: res = self.query(u \u0026lt;\u0026lt; 1, l, mid, ql, qr) if qr \u0026gt; mid: res += self.query(u \u0026lt;\u0026lt; 1 | 1, mid + 1, r, ql, qr) return res def index(self, u, l, r, qr, v): if self.mn[u] \u0026gt; v: return 0 if l == r: return l mid = l + r \u0026gt;\u0026gt; 1 if self.mn[u \u0026lt;\u0026lt; 1] \u0026lt;= v: return self.index(u \u0026lt;\u0026lt; 1, l, mid, qr, v) if qr \u0026gt; mid: return self.index(u \u0026lt;\u0026lt; 1 | 1, mid + 1, r, qr, v) return 0 def gather(self, k: int, maxRow: int) -\u0026gt; List[int]: i = self.index(1, 1, self.n, maxRow + 1, self.m - k) if i == 0: return [] col = self.query(1, 1, self.n, i, i) self.modify(1, 1, self.n, i, k) return [i - 1, col] def scatter(self, k: int, maxRow: int) -\u0026gt; bool: if self.m * (maxRow + 1) - self.query(1, 1, self.n, 1, maxRow + 1) \u0026lt; k: return False i = self.index(1, 1, self.n, maxRow + 1, self.m - 1) while True: rest = self.m - self.query(1, 1, self.n, i, i) if k \u0026lt;= rest: self.modify(1, 1, self.n, i, k) return True self.modify(1, 1, self.n, i, rest) k -= rest i += 1 其他题目 3031. 将单词恢复初始状态所需的最短时间 II Z函数 题目大意： 给定一个字符串 word 和一个整数 k，每秒需要执行两种操作：移除字符串 word 的前 k 个字符，并在字符串末尾添加 k 个任意字符。要求返回将 word 恢复到初始状态所需的最短时间。\n实现思路： 首先，我们可以利用 Z 函数（Z algorithm）来找到字符串的最长前缀后缀匹配长度。然后，我们可以利用 Z 函数的性质，将字符串分割成不同的前缀子串，找到满足条件的最小时间。\n具体步骤如下：\n初始化一个数组 z，用于存储字符串 s 的 Z 函数值。 使用双指针 l 和 r 来维护当前匹配的子串。 遍历字符串 s，计算 z[i] 的值，即以第 i 个字符为起始的最长前缀后缀匹配长度。 在每次遍历中，更新 l 和 r 的值，保持当前匹配的子串范围。 如果当前位置 i 能够满足条件：即 i 是 k 的倍数且 z[i] 等于剩余字符串的长度（n - i），则返回 i 除以 k。 若遍历完字符串后仍未找到满足条件的位置，则返回 (n - 1) 除以 k 再加 1，表示需要把剩余的字符串都移除并添加到末尾。 class Solution: def minimumTimeToInitialState(self, s: str, k: int) -\u0026gt; int: n = len(s) z = [0] * n l, r = 0, 0 for i in range(1, n): if i \u0026lt;= r and z[i - l] \u0026lt; r - i + 1: z[i] = z[i - l] else: z[i] = max(0, r - i + 1) while i + z[i] \u0026lt; n and s[z[i]] == s[i + z[i]]: z[i] += 1 if i + z[i] - 1 \u0026gt; r: l = i r = i + z[i] - 1 if i%k==0 and z[i] == n-i: return i//k return (n-1)//k+1 5. 最长回文子串马拉车算法 题意：求字符串内的最大回文串长度 思路：马拉车算法，由当前已知的最大回文串长度，我们可以由已知的回文串长度，推出其覆盖的点的最大回文串长度。如下图，p[i]位置的回文串长度可以由最长的回文串(以a为中心)得出，因为回文串两边是对称的，所以p[i] = p[c + c-i], 但是对于覆盖不到的部分，需要取下限r-i。 class Solution: # 推荐教学视频 ：https://www.bilibili.com/video/BV1Sx4y1k7jG/?spm_id_from=333.337.search-card.all.click\u0026amp;vd_source=a4a2b56f746715b34521bfb853094cf4 def longestPalindrome(self, s: str) -\u0026gt; str: s = \u0026#39;#\u0026#39; + \u0026#39;#\u0026#39;.join(list(s)) + \u0026#39;#\u0026#39; n = len(s) p = [0]*n #每个点的 最长回文字串 能到的 右侧位置 c, r = 0, 0 # 右边能到达最远的蘑菇的位置 和 其最右边能达到的位置 for i in range(n): if i\u0026lt;=r: p[i] = min(r-i, p[c + c-i]) # 由已知条件得到当前位置能达到的最大右侧距离( 需要取min(镜像位置的值, 当前最大蘑菇能覆盖到的最大值) ) while i+p[i]+1 \u0026lt; n and s[i-p[i]-1] == s[i+p[i]+1]: p[i]+=1 if p[i]+i \u0026gt; r: r = p[i] + i c = i ma = max(p) idx = p.index(ma) return s[idx-ma+1:idx+ma+1:2] ","permalink":"https://kennems.github.io/posts/tech/leetcode%E7%AC%94%E8%AE%B0/","summary":"LeetCode笔记 目标：2500分 HOT100 301. 删除无效的括号 题目大意： 给你一个由若干括号和字母组成的字符串 s ，删除最小数量的无效括号，使得输入的字","title":" LeetCode笔记"},{"content":"Linux 快捷键：\nctrl + l 清空屏幕\nLinux文件系统 FHS3.0（File system Hierarchy Standard） / etc 配置文件 bin 必要命令 usr 二级目录 home 家目录 var 动态数据 VFS虚拟文件系统 内核层抽象出通用的文件系统接口\n支持文件、网络、特殊文件系统\n抽象对象：\n超级快：文件系统 目录项：文件路径 索引节点：具体文件 文件：进程打开的文件 属性分层结构\n一切皆文件\n数据盘挂载 fdisk -l inode ：存储数据的元数据\nLinux没有盘符的概念，只有一个根目录/，所有文件都在其下\n/\n根目录 层级关系 命令 通用格式：\ncommand [-options] [parameter] command ：命令本身 -options： [可选，非必填] 命令的一些选项，可以通过选项控制命令的行为细节 parameter： [可选，非必填]命令的参数，多数用于命令的指向目标等 语法中[]表示可选\nls ls [-a -l -h] [Linux路径] -a all 前面带.的文件使隐藏文件/文件夹，只有通过-a选项才能看到 -l 以列表（竖向排列） -h 表示以易于阅读的形式，列出文件大小，如K，M，G /home/用户名\n组合使用\ncd change directory\ncd [Linux路径] 不写参数回到用户的HOME目录下\n绝对路径 相对路径 . 表示当前目录\n.. 表示上一级目录\n~ 表示HOME目录\nmkdir 创建目录\nmkdir [-p] 路径 -p可选，创建多级不存在的目录时使用\ntouch 创建文件\ntouch 路径\ncat 查看内容\ncat 路径\nmore 查看内容，支持翻页，空格翻页，q退出\nmore 路径\ncp 可以用于复制文件\\文件夹\ncp [-r] 参数1 参数2 -r选项，可选，用于复制文件夹使用，表示递归 参数1，Linux路径，表示被复制的文件或文件夹 参数2，Linux路径，表示要复制去的地方 mv mv 参数1 参数2 可以用于改名\nrm 删除文件，文件夹\nrm [-r -f] 参数1 参数2 参数n -r， 删除文件夹 -f，force，强制删除（不会弹出提示信息） 普通用户删除内容不会弹出提示，只有root管理员用户删除内容会有提示 所以一般普通用户用不到-f 参数1，参数2， \u0026hellip;，参数n 表示要删除的文件或文件夹路径，按照空格隔开。 支持用通配符来模糊匹配\n回收站式删除Trash-Cli rm太危险了， 为了避免出错， 在~/.bashrc中添加\nalias rm=\u0026#39;echo \u0026#34;This is not the command you are looking for.\u0026#34;; false\u0026#39; 然后 source ~/.bashrc\n使用 Trash-Cli trash-put： 删除文件和目录（仅放入回收站中） trash-list ：列出被删除了的文件和目录 trash-restore：从回收站中恢复文件或目录 trash. trash-rm：删除回收站中的文件 trash-empty：清空回收站 pwd Print Work Directory\ntree 树状目录\nwhich Linux命令本体就是一个个的二进制可执行文件\nwhich 命令 find find 起始路径 -name \u0026#34;被查找文件名\u0026#34; find 起始路径 -size + | -n[kMG] +, - 表示大于和小于 n表示大小数字 kMG表示大小单位，k表示kb,M表示MB，G表示GB grep 通过grep命令，从文件中通过关键字过滤文件行\ngrep [-n] 关键字 文件路径 选项 -n 可选，表示在结果中显示匹配的行的行号\n参数，关键字，必填，表示过滤的关键字，带有空格或其它特殊符号，建议使用“ ”将关键字包围起来\n参数，文件路径，必填，表示要过滤内容的文件路径，可作为内容输入端口\nwc wc [-c -m -l -w] 文件路径 选项， -c， 统计bytes数量 选项，-m，统计字符数量 选项，-l，统计行数 选项，-w，统计单词数量 参数，文件路径， 被统计的文件，可作为内容输入端口 默认行数、字数、字符数\n管道符 左 | 右。 将左边的结果作为右边的输入\necho 命令行内输出指定内容\n反引号` 在echo中，用``括起来表示命令信息\necho `pwd` 重定向符号 \u0026gt; 将左侧命令的结果，覆盖写入到符号右侧指定的文件中 \u0026gt;\u0026gt; 将左侧命令的结果，追加写入到符号右侧指定的文件中 tail tail [-f -num] 参数 参数，linux命令，表示被跟踪的文件路径 选项，-f，表示持续跟踪 选项，-num，表示尾部多少行，不填默认10行 awk 编写规则，根据输入的文本数据来执行特定的操作\n打印整行：\nawk \u0026#39;{print}\u0026#39; file.txt 这个命令将打印文件file.txt中的每一行。\n根据字段进行匹配和操作：\nawk \u0026#39;$1 == \u0026#34;pattern\u0026#34; {print $2}\u0026#39; file.txt 这个命令将打印文件file.txt中第一个字段为\u0026quot;pattern\u0026quot;的行的第二个字段。\n使用正则表达式进行匹配：\nawk \u0026#39;/pattern/ {print}\u0026#39; file.txt 这个命令将打印文件file.txt中包含\u0026quot;pattern\u0026quot;的每一行。\n计算字段的总和或平均值：\nawk \u0026#39;{sum+=$1} END {print \u0026#34;Sum:\u0026#34;, sum}\u0026#39; file.txt 这个命令将计算文件file.txt中第一个字段的总和，并在文件处理结束时打印出来。\n自定义字段分隔符：\nawk -F\u0026#39;,\u0026#39; \u0026#39;{print $1}\u0026#39; file.csv 这个命令将使用逗号作为字段分隔符，并打印文件file.csv中的每一行的第一个字段。\n使用内置函数：\nawk \u0026#39;{print toupper($1)}\u0026#39; file.txt 这个命令将将文件file.txt中的第一个字段转换为大写并打印出来。\n过滤并处理文件内容：\nawk \u0026#39;$3 \u0026gt; 10 {print $1, $2 * $3}\u0026#39; file.txt 这个命令将打印文件file.txt中第三个字段大于10的行的第一个和第二个字段的乘积。\n自定义输出格式：\nawk \u0026#39;{printf \u0026#34;%-10s %-5s\\n\u0026#34;, $1, $2}\u0026#39; file.txt 这个命令将按照指定的格式打印文件file.txt中的每一行的前两个字段。\nVim 命令模式 i : 在当前光标位置进入输入模式\na : 在当前光标位置 之后 进入输入模式\nI ： 在当前行的开头，进入输入模式\nA ： 在当前行的结尾，进入输入模式\no : 在当前行的下一行进入输入模式\nO ： 在当前行的上一行进入输入模式\n0 : 移动光标至开头\n$ : 移动给光标至行结尾\npageup : 向上翻页\npagedown : 向下翻页\n/ ： 进入搜索模式\nn : 向下继续搜索\nN : 向上继续搜索\ndd ： 删除光标所在的行\nndd : n是数字，表示删除当前光标向下n行\nyy : 复制当前行\nnyy ： 复制当前行和下面的n行\np : 粘贴复制的内容\nu : 撤销修改\nctrl + r ： 反向撤销修改\ngg ： 跳到首行\nG ： 跳到尾行\ndG : 从当前行开始，向下全部删除\ndgg ： 从当前行开始，向上全部删除\ndS : 从当前光标开始，删除到本行的结尾\nd0 ： 从当前光标开始，删除到本行的开头\n底线命令模式 : wq 保存并退出 q 仅退出\nq! 强制退出\n:w 仅保存\n:set nu 显示行号\n:set paste 设置粘贴模式\nCtrl + R使用 Ctrl + R : 反向搜索（reverse-i-search) 连续按键继续搜索\nCtrl + S : 正向搜索 （i-search) 连续按键继续搜索\nEnter输入该命令\nCtrl + G 或 Ctrl + C退出反向搜索模式\nAlt + . 插入最后一个参数，插入前一个命令的最后一个参数\nCtrl + J 选择当前命令\nCtrl + O 直接执行当前命令，并选择当前命令的下一条命令\n禁用Ctrl + S 禁用 XON/XOFF 流控制\n打开终端配置文件\n~/.bashrc 或\n~/.bash_profile 然后添加以下行：\nstty -ixon 保存文件并重新加载配置：\nsource ~/.bashrc 命令行终端左右移动\nCtrl + A 移动光标到行首\nCtrl + E 移动光标到行尾\nCtrl + B 向左移动光标\nCtrl + F 向右移动光标\nAlt + B 向左移动一个单词\nAlt + F 向右移动一个单词\nWSL 与 windows剪切板通信 visual模式选中文本，之后 :'\u0026lt;,'\u0026gt;w !clip.exe 复制选择的文本\n:w !clip.exe 复制整个文本\nLinux权限和用户 su su [-] [用户名] sudo 普通用户使用sudo使用root权限\n用户与用户组\n用户和用户组 groupadd 创建用户组 groupdel 用户组名 useradd [-g -d] 用户名 选项： -g指定用户的组，不指定-g，会创建同名组加入，指定-g需要组已经存在，如已存在同名组，必须使用-g。 选项： -d指定用户HOME路径，不指定，HOME目录默认在： /home/用户名 userdel [-r] 用户名 选项：-r，删除用户的HOME目录，不使用-r，删除目录时，HOME目录保留 id [用户名] 参数：用户名，被查看的用户，如果不提供则查看自身。 usermod -aG 用户组 用户名 将指定用户加入指定用户组 getent passwd\rgetent group 使用getent命令，可以查看当前系统内有那些命令\n七份信息：\n用户名 ： 密码（X） ： 用户ID ： 组ID ： 描述信息（无用） ： HOME目录 ： 执行终端（默认bash）\n查看权限管控信息 文件或文件夹的控制信息\n文件或文件夹所属用户\n文件或文件夹所属用户组\n第一个d表示文件夹 所属用户 所有用户组 所属其他用户 r代表读 文件夹表示可以查看文件夹内容 w代表写 文件夹表示可以在文件夹内：创建，删除，改名等操作 x代表可执行权限，针对文件表示可以将文件作为程序执行 针对文件夹，表示可以更改工作目录到此文件夹，即cd进入 chmod 修改文件或目录的权限。\nchmod u = rwx, g = rx, o = x hello.txt -R选项可以将文件夹以及文件夹内全部内容权限设置为：rwxrwxrwx\nchmod -R u=rwx, g=rwx, o=rwx hello.tx 使用数字序号\nchmod 751 hello.txt chown 更改文件或目录的所有者为指定的用户或用户组。\nchown [-R] [用户] [:] [用户组] 文件或文件夹 选项，-R，同chmod，对文件夹内全部内容应用相同规则 选项，用户，修改所属用户 选项，用户组，修改所属用户组 ： 用于分隔用户和用户组 普通用户无法使用，只能用root用户\nLinux使用操作 快捷键： ctrl + c 强制停止,退出当前命令输入 ctrl + d 退出账户的登录 history 查看历史输入的命令 !搜索历史命令，自动匹配，例如！py ctrl + a，跳到命令开头 ctrl + b, backward ctrl + f, forward esc + f, forward a word esc + b, backward a word ctrl + e，跳到命令结尾 ctrl + \u0026lt;-， 向左跳一个单词 ctrl + -\u0026gt;， 向右跳一个单词 ctrl + l 清空终端内容 clear 清空终端内容 软件安装 yum ： RPM软件管理器，用于自动化安装配置Linux软件，并可以自动解决依赖问题。\nyum [-y] [install | remove | search] 软件名称 -y 自动确认，无需手动确认安装或卸载过程 yum命令需要root权限，可以su切换到root，或使用sudo权限，yum命令需要联网\nUbuntu apt [-y] [install | remove | search] wget systemctl systemctl start | stop | status | enable | disable 服务名 NetworkManager, 主网络服务 newwork, 副网络服务 firewalld , 防火墙服务 sshd, ssh服务（FinalShell远程登录Linux使用的就是此服务） 除了内置的服务以外，部分第三方软件安装后也可以用systemctl进行控制\n软链接 在系统中创建软链接，可以将文件、文件夹链接到其他位置。类似快捷方式\nln -s 参数1 参数2 -s ，创建软链接 参数1 ： 被链接的文件或文件夹 参数2 ： 要链接去的目的地 日期，时区 date [-d] [+格式化字符串] -d按照给定的字符串显示日期，一般用于日期计算\n格式化字符串： 通过特定的字符串标记，来控制显示的日期格式\n%Y ， 年 %y,， 年份后两位数字（00，99） %M 月份 （01，12） %d 日(01,31) %H 小时（00，23） %M 分钟（00，59） %S 秒（00，59） %s 自1970-01-01 00:00:00到现在的秒数 使用-d支持的时间标记：(同样支持格式化字符串)\nyear 年 month 月 day 天 hour 小时 minute 分钟 second 秒 ntp 可以自动联网同步时间，也可以通过ntp -u ntp.aliyun.com 手动校准时间\nIP地址 DHCP : 动态获取IP地址，即每次重启设备后都会获取一次，可能导致IP地址频繁变更\n每一台联网的电脑都会有一个地址，用于和其他计算机进行通信，IP地址主要有两个版本，V4和V6版本\nIPv4的地址格式为a.b.c.d，其中abcd表示0~255的数字，如192.168.88.101\n通过ipconfig查看本机的IP地址。\n127.0.0.1表示本机\n0.0.0.0\n可以用于指代本机 可以在端口绑定中用来确定绑定关系 在一些IP地址中，表示所有IP的意思，如放行规则设置为0.0.0.0，表示允许任意IP访问 主机名 hostname 修改主机名\nhostnamectl set-hostname name 域名解析 ping 可以通过ping命令来检查指定的网络服务器是否是可联通的。\nping [-c num] ip或主机名 选项， -c，检查的次数，不适用-c选项，将无限次数持续检查 参数：ip或主机名，被检查的服务器的ip地址或主机名地址 wget 非交互式的文件下载器，可以在命令行内下载网络文件\nwget [-b] url 选项 ： -b ，后台下载，会将日志写入到当前工作目录的wget-log文件 参数：url，下载链接 curl 发送http网络请求，可用于下载文件，获取信息等\ncurl [-O] url 选项：-O，用于下载文件，当url是下载链接时，可以使用此选项保存文件 参数：url，要发起请求的网络地址 端口 端口，是设备与外界通讯交流的出入口，端口可以分为物理端口和虚拟端口\n物理端口：又可称之为接口，是可见的端口，如USB接口，RJ45网口，HDMI端口等 虚拟端口：是指计算机内部的端口，是不可见的，是用来操作系统和外部进行交互使用的 Linux支持65535个端口，分为3类进行使用：\n公认端口：1~1023，通常用于一些系统内置或知名程序的预留使用，如SSH服务的22端口，HTTPS服务的443端口，非特殊需要，不要占用这个范围的端口 注册端口：1024~49151，通常可以随意使用，用于松散的绑定一些程序/服务 动态端口：49152~65535，通常不会固定绑定程序，而是当程序对外进行网络链接时，用于临时使用。 进程管理 ps [-e -f] -e 显示出全部的进程 -f 以完全格式化的形式展示信息（展示全部信息） 一般来说，固定用法就是 ps -ef 列出全部进程的全部信息 UID ： 进程所属的用户ID\nPID ： 进程的进程号ID\nPPID ： 进程的父ID（启动此进程的其他进程）\nC ： 此进程的CPU占用率（百分比）\nSTIME ： 进程的启动时间\nTTY ： 启动此进程的终端序号，如果显示？，表示非终端启动\nTIME ： 进程启用CPU的时间\nCMD ： 进程对应的名称或启动路径和启动命令\n关闭进程 kill -9 进程ID -9, 表示强制关闭进程，不适用此选项会向进程发送信号要求其关闭，但是否关闭看进程自身的处理机制 主机状态 查看CPU，内存使用情况\ntop 第一行 ：\ntop ： 命令名称\n14：08 ：23 当前系统时间，up 6min：启动了六分钟\n2 users : 2个用户登录， load ：15分钟负载\n第二行：\nTasks : 175个进程 1 running : 1个子进程在运行\n174 sleeping : 174个进程睡眠，0个停止进程， 0个僵尸进程\n第三行：\n%Cpu(s) : CPU使用率，us：用户CPU使用率，sy ：系统CPU使用率，ni：高优先级进程占用CPU时间百分比，id：空闲CPU率，wa：IO等待CPU占用率，hi：CPU硬件中断率，si：CPU软件中断率，st：强制等待占用CPU率\n第四、五行\nKib Mem : 物理内存，total : 总量， free : 空闲， used ： 使用， buff/cache : buff和cache占用\nKibSwap : 虚拟内存（交换空间），total : 总量，free : 空闲，used：使用，buff/cache : buff和cache占用\nPID ： 进程ID USER ： 进程所属用户 PR ： 进程优先级，越小越好 NI ： 负值表示高优先级，正表示低优先级 VIRT ： 进程使用虚拟内存，单位KB RES ： 进程使用物理内存，单位KB SHR ： 进程使用共享内存， 单位KB S ： 进程状态(S休眠，R运行，Z僵死状态，N负数优先级，I空闲状态) %CPU ： 进程占用CPU率 %MEM： 进程占用内存率 TIME+ ： 进程使用CPU时间总计，单位10毫秒 COMMAND ： 进程的命令或名称或程序文件路径 -p : 只显示某个进程信息 -d : 设置刷新时间，默认为5s -c : 显示产生进程的完整命令，默认是进程名 -n : 制定刷新次数，比如 top -n 3 是新输出三次后退出 -b : 以非交互非全屏模式运行，以批次的方式执行top，一般配合-n制定输出几次统计信息，将输出重定向到制定文件，比如 top -b -n 3 \u0026gt; /tmp/top.tmp -i : 不显示任何闲置（idle）或无用的进程 -u ： 查找特定用户启动的进程 top以交互式运行：\nh ： 按下h键，会显示帮助画面 c ： 按下c键，会显示产生进程的完整命令，等同于-c参数 f ： 可以选择需要展示的项目 M ： 根据驻留内存大小（RES）排序 T ： 根据CPU使用百分比大小进行排序 T ： 根据时间/累计时间进行排序 E ： 切换顶部内存显示单位 e ： 切换进程内存显示单位 l ： 切换显示平均负载和启动时间信息 i ： 不显示闲置或无用的进程，等同于-i参数 t ： 切换显示CPU状态信息 m ： 切换显示内存信息 硬盘使用情况：\ndf -h -h， 以更加人性化的单位显示 磁盘信息监控：\niostat [-x] [num1] [num2] 网络状态监控：\n可以使用sar命令查看网络的相关统计 sar -n DEV num1 num2 -n 查看网络，DEV表示查看网络接口 num1 : 刷新间隔（不填就查看一次阶数）num2 : 查看次数（不填无限次数） 环境变量 环境变量是一组信息记录，类型是Key Value类型（名称=值），用于操作系统运行的时候记录关键信息\nenv 查看环境变量\n环境变量： PATH，通过$取出环境变量的值\n环境变量PATH会记录一组目录，目录之间用：隔开。记录的是命令的搜索路径。当执行命令会从记录中记录的目录中挨个搜索要执行的命令并执行\n可以通过这个项目的值，加入自定义的命令搜索路径\n如\nexport PATH=$PATH:目录 修改环境变量\n临时生效 ： export 名称 = 值 永久生效 针对用户 ： ~/.bashrc文件中配置 针对全部用户 文件上传和下载 通过finalShell或者xshell 上传或下载，拖动\n压缩和解压 .tar 称之为tarball，简单的将文件组装到一个.tar的文件中，并没有太多文件体积的减少，仅仅是简单的封装 .gz，也常见为.tar.gz，gzip格式压缩文件，即使用gzip压缩算法将文件压缩到一个文件内，可以极大的减少压缩后的体积 tar [-c -v -x -f -z -C] 参数1 参数2 ... 参数N -c 创建压缩文件，用于压缩模式 -v 显示压缩，解压过程，用于查看进度 -x 解压模式 -f 要创建的文件，或者要解压的文件，-f选项必须在所有选项中位置处于最后一个 -z gzip模式，不适用-z就是普通的tarball模式 -C 选择解压的目的地，用于解压模式 1. 压缩并打包文件或目录 使用 -czf 参数将文件或目录打包并压缩成 .tar.gz 格式：\ntar -czf 压缩包名.tar.gz 要压缩的文件或目录 例如，将目录 my_folder 压缩成 archive.tar.gz：\ntar -czf archive.tar.gz my_folder 2. 解压 .tar.gz 文件 使用 -xzf 参数解压 .tar.gz 文件：\ntar -xzf 压缩包名.tar.gz 例如，解压 archive.tar.gz 到当前目录：\ntar -xzf archive.tar.gz 3. 列出 .tar.gz 文件内容 使用 -tzf 参数查看 .tar.gz 文件中的内容，而不解压：\ntar -tzf 压缩包名.tar.gz 4. 打包但不压缩 如果不需要压缩，只想打包成 .tar 文件，可以使用 -cf 参数：\ntar -cf 包名.tar 要打包的文件或目录 例如，将 my_folder 打包成 archive.tar：\ntar -cf archive.tar my_folder 5. 解包 .tar 文件 使用 -xf 参数解包 .tar 文件：\ntar -xf 包名.tar zip [-r] 参数 -r 压缩文件夹使用 unzip unzip [-d] 参数\n-d 制定解压的目录 7z 1. 压缩文件或文件夹 使用 7z 命令创建 .7z 格式的压缩文件：\n7z a 压缩文件名.7z 要压缩的文件或文件夹 将 my_folder 压缩成 archive.7z：\n7z a archive.7z my_folder/ 2. 解压缩 .7z 文件 要解压缩 .7z 文件，可以使用：\n7z x 压缩文件名.7z 例如，解压缩 archive.7z 到当前目录：\n7z x archive.7z 3. 列出 .7z 文件内容 如果你想查看压缩文件中的内容，而不解压缩它，可以使用 l 参数：\n7z l 压缩文件名.7z 4. 解压缩到指定目录 你可以通过 -o 选项将文件解压缩到指定目录：\n7z x 压缩文件名.7z -o输出目录 例如，将 archive.7z 解压缩到 my_folder 目录下：\n7z x archive.7z -o./my_folder 6. 其他常用选项 -t7z：指定压缩类型为 .7z（默认）。 -mx=9：最大压缩级别，9 表示最强压缩。 例如：\n7z a -t7z -mx=9 压缩文件名.7z 文件或文件夹 Mysql wget --no-check-certificate https: /dlcdn.apache.org/tomcat/tomcat10/v10.0.27/bin/apache-tomcat-10.0.27.tar.gz Redis ElasticSearch Tomcat Nginx RabbitMq ","permalink":"https://kennems.github.io/posts/tech/linux/","summary":"Linux 快捷键： ctrl + l 清空屏幕 Linux文件系统 FHS3.0（File system Hierarchy Standard） / etc 配置文件 bin 必要命令 usr 二级目录 home 家目录 var 动态数据 VF","title":" Linux"},{"content":"LeetCode Hot 100 精练🥸(1) 记忆中的东西一定会消退，真正留下的才是学到的，一定要及时回顾。\n11. 盛最多水的容器 题目大意：给定一个长度为n的整数数组height，数组中的每个元素代表一条垂直线的高度。找出其中的两条线，使得它们与x轴构成的容器可以容纳最多的水。\n实现思路：使用双指针法。初始化左指针l指向数组的起始位置，右指针r指向数组的末尾位置。设置变量ret用于记录当前最大容量，初始化为0。在每一轮循环中，计算当前容器的容量，即min(height[l], height[r])乘以r和l之间的距离，更新ret。然后根据指针所指向的高度的大小，移动指针，如果height[l]\u0026lt;height[r]，则移动左指针l向右一步，否则移动右指针r向左一步。直到左右指针相遇，循环结束，返回ret即可。\n正确性证明： 对于左右端点 $ l, r$， 两点之间的距离为$len = r-l+1-1$(因为两个点之间算一段，所以长度要减一)，$ ret = (r-l)*min(height[l], height[r])$,假设 $height[l]\u0026lt;height[r]$, 对于左端点，其作为柱子能容纳的最多的水的数量已经为最大值，任意的 $l\u0026lt;x\u0026lt;r$ 作为右端点一定比$r$做端点更差，所以可以排除左端点$l$，计算下一点即$l+1$。从左右端点开始，对于每次排除的点，已经找到这个端点可能的最大值， 所以可以保证结果的正确性。 class Solution: def maxArea(self, height: List[int]) -\u0026gt; int: l, r = 0, len(height) - 1 res = 0 while l \u0026lt; r: res = max(res, (r - l) * min(height[l], height[r])) if height[l] \u0026lt; height[r]: l += 1 elif height[l] \u0026gt; height[r]: r -= 1 else: l += 1 r -= 1 return res 15. 三数之和 题目大意：给定一个整数数组 nums，判断是否存在三元组 [nums[i], nums[j], nums[k]] 满足 i != j、i != k 且 j != k，同时还满足 nums[i] + nums[j] + nums[k] == 0。返回所有满足条件的不重复的三元组。\n枚举 实现思路：首先对数组 nums 进行排序。然后遍历数组，对于每个元素 nums[i]，设定两个指针 l 和 r 分别指向 i+1 和数组末尾。在 l 和 r 之间寻找和为 0 的两个数。具体地，如果当前元素与前一个元素相同，跳过；如果当前元素与 l+1 处的元素相同，跳过；在 l 和 r 之间利用双指针的方式找到满足条件的两个数，如果找到了满足条件的三元组，则添加到结果中。最后返回结果列表 res。\nclass Solution: def threeSum(self, nums: List[int]) -\u0026gt; List[List[int]]: n = len(nums) nums.sort() res = [] for i in range(n): l = i r = n-1 if i and nums[i]==nums[i-1]: continue for m in range(l+1, n): if m\u0026gt;l+1 and nums[m]==nums[m-1]: continue while r\u0026gt;m and nums[r]+nums[m]+nums[l]\u0026gt;0: r-=1 if m==r: break if nums[r]+nums[m]+nums[l]==0: res.append([nums[l], nums[m], nums[r]]) return res 计数排序双指针 实现思路：首先，利用 Counter 函数统计每个数出现的次数，并检查是否有 0 出现至少三次，如果是则将 [0, 0, 0] 添加到结果中。然后，对不重复的数进行排序。遍历排序后的数，对于每个数 num，如果 num 不等于 0 且 num 出现次数大于 1 且 -num*2 也在 Counter 中，则将 [num, num, -num*2] 添加到结果中。然后，在负数部分，利用双指针的方式寻找满足条件的两个数。最后返回结果列表 res。\nclass Solution: def threeSum(self, nums: List[int]) -\u0026gt; List[List[int]]: res = [] c = Counter(nums) if 0 in c and c[0] \u0026gt;= 3: res.append([0,0,0]) no_repeat_nums = sorted(c.keys()) for i,num in enumerate(no_repeat_nums): if num != 0 and c[num] \u0026gt; 1 and -num*2 in c: res.append([num,num,-num*2]) if num \u0026lt; 0: for num3 in no_repeat_nums[ bisect_left(no_repeat_nums,((-num+1)/2)) : bisect_right(no_repeat_nums,-num*2-1) ]: num2 = -num-num3 if num2 in c: res.append([num,num2,num3]) return res 19. 删除链表的倒数第 N 个结点 题目大意：给定一个链表，要求删除倒数第n个节点，并返回链表的头结点。\n实现思路：使用双指针，首先让第一个指针从头节点开始向后移动n步，然后同时移动第一个指针和第二个指针，直到第一个指针到达链表末尾。这样第二个指针所指的位置就是倒数第n个节点的前一个节点，然后进行删除操作即可。需要注意的是要考虑边界情况，比如链表长度为1，删除头节点等情况。\nclass Solution: def removeNthFromEnd(self, head: Optional[ListNode], n: int) -\u0026gt; Optional[ListNode]: if not head.next: return None p1 = head n -= 1 while n: p1 = p1.next n -= 1 pre = p2 = head while p1.next: p1 = p1.next pre = p2 p2 = p2.next if p2 == head: head = head.next else: pre.next = pre.next.next return head 31. 下一个排列 题目大意：给定一个整数数组，要求找出这个数组的下一个排列，即比当前排列大的下一个排列，如果不存在则返回字典序最小的排列。\n实现思路：要找到下一个排列，可以遵循以下步骤：\n从数组末尾开始，找到第一个相邻的两个数，满足 nums[i] \u0026lt; nums[i+1]。 如果找到了这样的一对数，说明当前排列还不是最大的排列，可以进行下一步操作。 在从右往左找到的第一个位置记为 i，再从数组末尾开始，找到第一个大于 nums[i] 的数，记为 j。 交换 nums[i] 和 nums[j]。 将从 i+1 位置开始到数组末尾的数逆序排列，以得到字典序最小的排列。 如果步骤1中没有找到相邻的两个数，则说明当前排列已经是最大的排列，直接将整个数组逆序排列即可。 class Solution: def nextPermutation(self, nums: List[int]) -\u0026gt; None: n = len(nums) i = n - 2 while i \u0026gt;= 0 and nums[i] \u0026gt;= nums[i + 1]: i -= 1 if i \u0026gt;= 0: j = n - 1 while j \u0026gt;= i and nums[j] \u0026lt;= nums[i]: j -= 1 nums[i], nums[j] = nums[j], nums[i] nums[i + 1 :] = reversed(nums[i + 1 :]) 33. 搜索旋转排序数组 题目大意： 给定一个按升序排列的整数数组 nums，数组中的值互不相同。该数组经过未知的某个下标旋转，即原本排在数组开头的一部分元素被移动到数组末尾。给定一个目标值 target，如果该目标值存在于旋转后的数组中，则返回其下标，否则返回 -1。要求设计一个时间复杂度为 O(log n) 的算法解决此问题。\n实现思路：\n使用二分查找算法来解决此问题，以满足 O(log n) 的时间复杂度要求。 初始化左右指针 l 和 r 分别指向数组的首尾元素。 在循环中，计算中间位置 mid，判断 nums[mid] 是否等于目标值 target，若是则直接返回 mid。 若 nums[0] \u0026lt;= nums[mid]，说明左半段是有序的，此时判断目标值是否在左半段范围内，若是则将右指针移到 mid-1，否则将左指针移到 mid+1。 若 nums[0] \u0026gt; nums[mid]，说明右半段是有序的，此时判断目标值是否在右半段范围内，若是则将左指针移到 mid+1，否则将右指针移到 mid-1。 若循环结束仍未找到目标值，则返回 -1。 class Solution: def search(self, nums: List[int], target: int) -\u0026gt; int: if not nums: return -1 n = len(nums) l, r = 0, n - 1 while l \u0026lt;= r: mid = l + r \u0026gt;\u0026gt; 1 if nums[mid] == target: return mid if nums[0] \u0026lt;= nums[mid]: if nums[0] \u0026lt;= target \u0026lt; nums[mid]: r = mid - 1 else: l = mid + 1 else: if nums[mid] \u0026lt; target \u0026lt;= nums[n - 1]: l = mid + 1 else: r = mid - 1 return -1 76. 最小覆盖子串 题目大意：给你一个字符串 s 、一个字符串 t 。返回 s 中涵盖 t 所有字符的最小子串。如果 s 中不存在涵盖 t 所有字符的子串，则返回空字符串 \u0026quot;\u0026quot; 。\n思路：双指针，为了保证对于每一个右端点，都能找到最优的左端点，对所有的已经遍历的字符都要计数-1， 这样在每一个符合条件的右端点判断每个字符是否有多余，这样确保左端点最优。\nclass Solution: def minWindow(self, s: str, t: str) -\u0026gt; str: m, n = len(s), len(t) needCnt = n need = Counter(t) res = (0, m) left = 0 for right, ch in enumerate(s): if need[ch] \u0026gt; 0: needCnt -= 1 need[ch] -= 1 # 关键点 if needCnt == 0: while need[s[left]]!=0: # 保证对于每个符合的右端点，都可以找到最优的左端点 need[s[left]] += 1 left += 1 if right - left + 1 \u0026lt; res[1] - res[0] + 1: res = (left, right) needCnt += 1 need[s[left]] += 1 left += 1 return s[res[0]:res[1]+1] if res[1] \u0026lt; m else \u0026#34;\u0026#34; 301. 删除无效的括号 题目大意：\n给你一个由若干括号和字母组成的字符串 s ，删除最小数量的无效括号，使得输入的字符串有效。\n返回所有可能的结果。答案可以按 任意顺序 返回。\n回溯 实现思路：\n统计无效括号数量：\n首先遍历字符串s，统计左括号和右括号的数量l和r，其中l表示未匹配的左括号数量，r表示需要删除的右括号数量。 回溯算法：\n编写回溯算法来尝试删除不同位置的括号，使得字符串有效。 回溯过程中需要注意以下情况： 已经匹配的括号数量ln和rn，以及当前位置i。 遍历字符串s的每个字符，当遇到重复的字符时跳过，以避免重复结果。 如果当前字符为左括号并且ln不为0，则递归调用删除当前左括号的情况，ln减一，否则继续。 如果当前字符为右括号并且rn不为0，则递归调用删除当前右括号的情况，rn减一，否则继续。 检查字符串有效性：\n编写辅助函数check来检查字符串是否有效，即左右括号数量是否匹配。 返回结果：\n将所有有效的字符串结果添加到结果列表ret中，并返回。 class Solution: def removeInvalidParentheses(self, s: str) -\u0026gt; List[str]: l, r = 0, 0 ret = [] n = len(s) for c in s: if c==\u0026#39;(\u0026#39;: l+=1 elif c==\u0026#39;)\u0026#39;: if l==0: r+=1 else: l-=1 def check(st): cnt=0 for c in st: if c==\u0026#39;(\u0026#39;: cnt+=1 elif c==\u0026#39;)\u0026#39;: cnt-=1 if cnt\u0026lt;0: return False return (cnt==0) def backtrace(st, start, ln, rn): if ln==0 and rn==0 and check(st): ret.append(st[:]) return for i in range(start, len(st)): if i\u0026gt;start and st[i]==st[i-1]: continue if ln+rn\u0026gt;n-1-i+1: break if ln and st[i]==\u0026#39;(\u0026#39;: backtrace(st[:i]+st[i+1:], i, ln-1, rn) elif rn and st[i]==\u0026#39;)\u0026#39;: backtrace(st[:i]+st[i+1:], i, ln, rn-1) backtrace(s, 0, l, r) return ret 广搜 这个实现使用了广度优先搜索（BFS）的思路来解决问题。\nBFS搜索：\n使用一个集合cur来存储当前层的所有字符串，初始时将输入的字符串s加入集合cur中。 在每一轮循环中，遍历当前集合cur中的所有字符串，如果其中有字符串是有效的，则将其加入结果列表ret中。 如果结果列表ret不为空，则跳出循环，表示已经找到了所有有效的字符串。 如果结果列表ret为空，则需要继续进行下一轮搜索，将当前集合cur中的每个字符串，通过删除一个括号的方式，生成所有可能的下一层字符串，加入到集合nxt中。 更新当前集合cur为nxt，继续下一轮搜索。 检查字符串有效性：\n定义一个辅助函数check，用于检查字符串是否有效。 遍历字符串中的每个字符，遇到左括号时增加计数器cnt，遇到右括号时如果cnt为0则返回False（表示右括号没有匹配的左括号），否则减少cnt。 最终判断cnt是否为0，如果为0表示字符串有效。 返回结果：\n返回结果列表ret，其中存储了所有有效的字符串。 class Solution: def removeInvalidParentheses(self, s: str) -\u0026gt; List[str]: ret = [] def check(st): cnt=0 for c in st: if c==\u0026#39;(\u0026#39;: cnt+=1 elif c==\u0026#39;)\u0026#39;: if cnt==0: return False cnt-=1 return cnt==0 cur = set([s]) while True: for st in cur: if check(st): ret.append(st) if len(ret): break nxt = set() for st in cur: for i in range(len(st)): if i\u0026gt;0 and st[i]==st[i-1]: continue if st[i]==\u0026#39;(\u0026#39; or st[i]==\u0026#39;)\u0026#39;: nxt.add(st[:i]+st[i+1:]) cur = nxt return ret 297. 二叉树的序列化与反序列化 不止第一次遇到了。\n题目大意：序列化是将一个数据结构或对象转换为连续的比特位的操作，从而可以存储在文件或内存中，并且通过网络传输到另一个计算机环境中。本题要求设计一个算法来实现二叉树的序列化和反序列化，即将二叉树转换为字符串并将字符串转换回原始的二叉树结构。\n实现思路：\n序列化：使用递归将二叉树转换为字符串，根节点值与左右子树序列化结果之间使用空格分隔，空节点用 \u0026lsquo;#\u0026rsquo; 表示。 反序列化：使用递归将字符串转换为二叉树。首先定义一个辅助函数 DerWork()，用于递归构建二叉树。在该函数中，按照前序遍历的顺序，依次提取字符串中的节点值，并根据节点值构建二叉树节点。如果节点值为 \u0026lsquo;#\u0026rsquo;，表示空节点，返回 None。否则，创建节点并递归构建其左右子树。 在反序列化过程中，使用一个全局变量 self.s 来记录当前待处理的字符串，每次递归处理后，将字符串中已经处理过的部分剔除，继续处理剩余部分。 最终返回根节点即可。 class Codec: def serialize(self, root): if not root: return \u0026#34;#\u0026#34; return ( str(root.val) + \u0026#34; \u0026#34; + self.serialize(root.left) + \u0026#34; \u0026#34; + self.serialize(root.right) ) def deserialize(self, data): self.s = data return self.DerWork() def DerWork(self): if len(self.s) == 0: return None try: idx = self.s.index(\u0026#34; \u0026#34;) except: idx = -1 node = self.s if idx == -1 else self.s[:idx] self.s = \u0026#34;\u0026#34; if idx == -1 else self.s[idx + 1 :] if node == \u0026#34;#\u0026#34;: return None t = TreeNode(int(node)) t.left = self.DerWork() t.right = self.DerWork() return t 84. 柱状图中最大的矩形 题目大意：给定 n 个非负整数，表示柱状图中各个柱子的高度。每个柱子彼此相邻，且宽度为 1。求在该柱状图中，能够勾勒出的矩形的最大面积。\n实现思路：\n使用单调栈解决问题。创建两个数组 l 和 r，分别记录每个柱子向左和向右第一个比其高度小的柱子的索引位置。 初始化一个空栈 stk。 遍历柱子的高度列表 heights： 若栈不为空且当前柱子的高度小于栈顶柱子的高度，则将栈顶元素弹出，并更新栈顶元素对应的 r 值为当前柱子的索引。 若栈为空或者当前柱子的高度大于栈顶柱子的高度，则将当前柱子的索引入栈。 在更新 r 值的同时，若栈不为空，则更新当前柱子的 l 值为栈顶元素的索引。 遍历完成后，对于每个柱子 i，计算以该柱子为高度的矩形面积为 (r[i] - l[i] - 1) * heights[i]，取最大值即为所求的最大矩形面积。 若柱状图为空，则返回 0。 class Solution: def largestRectangleArea(self, heights: List[int]) -\u0026gt; int: # 单调栈，找到每个高度能组成的最大矩形 # 往左右两面找到第一个小于 自身高度的柱子，那么这两个柱子之间的柱子一定可以达到自身的高度，所以是自身高度可以组成的最大面积 n = len(heights) l, r = [-1]*n, [n]*n res = 0 stk = [] for i in range(n): h = heights[i] while stk and heights[stk[-1]] \u0026gt;= h: r[stk[-1]] = i stk.pop() if stk: l[i] = stk[-1] stk.append(i) # stk = [] # for i in range(n-1, -1, -1): # h = heights[i] # while stk and heights[stk[-1]] \u0026gt;= h: # stk.pop() # if stk: # r[i] = stk[-1] # stk.append(i) for i in range(n): if heights[i] * (r[i]-l[i]-1) \u0026gt; res: res = heights[i] * (r[i]-l[i]-1) return res 85. 最大矩形 题目大意：给定一个仅包含 0 和 1、大小为 rows x cols 的二维二进制矩阵，找出只包含 1 的最大矩形，并返回其面积。\n实现思路：\n将问题转化为矩形最大面积问题。 定义变量 area 用于记录最大矩形的面积。 创建二维数组 left，用于记录每个位置 (i, j) 左侧连续 1 的个数。 遍历二维矩阵，初始化 left 数组： 若当前位置为 \u0026lsquo;1\u0026rsquo;，则 left[i][j] 等于 left[i][j-1] + 1，否则为 0。 遍历矩阵的每一列，对于每一列 j，使用单调栈来计算以当前列为底边的最大矩形的面积： 初始化一个空栈 stk。 定义两个数组 up 和 down，分别记录当前位置上方第一个小于等于其高度的位置和下方第一个小于等于其高度的位置。 遍历矩阵的每一行 i，进行以下操作： 当栈不为空且栈顶位置对应的 left 值大于等于当前位置的 left 值时，弹出栈顶位置，并更新 down 值。 如果栈为空，则当前位置的 up 值为 -1，否则为栈顶位置。 将当前行索引入栈。 在计算当前列的矩形面积时，height 为 down[i] - up[i] - 1，宽度为 left[i][j]，计算当前列的最大面积并更新 area。 返回最大面积 area。 class Solution: def maximalRectangle(self, matrix: List[List[str]]) -\u0026gt; int: # 转化为矩形最大面积问题 n, m = len(matrix), len(matrix[0]) area = 0 left = [[0]*m for _ in range(n)] for i in range(n): for j in range(m): if matrix[i][j]==\u0026#39;1\u0026#39;: left[i][j] += left[i][j-1]+1 if j else 1 for j in range(m): stk = [] up, down = [-1]*n, [n]*n for i in range(n): #行 while stk and left[ stk[-1] ][j]\u0026gt;=left[i][j]: down[stk[-1]] = i stk.pop() up[i] = stk[-1] if stk else -1 stk.append(i) for i in range(n): height = down[i]-up[i]-1 area = max(area, height*left[i][j]) return area 312. 戳气球 题意：给定n个数字num[0~n-1],每次戳破一个气球可以获得nums[i-1]*nums[i]*nums[i+1]个硬币，最两旁默认为1，问最终获得的最大硬币数量。 思路：区间DP，逆向思维, 思考如何放气球能使硬币最大，f[i][j]代表开区间i~j可以获得的最大硬币， 先枚举小区间，再枚举大区间，枚举区间内每个数字，状态转移有：f[i][j] = max(f[i][j], f[i][k]+f[k][j]+nums[i]*nums[k]*nums[j])。最终输出f[0][n+1] class Solution: def maxCoins(self, nums: List[int]) -\u0026gt; int: n = len(nums) nums = [1] + nums + [1] f = [[0] * (n + 5) for _ in range(n + 5)] # 开区间 (left, right) 区间内能获得的最大硬币 for l in range(2, n + 2): # len:2~n+1 for i in range(n + 1 - l + 1): # left:0~n+1-len j = i + l # right = left + len for k in range(i + 1, j): # 开区间(i,j) 即[i+1, j-1] f[i][j] = max( f[i][j], f[i][k] + f[k][j] + nums[i] * nums[k] * nums[j] ) return f[0][n + 1] 301. 删除无效的括号 题目大意：给定一个由字母和括号组成的字符串s，要求删除最小数量的括号，使得字符串成为有效的括号组合，并返回所有可能的结果。\n实现思路：\n首先定义一个辅助函数check(st)，用于检查字符串st是否为有效的括号组合。遍历字符串中的每个字符，维护一个计数器cnt，遇到左括号增加计数，遇到右括号减少计数，若出现cnt为负数，或者遍历结束后cnt不为0，则说明括号不匹配，返回False，否则返回True。\n初始化一个空列表ret，用于存储结果。\n初始化一个集合cur，初始时将输入字符串s作为唯一元素加入其中。\n使用while循环，直到找到符合条件的结果为止：\n遍历集合cur中的每个字符串，检查其是否为有效括号组合，若是则将其加入结果列表ret。\n若结果列表ret不为空，则说明已找到符合条件的结果，结束循环。\n否则，初始化一个空集合nxt，用于存储下一轮迭代的候选字符串集合。\n遍历集合cur中的每个字符串，对于每个字符串，尝试删除一个字符（括号），生成新的字符串，并将其加入nxt中。\n更新cur为nxt，继续下一轮迭代。\n返回结果列表ret。\nclass Solution: def removeInvalidParentheses(self, s: str) -\u0026gt; List[str]: ret = [] def check(st): cnt=0 for c in st: if c==\u0026#39;(\u0026#39;: cnt+=1 elif c==\u0026#39;)\u0026#39;: if cnt==0: return False cnt-=1 return cnt==0 cur = set([s]) while True: for st in cur: if check(st): ret.append(st) if len(ret): break nxt = set() for st in cur: for i in range(len(st)): if i\u0026gt;0 and st[i]==st[i-1]: continue if st[i]==\u0026#39;(\u0026#39; or st[i]==\u0026#39;)\u0026#39;: nxt.add(st[:i]+st[i+1:]) cur = nxt return ret 647. 回文子串 题目大意：给定一个字符串s，统计并返回该字符串中回文子串的数目。回文字符串是指正着读和倒过来读一样的字符串。子字符串是字符串中的由连续字符组成的一个序列。即使是由相同字符组成的不同开始位置或结束位置的子串，也会被视作不同的子串。\n实现思路：遍历字符串s的所有可能的中心位置，对于每个中心位置，向两边扩展，判断是否是回文串。在扩展的过程中，每当发现一个回文子串，就将计数器加1。最终返回计数器的值即可。\nclass Solution: def countSubstrings(self, s: str) -\u0026gt; int: n = len(s) ans = 0 for i in range(2*n - 1): l, r = i//2, i//2 + (i\u0026amp;1) while l\u0026gt;=0 and r\u0026lt;n and s[l]==s[r]: l-=1; r+=1 ans+=1 return ans 93. 复原 IP 地址 题目大意：给定一个只包含数字的字符串s，表示一个IP地址，要求返回所有可能的有效IP地址，即每个IP地址由四个整数组成（每个整数位于0到255之间，且不能含有前导0），整数之间用'.'分隔。不能重新排序或删除s中的任何数字，可以按任何顺序返回答案。\n实现思路：使用深度优先搜索（DFS）算法，递归地搜索所有可能的IP地址组合。在搜索过程中，首先确定每个整数的范围，然后遍历可能的数字组合，逐步构建IP地址。递归的终止条件是已经找到了四个整数并且已经遍历完了整个字符串s。\nclass Solution: def restoreIpAddresses(self, s: str) -\u0026gt; List[str]: n = len(s) res, addr = [], [\u0026#39;0\u0026#39;]*4 def dfs(i, start): if i==4 or start==n: if i==4 and start==n: res.append(\u0026#39;.\u0026#39;.join(addr)) return if s[start]==\u0026#39;0\u0026#39;: addr[i] = \u0026#39;0\u0026#39; dfs(i+1, start+1) return num = 0 for end in range(start, n): num = num*10 + int(s[end]) if num in range(256): addr[i] = str(num) dfs(i+1, end+1) dfs(0, 0) return res 538. 把二叉搜索树转换为累加树 题目大意：给定一个二叉搜索树的根节点，需要将其转换为累加树，即每个节点的新值等于原树中大于或等于该节点值的节点值之和。\n实现思路：\n递归解法 class Solution: def convertBST(self, root: Optional[TreeNode]) -\u0026gt; Optional[TreeNode]: s = 0 def dfs(r): nonlocal s if not r: return 0 dfs(r.right) s += r.val r.val = s dfs(r.left) dfs(root) return root (Morris 遍历) 从根节点开始，采用反向中序遍历（右-根-左）的方式进行遍历。利用一个变量 s 记录累加和，初始值为 0。对于每个节点，首先判断其是否存在右子节点，如果不存在，则将其值加上累加和并更新累加和，然后将当前节点指向其左子节点；如果存在右子节点，则找到其中序遍历的后继节点，即右子树中最左边的节点。如果后继节点的左子节点为空，说明还未处理过该节点，则将后继节点的左子节点指向当前节点，并将当前节点指向其右子节点；如果后继节点的左子节点为当前节点，则说明已经处理过该节点，则将后继节点的左子节点置为空，将当前节点的值加上累加和并更新累加和，并将当前节点指向其左子节点。最后返回根节点。\nclass Solution: def convertBST(self, root: Optional[TreeNode]) -\u0026gt; Optional[TreeNode]: def getSucc(node): succ = node.right while succ.left and succ.left!=node: succ = succ.left return succ newRoot = root s = 0 while root: if not root.right: s += root.val root.val = s root = root.left else: succ = getSucc(root) if not succ.left: succ.left = root root = root.right else: succ.left = None s += root.val root.val = s root = root.left return newRoot 494. 目标和 题目大意：给定一个非负整数数组 nums 和一个目标整数 target，通过给数组中的每个整数前添加 \u0026lsquo;+\u0026rsquo; 或 \u0026lsquo;-\u0026rsquo;，然后串联起来构造表达式，返回可以构造的表达式数目，使其运算结果等于目标数。\n记忆化搜索 实现思路：这个问题可以转化为一个背包问题。我们可以将问题转化为在数组中选取一些数，使得它们的和等于 target。定义一个递归函数 dfs(i, s)，表示在数组 nums 中考虑第 i 个数，使得目前的和为 s 的表达式数目。递归的终止条件是遍历完所有数，如果 s 等于 0，表示找到了一种构造方式，返回 1，否则返回 0。递归过程中，如果 s 小于当前数 nums[i]，说明无法选取当前数，直接跳过；否则，递归考虑选取当前数和不选取当前数两种情况。利用缓存装饰器 @cache 可以将重复计算的结果进行缓存，提高计算效率。最后返回 dfs(0, target) 即可得到结果。\nclass Solution: def findTargetSumWays(self, nums: List[int], target: int) -\u0026gt; int: target += sum(nums) if target\u0026lt;0 or target\u0026amp;1: return 0 target//=2 @cache def dfs(i, s): if i==len(nums): return 1 if s==0 else 0 if s\u0026lt;nums[i]: return dfs(i+1, s) else: return dfs(i+1, s) + dfs(i+1, s-nums[i]) return dfs(0, target) 动态规划 实现思路：\n问题转化：假设数组 nums 的元素和为 s，我们希望找到一种方式使得加正号和负号的和等于 target。通过推导，得到目标问题转化为：$p + n = s$， $p - n = target$ 从数组中选出和为 (s + target) / 2 的子集。如果 s + target 为负数或奇数，直接返回 0。 背包问题：将问题转化为一个经典的 0-1 背包问题。我们需要求解从 nums 中选取一些元素，使得它们的和恰好为 (s + target) / 2。 动态规划：定义 dp[j] 为和为 j 的子集数目。初始化 dp[0] = 1，表示和为 0 的方案有 1 种。然后遍历每个元素，并更新 dp 数组。 class Solution: def findTargetSumWays(self, nums: List[int], target: int) -\u0026gt; int: target += sum(nums) if target \u0026lt; 0 or target % 2: return 0 target //= 2 n = len(nums) f = [[0] * (target + 1) for _ in range(n + 1)] f[0][0] = 1 for i in range(1, n + 1): for j in range(target + 1): if j \u0026lt; nums[i - 1]: f[i][j] = f[i - 1][j] else: f[i][j] = f[i - 1][j] + f[i - 1][j - nums[i - 1]] return f[n][target] 416. 分割等和子集 题目大意：给定一个非空数组 nums，数组中只包含正整数。要求判断是否能将该数组分割成两个子集，使得这两个子集的元素和相等。\n实现思路：\n首先计算数组 nums 的总和 s。 如果总和 s 为奇数，那么无法分割成两个和相等的子集，直接返回 False。 如果数组中的最大值大于总和的一半，则无法分割成两个和相等的子集，直接返回 False。 初始化一个大小为总和一半加一的布尔数组 f，f[i] 表示是否存在子集的和为 i。 将 f[0] 初始化为 True，表示子集的和为 0。 遍历数组 nums，对于每个正整数 num，从总和一半开始向前遍历，更新数组 f，如果 f[j-num] 为 True，则说明存在一个子集的和为 j-num，加上当前的 num 后，和为 j，因此 f[j] 也为 True。 最终返回 f[s//2]，表示是否存在一个子集的和为总和一半，即是否能分割成两个和相等的子集。 class Solution: def canPartition(self, nums: List[int]) -\u0026gt; bool: s = sum(nums) if s \u0026amp; 1: return False mx = max(nums) t = s // 2 if mx \u0026gt; t: return False n = len(nums) f = [False] * (t + 1) f[0] = True for i, num in enumerate(nums): for j in range(t, num - 1, -1): f[j] |= f[j - num] return f[t] 394. 字符串解码 题目大意：给定一个经过编码的字符串，其中编码规则为k[encoded_string]，表示encoded_string中的内容重复k次。要求解码该字符串。\n实现思路：使用递归来解码字符串。遍历输入字符串，根据不同情况进行处理：\n若遇到数字，则累加数字直至遇到非数字字符。 若遇到字母，则直接加入当前解码的字符串中。 若遇到左括号\u0026rsquo;[\u0026rsquo;，则递归调用解码函数，处理括号内的内容，直至遇到右括号\u0026rsquo;]\u0026rsquo;。将括号内的解码结果乘以前面累积的数字，并加入当前解码的字符串中。 若遇到右括号\u0026rsquo;]\u0026rsquo;，则返回当前解码的字符串和当前索引。 返回最终解码结果。 class Solution: def decodeString(self, s: str) -\u0026gt; str: def decode(i, n): cur = \u0026#34;\u0026#34; num = 0 while i \u0026lt; len(s): if s[i].isdigit(): num = num * 10 + int(s[i]) elif s[i].isalpha(): cur += s[i] elif s[i] == \u0026#34;[\u0026#34;: ns, ni = decode(i + 1, num) # next str, next index cur += ns i = ni num = 0 elif s[i] == \u0026#34;]\u0026#34;: return cur * n, i i += 1 return cur * n, i res, _ = decode(0, 1) return res 72. 编辑距离 题目大意： 给定两个单词 word1 和 word2，求通过插入、删除或替换字符，将 word1 转换成 word2 所需的最少操作数。\n记忆化搜索 这段代码使用了递归的方式求解，其中 dfs 函数表示将 s 的前 i 个字符转换为 t 的前 j 个字符所需的最少操作数。递归的基本情况是当 i 小于 0 时，表示 s 已经遍历完，需要插入 t 的前 j+1 个字符；当 j 小于 0 时，表示 t 已经遍历完，需要删除 s 的前 i+1 个字符；当 s[i] 等于 t[j] 时，不需要额外操作，直接递归处理 i-1 和 j-1；当 s[i] 不等于 t[j] 时，可以选择插入、删除或替换操作，选择操作数最小的方案。递归的过程中利用了缓存装饰器 @cache 来提高效率。\nclass Solution: def minDistance(self, s: str, t: str) -\u0026gt; int: n, m = len(s), len(t) @cache def dfs(i, j): if i \u0026lt; 0: return j + 1 if j \u0026lt; 0: return i + 1 if s[i] == t[j]: return dfs(i - 1, j - 1) return min(dfs(i - 1, j), dfs(i, j - 1), dfs(i - 1, j - 1)) + 1 return dfs(n - 1, m - 1) 递推 实现思路： 可以使用动态规划来解决这个问题。定义一个二维数组 f，其中 f[i][j] 表示将 word1 的前 i 个字符转换为 word2 的前 j 个字符所需的最少操作数。初始时，f[i][0] 表示将 word1 的前 i 个字符全部删除，需要的操作数为 i，而 f[0][j] 表示将 word2 的前 j 个字符全部插入到 word1 中，需要的操作数为 j。 然后，根据动态规划的状态转移方程，逐步计算 f[i][j] 的值。若 word1[i] 等于 word2[j]，则 f[i][j] 等于 f[i-1][j-1]，即不需要额外操作；若不相等，则可以考虑插入、删除或替换操作，选择操作数最小的方案。最终，返回 f[n][m]，其中 n 和 m 分别为 word1 和 word2 的长度。\nclass Solution: def minDistance(self, s: str, t: str) -\u0026gt; int: n, m = len(s), len(t) f = [[0] * (m + 1) for _ in range(n + 1)] f[0] = list(range(m + 1)) # f[0][j] = j for i in range(n): f[i + 1][0] = i + 1 for j in range(m): if s[i] == t[j]: f[i + 1][j + 1] = f[i][j] else: f[i + 1][j + 1] = min(f[i][j + 1], f[i + 1][j], f[i][j]) + 1 return f[n][m] 96. 不同的二叉搜索树 题目大意： 给定一个整数 n，要求计算由 n 个节点组成的二叉搜索树（BST）的数量，节点的值从 1 到 n 且互不相同。返回满足条件的二叉搜索树的种数。\n解题思路： 二叉搜索树的性质： 对于二叉搜索树，任意节点的左子树中的值都小于该节点的值，右子树中的值都大于该节点的值。 给定一个根节点 i（范围从 1 到 n），其左子树的节点值来自 [1, i-1]，右子树的节点值来自 [i+1, n]。 通过递归计算左子树和右子树的不同构造方式，可以得到当前根节点 i 时，整个二叉搜索树的数量。 动态规划： 用 f[i] 表示 i 个节点可以组成的不同二叉搜索树的数量。 初始条件：f[0] = 1，f[1] = 1，这分别表示0个节点和1个节点的二叉搜索树只有1种（空树和单个节点）。 左子树的节点数为 j-1，右子树的节点数为 i-j。 其中，f[j-1] 表示左子树有 j-1 个节点时的二叉搜索树种数，f[i-j] 表示右子树有 i-j 个节点时的二叉搜索树种数。 算法步骤： 使用动态规划数组 f 来存储从 0 到 n 个节点的不同二叉搜索树的数量。 通过递推关系来填充数组 f。 最终 f[n] 就是所求的结果。 f[i] += f[j - 1] * f[i - j] 表示当前根节点 j 时，左子树和右子树的种数乘积，累加到 f[i]。 class Solution: def numTrees(self, n: int) -\u0026gt; int: f = [0]*(n+1) f[0] = 1; f[1] = 1 for i in range(2, n+1): for j in range(1, i+1): f[i] += f[i-j]*f[j-1] return f[n] 160. 相交链表 题目大意：\n给定两个单链表的头节点 headA 和 headB，要求找出并返回这两个链表相交的第一个节点。如果两个链表不相交，返回 null\n解题思路:\n初始化两个指针 l1 和 l2，分别指向 headA 和 headB。\n让两个指针交替遍历两个链表：当一个指针到达链表尾部时，重新指向另一个链表的头部。这样，两个指针会同步遍历剩余部分，且相交的节点会在相同的步数内被找到。\n如果两个链表相交，最终两个指针会相遇在相交的节点。如果没有交点，两个指针都会变为 null。\nclass Solution: def getIntersectionNode(self, headA: ListNode, headB: ListNode) -\u0026gt; Optional[ListNode]: l1, l2 = headA, headB while l1 != l2: # 当 l1 到达尾部时，重新指向 headB；当 l2 到达尾部时，重新指向 headA l1 = headB if not l1 else l1.next l2 = headA if not l2 else l2.next return l1 148. 排序链表 题目大意：给定一个链表的头结点head，要求将链表按升序排列，并返回排序后的链表。\n实现思路：\n使用归并排序的思想对链表进行排序。 编写递归函数sortFun(head, tail)，其中head表示当前待排序的子链表的头结点，tail表示当前待排序的子链表的尾结点的下一个结点（即尾结点的后继结点）。 在sortFun函数中，使用快慢指针找到当前待排序子链表的中间结点mid，并将链表分为两部分，左边部分由head到mid-1，右边部分由mid到tail-1。 递归调用sortFun函数对左右两部分进行排序，直至排序完成。 编写merge函数，将已经排好序的左右两部分链表进行合并，合并过程中按照结点的值大小进行比较，将较小的结点连接到结果链表中。 返回合并后的链表。 class Solution: def sortList(self, head: Optional[ListNode]) -\u0026gt; Optional[ListNode]: def sortFun(head, tail): if not head: return head if head.next == tail: head.next = None return head slow = fast = head while fast != tail: fast = fast.next slow = slow.next if fast != tail: fast = fast.next mid = slow return merge(sortFun(head, mid), sortFun(mid, tail)) def merge(h1, h2): dummy = ListNode(-1) cur = dummy while h1 and h2: if h1.val\u0026lt;=h2.val: cur.next = h1 h1 = h1.next else: cur.next = h2 h2 = h2.next cur = cur.next if h1: cur.next = h1 if h2: cur.next = h2 return dummy.next return sortFun(head, None) 581. 最短无序连续子数组 题目大意：给定一个整数数组nums，找出一个连续子数组，使得对该子数组进行升序排序后，整个数组都变为升序排序。要求找出符合条件的最短子数组，并输出其长度。\n实现思路：\n首先初始化最大值mx为负无穷，最小值mn为正无穷，以及最短子数组的左右边界left和right分别为-1。 遍历数组nums，从左向右寻找右边界right，如果当前元素小于前面的最大值mx，则更新right为当前索引；否则更新最大值mx为当前元素。 同时，从右向左寻找左边界left，如果当前元素大于后面的最小值mn，则更新left为当前索引；否则更新最小值mn为当前元素。 最后返回右边界和左边界的差加1，即为最短子数组的长度。如果左边界仍为初始值-1，则返回0表示整个数组已经有序。 class Solution: def findUnsortedSubarray(self, nums: List[int]) -\u0026gt; int: n = len(nums) mx, right = -inf, -1 mn, left = inf, -1 for i in range(n): if mx \u0026gt; nums[i]: right = i else: mx = nums[i] if mn \u0026lt; nums[n-1-i]: left = n-1-i else: mn = nums[n-1-i] return 0 if left == -1 else right-left+1 ","permalink":"https://kennems.github.io/posts/tech/leetcode-hot-100-1/","summary":"LeetCode Hot 100 精练🥸(1) 记忆中的东西一定会消退，真正留下的才是学到的，一定要及时回顾。 11. 盛最多水的容器 题目大意：给定一个长度为n的整数数组heig","title":"LeetCode Hot 100 精练🥸(1)"},{"content":"每日一题（202404） 2009. 使数组连续的最少操作数 题意：给定一个可能有重复元素的数组，可以修改数组中值为任意其他值，问使数组连续的最小操作数。\n思路：由于只能改动元素，所以最后的元素个数不变，去重后，枚举每个值作为左端点，则右端点为nums[i]+n-1, 用双指针计算在区间内的元素个数即为可以保留的数字，其他数字修改元素值填满空隙即可。\nclass Solution: def minOperations(self, nums: List[int]) -\u0026gt; int: n = len(nums) nums = sorted(set(nums)) j, ans = 0, 0 for i in range(len(nums)): right = nums[i]+ n-1 if len(nums)-1 - i + 1 \u0026lt;= ans: break while j\u0026lt;len(nums) and nums[j]\u0026lt;=right: j+=1 ans = max(ans, j-i) return n-ans 1600. 王位继承顺序 题意：国王继承次序按嫡长子次序，实现ThroneInheritance(string kingName)初始化,void birth(string parentName, string childName) 出生，void death(string name)人死亡，string[] getInheritanceOrder() 返回 除去 死亡人员的当前继承顺序列表。\n思路：类似树形结构，国王先继承，之后是国王的长子，之后是长子的长子， 如果不存在则为国王的次子以此类推， 所以可以用defaultdict()存储每个的儿子情况，然后查询时，先将自己入结果列表，然后是第一个儿子\u0026hellip;；并记录每个人的存活情况，排除掉已经死掉的人。\nclass ThroneInheritance: def __init__(self, kingName: str): self.son = defaultdict(list) self.die = set() self.king = kingName def birth(self, parentName: str, childName: str) -\u0026gt; None: self.son[parentName].append(childName) def death(self, name: str) -\u0026gt; None: self.die.add(name) def getInheritanceOrder(self) -\u0026gt; List[str]: ret = [] def dfs(root): if root not in self.die: ret.append(root) for child in self.son[root]: dfs(child) dfs(self.king) return ret 1483. 树节点的第 K 个祖先 题意：给定n个点(0~n-1)每个点的父亲节点，快速查询每个节点的第k个祖宗节点。\n思路：LCA倍增原理，$ancestor[j][i] = ancestor[ ancestor[j][i-1] ][i-1]$ 节点j的第$2^i$个祖宗节点为节点第$2^{i-1}$个祖宗的第$2^{i-1}$个祖宗，即$2^{i-1}*2$个祖宗节点， 所以先预处理好每个节点的各个二进制位上的祖宗节点是谁，之后分解二进制位据可以得知任意第k个祖宗节点是谁。\nclass TreeAncestor: def __init__(self, n: int, parent: List[int]): self.level = 16 self.ancestor = [[-1]*self.level for _ in range(n)] for i in range(1, n): self.ancestor[i][0] = parent[i] for i in range(1, self.level): for j in range(1, n): if self.ancestor[j][i-1]!=-1: self.ancestor[j][i] = self.ancestor[ self.ancestor[j][i-1] ][i-1] def getKthAncestor(self, node: int, k: int) -\u0026gt; int: while k: t = k\u0026amp;-k k -= t t = t.bit_length()-1 node = self.ancestor[node][t] if node==-1: return -1 return node 面试题 08.12. 八皇后 题目大意：\n这道题目是经典的八皇后问题的扩展，需要设计一个算法来打印 N 皇后在 N × N 棋盘上的各种摆法，其中每个皇后都不在同一行、同一列，也不在任何对角线上。\n实现思路：\n回溯算法：\n使用回溯算法来尝试所有可能的皇后摆放方式。 从第一行开始，依次尝试每一列放置皇后，然后继续递归地尝试下一行的放置，直到所有行都放置完毕。 在递归过程中，通过检查每个位置的列、主对角线和副对角线是否已经存在皇后来确定是否可以放置皇后。 生成棋盘：\n当确定了一种合法的皇后摆放方式时，将其转换为棋盘的形式，并将其添加到结果列表中。 对于每行中皇后的位置，用 \u0026lsquo;Q\u0026rsquo; 表示，其他位置用 \u0026lsquo;.\u0026rsquo; 表示。 辅助函数：\nsolve: 递归函数，尝试在每行放置皇后。 generate: 将合法的皇后摆放方式转换为棋盘形式并添加到结果列表中。 剪枝优化：\n使用位运算来表示列、主对角线和副对角线的占用情况，可以快速判断某个位置是否可以放置皇后，从而提高效率。 在每次递归时，利用位运算进行剪枝，排除不可能的位置。 class Solution: def solveNQueens(self, n: int) -\u0026gt; List[List[str]]: def generate(): board = [] for r in range(n): c = pos[r] row[c] = \u0026#39;Q\u0026#39; board.append(\u0026#34;\u0026#34;.join(row)) row[c] = \u0026#39;.\u0026#39; ret.append(board) def solve(row, column, diag1, diag2): if row==n: generate() else: avail = ( (1\u0026lt;\u0026lt;n)-1) \u0026amp; ( ~(column|diag1|diag2) ) while avail: colPos = avail\u0026amp;(-avail) avail -= colPos colNum = bin(colPos-1).count(\u0026#34;1\u0026#34;) pos[row]=colNum solve(row+1, column|colPos, (diag1|colPos)\u0026lt;\u0026lt;1, (diag2|colPos)\u0026gt;\u0026gt;1) pos = [0]*n ret = [] row = [\u0026#39;.\u0026#39;]*n solve(0, 0, 0, 0) return ret 1702. 修改后的最大二进制字符串 题意：给定一个二进制字符串00-\u0026gt;10, 10-\u0026gt;01问任意次操作后能达到的最大二进制字符串。\n思路：构造，根据条件推过程，10-\u0026gt;01可以看作后面的0浮到前面，所有的0聚到一起可以变成10串，所以最后至多只有一个0。根据构造来做，统计第一个0的位置和0的个数，最后构造出最后的0的位置；双指针来做：遇到0时找到后面第一个0的位置，将其浮到旁边，并换成10。\n构造：\nclass Solution: def maximumBinaryString(self, binary: str) -\u0026gt; str: cnt = binary.count(\u0026#39;0\u0026#39;) if cnt\u0026lt;=1: return binary n = len(binary) ans = [\u0026#39;1\u0026#39;]*n index = binary.index(\u0026#39;0\u0026#39;) ans[index+cnt-1]=\u0026#39;0\u0026#39; return \u0026#39;\u0026#39;.join(ans) 双指针：\nclass Solution: def maximumBinaryString(self, binary: str) -\u0026gt; str: n = len(binary) s = list(binary) j = 0 for i in range(n): if s[i]==\u0026#39;0\u0026#39;: while j\u0026lt;=i or (j\u0026lt;n and s[j]==\u0026#39;1\u0026#39;): j+=1 if j\u0026lt;n: s[i], s[j], s[i+1] = \u0026#39;1\u0026#39;, \u0026#39;1\u0026#39;, \u0026#39;0\u0026#39; return \u0026#39;\u0026#39;.join(s) 24. 两两交换链表中的节点 题意：给定一个链表，分别两个一组交换相对位置。\n思路：链表交换next指针操作，prev-\u0026gt;A-\u0026gt;B-\u0026gt;C变成prev-\u0026gt;B-\u0026gt;A-\u0026gt;C，一共要变三条边。需要记录前面的点，后面的点。\nclass Solution: def swapPairs(self, head: Optional[ListNode]) -\u0026gt; Optional[ListNode]: dummy = head prev = None while head and head.next: tmp = head.next.next #A-\u0026gt;B 变成 B-\u0026gt;A nxt = head.next #nxt是B, head是A nxt.next = head head.next = tmp if prev: prev.next = nxt prev = nxt.next #是头节点(即没有前面的点)的时候不需要这一步 if dummy==head: dummy = nxt prev = nxt.next head = tmp return dummy 25. K 个一组翻转链表 题意：每隔k个数字翻转链表。\n思路：链表交换指针操作。\n# Definition for singly-linked list. # class ListNode: # def __init__(self, val=0, next=None): # self.val = val # self.next = next class Solution: def reverseKGroup(self, head: Optional[ListNode], k: int) -\u0026gt; Optional[ListNode]: def reverse(head, tail): # A-\u0026gt;B-\u0026gt;C 变成 C-\u0026gt;B-\u0026gt;A cur = tail.next dummy = head while cur != tail: nxt = dummy.next dummy.next = cur cur = dummy dummy = nxt return tail, head # 原来的tail和head位置没变，但中间点的指向关系变了 hair = ListNode(-1) # 伪头节点 hair.next = head pre = hair while head: tail = pre for i in range(k): # 走过k个点 tail = tail.next if not tail: return hair.next head, tail = reverse(head, tail) pre.next = head # pre-\u0026gt;C pre = tail # pre变成尾节点 head = tail.next # 头节点变成当前尾节点的下个一个节点 return hair.next 1766. 互质树 题意：给定一棵树0~n-1共n个节点， 每个节点有一个值，返回每个节点的 最近的 与自己互质的(gcd(a,b)=1) 祖宗节点的编号。值的范围为[1,50] 思路：DFS， 遍历一遍树，维护一个祖宗节点的列表，判断当前节点与祖宗节点的互质关系。但朴素的将所有的祖宗节点都加入列表中，到深层的子节点时会遍历整个列表，会超时。由于值的范围最大为50，所以可以先预处理50范围以内的互质关系，对于每个节点，只需要判断祖宗节点里面有没有这些互质的数即可，但是需要的是最近的祖宗节点，所以还要添加一个深度信息，这样才能保证在相同值的祖宗节点中选择离自己最近的祖宗节点。 class Solution: def getCoprimes(self, nums: List[int], edges: List[List[int]]) -\u0026gt; List[int]: n = len(nums) g = [[]*n for _ in range(n)] ret = [-1]*n store = [[] for _ in range(51)] mem = [(-1, -1)]*(51) for i in range(1, 51): for j in range(1, 51): if gcd(i, j)==1: store[i].append(j) for u, v in edges: g[u].append(v) g[v].append(u) def dfs(u, last, level): ret[u] = max(mem[i] for i in store[nums[u]])[1] tmp = mem[nums[u]] mem[nums[u]] = (level, u) for son in g[u]: if son==last: continue dfs(son, u, level+1) mem[nums[u]] = tmp dfs(0, -1, 0) return ret 924. 尽量减少恶意软件的传播 题目大意：给定一个由n个节点组成的网络，用n x n个邻接矩阵图graph表示。节点之间存在直接连接当且仅当graph[i][j] = 1。一些节点initial最初被恶意软件感染，如果两个节点直接连接且至少一个节点被感染，则两个节点都将被感染。移除一个节点后，返回使得整个网络中感染恶意软件的最终节点数最小的节点，若有多个节点满足条件，则返回索引最小的节点。\n实现思路：首先使用并查集将节点分组，然后计算每个分组的大小和其中感染节点的数量。遍历initial列表，找到使得其所在分组中只有一个感染节点且分组大小最大的节点，返回其索引。\nclass Solution: def minMalwareSpread(self, g: List[List[int]], initial: List[int]) -\u0026gt; int: n, m = len(g), len(initial) f = [i for i in range(n)] size = [1 for _ in range(n)] # 连通块内的点数 num = [0 for _ in range(n)] # 连通块内的感染点数 for x in initial: num[x]=1 def find(x): if f[x] != x: f[x] = find(f[x]) return f[x] for i in range(n): for j in range(i+1, n): if g[i][j]: fi, fj = find(i), find(j) if fi!=fj: f[fi] = fj num[fj] += num[fi] size[fj] += size[fi] ma = -1 initial.sort() idx = initial[0] for x in initial: if num[find(x)]==1 and size[find(x)]\u0026gt;ma: ma = size[find(x)] idx = x return idx 928. 尽量减少恶意软件的传播 II 题目大意：给定一个由n个节点组成的网络，用n x n个邻接矩阵graph表示。节点之间存在直接连接当且仅当graph[i][j] = 1。一些节点initial最初被恶意软件感染，如果两个节点直接连接且至少一个节点被感染，则两个节点都将被感染。移除一个节点及其连接后，返回移除后能使整个网络中感染恶意软件的最终节点数最小的节点，若有多个节点满足条件，则返回索引最小的节点。\n实现思路：首先通过并查集将不在initial中的节点进行合并，然后计算每个initial节点的直接感染节点数。最后选择使得感染节点数最小且索引最小的initial节点返回。\nclass Solution: def minMalwareSpread(self, g: List[List[int]], initial: List[int]) -\u0026gt; int: n = len(g) def find(x): if f[x] != x: f[x] = find(f[x]) return f[x] f = [i for i in range(n)] source = [[] for _ in range(n)] cnt = [0]*n init = [0]*n for i in initial: init[i] = 1 for i in range(n): if init[i]: continue for j in range(n): if init[j] or not g[i][j]: continue fi, fj = find(i), find(j) if fi!=fj: f[fi] = fj for x in initial: infected = [0]*n for j in range(n): if not g[x][j] or init[j] or infected[find(j)]: continue infected[find(j)] = 1 for j in range(n): if infected[j]: source[j].append(x) for i in range(n): if len(source[i])==1: root = source[i][0] for j in range(n): if find(i)==find(j): # 是一个连通块 cnt[root]+=1 idx = initial[0] for x in initial: if cnt[x]\u0026gt;cnt[idx] or (cnt[x]==cnt[idx] and x\u0026lt;idx): idx = x return idx 2007. 从双倍数组中还原原数组 题目大意：给定一个数组 changed，通过以下方式构造原始数组 original：将 changed 中的每个元素乘以2，并将结果随机打乱，然后返回原始数组 original。如果无法构造原始数组，则返回空数组。\n实现思路：首先判断数组 changed 的长度是否为偶数，如果不是偶数，则无法构造原始数组，直接返回空数组。接着使用一个字典记录数组 changed 中各个元素的出现次数。然后遍历数组 changed，对于每个元素 i，判断是否存在 i 的两倍的元素，若存在，则将 i 和其两倍的元素都从字典中减去一个，并将 i 加入结果数组中。最后判断结果数组的长度是否达到了原始数组的一半，如果达到了则返回结果数组的前一半，否则返回空数组。\nclass Solution: def findOriginalArray(self, changed: List[int]) -\u0026gt; List[int]: n = len(changed) if n\u0026amp;1: return [] d = defaultdict(int) res = [] cnt = 0 changed.sort() for i in changed: d[i]+=1 for i in changed: if not d[i]: continue x = i*2 if i==x: # 0*2 = 0 d[x]-=1 if d[x]: d[x]-=1 # 匹配成功 cnt+=1 res.append(i) else: if d[x]: d[x]-=1 # 匹配成功 d[i]-=1 cnt+=1 res.append(i) if cnt\u0026gt;=n//2: return res[:n//2] return [] 实现思路：首先使用 Counter 统计数组 changed 中各个元素的出现次数。然后将字典中键为 0 的元素（如果存在）弹出，因为原始数组中不可能有 0。接着判断字典中键为 0 的元素出现次数是否为偶数，如果不是偶数则无法构造原始数组，直接返回空数组。然后初始化一个由 0 组成的数组 ans，长度为 cnt_0 的一半。接下来遍历字典中的键值对，对于每个键 x，判断是否存在其一半的键值对，并将 x 加入结果数组 ans 中相应次数。最后返回结果数组 ans。\nclass Solution: def findOriginalArray(self, changed: List[int]) -\u0026gt; List[int]: cnt = Counter(changed) cnt_0 = cnt.pop(0, 0) if cnt_0\u0026amp;1: return [] ans = [0]*(cnt_0//2) for x in cnt: if x%2==0 and cnt[x//2]: continue while x in cnt: if cnt[2*x]\u0026lt;cnt[x]: return [] ans.extend([x]*(cnt[x])) if cnt[2*x]\u0026gt;cnt[x]: cnt[2*x]-=cnt[x] x*=2 else: x*=4 return ans 1883. 准时抵达会议现场的最小跳过休息次数 题目大意：题目给出了一组道路的长度和行驶速度，以及剩余可用时间。要求计算在给定的时间内，最少跳过休息次数，以准时抵达会议现场。\n实现思路：动态规划。使用二维数组dp[i][j]表示到达第i条路，跳过j次休息的最小距离。初始化dp数组，然后遍历每一条路，在遍历的过程中更新dp数组。最后检查是否有方案可以在规定时间内到达会议现场，如果有，返回跳过休息的最小次数，否则返回-1。\nclass Solution: def minSkips(self, dist: List[int], speed: int, hoursBefore: int) -\u0026gt; int: n = len(dist) if sum(dist) \u0026gt; hoursBefore * speed: return -1 dp = [[inf] * (n + 1) for _ in range(n + 1)] dp[0][0] = 0 for i in range(1, n): for j in range(i+1): # 到第i条路，跳过次数为j的最小距离 # 不跳过第 i 条路 dp[i][j] = min(dp[i][j], (dp[i-1][j] + dist[i-1] + speed -1)//speed*speed) # 跳过第 i 条路 if j: dp[i][j] = min(dp[i][j], dp[i - 1][j -1] + dist[i-1]) for j in range(n): # 可以跳0~n-1次(最后一条边不用跳) if dp[n-1][j]+dist[-1] \u0026lt;= hoursBefore * speed: return j return -1 39. 组合总和 题目大意 ：给定一个无重复元素的整数数组 candidates 和一个目标整数 target，找出 candidates 中可以使数字和为目标数 target 的所有不同组合，并以列表形式返回。可以无限制重复选择 candidates 中的同一个数字。\n实现思路 ：\n使用深度优先搜索（DFS）进行组合搜索。 定义一个辅助函数 dfs(i, s)，其中 i 表示当前遍历到的 candidates 数组的索引，s 表示当前已经选取的数字的和。 在 dfs 函数中，如果 s 大于等于 target 或者已经遍历到数组末尾，则进行以下判断： 如果 s 等于 target，则将当前的组合 ls 加入结果列表 ret 中。 如果 s 大于 target 或者已经遍历到数组末尾，则直接返回。 在 dfs 函数中，分别尝试两种情况： 不选择当前数字，继续向后搜索：dfs(i+1, s)。 选择当前数字，继续向后搜索：将当前数字加入组合 ls 中，更新 s，并递归调用 dfs(i, s+c[i])。 在递归调用之后，需要将当前选择的数字从组合 ls 中弹出，保证不影响后续搜索。 最终返回结果列表 ret。 class Solution: def combinationSum(self, c: List[int], t: int) -\u0026gt; List[List[int]]: n = len(c) ret, ls = [], [] def dfs(i, s): if s\u0026gt;=t or i==n: if s==t: ret.append(ls[:]) return dfs(i+1, s) ls.append(c[i]) dfs(i, s+c[i]) ls.pop() dfs(0, 0) return ret 216. 组合总和 III 题目大意：找出所有相加之和为n的k个数的组合，要求使用数字1到9，每个数字最多使用一次，返回所有可能的有效组合的列表。列表不能包含相同的组合两次，组合可以以任何顺序返回。\n实现思路：使用深度优先搜索（DFS）的方法，从1到9的数字中进行遍历，每次选择一个数字或不选择，直到满足条件为止。递归过程中，维护一个列表ls，记录当前已选数字的集合，如果当前集合的数字个数等于k且它们的和等于n，则将其加入结果列表ret中。\nclass Solution: def combinationSum3(self, k: int, n: int) -\u0026gt; List[List[int]]: ret, ls = [], [] def dfs(i, s, cnt): if i==10 or s\u0026gt;=n or cnt\u0026gt;=k: if s==n and cnt==k: ret.append(ls[:]) return dfs(i+1, s, cnt) ls.append(i) dfs(i+1, s+i, cnt+1) ls.pop() dfs(1, 0, 0) return ret 377. 组合总和 Ⅳ 题目大意：给定一个由不同整数组成的数组nums和一个目标整数target，要求从nums中找出总和为target的元素组合的个数。\n实现思路：这是一个典型的动态规划问题。使用递归+记忆化搜索（Memoization）的方法来解决。定义dfs函数，参数为当前的和s，函数返回当前和s能够组成的组合数目。递归的终止条件是当前和s大于等于目标target，则返回1（如果s等于target，则表示找到一种组合）。否则，遍历数组nums中的每个数，对每个数进行递归调用dfs(s+i)，累加得到的组合数目。使用cache装饰器对dfs函数进行记忆化搜索，避免重复计算。最终返回dfs(0)，即从初始和为0开始的组合数目。\nclass Solution: def combinationSum4(self, nums: List[int], target: int) -\u0026gt; int: @cache def dfs(s): if s\u0026gt;=target: if s==target: return 1 return 0 cnt = 0 for i in nums: cnt += dfs(s+i) return cnt return dfs(0) 1146. 快照数组 题目大意：实现一个支持快照的数组数据结构SnapshotArray，具体包括以下接口：\nSnapshotArray(length)：初始化一个与指定长度相等的类数组的数据结构，初始时每个元素都为0。 set(index, val)：将指定索引index处的元素设置为val。 snap()：获取该数组的快照，并返回快照的编号snap_id（快照号是调用snap()的总次数减去1）。 get(index, snap_id)：根据指定的snap_id选择快照，并返回该快照指定索引index的值。 实现思路：使用一个字典存储每个索引处的快照历史记录，键为索引，值为一个列表，列表中每个元素是一个元组，元组第一个值是快照的编号，第二个值是该快照对应索引的值。对于set操作，直接将快照编号和值添加到对应索引的列表中；对于snap操作，记录快照编号并返回；对于get操作，利用二分查找找到snap_id对应的快照，返回快照中该索引的值。\nclass SnapshotArray: def __init__(self, length: int): self.id = 0 self.arr = defaultdict(list) def set(self, index: int, val: int) -\u0026gt; None: self.arr[index].append((self.id, val)) def snap(self) -\u0026gt; int: self.id+=1 return self.id-1 def get(self, index: int, snap_id: int) -\u0026gt; int: # if not len(self.arr[index]): # return 0 # l, r = 0, len(self.arr[index])-1 # while l\u0026lt;r: # mid = (l+r+1)\u0026gt;\u0026gt;1 # if self.arr[index][mid][0] \u0026lt;= snap_id: # l = mid # else: # r = mid-1 # return self.arr[index][r][1] if self.arr[index][r][0] \u0026lt;= snap_id else 0 l = bisect.bisect_right(self.arr[index], (snap_id, inf)) - 1 return self.arr[index][l][1] if l\u0026gt;=0 else 0 857. 雇佣 K 名工人的最低成本 题目大意：给定一组工人，每个工人有工作质量和最低期望工资，现在要雇佣 k 名工人组成一个工资组。雇佣工人时，按照每名工人的工作质量与同组其他工人的工作质量的比例来支付工资，每名工人至少应得到其最低期望工资。求组成满足条件的付费群体所需的最小金额。\n实现思路：首先按照工资与工作质量的比例对工人进行排序，然后使用最小堆来维护一个大小为 k 的堆，堆中存放的是负的工作质量。初始化堆时，将前 k 名工人的质量放入堆中。计算当前堆中所有工人的总质量，并计算以当前工资标准下的总支付金额。然后遍历剩余的工人，每次将堆顶的质量弹出，加上新的工人的质量，计算新的总质量，并更新总支付金额。找出所有情况下的最小总支付金额即可。\nclass Solution: def mincostToHireWorkers(self, quality: List[int], wage: List[int], k: int) -\u0026gt; float: emp = sorted(zip(wage, quality), key = lambda e:e[0]/e[1]) h = [-q for _, q in emp[:k]] heapify(h) sum_q = -sum(h) ans = sum_q*(emp[k-1][0]/emp[k-1][1]) for w, q in emp[k:]: sum_q += heapreplace(h, -q) + q ans = min(ans, sum_q*w/q) return ans ","permalink":"https://kennems.github.io/posts/tech/leetcode%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98202404/","summary":"每日一题（202404） 2009. 使数组连续的最少操作数 题意：给定一个可能有重复元素的数组，可以修改数组中值为任意其他值，问使数组连续的最小操作数。","title":"LeetCode每日一题（202404）"},{"content":"每日一题（202404） 2009. 使数组连续的最少操作数 题意：给定一个可能有重复元素的数组，可以修改数组中值为任意其他值，问使数组连续的最小操作数。\n思路：由于只能改动元素，所以最后的元素个数不变，去重后，枚举每个值作为左端点，则右端点为nums[i]+n-1, 用双指针计算在区间内的元素个数即为可以保留的数字，其他数字修改元素值填满空隙即可。\nclass Solution: def minOperations(self, nums: List[int]) -\u0026gt; int: n = len(nums) nums = sorted(set(nums)) j, ans = 0, 0 for i in range(len(nums)): right = nums[i]+ n-1 if len(nums)-1 - i + 1 \u0026lt;= ans: break while j\u0026lt;len(nums) and nums[j]\u0026lt;=right: j+=1 ans = max(ans, j-i) return n-ans 1600. 王位继承顺序 题意：国王继承次序按嫡长子次序，实现ThroneInheritance(string kingName)初始化,void birth(string parentName, string childName) 出生，void death(string name)人死亡，string[] getInheritanceOrder() 返回 除去 死亡人员的当前继承顺序列表。\n思路：类似树形结构，国王先继承，之后是国王的长子，之后是长子的长子， 如果不存在则为国王的次子以此类推， 所以可以用defaultdict()存储每个的儿子情况，然后查询时，先将自己入结果列表，然后是第一个儿子\u0026hellip;；并记录每个人的存活情况，排除掉已经死掉的人。\nclass ThroneInheritance: def __init__(self, kingName: str): self.son = defaultdict(list) self.die = set() self.king = kingName def birth(self, parentName: str, childName: str) -\u0026gt; None: self.son[parentName].append(childName) def death(self, name: str) -\u0026gt; None: self.die.add(name) def getInheritanceOrder(self) -\u0026gt; List[str]: ret = [] def dfs(root): if root not in self.die: ret.append(root) for child in self.son[root]: dfs(child) dfs(self.king) return ret 1483. 树节点的第 K 个祖先 题意：给定n个点(0~n-1)每个点的父亲节点，快速查询每个节点的第k个祖宗节点。\n思路：LCA倍增原理，$ancestor[j][i] = ancestor[ ancestor[j][i-1] ][i-1]$ 节点j的第$2^i$个祖宗节点为节点第$2^{i-1}$个祖宗的第$2^{i-1}$个祖宗，即$2^{i-1}*2$个祖宗节点， 所以先预处理好每个节点的各个二进制位上的祖宗节点是谁，之后分解二进制位据可以得知任意第k个祖宗节点是谁。\nclass TreeAncestor: def __init__(self, n: int, parent: List[int]): self.level = 16 self.ancestor = [[-1]*self.level for _ in range(n)] for i in range(1, n): self.ancestor[i][0] = parent[i] for i in range(1, self.level): for j in range(1, n): if self.ancestor[j][i-1]!=-1: self.ancestor[j][i] = self.ancestor[ self.ancestor[j][i-1] ][i-1] def getKthAncestor(self, node: int, k: int) -\u0026gt; int: while k: t = k\u0026amp;-k k -= t t = t.bit_length()-1 node = self.ancestor[node][t] if node==-1: return -1 return node 面试题 08.12. 八皇后 题目大意：\n这道题目是经典的八皇后问题的扩展，需要设计一个算法来打印 N 皇后在 N × N 棋盘上的各种摆法，其中每个皇后都不在同一行、同一列，也不在任何对角线上。\n实现思路：\n回溯算法：\n使用回溯算法来尝试所有可能的皇后摆放方式。 从第一行开始，依次尝试每一列放置皇后，然后继续递归地尝试下一行的放置，直到所有行都放置完毕。 在递归过程中，通过检查每个位置的列、主对角线和副对角线是否已经存在皇后来确定是否可以放置皇后。 生成棋盘：\n当确定了一种合法的皇后摆放方式时，将其转换为棋盘的形式，并将其添加到结果列表中。 对于每行中皇后的位置，用 \u0026lsquo;Q\u0026rsquo; 表示，其他位置用 \u0026lsquo;.\u0026rsquo; 表示。 辅助函数：\nsolve: 递归函数，尝试在每行放置皇后。 generate: 将合法的皇后摆放方式转换为棋盘形式并添加到结果列表中。 剪枝优化：\n使用位运算来表示列、主对角线和副对角线的占用情况，可以快速判断某个位置是否可以放置皇后，从而提高效率。 在每次递归时，利用位运算进行剪枝，排除不可能的位置。 class Solution: def solveNQueens(self, n: int) -\u0026gt; List[List[str]]: def generate(): board = [] for r in range(n): c = pos[r] row[c] = \u0026#39;Q\u0026#39; board.append(\u0026#34;\u0026#34;.join(row)) row[c] = \u0026#39;.\u0026#39; ret.append(board) def solve(row, column, diag1, diag2): if row==n: generate() else: avail = ( (1\u0026lt;\u0026lt;n)-1) \u0026amp; ( ~(column|diag1|diag2) ) while avail: colPos = avail\u0026amp;(-avail) avail -= colPos colNum = bin(colPos-1).count(\u0026#34;1\u0026#34;) pos[row]=colNum solve(row+1, column|colPos, (diag1|colPos)\u0026lt;\u0026lt;1, (diag2|colPos)\u0026gt;\u0026gt;1) pos = [0]*n ret = [] row = [\u0026#39;.\u0026#39;]*n solve(0, 0, 0, 0) return ret 1702. 修改后的最大二进制字符串 题意：给定一个二进制字符串00-\u0026gt;10, 10-\u0026gt;01问任意次操作后能达到的最大二进制字符串。\n思路：构造，根据条件推过程，10-\u0026gt;01可以看作后面的0浮到前面，所有的0聚到一起可以变成10串，所以最后至多只有一个0。根据构造来做，统计第一个0的位置和0的个数，最后构造出最后的0的位置；双指针来做：遇到0时找到后面第一个0的位置，将其浮到旁边，并换成10。\n构造：\nclass Solution: def maximumBinaryString(self, binary: str) -\u0026gt; str: cnt = binary.count(\u0026#39;0\u0026#39;) if cnt\u0026lt;=1: return binary n = len(binary) ans = [\u0026#39;1\u0026#39;]*n index = binary.index(\u0026#39;0\u0026#39;) ans[index+cnt-1]=\u0026#39;0\u0026#39; return \u0026#39;\u0026#39;.join(ans) 双指针：\nclass Solution: def maximumBinaryString(self, binary: str) -\u0026gt; str: n = len(binary) s = list(binary) j = 0 for i in range(n): if s[i]==\u0026#39;0\u0026#39;: while j\u0026lt;=i or (j\u0026lt;n and s[j]==\u0026#39;1\u0026#39;): j+=1 if j\u0026lt;n: s[i], s[j], s[i+1] = \u0026#39;1\u0026#39;, \u0026#39;1\u0026#39;, \u0026#39;0\u0026#39; return \u0026#39;\u0026#39;.join(s) 24. 两两交换链表中的节点 题意：给定一个链表，分别两个一组交换相对位置。\n思路：链表交换next指针操作，prev-\u0026gt;A-\u0026gt;B-\u0026gt;C变成prev-\u0026gt;B-\u0026gt;A-\u0026gt;C，一共要变三条边。需要记录前面的点，后面的点。\nclass Solution: def swapPairs(self, head: Optional[ListNode]) -\u0026gt; Optional[ListNode]: dummy = head prev = None while head and head.next: tmp = head.next.next #A-\u0026gt;B 变成 B-\u0026gt;A nxt = head.next #nxt是B, head是A nxt.next = head head.next = tmp if prev: prev.next = nxt prev = nxt.next #是头节点(即没有前面的点)的时候不需要这一步 if dummy==head: dummy = nxt prev = nxt.next head = tmp return dummy 25. K 个一组翻转链表 题意：每隔k个数字翻转链表。\n思路：链表交换指针操作。\n# Definition for singly-linked list. # class ListNode: # def __init__(self, val=0, next=None): # self.val = val # self.next = next class Solution: def reverseKGroup(self, head: Optional[ListNode], k: int) -\u0026gt; Optional[ListNode]: def reverse(head, tail): # A-\u0026gt;B-\u0026gt;C 变成 C-\u0026gt;B-\u0026gt;A cur = tail.next dummy = head while cur != tail: nxt = dummy.next dummy.next = cur cur = dummy dummy = nxt return tail, head # 原来的tail和head位置没变，但中间点的指向关系变了 hair = ListNode(-1) # 伪头节点 hair.next = head pre = hair while head: tail = pre for i in range(k): # 走过k个点 tail = tail.next if not tail: return hair.next head, tail = reverse(head, tail) pre.next = head # pre-\u0026gt;C pre = tail # pre变成尾节点 head = tail.next # 头节点变成当前尾节点的下个一个节点 return hair.next 1766. 互质树 题意：给定一棵树0~n-1共n个节点， 每个节点有一个值，返回每个节点的 最近的 与自己互质的(gcd(a,b)=1) 祖宗节点的编号。值的范围为[1,50] 思路：DFS， 遍历一遍树，维护一个祖宗节点的列表，判断当前节点与祖宗节点的互质关系。但朴素的将所有的祖宗节点都加入列表中，到深层的子节点时会遍历整个列表，会超时。由于值的范围最大为50，所以可以先预处理50范围以内的互质关系，对于每个节点，只需要判断祖宗节点里面有没有这些互质的数即可，但是需要的是最近的祖宗节点，所以还要添加一个深度信息，这样才能保证在相同值的祖宗节点中选择离自己最近的祖宗节点。 class Solution: def getCoprimes(self, nums: List[int], edges: List[List[int]]) -\u0026gt; List[int]: n = len(nums) g = [[]*n for _ in range(n)] ret = [-1]*n store = [[] for _ in range(51)] mem = [(-1, -1)]*(51) for i in range(1, 51): for j in range(1, 51): if gcd(i, j)==1: store[i].append(j) for u, v in edges: g[u].append(v) g[v].append(u) def dfs(u, last, level): ret[u] = max(mem[i] for i in store[nums[u]])[1] tmp = mem[nums[u]] mem[nums[u]] = (level, u) for son in g[u]: if son==last: continue dfs(son, u, level+1) mem[nums[u]] = tmp dfs(0, -1, 0) return ret 924. 尽量减少恶意软件的传播 题目大意：给定一个由n个节点组成的网络，用n x n个邻接矩阵图graph表示。节点之间存在直接连接当且仅当graph[i][j] = 1。一些节点initial最初被恶意软件感染，如果两个节点直接连接且至少一个节点被感染，则两个节点都将被感染。移除一个节点后，返回使得整个网络中感染恶意软件的最终节点数最小的节点，若有多个节点满足条件，则返回索引最小的节点。\n实现思路：首先使用并查集将节点分组，然后计算每个分组的大小和其中感染节点的数量。遍历initial列表，找到使得其所在分组中只有一个感染节点且分组大小最大的节点，返回其索引。\nclass Solution: def minMalwareSpread(self, g: List[List[int]], initial: List[int]) -\u0026gt; int: n, m = len(g), len(initial) f = [i for i in range(n)] size = [1 for _ in range(n)] # 连通块内的点数 num = [0 for _ in range(n)] # 连通块内的感染点数 for x in initial: num[x]=1 def find(x): if f[x] != x: f[x] = find(f[x]) return f[x] for i in range(n): for j in range(i+1, n): if g[i][j]: fi, fj = find(i), find(j) if fi!=fj: f[fi] = fj num[fj] += num[fi] size[fj] += size[fi] ma = -1 initial.sort() idx = initial[0] for x in initial: if num[find(x)]==1 and size[find(x)]\u0026gt;ma: ma = size[find(x)] idx = x return idx 928. 尽量减少恶意软件的传播 II 题目大意：给定一个由n个节点组成的网络，用n x n个邻接矩阵graph表示。节点之间存在直接连接当且仅当graph[i][j] = 1。一些节点initial最初被恶意软件感染，如果两个节点直接连接且至少一个节点被感染，则两个节点都将被感染。移除一个节点及其连接后，返回移除后能使整个网络中感染恶意软件的最终节点数最小的节点，若有多个节点满足条件，则返回索引最小的节点。\n实现思路：首先通过并查集将不在initial中的节点进行合并，然后计算每个initial节点的直接感染节点数。最后选择使得感染节点数最小且索引最小的initial节点返回。\nclass Solution: def minMalwareSpread(self, g: List[List[int]], initial: List[int]) -\u0026gt; int: n = len(g) def find(x): if f[x] != x: f[x] = find(f[x]) return f[x] f = [i for i in range(n)] source = [[] for _ in range(n)] cnt = [0]*n init = [0]*n for i in initial: init[i] = 1 for i in range(n): if init[i]: continue for j in range(n): if init[j] or not g[i][j]: continue fi, fj = find(i), find(j) if fi!=fj: f[fi] = fj for x in initial: infected = [0]*n for j in range(n): if not g[x][j] or init[j] or infected[find(j)]: continue infected[find(j)] = 1 for j in range(n): if infected[j]: source[j].append(x) for i in range(n): if len(source[i])==1: root = source[i][0] for j in range(n): if find(i)==find(j): # 是一个连通块 cnt[root]+=1 idx = initial[0] for x in initial: if cnt[x]\u0026gt;cnt[idx] or (cnt[x]==cnt[idx] and x\u0026lt;idx): idx = x return idx 2007. 从双倍数组中还原原数组 题目大意：给定一个数组 changed，通过以下方式构造原始数组 original：将 changed 中的每个元素乘以2，并将结果随机打乱，然后返回原始数组 original。如果无法构造原始数组，则返回空数组。\n实现思路：首先判断数组 changed 的长度是否为偶数，如果不是偶数，则无法构造原始数组，直接返回空数组。接着使用一个字典记录数组 changed 中各个元素的出现次数。然后遍历数组 changed，对于每个元素 i，判断是否存在 i 的两倍的元素，若存在，则将 i 和其两倍的元素都从字典中减去一个，并将 i 加入结果数组中。最后判断结果数组的长度是否达到了原始数组的一半，如果达到了则返回结果数组的前一半，否则返回空数组。\nclass Solution: def findOriginalArray(self, changed: List[int]) -\u0026gt; List[int]: n = len(changed) if n\u0026amp;1: return [] d = defaultdict(int) res = [] cnt = 0 changed.sort() for i in changed: d[i]+=1 for i in changed: if not d[i]: continue x = i*2 if i==x: # 0*2 = 0 d[x]-=1 if d[x]: d[x]-=1 # 匹配成功 cnt+=1 res.append(i) else: if d[x]: d[x]-=1 # 匹配成功 d[i]-=1 cnt+=1 res.append(i) if cnt\u0026gt;=n//2: return res[:n//2] return [] 实现思路：首先使用 Counter 统计数组 changed 中各个元素的出现次数。然后将字典中键为 0 的元素（如果存在）弹出，因为原始数组中不可能有 0。接着判断字典中键为 0 的元素出现次数是否为偶数，如果不是偶数则无法构造原始数组，直接返回空数组。然后初始化一个由 0 组成的数组 ans，长度为 cnt_0 的一半。接下来遍历字典中的键值对，对于每个键 x，判断是否存在其一半的键值对，并将 x 加入结果数组 ans 中相应次数。最后返回结果数组 ans。\nclass Solution: def findOriginalArray(self, changed: List[int]) -\u0026gt; List[int]: cnt = Counter(changed) cnt_0 = cnt.pop(0, 0) if cnt_0\u0026amp;1: return [] ans = [0]*(cnt_0//2) for x in cnt: if x%2==0 and cnt[x//2]: continue while x in cnt: if cnt[2*x]\u0026lt;cnt[x]: return [] ans.extend([x]*(cnt[x])) if cnt[2*x]\u0026gt;cnt[x]: cnt[2*x]-=cnt[x] x*=2 else: x*=4 return ans 1883. 准时抵达会议现场的最小跳过休息次数 题目大意：题目给出了一组道路的长度和行驶速度，以及剩余可用时间。要求计算在给定的时间内，最少跳过休息次数，以准时抵达会议现场。\n实现思路：动态规划。使用二维数组dp[i][j]表示到达第i条路，跳过j次休息的最小距离。初始化dp数组，然后遍历每一条路，在遍历的过程中更新dp数组。最后检查是否有方案可以在规定时间内到达会议现场，如果有，返回跳过休息的最小次数，否则返回-1。\nclass Solution: def minSkips(self, dist: List[int], speed: int, hoursBefore: int) -\u0026gt; int: n = len(dist) if sum(dist) \u0026gt; hoursBefore * speed: return -1 dp = [[inf] * (n + 1) for _ in range(n + 1)] dp[0][0] = 0 for i in range(1, n): for j in range(i+1): # 到第i条路，跳过次数为j的最小距离 # 不跳过第 i 条路 dp[i][j] = min(dp[i][j], (dp[i-1][j] + dist[i-1] + speed -1)//speed*speed) # 跳过第 i 条路 if j: dp[i][j] = min(dp[i][j], dp[i - 1][j -1] + dist[i-1]) for j in range(n): # 可以跳0~n-1次(最后一条边不用跳) if dp[n-1][j]+dist[-1] \u0026lt;= hoursBefore * speed: return j return -1 39. 组合总和 题目大意 ：给定一个无重复元素的整数数组 candidates 和一个目标整数 target，找出 candidates 中可以使数字和为目标数 target 的所有不同组合，并以列表形式返回。可以无限制重复选择 candidates 中的同一个数字。\n实现思路 ：\n使用深度优先搜索（DFS）进行组合搜索。 定义一个辅助函数 dfs(i, s)，其中 i 表示当前遍历到的 candidates 数组的索引，s 表示当前已经选取的数字的和。 在 dfs 函数中，如果 s 大于等于 target 或者已经遍历到数组末尾，则进行以下判断： 如果 s 等于 target，则将当前的组合 ls 加入结果列表 ret 中。 如果 s 大于 target 或者已经遍历到数组末尾，则直接返回。 在 dfs 函数中，分别尝试两种情况： 不选择当前数字，继续向后搜索：dfs(i+1, s)。 选择当前数字，继续向后搜索：将当前数字加入组合 ls 中，更新 s，并递归调用 dfs(i, s+c[i])。 在递归调用之后，需要将当前选择的数字从组合 ls 中弹出，保证不影响后续搜索。 最终返回结果列表 ret。 class Solution: def combinationSum(self, c: List[int], t: int) -\u0026gt; List[List[int]]: n = len(c) ret, ls = [], [] def dfs(i, s): if s\u0026gt;=t or i==n: if s==t: ret.append(ls[:]) return dfs(i+1, s) ls.append(c[i]) dfs(i, s+c[i]) ls.pop() dfs(0, 0) return ret 216. 组合总和 III 题目大意：找出所有相加之和为n的k个数的组合，要求使用数字1到9，每个数字最多使用一次，返回所有可能的有效组合的列表。列表不能包含相同的组合两次，组合可以以任何顺序返回。\n实现思路：使用深度优先搜索（DFS）的方法，从1到9的数字中进行遍历，每次选择一个数字或不选择，直到满足条件为止。递归过程中，维护一个列表ls，记录当前已选数字的集合，如果当前集合的数字个数等于k且它们的和等于n，则将其加入结果列表ret中。\nclass Solution: def combinationSum3(self, k: int, n: int) -\u0026gt; List[List[int]]: ret, ls = [], [] def dfs(i, s, cnt): if i==10 or s\u0026gt;=n or cnt\u0026gt;=k: if s==n and cnt==k: ret.append(ls[:]) return dfs(i+1, s, cnt) ls.append(i) dfs(i+1, s+i, cnt+1) ls.pop() dfs(1, 0, 0) return ret 377. 组合总和 Ⅳ 题目大意：给定一个由不同整数组成的数组nums和一个目标整数target，要求从nums中找出总和为target的元素组合的个数。\n实现思路：这是一个典型的动态规划问题。使用递归+记忆化搜索（Memoization）的方法来解决。定义dfs函数，参数为当前的和s，函数返回当前和s能够组成的组合数目。递归的终止条件是当前和s大于等于目标target，则返回1（如果s等于target，则表示找到一种组合）。否则，遍历数组nums中的每个数，对每个数进行递归调用dfs(s+i)，累加得到的组合数目。使用cache装饰器对dfs函数进行记忆化搜索，避免重复计算。最终返回dfs(0)，即从初始和为0开始的组合数目。\nclass Solution: def combinationSum4(self, nums: List[int], target: int) -\u0026gt; int: @cache def dfs(s): if s\u0026gt;=target: if s==target: return 1 return 0 cnt = 0 for i in nums: cnt += dfs(s+i) return cnt return dfs(0) ","permalink":"https://kennems.github.io/posts/tech/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98202404/","summary":"每日一题（202404） 2009. 使数组连续的最少操作数 题意：给定一个可能有重复元素的数组，可以修改数组中值为任意其他值，问使数组连续的最小操作数。","title":"LeetCode每日一题（202404）"},{"content":"剑指Offer 数据流中的中位数 用两个堆模拟， 左边大顶堆，右边小顶堆，则两个堆顶是最中间的数字。\n添加数字时：\n如果输入的是第奇数个（比如第一个，则N初始化为0，插入后N为1，代表一共有一个数字），则先插入大顶堆，然后把堆顶插入小顶堆。保证小顶堆的任意一个值都比大顶堆大。 同样，如果输入的是第偶数个（第二个），则先插入小顶堆，然后将小顶堆最小值插入大顶堆。同样是保证小顶堆的任意一个值都比大顶堆大。 至于先插入哪一个堆是没有关系的，只要保证交替插入不同的堆即可，并且要确保边界问题（比如在奇数个元素的的中位数， 只有一个数据时应返回先插入的堆顶值， 否则堆为空会报错）。\nimport heapq as hp class Solution: heapl = [] # 大根堆 heapr = [] # 小根堆 N = 0 def insert(self, num): \u0026#34;\u0026#34;\u0026#34; :type num: int :rtype: void \u0026#34;\u0026#34;\u0026#34; if self.N % 2 ==0: hp.heappush(self.heapl, -num) hp.heappush(self.heapr, -hp.heappop(self.heapl)) else: hp.heappush(self.heapr, num) hp.heappush(self.heapl, -hp.heappop(self.heapr)) self.N += 1 def getMedian(self): \u0026#34;\u0026#34;\u0026#34; :rtype: float \u0026#34;\u0026#34;\u0026#34; if self.N %2==0: return (-self.heapl[0]+self.heapr[0])/2.0 else: return self.heapr[0]*1.0 字符流中第一个只出现一次的字符 import collections class Solution: d = collections.defaultdict(int) q = collections.deque() def firstAppearingOnce(self): \u0026#34;\u0026#34;\u0026#34; :rtype: str \u0026#34;\u0026#34;\u0026#34; return \u0026#39;#\u0026#39; if not self.q else self.q[0] def insert(self, char): \u0026#34;\u0026#34;\u0026#34; :type char: str :rtype: void \u0026#34;\u0026#34;\u0026#34; self.d[char]+=1 self.q.append(char) while self.q and self.d[self.q[0]]\u0026gt;1: self.q.popleft() 最长不含重复字符的子字符串 class Solution: def longestSubstringWithoutDuplication(self, s): \u0026#34;\u0026#34;\u0026#34; :type s: str :rtype: int \u0026#34;\u0026#34;\u0026#34; char_index = {} # 存储字符的最近出现位置 ans = 0 start = 0 for i, char in enumerate(s): if char in char_index and char_index[char] \u0026gt;= start: start = char_index[char] + 1 char_index[char] = i ans = max(ans, i - start + 1) return ans 骰子的点数 线性DP ：\n注意点： 算法先从最简单的方法想起，DP先用二维想，实现完之后再优化。\n因为每次计算状态时会修改$ j-1, j-2, j-3, j-4, j-5, j-6$, 而$j+1$会计算 $j+1-1=j, j+1-2=j-1, \u0026hellip; j-1$会计算$j-1-1=j-2,j-1-2=j-3,\u0026hellip;$没有单调性，所以不能优化第一维空间\nclass Solution(object): def numberOfDice(self, n): \u0026#34;\u0026#34;\u0026#34; :type n: int :rtype: List[int] \u0026#34;\u0026#34;\u0026#34; N = 6*n+10 f = [[0]*N for _ in range(N)] f[0][0]=1 for i in range(1,n+1): for j in range(1,n*6+1): for k in range(1,min(j, 6)+1): f[i][j] += f[i-1][j-k] return f[n][1*n:6*n+1] 数组中数值和下标相等的元素 class Solution(object): def getNumberSameAsIndex(self, nums): \u0026#34;\u0026#34;\u0026#34; :type nums: List[int] :rtype: int \u0026#34;\u0026#34;\u0026#34; l, r = 0, len(nums)-1 while l\u0026lt;r: mid = l+r+1\u0026gt;\u0026gt;1 if nums[mid]\u0026gt;mid: r=mid-1 elif nums[mid]\u0026lt;mid: l=mid else: return mid break return l if nums[l]==l else -1 复杂链表的复刻 class Solution(object): def copyRandomList(self, head): hash = {} hash[None] = None cloneHead = ListNode(-1) cur = cloneHead while head: if head not in hash: hash[head] = ListNode(head.val) if head.random not in hash: hash[head.random] = ListNode(head.random.val) cur.next = hash[head] cur = cur.next cur.random = hash[head.random] head = head.next return cloneHead.next 矩阵中的路径 class Solution(object): def hasPath(self, matrix, string): if not matrix or not(matrix[0]): return False dx = [1, 0, -1, 0] dy = [0, 1, 0, -1] def dfs(x, y, idx): if matrix[x][y]!=string[idx]: return False if idx==len(string)-1: return True for h,v in zip(dx, dy): xx, yy = x+h, y+v if xx\u0026lt;0 or xx\u0026gt;=len(matrix) or yy\u0026lt;0 or yy\u0026gt;=len(matrix[0]): continue memo = matrix[x][y] matrix[x][y] = \u0026#39;#\u0026#39; if dfs(xx,yy,idx+1): return True matrix[x][y] = memo return False for i in range(len(matrix)): for j in range(len(matrix[0])): if matrix[i][j]==string[0]: if dfs(i,j,0): return True return False 正则表达式匹配 DP:\nclass Solution(object): def isMatch(self, s, p): \u0026#34;\u0026#34;\u0026#34; :type s: str :type p: str :rtype: bool \u0026#34;\u0026#34;\u0026#34; n, m = len(s), len(p) s, p = \u0026#39; \u0026#39;+s, \u0026#39; \u0026#39;+p f = [[False]*(m+1) for _ in range(n+1)] f[0][0] = True for i in range(2,m+1): if p[i]==\u0026#39;*\u0026#39;: f[0][i] = f[0][i-2] for i in range(1,n+1): for j in range(1,m+1): if s[i]==p[j] or p[j]==\u0026#39;.\u0026#39;: f[i][j] = f[i-1][j-1] elif p[j]==\u0026#39;*\u0026#39;: if s[i]==p[j-1] or p[j-1]==\u0026#39;.\u0026#39;: f[i][j] = f[i-1][j] f[i][j] |= f[i][j-2] return f[n][m] LCR 168. 丑数 题目大意：给定一个整数 $n$，找出并返回第 $n$ 个丑数。丑数是只包含质因数$ 2$、$3$ 和/或 5 的正整数，$1$ 是丑数。\n实现思路：\n初始化一个数组 $f$，用于存储前$ n$ 个丑数，初始化 $f[1] = 1$。 初始化三个指针 $i2$、$i3$、$i5$，分别表示下一个丑数是通过乘以$2、3、5$得到的。 初始化三个变量 $n2、n3、n5$，分别表示通过指针 $i2、i3、i5$ 得到的下一个丑数的候选值。 从第$ 2 $个丑数开始遍历到第 $n $个丑数： 计算下一个丑数的候选值：$n2=f[i2]*2$，$n3=f[i3]*3$，$n5=f[i5]*5$。 将下一个丑数更新为三个候选值中的最小值：$f[i]=min(n2,n3,n5)$。 如果最小值等于 $n2$，则指针 $i2$ 往后移动一位；如果最小值等于 $n3$，则指针 $i3$ 往后移动一位；如果最小值等于 $n5$，则指针 i5 往后移动一位。 遍历结束后，返回第 $n$ 个丑数$ f[n]$。 class Solution: def nthUglyNumber(self, n: int) -\u0026gt; int: if n\u0026lt;=6: return n f=[0 for _ in range(n+1)] f[1]=1 i2,i3,i5,n2,n3,n5=1,1,1,0,0,0 for i in range(2,n+1): n2,n3,n5=f[i2]*2,f[i3]*3,f[i5]*5 f[i]=min(n2,n3,n5) if f[i]==n2: i2+=1 if f[i]==n3: i3+=1 if f[i]==n5: i5+=1 return f[n] ","permalink":"https://kennems.github.io/posts/tech/%E5%89%91%E6%8C%87offer/","summary":"剑指Offer 数据流中的中位数 用两个堆模拟， 左边大顶堆，右边小顶堆，则两个堆顶是最中间的数字。 添加数字时： 如果输入的是第奇数个（比如第一个，","title":"剑指Offer"},{"content":"Java20天速成——进阶课程(2) 正则表达式 符号 含义 举例 [] 匹配方括号内的任一字符 [abc] ^ 匹配除指定字符外的任意字符 [^abc] \u0026amp;\u0026amp; 匹配两个字符集的交集，需作为整体出现 [a-z\u0026amp;\u0026amp;m-p] . 匹配除换行符外的任意字符 a.b （匹配 \u0026ldquo;a\u0026rdquo; 后接任意字符，再接 \u0026ldquo;b\u0026rdquo;） \\ 转义字符，用于匹配特殊字符 \\\\d \\\\d 匹配数字 0-9 \\\\d+ \\\\D 匹配非数字字符 \\\\D+ \\\\s 匹配空白字符 \\s匹配空格、制表符、换行符等等 \\\\S 匹配非空白字符 \\\\S+ （匹配非空白字符序列） \\\\w 匹配单词字符 [a-zA-Z_0-9] \\\\W 匹配非单词字符 [^\\w] * 匹配前面的元素零次或多次，即可有可无 a*b （匹配 \u0026ldquo;b\u0026rdquo;、\u0026ldquo;ab\u0026rdquo;、\u0026ldquo;aab\u0026rdquo;、等等） ? 匹配前面的元素零次或一次，即可有可无 colou?r （匹配 \u0026ldquo;color\u0026rdquo; 或 \u0026ldquo;colour\u0026rdquo;） () 分组，将其中的字符视为一个单元 a(bc)+ \\f 匹配换页符 \\f | `|` | 或，用于匹配多个模式中的任意一个 | `ab\\|AB` | public static void method1() { // 给定的字符串包含了电话号码和邮箱地址的信息 String data = \u0026#34; 来黑马程序员学习Java，\\n\u0026#34; + \u0026#34; 电话：1866668888，18699997777\\n\u0026#34; + \u0026#34; 或者联系邮箱：boniu@itcast.cn，\\n\u0026#34; + \u0026#34; 座机电话：01036517895，010-98951256\\n\u0026#34; + \u0026#34; 邮箱：bozai@itcast.cn，\\n\u0026#34; + \u0026#34; 邮箱：dlei0009@163.com，\\n\u0026#34; + \u0026#34; 热线电话：400-618-9090 ，400-618-4000，4006184000，4006189090\u0026#34;; // 定义正则表达式来匹配电话号码和邮箱地址 String regex = \u0026#34;(1[3-9]\\\\d{9})|\u0026#34; + \u0026#34;(0\\\\d{2,9}-?\\\\d{7,18})|\u0026#34; // 匹配固定电话号码，包括区号和分机号 + \u0026#34;(\\\\w{2,}@\\\\w{2,20}(\\\\.\\\\w{2,10}){1,2})|\u0026#34; // 匹配邮箱地址 + \u0026#34;(400-?\\\\d{3,7}-?\\\\d{3,7})\u0026#34;; // 匹配400电话号码，包括可能的分机号 // 编译正则表达式 Pattern pattern = Pattern.compile(regex); // 创建匹配器对象 Matcher matcher = pattern.matcher(data); // 循环查找匹配项并打印 while(matcher.find()){ String res = matcher.group(); // 获取匹配到的字符串 System.out.println(res); } } String s1 = \u0026#34;古力娜扎ai8888迪丽热巴999aa5566马尔扎哈fbbfsfs42425卡尔扎巴\u0026#34;; System.out.println(s1.replaceAll(\u0026#34;\\\\w+\u0026#34;, \u0026#34;-\u0026#34;)); String s2 = \u0026#34;我我我喜欢编编编编编编编编编编编编程程程\u0026#34;; System.out.println(s2.replaceAll(\u0026#34;(.)\\\\1+\u0026#34;, \u0026#34;$1\u0026#34;)); String s3 = \u0026#34;古力娜扎ai8888迪丽热巴999aa5566马尔扎哈fbbfsfs42425卡尔扎巴\u0026#34;; String[] names = s3.split(\u0026#34;\\\\w+\u0026#34;); System.out.println(Arrays.toString(names)); 异常 Error： 代表的系统级别错误（属于严重问题）， 也就是说系统一旦出现问题，sun公司会把这些问题封装成Error对象给出了，即Error是Sun公司自己用的，而不是给程序员用的\nException：异常，它代表的才是程序可能出现的错误，所以通常会用Exception以及它的子类来封装程序出现的错误\n运行时异常：RuntimeException及其子类，编译阶段不会出现错误提醒，运行时出现的异常（数组索引越界异常） 编译时异常：编译阶段就会出现的错误提醒。（日期解析异常） 自定义异常 运行时异常 package com.showguan.Exception; // 自定义运行时异常类，用于表示年龄不合法的情况 public class AgeIllegalRuntimeException extends RuntimeException { // 默认构造函数 public AgeIllegalRuntimeException() { } // 带有消息参数的构造函数，用于传递异常信息 public AgeIllegalRuntimeException(String message) { super(message); } } public class Main { // 保存年龄的方法，如果年龄不合法则抛出自定义的运行时异常 public static void saveAge(int age) { if (age \u0026gt; 0 \u0026amp;\u0026amp; age \u0026lt; 150) { System.out.println(\u0026#34;年龄合法\u0026#34;); } else { throw new AgeIllegalRuntimeException(\u0026#34;/age is illegal, your age is \u0026#34; + age); } } public static void main(String[] args) { try { // 调用保存年龄的方法，传入一个不合法的年龄值 saveAge(-1); System.out.println(\u0026#34;底层执行成功了\u0026#34;); } catch (Exception e) { // 捕获自定义的异常并打印异常信息 e.printStackTrace(); System.out.println(\u0026#34;底层出现了异常\u0026#34;); } } } 编译时异常 package com.showguan.Exception; // 自定义异常类，继承自Exception类，用于表示年龄不合法的情况 public class AgeIllegalException extends Exception { // 默认构造函数 public AgeIllegalException() { } // 带有消息参数的构造函数，用于传递异常信息 public AgeIllegalException(String message) { super(message); } } public class Main { // 保存年龄的方法，如果年龄不合法则抛出自定义的受检查异常 public static void saveAge2(int age) throws AgeIllegalException { if (age \u0026gt; 0 \u0026amp;\u0026amp; age \u0026lt; 150) { System.out.println(\u0026#34;年龄合法\u0026#34;); } else { throw new AgeIllegalException(\u0026#34;/age is illegal, your age is \u0026#34; + age); } } public static void main(String[] args) { try { // 调用保存年龄的方法，传入一个合法的年龄值 saveAge2(1); System.out.println(\u0026#34;底层执行成功了\u0026#34;); } catch (Exception e) { // 捕获自定义的异常并打印异常信息 e.printStackTrace(); System.out.println(\u0026#34;底层出现了异常\u0026#34;); } } } public class Demo2 { public static void main(String[] args) { try { // 调用test1方法，该方法声明了可能抛出ParseException和FileNotFoundException异常 test1(); } catch (ParseException e) { // 捕获ParseException异常，并输出错误提示信息 System.out.println(\u0026#34;日期格式错误，请检查日期格式\u0026#34;); // 抛出一个新的RuntimeException异常，将原始异常作为其cause throw new RuntimeException(e); } catch (FileNotFoundException e) { // 捕获FileNotFoundException异常，并输出错误提示信息 System.out.println(\u0026#34;指定文件夹内没有该文件，请检查文件路径\u0026#34;); // 抛出一个新的RuntimeException异常，将原始异常作为其cause throw new RuntimeException(e); } } // test1方法声明了可能抛出ParseException和FileNotFoundException异常 public static void test1() throws ParseException, FileNotFoundException { // 创建SimpleDateFormat对象，用于解析日期字符串 SimpleDateFormat sdf = new SimpleDateFormat(\u0026#34;yyyy-MM-dd HH:mm:ss\u0026#34;); // 解析日期字符串，如果日期格式不正确会抛出ParseException异常 Date d = sdf.parse(\u0026#34;2077-09-23 10:34:22\u0026#34;); System.out.println(d); // 调用test2方法，该方法声明了可能抛出FileNotFoundException异常 test2(); } // test2方法声明了可能抛出FileNotFoundException异常 public static void test2() throws FileNotFoundException { // 创建FileInputStream对象，如果指定文件不存在会抛出FileNotFoundException异常 InputStream is = new FileInputStream(\u0026#34;D:/Java.txt\u0026#34;); } } package com.showguan.Exception; import java.io.FileInputStream; import java.io.FileNotFoundException; import java.io.InputStream; import java.text.ParseException; import java.text.SimpleDateFormat; import java.util.Date; public class Demo3 { public static void main(String[] args) { try { // 调用test1方法，该方法声明了可能抛出Exception异常 test1(); } catch (Exception e) { // 捕获Exception异常，并输出错误提示信息 System.out.println(\u0026#34;操作有误\u0026#34;); // 抛出一个新的RuntimeException异常，将原始异常作为其cause throw new RuntimeException(e); } } // test1方法声明了可能抛出Exception异常 public static void test1() throws Exception { // 创建SimpleDateFormat对象，用于解析日期字符串 SimpleDateFormat sdf = new SimpleDateFormat(\u0026#34;yyyy-MM-dd HH:mm:ss\u0026#34;); // 解析日期字符串，如果日期格式不正确会抛出ParseException异常 Date d = sdf.parse(\u0026#34;2077-09-23 10:34:22\u0026#34;); System.out.println(d); // 调用test2方法，该方法声明了可能抛出Exception异常 test2(); } // test2方法声明了可能抛出Exception异常 public static void test2() throws Exception { // 创建FileInputStream对象，如果指定文件不存在会抛出FileNotFoundException异常 InputStream is = new FileInputStream(\u0026#34;D:/Java.txt\u0026#34;); } } 集合 Collection集合特点：\nList系列集合：添加的元素是有序、可重复、有索引的。\nArrayList, LinkedList：有序、可重复、有索引 Set系列集合：添加的元素是无序、不重复、无索引\nHashSet: 无序、不重复、无索引 LinkedHashSet: 有序、不重复、无索引 TreeSet : 按照大小默认升序排列、不重复、无索引 Collection import java.util.ArrayList; import java.util.Arrays; import java.util.Collection; public class Main { public static void main(String[] args) { // 创建一个ArrayList对象，并向其中添加元素 Collection\u0026lt;String\u0026gt; c = new ArrayList\u0026lt;\u0026gt;(); c.add(\u0026#34;java1\u0026#34;); c.add(\u0026#34;java2\u0026#34;); c.add(\u0026#34;java3\u0026#34;); c.add(\u0026#34;java1\u0026#34;); // 可以添加重复元素 System.out.println(c); // 输出集合中的所有元素 // 清空集合中的所有元素 // c.clear(); System.out.println(c); // 判断集合是否为空 System.out.println(c.isEmpty()); // 获取集合中元素的个数 System.out.println(c.size()); // 判断集合是否包含指定元素 System.out.println(c.contains(\u0026#34;java1\u0026#34;)); // 移除集合中的指定元素 c.remove(\u0026#34;java1\u0026#34;); System.out.println(c); // 将集合转换为数组 Object[] arr = c.toArray(); System.out.println(Arrays.toString(arr)); // 将集合转换为指定类型的数组 String[] arr2 = c.toArray(new String[c.size()]); System.out.println(Arrays.toString(arr2)); // 创建另一个集合，并将其元素全部添加到当前集合中 Collection\u0026lt;String\u0026gt; c2 = new ArrayList\u0026lt;\u0026gt;(); c2.add(\u0026#34;Java8\u0026#34;); c2.add(\u0026#34;java9\u0026#34;); c.addAll(c2); System.out.println(c); } } 迭代器 import java.util.ArrayList; import java.util.Collection; import java.util.function.Consumer; public class Main { public static void main(String[] args) { // 创建一个 ArrayList 集合对象 Collection\u0026lt;String\u0026gt; c = new ArrayList\u0026lt;\u0026gt;(); // 向集合中添加元素 c.add(\u0026#34;Kennem\u0026#34;); c.add(\u0026#34;999\u0026#34;); c.add(\u0026#34;show\u0026#34;); // 使用 forEach 方法遍历集合，传统方式 c.forEach(new Consumer\u0026lt;String\u0026gt;() { @Override public void accept(String s) { System.out.println(s); } }); // 使用 Lambda 表达式遍历集合，Lambda 参数类型推断 c.forEach((String s) -\u0026gt; { System.out.println(s); }); // 使用 Lambda 表达式遍历集合，简化参数类型 c.forEach((String s) -\u0026gt; System.out.println(s)); // 使用方法引用遍历集合，等同于 Lambda 表达式 System.out::println c.forEach( System.out::println ) ; } } public class Main { public static void main(String[] args) { // 创建一个 Movie 类型的集合对象 Collection\u0026lt;Movie\u0026gt; movies = new ArrayList\u0026lt;\u0026gt;(); // 向集合中添加 Movie 对象 movies.add(new Movie(\u0026#34;《阿甘正传》\u0026#34;, 9.5, \u0026#34;汤姆\u0026#34;)); // 打印集合内容 System.out.println(movies); // 使用增强型 for 循环遍历集合中的 Movie 对象 for (Movie movie : movies) { // 获取电影名称并打印 System.out.println(movie.getName()); // 获取电影评分并打印 System.out.println(movie.getScore()); // 获取主演名称并打印 System.out.println(movie.getActor()); } } } List() ArrayList() 添加元素：add(E e) 和 add(int index, E element)\n删除元素：remove(int index) 和 remove(Object o)\n获取元素：get(int index)\n修改元素：set(int index, E element)\n检查元素是否存在：contains(Object o)\n获取列表大小：size()\n获取元素位置：indexOf(Object o) 和 lastIndexOf(Object o)\n遍历列表：使用 for-each 循环和 Iterator\n转换为数组：toArray()\n获取子列表：subList(int fromIndex, int toIndex)\n清空列表：clear()\n判断列表是否为空：isEmpty()\nimport java.util.ArrayList; import java.util.List; public class Main { public static void main(String[] args) { // 创建一个 ArrayList 对象 ls List\u0026lt;String\u0026gt; ls = new ArrayList\u0026lt;\u0026gt;(); // 向 ls 中添加元素 ls.add(\u0026#34;Kennem\u0026#34;); ls.add(\u0026#34;K\u0026#34;); ls.add(\u0026#34;至尊宝\u0026#34;); ls.add(\u0026#34;牛夫人\u0026#34;); // 打印 ls 的内容 System.out.println(\u0026#34;Initial list: \u0026#34; + ls); // 在索引位置 2 插入元素 \u0026#34;紫霞仙子\u0026#34; ls.add(2, \u0026#34;紫霞仙子\u0026#34;); System.out.println(\u0026#34;After adding \u0026#39;紫霞仙子\u0026#39; at index 2: \u0026#34; + ls); // 移除索引位置 2 处的元素并打印移除的元素 System.out.println(\u0026#34;Removed element: \u0026#34; + ls.remove(2)); System.out.println(\u0026#34;After removal: \u0026#34; + ls); // 获取索引位置 2 处的元素并打印 System.out.println(\u0026#34;Element at index 2: \u0026#34; + ls.get(2)); // 将索引位置 1 处的元素修改为 \u0026#34;牛魔王\u0026#34;，并打印被替换掉的元素 System.out.println(\u0026#34;Replaced element: \u0026#34; + ls.set(1, \u0026#34;牛魔王\u0026#34;)); System.out.println(\u0026#34;After setting \u0026#39;牛魔王\u0026#39; at index 1: \u0026#34; + ls); // 检查列表中是否包含某个元素 System.out.println(\u0026#34;Contains \u0026#39;至尊宝\u0026#39;: \u0026#34; + ls.contains(\u0026#34;至尊宝\u0026#34;)); System.out.println(\u0026#34;Contains \u0026#39;紫霞仙子\u0026#39;: \u0026#34; + ls.contains(\u0026#34;紫霞仙子\u0026#34;)); // 获取列表大小 System.out.println(\u0026#34;List size: \u0026#34; + ls.size()); // 获取某个元素的索引 System.out.println(\u0026#34;Index of \u0026#39;牛魔王\u0026#39;: \u0026#34; + ls.indexOf(\u0026#34;牛魔王\u0026#34;)); System.out.println(\u0026#34;Index of \u0026#39;至尊宝\u0026#39;: \u0026#34; + ls.indexOf(\u0026#34;至尊宝\u0026#34;)); // 遍历列表 System.out.println(\u0026#34;List elements:\u0026#34;); for (String element : ls) { System.out.println(element); } // 转换为数组 Object[] array = ls.toArray(); System.out.println(\u0026#34;Array elements:\u0026#34;); for (Object obj : array) { System.out.println(obj); } // 获取子列表 List\u0026lt;String\u0026gt; subList = ls.subList(1, 3); System.out.println(\u0026#34;Sublist (from index 1 to 3): \u0026#34; + subList); // 使用迭代器遍历列表 System.out.println(\u0026#34;List elements using iterator:\u0026#34;); for (var iterator = ls.iterator(); iterator.hasNext();) { System.out.println(iterator.next()); } // 清空列表 ls.clear(); System.out.println(\u0026#34;Is list empty after clear? \u0026#34; + ls.isEmpty()); } } LinkedList() 添加元素：add(E e) 和 add(int index, E element)\n删除元素：remove(int index) 和 remove(Object o)\n获取元素：get(int index)\n修改元素：set(int index, E element)\n检查元素是否存在：contains(Object o)\n获取列表大小：size()\n获取元素位置：indexOf(Object o) 和 lastIndexOf(Object o)\n遍历列表：使用 for-each 循环和 Iterator\n转换为数组：toArray()\n获取子列表：subList(int fromIndex, int toIndex)\n清空列表：clear()\n判断列表是否为空：isEmpty()\n特有方法：addFirst(E e)，addLast(E e)，getFirst()，getLast()，removeFirst()，removeLast()\nimport java.util.LinkedList; import java.util.Iterator; public class LinkedListExample { public static void main(String[] args) { LinkedList\u0026lt;String\u0026gt; list = new LinkedList\u0026lt;\u0026gt;(); // 添加元素 list.add(\u0026#34;element1\u0026#34;); list.add(\u0026#34;element2\u0026#34;); list.add(1, \u0026#34;element1.5\u0026#34;); list.addFirst(\u0026#34;firstElement\u0026#34;); list.addLast(\u0026#34;lastElement\u0026#34;); // 访问元素 System.out.println(\u0026#34;First element: \u0026#34; + list.getFirst()); System.out.println(\u0026#34;Last element: \u0026#34; + list.getLast()); System.out.println(\u0026#34;Element at index 1: \u0026#34; + list.get(1)); // 删除元素 list.remove(1); list.remove(\u0026#34;element1\u0026#34;); list.removeFirst(); list.removeLast(); // 替换元素 list.set(1, \u0026#34;newElement\u0026#34;); // 检查元素是否存在 System.out.println(\u0026#34;Contains \u0026#39;element2\u0026#39;: \u0026#34; + list.contains(\u0026#34;element2\u0026#34;)); // 获取列表大小 System.out.println(\u0026#34;List size: \u0026#34; + list.size()); // 遍历列表 System.out.println(\u0026#34;Elements in the list:\u0026#34;); for (String element : list) { System.out.println(element); } // 转换为数组 Object[] array = list.toArray(); System.out.println(\u0026#34;Array: \u0026#34;); for (Object obj : array) { System.out.println(obj); } // 获取子列表 List\u0026lt;String\u0026gt; subList = list.subList(0, 1); System.out.println(\u0026#34;Sublist: \u0026#34; + subList); // 清空列表 list.clear(); System.out.println(\u0026#34;Is list empty? \u0026#34; + list.isEmpty()); } } LinkedList()特有方法 import java.util.LinkedList; public class LinkedListExample { public static void main(String[] args) { LinkedList\u0026lt;String\u0026gt; linkedList = new LinkedList\u0026lt;\u0026gt;(); // 添加元素到开头和末尾 linkedList.addFirst(\u0026#34;firstElement\u0026#34;); linkedList.addLast(\u0026#34;lastElement\u0026#34;); System.out.println(\u0026#34;After adding elements to first and last: \u0026#34; + linkedList); // 获取第一个和最后一个元素 System.out.println(\u0026#34;First element: \u0026#34; + linkedList.getFirst()); System.out.println(\u0026#34;Last element: \u0026#34; + linkedList.getLast()); // 删除第一个和最后一个元素 System.out.println(\u0026#34;Removed first element: \u0026#34; + linkedList.removeFirst()); System.out.println(\u0026#34;Removed last element: \u0026#34; + linkedList.removeLast()); System.out.println(\u0026#34;After removing first and last elements: \u0026#34; + linkedList); // 栈操作 linkedList.push(\u0026#34;stackElement\u0026#34;); System.out.println(\u0026#34;After push: \u0026#34; + linkedList); System.out.println(\u0026#34;Popped element: \u0026#34; + linkedList.pop()); System.out.println(\u0026#34;After pop: \u0026#34; + linkedList); // 添加元素到队列两端 linkedList.offerFirst(\u0026#34;offerFirstElement\u0026#34;); linkedList.offerLast(\u0026#34;offerLastElement\u0026#34;); System.out.println(\u0026#34;After offering elements: \u0026#34; + linkedList); // 获取并移除队列两端的元素 System.out.println(\u0026#34;Polled first element: \u0026#34; + linkedList.pollFirst()); System.out.println(\u0026#34;Polled last element: \u0026#34; + linkedList.pollLast()); System.out.println(\u0026#34;After polling elements: \u0026#34; + linkedList); } } ArrayList() 和 LinkedList() 区别 ArrayList 和 LinkedList 都实现了 List 接口，因此有许多相同的方法。\nLinkedList 还实现了 Deque 接口，因此有许多特有的方法，这些方法在 ArrayList 中不存在。\nArrayList 在随机访问性能上优于 LinkedList，而 LinkedList 在频繁插入和删除操作时表现更优。\nSet() HashSet() 哈希值\n就是一个int类型的数值，Java中每个对象都有一个哈希值 Java中的所有对象，都可以调用Object类提供的hashCode方法，返回该对象自己的哈希值 哈希表\nJDK 8之前， 基于数组+链表\n创建一个默认长度为16的数组，默认加载因子为0.75， 数组名为table 使用元素的哈希值对数组长度求余计算出应存入的位置 判断当前位置是否为null， 如果是null直接存入 如果不为null， 表示有元素，则调用equals方法比较 若相等则不存入，否则存入 JDK 8之前，新元素存入数组，占老元素位置，老元素挂下面 JDK 8开始之后， 新元素直接挂在老元素下面 JDK 8开始之后，哈希表中引入了红黑树，进一步提高了操作数据的性能\n树：\n二叉树中，任意节点的度\u0026lt;=2\n度：每一个节点的子节点数量 树高：树的总层数 根节点：最顶层的节点 二叉查找树（二叉排序树）\n规则：小的存左边，大的存右边，一样的不存\n平衡二叉树：左右子树的高度差不超过1\n红黑树：可以自平衡的二叉树, 是一种增删改查性能都相对较好的结构\n从JDK8开始，当链表的长度超过8，且数组长度\u0026gt;=64时，自动将链表转成红黑树\npublic static void main(String[] args) { // 创建一个 HashSet 对象，用于存储整数数据 Set\u0026lt;Integer\u0026gt; set = new HashSet\u0026lt;\u0026gt;(); // 往 HashSet 中添加整数元素 // HashSet 会自动去重，不会存储重复的元素 set.add(999); // 添加整数 999 set.add(999); // 添加重复的整数 999，但由于 HashSet 不允许重复元素，此次添加无效 set.add(777); // 添加整数 777 // 打印 HashSet 中的元素 // 输出结果：[777, 999] // HashSet 中的元素无序，并且已经去重了，只保留了一个 999 System.out.println(set); } LinkedHashSet public static void main(String[] args) { // 创建一个 LinkedHashSet 对象，用于存储整数数据，并保持元素的插入顺序 Set\u0026lt;Integer\u0026gt; set = new LinkedHashSet\u0026lt;\u0026gt;(); // 往 LinkedHashSet 中添加整数元素 // LinkedHashSet 会保持元素的插入顺序，并且会自动去重，不会存储重复的元素 // 添加顺序：999, 000, 777, 888 // 由于 LinkedHashSet 会保持插入顺序，因此打印时也会按照添加顺序输出 set.add(999); set.add(000); // 注意：整数 000 在打印时会自动去掉前导零，变成 0 set.add(777); set.add(888); set.add(999); // 重复元素不会被添加进 LinkedHashSet // 打印 LinkedHashSet 中的元素 // 输出结果：[999, 0, 777, 888] // LinkedHashSet 中的元素按照插入顺序排列，并且去重了 System.out.println(set); } TreeSet() 基于红黑树实现排序，\npublic static void main(String[] args) { // 创建一个 TreeSet 对象，用于存储整数数据，并按照自然顺序进行排序 Set\u0026lt;Integer\u0026gt; set = new TreeSet\u0026lt;\u0026gt;(); // 往 TreeSet 中添加整数元素 // TreeSet 会自动去重，不会存储重复的元素 // 添加顺序：999, 000, 777, 888 // 由于 TreeSet 是有序的，它会根据自然顺序（从小到大）对元素进行排序 set.add(999); set.add(000); // 注意：整数 000 在打印时会自动去掉前导零，变成 0 set.add(777); set.add(888); set.add(999); // 重复元素不会被添加进 TreeSet // 打印 TreeSet 中的元素 // 输出结果：[0, 777, 888, 999] // TreeSet 中的元素已经按照自然顺序排好序，并且去重了 System.out.println(set); } 对于自定义对象，确保存储的值相同就重复，重写hashCode方法\n@Override public int hashCode() { return Objects.hash(name, age, height);//只要内容一样，哈希值就相同 } 自定义排序规则： TreeSet集合存储自定义类型的对象时， 必须指定排序规则，支持如下两种方式来指定比较规则 方式一\n让自定义的类（如学生类）实现Comparable接口，重写里面的compareTo方法来执行比较规则 @Override public int compareTo(Student o) { return this.age - o.age; } 方式二\n通过调用TreeSet集合有参数构造器，可以设置Comparator对象（比较器对象，用于指定比较规则。） // 就近选择自己自带的比较器进行比较 // Set\u0026lt;Student\u0026gt; students = new TreeSet\u0026lt;\u0026gt;(new Comparator\u0026lt;Student\u0026gt;() { // @Override // public int compare(Student o1, Student o2) { // return Double.compare(o1.getHeight(), o2.getHeight()); // } // }); Set\u0026lt;Student\u0026gt; students = new TreeSet\u0026lt;\u0026gt;( (o1, o2) -\u0026gt; Double.compare(o1.getHeight(), o2.getHeight())); 集合的并发修改异常 public static void main(String[] args) { // 创建一个字符串列表 List\u0026lt;String\u0026gt; list = new ArrayList\u0026lt;\u0026gt;(); list.add(\u0026#34;小李子\u0026#34;); list.add(\u0026#34;利玛窦\u0026#34;); list.add(\u0026#34;胡风云\u0026#34;); list.add(\u0026#34;胡面上\u0026#34;); list.add(\u0026#34;胡椒粉\u0026#34;); list.add(\u0026#34;kennem\u0026#34;); list.add(\u0026#34;百事快\u0026#34;); System.out.println(list); // 使用迭代器遍历列表并移除包含特定字符的元素 Iterator\u0026lt;String\u0026gt; it = list.iterator(); while (it.hasNext()) { String name = it.next(); if (name.contains(\u0026#34;胡\u0026#34;)) { it.remove(); // 解决集合的并发修改异常 } } System.out.println(list); // 使用普通for循环遍历列表并移除包含特定字符的元素 // 通过维护索引，避免并发修改异常 /* for (int i = 0; i \u0026lt; list.size(); i++) { String name = list.get(i); if (name.contains(\u0026#34;胡\u0026#34;)) { list.remove(name); i--; // 解决集合的并发修改异常 } } System.out.println(list); */ // 使用增强for循环遍历列表并移除包含特定字符的元素 // 不推荐，会导致ConcurrentModificationException异常 /* for (String s : list) { if (s.contains(\u0026#34;胡\u0026#34;)) { list.remove(s); } } System.out.println(list); */ } 可变参数 public static void main(String[] args) { // 调用test方法，传入单个整数参数 test(1); // 调用test方法，传入单个整数参数 test(10); // 调用test方法，传入多个整数参数，其中最后一个参数为可变参数 test(100, 10, 0); // 调用test方法，传入一个整数参数和一个整数数组参数 test(1, new int[] {1, 2, 4, 4, 3, 3, 3, 3, 4, 3}); } // 1. 一个形参列表中，只能有一个可变参数 // 2. 可变参数必须放在形参列表的最后面 public static void test(int age, int...nums){ // 打印可变参数数组 System.out.println(Arrays.toString(nums)); // 打印可变参数数组的长度 System.out.println(nums.length); // 打印分隔线 System.out.println(\u0026#34;----------\u0026#34;); } Collections public static void main(String[] args) { // 创建一个字符串列表 List\u0026lt;String\u0026gt; names = new ArrayList\u0026lt;\u0026gt;(); // 向列表中添加元素 Collections.addAll(names, \u0026#34;Kennem\u0026#34;, \u0026#34;张一\u0026#34;,\u0026#34;李三\u0026#34;,\u0026#34;王六\u0026#34;); // 打印列表内容 System.out.println(names); // 打乱列表中元素的顺序 Collections.shuffle(names); // 打印打乱后的列表内容 System.out.println(names); // 创建一个整数列表 List\u0026lt;Integer\u0026gt; list = new ArrayList\u0026lt;\u0026gt;(); // 向列表中添加元素 list.add(3); list.add(4); list.add(1); // 对列表中的元素进行排序 Collections.sort(list); // 打印排序后的列表内容 System.out.println(list); // 创建一个学生对象列表 List\u0026lt;Student\u0026gt; students = new ArrayList\u0026lt;\u0026gt;(); // 创建学生对象并添加到列表中 Student s1 = new Student(\u0026#34;至尊宝\u0026#34;, 21, 181.9); Student s2 = new Student(\u0026#34;蜘蛛精\u0026#34;, 21, 188); Student s3 = new Student(\u0026#34;牛魔王\u0026#34;, 20, 165.3); Student s4 = new Student(\u0026#34;蝎子精\u0026#34;, 20, 165.3); Student s5 = new Student(\u0026#34;葫芦娃\u0026#34;, 20, 165.3); Student s6 = new Student(\u0026#34;至尊宝\u0026#34;, 21, 181); students.add(s1); students.add(s2); students.add(s3); students.add(s4); students.add(s5); students.add(s6); // 打印学生列表内容 System.out.println(students); // 使用Lambda表达式对学生列表按身高进行排序 Collections.sort(students, (o1, o2) -\u0026gt; Double.compare(o1.getHeight(), o2.getHeight())); // 打印按身高排序后的学生列表内容 System.out.println(students); } Map HashMap ：无序、不重复、无索引；（用的最多） LinkedHashMap：由键决定的特点：有序，不重复，无索引 TreeMap:按照大小默认升序排序，不重复，无索引 public static void main(String[] args) { // 创建一个HashMap对象 Map\u0026lt;String, Integer\u0026gt; map = new HashMap\u0026lt;\u0026gt;(); // 向map中添加键值对 map.put(\u0026#34;手表\u0026#34;, 100); map.put(\u0026#34;手机\u0026#34;, 20); map.put(\u0026#34;Java\u0026#34;, 120); map.put(null, null); // 允许键和值为null // 打印map的内容 System.out.println(map); // 获取map的大小 System.out.println(map.size()); // 清空map // map.clear(); // 打印清空后的map System.out.println(map); // 判断map是否为空 System.out.println(map.isEmpty()); // 获取指定键对应的值 System.out.println(map.get(\u0026#34;手机\u0026#34;)); // 获取一个不存在的键对应的值 System.out.println(map.get(\u0026#34;666\u0026#34;)); // 移除指定键对应的键值对，并返回对应的值 System.out.println(map.remove(\u0026#34;手机\u0026#34;)); // 判断map中是否包含指定的键 System.out.println(map.containsKey(\u0026#34;手机\u0026#34;)); System.out.println(map.containsKey(\u0026#34;手机\u0026#34;)); // 获取map中所有的键，并存储到Set集合中 Set\u0026lt;String\u0026gt; keys = map.keySet(); System.out.println(keys); // 获取map中所有的值，并存储到Collection集合中 Collection\u0026lt;Integer\u0026gt; values = map.values(); System.out.println(values); // 创建另一个HashMap对象 Map\u0026lt;String, Integer\u0026gt; map1 = new HashMap\u0026lt;\u0026gt;(); map1.put(\u0026#34;Java1\u0026#34;, 100); map1.put(\u0026#34;Java2\u0026#34;, 200); map1.put(\u0026#34;Java3\u0026#34;, 300); // 创建另一个HashMap对象 Map\u0026lt;String, Integer\u0026gt; map2 = new HashMap\u0026lt;\u0026gt;(); map2.put(\u0026#34;Java3\u0026#34;, 400); map2.put(\u0026#34;Java4\u0026#34;, 500); // 打印map1和map2的内容 System.out.println(map1); System.out.println(map2); // 将map2中的键值对全部添加到map1中 map1.putAll(map2); // 打印合并后的map1 System.out.println(map1); } 遍历Map public class Main { public static void main(String[] args) { // 创建一个HashMap对象，键为String类型，值为Double类型 Map\u0026lt;String, Double\u0026gt; map = new HashMap\u0026lt;\u0026gt;(); // 向map中添加键值对 map.put(\u0026#34;蜘蛛精\u0026#34;, 167.2); // 如果键已存在，则覆盖原有值 map.put(\u0026#34;蜘蛛精\u0026#34;, 169.2); map.put(\u0026#34;至尊宝\u0026#34;, 164.2); map.put(\u0026#34;牛魔王\u0026#34;, 187.2); // 获取map中所有的键，并存储在Set集合中 Set\u0026lt;String\u0026gt; keys = map.keySet(); // 打印所有的键 System.out.println(keys); // 遍历Set集合，获取每个键对应的值，并打印键值对 for (String key : keys) { double value = map.get(key); System.out.println(key + \u0026#34; \u0026#34; + map.get(key)); } } } entry遍历方式 // 获取map中所有的键值对，并存储在Set集合中 Set\u0026lt;Map.Entry\u0026lt;String, Double\u0026gt;\u0026gt; entries = map.entrySet(); // 遍历Set集合，获取每个键值对，并打印键值对 for (Map.Entry\u0026lt;String, Double\u0026gt; entry : entries) { String key = entry.getKey(); double value = entry.getValue(); System.out.println(key + \u0026#34;-----\u0026gt;\u0026#34; + value); } forEach方式遍历\n// 使用forEach方法遍历map，打印每个键值对 map.forEach((k, v) -\u0026gt; { System.out.println(k + \u0026#34;---\u0026gt;\u0026#34; + v); }); LinkedHashMap 类似LinkedHashSet(), 而且LinkedHashSet()底层使用的就是linkedHashMap()\npublic static void main(String[] args) { // 创建一个LinkedHashMap对象，键为Student类型，值为Integer类型 Map\u0026lt;Student, Integer\u0026gt; lmap = new LinkedHashMap\u0026lt;\u0026gt;(); // 向lmap中添加键值对，其中键为Student对象，值为Integer对象 // 注意：Student类需要正确实现equals()和hashCode()方法以确保对象的唯一性 lmap.put(new Student(\u0026#34;Ken\u0026#34;, 25, 150), 100); lmap.put(new Student(\u0026#34;Mary\u0026#34;, 23, 182), 123300); lmap.put(new Student(\u0026#34;Bob\u0026#34;, 21, 1180), 12300); lmap.put(new Student(\u0026#34;Paul\u0026#34;, 22, 130), 12); lmap.put(new Student(\u0026#34;Sam\u0026#34;, 15, 280), 120); lmap.put(new Student(\u0026#34;Ken\u0026#34;, 25, 150), 10); // 注意：与第一个Ken对象相同，但是值不同 // 使用forEach方法遍历lmap，打印每个键值对 lmap.forEach((k, v) -\u0026gt; { System.out.println(k + \u0026#34; \u0026#34; + v); }); } 重写equals方法可以去除重复值\n@Override public boolean equals(Object o) { if (this == o) return true; if (o == null || getClass() != o.getClass()) return false; Student student = (Student) o; return age == student.age \u0026amp;\u0026amp; Double.compare(height, student.height) == 0 \u0026amp;\u0026amp; Objects.equals(name, student.name); } TreeMap 比较规则用重写Comparable接口，或者重写Comparator方法\npublic static void main(String[] args) { // 创建一个TreeMap对象，键为Student类型，值为Integer类型 // 在构造TreeMap对象时，传入一个Comparator对象，用于按照学生身高进行排序 Map\u0026lt;Student, Integer\u0026gt; tmap = new TreeMap\u0026lt;\u0026gt;((o1, o2) -\u0026gt; Double.compare(o1.getHeight(), o2.getHeight())); // 向tmap中添加键值对，其中键为Student对象，值为Integer对象 // 注意：Student类需要正确实现equals()和hashCode()方法以确保对象的唯一性 tmap.put(new Student(\u0026#34;Ken\u0026#34;, 25, 150), 100); tmap.put(new Student(\u0026#34;Mary\u0026#34;, 23, 182), 123300); tmap.put(new Student(\u0026#34;Bob\u0026#34;, 21, 1180), 12300); tmap.put(new Student(\u0026#34;Paul\u0026#34;, 22, 130), 12); tmap.put(new Student(\u0026#34;Sam\u0026#34;, 15, 280), 120); tmap.put(new Student(\u0026#34;Ken\u0026#34;, 25, 150), 10); // 与第一个Ken对象相同，但是值不同 // 使用forEach方法遍历tmap，打印每个键值对 tmap.forEach((k, v) -\u0026gt; { System.out.println(k + \u0026#34; \u0026#34; + v); }); } 重写Comparable中的compareTo方法\n@Override public int compareTo(Student o) { return this.age - o.age; } 集合的嵌套 public static void main(String[] args) { // 创建一个HashMap对象，键为String类型，值为List\u0026lt;String\u0026gt;类型 Map\u0026lt;String, List\u0026lt;String\u0026gt;\u0026gt; map = new HashMap\u0026lt;\u0026gt;(); // 创建第一个城市列表，存储江苏省的城市信息 List\u0026lt;String\u0026gt; cities1 = new ArrayList\u0026lt;\u0026gt;(); // 使用Collections.addAll方法向cities1中添加多个元素 Collections.addAll(cities1, \u0026#34;南京市\u0026#34;, \u0026#34;扬州市\u0026#34;, \u0026#34;苏州市\u0026#34;, \u0026#34;无锡市\u0026#34;, \u0026#34;常州市\u0026#34;); // 将键值对添加到map中，键为\u0026#34;江苏省\u0026#34;，值为cities1列表 map.put(\u0026#34;江苏省\u0026#34;, cities1); // 创建第二个城市列表，存储湖北省的城市信息 List\u0026lt;String\u0026gt; cities2 = new ArrayList\u0026lt;\u0026gt;(); Collections.addAll(cities2, \u0026#34;武汉市\u0026#34;, \u0026#34;孝感市\u0026#34;, \u0026#34;十堰市\u0026#34;, \u0026#34;宜昌市\u0026#34;, \u0026#34;鄂州市\u0026#34;); map.put(\u0026#34;湖北省\u0026#34;, cities2); // 打印整个map System.out.println(map); // 打印湖北省对应的城市列表 System.out.println(map.get(\u0026#34;湖北省\u0026#34;)); // 使用增强for循环遍历第二个城市列表，打印其中的城市信息 for (String s : cities2) { System.out.println(s); } // 使用forEach方法遍历map，打印每个省份及其对应的城市列表 map.forEach((k, v) -\u0026gt; System.out.println(k + \u0026#34;---\u0026gt;\u0026#34; + v)); } Stream import java.util.ArrayList; import java.util.Collections; import java.util.List; import java.util.stream.Collectors; public class Main { public static void main(String[] args) { // 创建一个字符串列表 List\u0026lt;String\u0026gt; names = new ArrayList\u0026lt;\u0026gt;(); // 向列表中添加多个元素 Collections.addAll(names, \u0026#34;张某\u0026#34;, \u0026#34;张五一\u0026#34;, \u0026#34;张无忌\u0026#34;, \u0026#34;张三丰\u0026#34;, \u0026#34;Kennem\u0026#34;); // 打印列表中的所有元素 System.out.println(names); // 创建一个新的列表，用于存储以\u0026#34;张\u0026#34;开头且长度为3的字符串 List\u0026lt;String\u0026gt; list = new ArrayList\u0026lt;\u0026gt;(); // 使用增强for循环遍历原始列表 for (String name : names) { // 如果字符串以\u0026#34;张\u0026#34;开头且长度为3，则添加到新列表中 if (name.startsWith(\u0026#34;张\u0026#34;) \u0026amp;\u0026amp; name.length() == 3) { list.add(name); } } // 打印新列表中的元素 System.out.println(list); // 使用流进行筛选，获取以\u0026#34;张\u0026#34;开头且长度为3的字符串，然后收集到新的列表中 List\u0026lt;String\u0026gt; list2 = names.stream() .filter(s -\u0026gt; s.startsWith(\u0026#34;张\u0026#34;)) // 筛选以\u0026#34;张\u0026#34;开头的字符串 .filter(a -\u0026gt; a.length() == 3) // 筛选长度为3的字符串 .collect(Collectors.toList()); // 收集到新的列表中 // 打印新列表中的元素 System.out.println(list2); } } ArrayList, HashSet, Map的Stream流 public static void main(String[] args) { // 创建一个字符串列表 List\u0026lt;String\u0026gt; names = new ArrayList\u0026lt;\u0026gt;(); // 向列表中添加多个元素 Collections.addAll(names, \u0026#34;张三丰\u0026#34;, \u0026#34;张某人\u0026#34;, \u0026#34;张某某\u0026#34;, \u0026#34;张某\u0026#34;, \u0026#34;张某某人\u0026#34;); // 创建一个流，并对其中包含\u0026#34;某\u0026#34;的元素进行筛选并打印 Stream\u0026lt;String\u0026gt; stream1 = names.stream(); stream1.filter(s -\u0026gt; s.contains(\u0026#34;某\u0026#34;)).forEach(System.out::println); // 创建一个HashSet集合，并将多个元素添加到其中 Set\u0026lt;String\u0026gt; set = new HashSet\u0026lt;\u0026gt;(); Collections.addAll(set, \u0026#34;张三丰\u0026#34;, \u0026#34;张某人\u0026#34;, \u0026#34;张某某\u0026#34;, \u0026#34;张某\u0026#34;, \u0026#34;张某某人\u0026#34;); // 创建一个流，并对其中包含\u0026#34;某\u0026#34;的元素进行筛选并打印 Stream\u0026lt;String\u0026gt; stream2 = set.stream(); stream2.filter(s -\u0026gt; s.contains(\u0026#34;某\u0026#34;)).forEach(System.out::println); // 创建一个HashMap对象，并向其中添加键值对 Map\u0026lt;String, Double\u0026gt; map = new HashMap\u0026lt;\u0026gt;(); map.put(\u0026#34;张某\u0026#34;, 165.3); map.put(\u0026#34;Kennem\u0026#34;, 181.2); map.put(\u0026#34;Karl\u0026#34;, 180.1); // 获取map中所有值的集合 Collection\u0026lt;Double\u0026gt; values = map.values(); // 创建一个流，并对其中包含\u0026#34;某\u0026#34;的键值对进行筛选并打印 Set\u0026lt;Map.Entry\u0026lt;String, Double\u0026gt;\u0026gt; entries = map.entrySet(); Stream\u0026lt;Map.Entry\u0026lt;String, Double\u0026gt;\u0026gt; stream3 = entries.stream(); stream3.filter(e -\u0026gt; e.getKey().contains(\u0026#34;某\u0026#34;)) .forEach(e -\u0026gt; System.out.println(e.getKey() + \u0026#34;--\u0026gt;\u0026#34; + e.getValue())); // 创建一个字符串数组，并将多个元素添加到其中 String[] names2 = {\u0026#34;张某人\u0026#34;, \u0026#34;东方不败\u0026#34;}; // 使用Arrays.stream方法创建一个流，并对其中的元素进行打印 Stream\u0026lt;String\u0026gt; stream4 = Arrays.stream(names2); stream4.forEach(System.out::println); // 使用Stream.of方法创建一个流，并对其中的元素进行打印 Stream\u0026lt;String\u0026gt; names21 = Stream.of(names2); names21.forEach(System.out::println); } 排序以及筛选 public static void main(String[] args) { // 创建一个Double类型的列表，存储考试成绩 List\u0026lt;Double\u0026gt; scores = new ArrayList\u0026lt;\u0026gt;(); Collections.addAll(scores, 88.5, 89.5, 90.0, 12.0, 1.0); // 使用流对考试成绩进行筛选，只打印及格的成绩 scores.stream().filter(s -\u0026gt; s \u0026gt;= 60) .forEach(System.out::println); System.out.println(\u0026#34;---------------\u0026#34;); // 创建一个Student对象的列表，存储学生信息 List\u0026lt;Student\u0026gt; students = new ArrayList\u0026lt;\u0026gt;(); // 创建多个Student对象，并添加到列表中 Student s1 = new Student(\u0026#34;至尊宝\u0026#34;, 21, 181.2); Student s2 = new Student(\u0026#34;蜘蛛精\u0026#34;, 21, 181.3); Student s3 = new Student(\u0026#34;牛魔王\u0026#34;, 20, 165.3); Student s4 = new Student(\u0026#34;蝎子精\u0026#34;, 20, 165.2); Student s5 = new Student(\u0026#34;蜘蛛精\u0026#34;, 22, 181.3); Collections.addAll(students, s1, s2, s3, s4, s5); // 使用流对学生信息进行筛选和排序，并打印结果 students.stream().filter(s -\u0026gt; s.getAge() \u0026gt;= 10 \u0026amp;\u0026amp; s.getAge() \u0026lt;= 30) .sorted((o1, o2) -\u0026gt; o2.getAge() - o1.getAge()) .forEach(System.out::println); System.out.println(\u0026#34;--------------\u0026#34;); // 使用流对学生信息按身高进行排序，并打印身高最高的前三名学生 students.stream().sorted(((o1, o2) -\u0026gt; Double.compare(o2.getHeight(), o1.getHeight()))) .limit(3) .forEach(System.out::println); System.out.println(\u0026#34;---------------\u0026#34;); // 使用流对学生信息按身高进行排序，并打印身高最低的两名学生 students.stream().sorted(((o1, o2) -\u0026gt; Double.compare(o2.getHeight(), o1.getHeight()))) .skip(students.size() - 2) .forEach(System.out::println); System.out.println(\u0026#34;-----------------\u0026#34;); // 使用流对学生信息进行筛选，找出身高大于168的学生，并打印他们的姓名（去重） students.stream() .filter(s -\u0026gt; s.getHeight() \u0026gt; 168) .map(Student::getName) .distinct() .forEach(System.out::println); // 使用Stream.concat方法将两个流合并，然后打印合并后的结果 Stream\u0026lt;Student\u0026gt; s11 = Stream.of(s1, s2); Stream\u0026lt;Student\u0026gt; s12 = Stream.of(s3, s4); Stream\u0026lt;Student\u0026gt; concat = Stream.concat(s11, s12); concat.forEach(System.out::println); } Stream终结方法 public static void main(String[] args) { // 创建学生列表 List\u0026lt;Student\u0026gt; students = new ArrayList\u0026lt;\u0026gt;(); // 创建学生对象并添加到列表中 Student s1 = new Student(\u0026#34;至尊宝\u0026#34;, 21, 181.2); Student s2 = new Student(\u0026#34;蜘蛛精\u0026#34;, 21, 181.3); Student s3 = new Student(\u0026#34;牛魔王\u0026#34;, 20, 165.3); Student s4 = new Student(\u0026#34;蝎子精\u0026#34;, 20, 165.2); Student s5 = new Student(\u0026#34;蜘蛛精\u0026#34;, 21, 181.3); Collections.addAll(students, s1, s2, s3, s4, s5); // 使用流过滤身高大于168的学生，并将结果收集到列表中 List\u0026lt;Student\u0026gt; res1 = students.stream() .filter(s -\u0026gt; s.getHeight() \u0026gt; 168) .collect(Collectors.toList()); System.out.println(res1); // 使用流过滤身高大于168的学生，并将结果收集到集合中 Set\u0026lt;Student\u0026gt; res2 = students.stream() .filter(s -\u0026gt; s.getHeight() \u0026gt; 168) .collect(Collectors.toSet()); System.out.println(res2); // 使用流过滤身高大于168的学生，去除重复的学生对象，并将姓名和身高映射到Map中 Map\u0026lt;String, Double\u0026gt; res3 = students.stream() .filter(s -\u0026gt; s.getHeight() \u0026gt; 168) .distinct() .collect(Collectors.toMap(a -\u0026gt; a.getName(), a -\u0026gt; a.getHeight())); System.out.println(res3); // 使用流过滤身高大于168的学生，去除重复的学生对象，并将结果转换为对象数组 Object[] res4 = students.stream() .filter(s -\u0026gt; s.getHeight() \u0026gt; 168) .distinct() .toArray(); System.out.println(Arrays.toString(res4)); // 使用流过滤身高大于168的学生，去除重复的学生对象，并将结果转换为指定长度的学生数组 Student[] res5 = students.stream() .filter(s -\u0026gt; s.getHeight() \u0026gt; 168) .distinct() .toArray(len -\u0026gt; new Student[len]); System.out.println(Arrays.toString(res5)); } 总结程序的知识点，并将知识点写到程序注释中去 ","permalink":"https://kennems.github.io/posts/tech/java20%E5%A4%A9%E9%80%9F%E6%88%90%E8%BF%9B%E9%98%B6%E8%AF%BE%E7%A8%8B2/","summary":"Java20天速成——进阶课程(2) 正则表达式 符号 含义 举例 [] 匹配方括号内的任一字符 [abc] ^ 匹配除指定字符外的任意字符 [^abc] \u0026amp;\u0026amp; 匹配两个字符集的交集，需","title":"Java20天速成——进阶课程(2)"},{"content":"LeetCode第 393 场周赛 第三题3116. 单面值组合的第 K 小金额 题目大意： 给定一个整数数组coins表示不同面额的硬币，另给定一个整数k。你有无限量的每种面额的硬币，但是，你不能组合使用不同面额的硬币。要求返回使用这些硬币能制造的第kth小金额。\n实现思路：\n首先，对于给定的硬币数组，我们需要求出它们的所有可能的组合方式。 使用位运算来枚举所有的组合方式，对于数组中的每个硬币，分别考虑选取和不选取两种情况，通过位运算将这两种情况枚举出来。 对于每种组合方式，计算其对应的最小公倍数（LCM）作为该组合的金额。 根据组合的奇偶性，将金额的正负号记录下来，并存储在列表ls中。 利用二分查找来求解第kth小的金额，通过不断调整左右边界，直到找到满足条件的金额。 返回最终找到的金额作为结果。 这种方法利用了位运算和二分查找的思想，可以在较短的时间内求解出结果。\nclass Solution: def findKthSmallest(self, coins: List[int], k: int) -\u0026gt; int: n = len(coins) ls = [] for i in range(1, 1\u0026lt;\u0026lt;n): Lcm = 1 for j, x in enumerate(coins): if i\u0026gt;\u0026gt;j \u0026amp; 1: Lcm = lcm(Lcm, x) ls.append((1, Lcm)) if i.bit_count()\u0026amp;1 else ls.append((-1, Lcm)) l, r = 1, int(5e10) while l\u0026lt;r: mid = l+r\u0026gt;\u0026gt;1 cnt = 0 for sign, val in ls: cnt += sign*(mid//val) if cnt\u0026gt;=k: r = mid else: l = mid+1 return l 第四题3117. 划分数组得到最小的值之和 题目大意： 给定两个数组nums和andValues，长度分别为n和m。数组的值等于该数组的最后一个元素。需要将nums划分为m个不相交的连续子数组，对于第ith个子数组[li, ri]，子数组元素的按位AND运算结果等于andValues[i]。返回将nums划分为m个子数组所能得到的可能的最小子数组值之和。如果无法完成这样的划分，则返回-1。\n实现思路：\n使用动态规划来解决此问题，具体来说，可以采用递归加记忆化搜索的方法。 定义dfs函数用于递归求解，其中i表示当前处理到nums的第i个元素，j表示当前处理到andValues的第j个元素，k表示当前子数组的按位AND运算结果。 在dfs函数中，首先进行边界条件的判断，如果i等于n，表示nums已经处理完毕，则返回0（如果j等于m）或者正无穷（如果j不等于m）。 然后，对当前nums[i]进行按位AND运算，并更新k的值。如果更新后的k小于andValues[j]，则返回正无穷。 如果更新后的k等于andValues[j]，则递归调用dfs函数继续处理下一个元素，同时更新i和j，并将k重置为-1。递归调用的结果加上nums[i]的值即为当前划分情况的子数组值之和。 最后，返回所有划分情况中的最小值作为答案，如果答案为正无穷，则返回-1。 这种方法利用了递归和记忆化搜索的思想，避免了重复计算，提高了效率。\nclass Solution: def minimumValueSum(self, nums: List[int], andValues: List[int]) -\u0026gt; int: n = len(nums) m = len(andValues) @cache def dfs(i, j, k): if i==n: return 0 if j==m else inf if j==m: return inf k\u0026amp;=nums[i] if k\u0026lt;andValues[j]: return inf res = dfs(i+1, j, k) if k==andValues[j]: res = min(res, dfs(i+1, j+1, -1)+nums[i]) return res ans = dfs(0, 0, -1) return ans if ans\u0026lt;inf else -1 ","permalink":"https://kennems.github.io/posts/tech/leetcode%E7%AC%AC-393-%E5%9C%BA%E5%91%A8%E8%B5%9B/","summary":"LeetCode第 393 场周赛 第三题3116. 单面值组合的第 K 小金额 题目大意： 给定一个整数数组coins表示不同面额的硬币，另给定一个整数k。你","title":"LeetCode周赛240414"},{"content":"进阶课程(1) OOP static 静态， 可以修饰成员变量，成员方法 成员变量按照有无static修饰，分为两种 类变量 ： 有static修饰，属于类，在计算机里只有一份，会被类的全部对象共享 实例变量（对象的变量）：无static修饰，属于每个对象 // 类变量推荐赋值方式 Student.name = \u0026#34;Java\u0026#34;; // 不推荐赋值方式 Student s1 = new Student(); s1.name = \u0026#34;True Java\u0026#34;; Student s2 = new Student(); s2.name = \u0026#34;False Java\u0026#34;; System.out.println(s2.name); //False Java System.out.println(Student.name); //False Java // 成员变量 s1.age = 25; s2.age = 15; System.out.println(s1.age); //25 System.out.println(s2.age); //15 //User类 public static int number; public User(){ number+=1; //类中访问自己的变量可以不写 User(). } //Test类 public static void main(String[] args) { User u1 = new User(); User u2 = new User(); User u3 = new User(); System.out.println(User.number); //3 } 类方法：有static修饰的成员方法，属于类。 实例方法：无static修饰的成员方法，属于对象 //Student double score; public static void printHelloWorld(){ System.out.println(\u0026#34;Hello World\u0026#34;); System.out.println(\u0026#34;Hello World\u0026#34;); } public void printPass(){ System.out.println(\u0026#34;成绩：\u0026#34; + (score \u0026gt;= 60 ? \u0026#34;及格\u0026#34; : \u0026#34;不及格\u0026#34;)); } //Test Student.printHelloWorld();//Hello World Hello World Student s = new Student(); s.score = 100; s.printPass(); //成绩：及格 类方法的常见应用案例 类方法最常见的应用场景是做工具类 工具类：工具类中的方法都是一些类方法，每个方法都是用来完成一个功能的，工具类是给开发人员共同使用的\n可以提高代码复用性：调用方便，提高了开发效率\n使用类方法、实例方法时的几点注意事项\n类方法中可以直接访问类的成员，不可以直接访问实例成员 实例方法中既可以直接访问类成员，也可以直接访问实例成员 实例方法中可以出现this关键字，类方法中不可以出现this关键字 代码块 静态代码块 格式 ： static{ } 特点：类加载时自动执行，由于类只会加载一次，所以静态代码块只会执行一次 作用：完成类的初始化，例如：对类变量的初始化赋值 实例代码块： 格式：{ } 特点：每次创建对象时，执行实例代码块，并在构造器前执行 作用：和构造器一样，都是用来完成对象的初始化的，例如：对实例变量进行初始化赋值 单例设计模式 设计模式（Design pattern） 就是解决问题的最优解。\n单例设计模式：确保一个类只有一个对象\n饿汉式单例类\n把类的构造器私有 定义一个类变量记为类的一个对象 定义一个类方法，返回对象 public class A { private static A a = new A(); private A(){ } public static A getObject(){ return a; } } 继承 继承的好处：减少重复代码的编写\npublic class people { private String name; public String getName(){ return this.name; } public void setName(String name){ this.name = name; } } public class teacher extends people{ private String skill; public String getSkill() { return skill; } public void setSkill(String skill) { this.skill = skill; } public void printInfo(){ System.out.println(getName() + \u0026#34;具备的技能 ： \u0026#34; + skill); } } public class Test { public static void main(String[] args) { teacher t1 = new teacher(); t1.setName(\u0026#34;Kennem\u0026#34;); t1.setSkill(\u0026#34;Java\u0026#34;); System.out.println(t1.getName()); //Kennem System.out.println(t1.getSkill()); //Java t1.printInfo(); //Kennem具备的技能 ： Java } } 继承的注意事项：\n权限修饰符 单继承，Object类 方法重写 子类中访问其他成员的特点 子类构造器的特点 注意事项的小结 修饰符 本类中 同一个包下的其他类继承 任意包下的子类继承 任意包下的任何类继承 private ✓ 缺省 ✓ ✓ protected ✓ ✓ ✓ public ✓ ✓ ✓ ✓ 注意：用protected修饰，只能在子类中访问，而不是子类的对象访问\n单继承 Java不支持多继承，支持多层继承\nObject类 Object类是任何类的父类。\n方法重写 重写注意事项\n使用Override注解\n@Override public void print(){ System.out.println(\u0026#34;88888888\u0026#34;); } @Override public void print2(){ System.out.println(\u0026#34;8\u0026#34;); } 子类复写父类方法时，访问权限必须大于或者等于父类该方法的权限（publc -\u0026gt; protected -\u0026gt; 缺省）\n重写的方法返回值类型，必须与被重写方法的返回值类型一致，或者范围更小\n私有方法、静态方法不能被重写\n声明不变，重新实现\ntoString()方法重写\n@Override public String toString() { return \u0026#34;Student{\u0026#34; + \u0026#34;name=\u0026#39;\u0026#34; + name + \u0026#39;\\\u0026#39;\u0026#39; + \u0026#34;, age=\u0026#34; + age + \u0026#39;}\u0026#39;; } 子列构造器的特点：\n子类的全部构造器，都会先调用父类的构造器，再执行自己的构造器。 子类构造器是符合实现调用父类构造器的： 默认情况下，子类全部构造器的第一行都是super()（默认都有），它会调用父类的无参数构造器。 如果父类没有无参数构造器，则我们必须再子类构造器的第一行手写super(...)， 指定去调用父类的有参数构造器。 class Student extends People{ private String skill; public Student(String name, int age, String skill){ super(name, age); //调用父类的有参构造器 父类中name和age构造器 this.skill = skill; } public String getSkill() { return skill; } public void setSkill(String skill) { this.skill = skill; } } 补充知识：this(...)调用兄弟构造器\n任意类的构造器中，是可以通过this(...)去调用该类的其他构造器的。 this(...) 和 super(...) 使用时的注意事项 this(...)、super(...)都只能放在构造器的第一行，因此，有了this(...)就不能写super(...)了，反之亦然 public Boy(String name, int age) { this(name, age, \u0026#34;黑马程序员\u0026#34;); } public Boy(String name, int age, String schoolName) { this.name = name; this.age = age; this.schoolName = schoolName; } 多态 多态是在继承/实现情况下的一种现象，表现为：对象多态，行为多态。\n在多态形式下，右边对象是解耦合的，更偏于扩展和维护。 public class People { public String name = \u0026#34;我是人\u0026#34;; public void run(){ System.out.println(\u0026#34;人可以跑\u0026#34;); } } public class Student extends People{ public String name = \u0026#34;我是学生\u0026#34;; @Override public void run() { System.out.println(\u0026#34;学生跑得很快！\u0026#34;); } public void test(){ System.out.println(\u0026#34;学生要考试...\u0026#34;); } } public class Teacher extends People{ public String name = \u0026#34;我是老师\u0026#34;; @Override public void run() { System.out.println(\u0026#34;老师跑的气喘吁吁！\u0026#34;); } } public class Test { public static void main(String[] args) { People p = new People(); System.out.println(p.name); People p1 = new Student(); System.out.println(p1.name); p1.run(); //编译看父类， 运行看子类 People p2 = new Teacher(); System.out.println(p2.name); p2.run(); } } if(p instanceof Student){ Student s = (Student) p; s.test(); }else if(p instanceof Teacher){ Teacher t = (Teacher) p; t.work(); } public class People { public String name = \u0026#34;我是人\u0026#34;; public void run(){ System.out.println(\u0026#34;人可以跑\u0026#34;); } } public class Student extends People { public String name = \u0026#34;我是学生\u0026#34;; @Override public void run() { System.out.println(\u0026#34;学生跑得很快！\u0026#34;); } public void test(){ System.out.println(\u0026#34;学生要考试\u0026#34;); } } public class Teacher extends People { public String name = \u0026#34;我是老师\u0026#34;; @Override public void run() { System.out.println(\u0026#34;老师跑的气喘吁吁！\u0026#34;); } public void work(){ System.out.println(\u0026#34;老师要上班\u0026#34;); } } final final关键字是最终的意思，可以修饰（类， 方法， 变量） 修饰类：该类被成为最终类，特点是不能被继承了 修饰方法：该方法被称为最终方法，特点是不能被重写了 修饰变量：该变量只能被赋值一次 public class Test { // 3.常量，建议名称全部大写，多个单词下划线连接 public static final String CURRENT_NAME = \u0026#34;Kennem\u0026#34;; public static void main(String[] args) { // final double pi = 3.14; //pi = 3.1; 报错，final修饰的变量不能修改 final int[] arr = {11, 22, 33}; arr[1] = 13; // 4.final修饰的地址不能变，但地址内的内容可以变 } } final class A{ // 1.final 修饰类，类不能被继承了 } // 2.final 修饰方法，方法不能被重写了 class C{ public final void test(){ } } class D extends C{ } 常量 使用了static final修饰的成员变量被称为常量\n作用：通常用于记录系统的配置信息\n使用常量记录系统配置信息的优势，执行原理\n代码可读性更好，可维护性也更好 程序编译后，常量会被\u0026quot;宏替换\u0026quot;；出现常量的地方全部会被替换成其记住的字面量，这样可以保证使用常量和直接用字面量的性能是一样的。 抽象类 public abstract class A { private String name; public static String schoolName; public abstract void run(); } public class B extends A{ @Override public void run() { System.out.println(\u0026#34;run\u0026#34;); } } 抽象类的好处：\n父类知道每个子类都要做某个行为，但每个子类要做的情况不一样，父类就定义成抽象方法，交给子类去重写实现，我们设计这样的抽象类，就是为了更好的支持多态。 抽象类可以制作模板类\n模板类 public abstract class People { public abstract String write(); public final void WriteOn(){ System.out.println(\u0026#34;\\t\\t今天是2023/04/14\u0026#34;); System.out.println(\u0026#34;\\t身份:\u0026#34;); System.out.println(write()); System.out.println(\u0026#34;以上就是我发表的内容\u0026#34;); System.out.println(\u0026#34;\\t\\t感谢大家！\u0026#34;); } } public class Teacher extends People { @Override public String write() { //只用重写每个类中需要不同实现的方法即可 return \u0026#34;我是老师，这里是老师类\u0026#34;; } } public class Student extends People { @Override public String write() { return \u0026#34;我是学生，这里是学生类\u0026#34;; } } public class Test { public static void main(String[] args) { Teacher t = new Teacher(); t.WriteOn(); Student s = new Student(); s.WriteOn(); } } 建议使用final关键字修饰模板类\n模板方法是给对象直接使用的不能被修改 一旦子类重写了模板方法，模板方法就失效了 接口 Java提供了一个关键字interface public class Test { public static void main(String[] args) { Driver d = new A(); d.drive(); } } class A extends Student implements Driver, Singer{ @Override public void drive() { } @Override public void sing() { } } class Student{ } interface Driver{ void drive(); } interface Singer{ void sing(); } 接口的好处：\n可以解决类单继承的问题，通过接口， 可以让一个类有一个继承父类的同时，还可以去找多个接口去拓展自己的功能 因为通过接口可以显性的知道你是谁 一个类可以实现多个接口，同样，一个接口也可以被多个类实现，这样的好处是我们的程序可以面向接口编程了，这样程序员就可以很方便的灵活切换各种业务实现了。 接口的综合案例:\n使用接口(StudentOperator)之后，在不同的继承接口的类(StudentOperatorImpl1, StudentOperatorImpl2)里面编写不同的程序，用接口对象实现操作时，仅需要改变不同的实现类即可。\n接口的其他方法 public class Student { private String name; private char sex; private int score; public Student() { } } public interface StudentOperator { void printInfo(ArrayList\u0026lt;Student\u0026gt; students); void printAverageScore(ArrayList\u0026lt;Student\u0026gt; students); } public class StudentOperatorImpl1 implements StudentOperator{ @Override public void printInfo(ArrayList\u0026lt;Student\u0026gt; students) { System.out.println(\u0026#34;==全班全部信息如下==\u0026#34;); for (int i = 0; i \u0026lt; students.size(); i++) { Student s = students.get(i); System.out.println(\u0026#34;姓名为 ： \u0026#34; + s.getName() + \u0026#34;, 性别为 ： \u0026#34; + s.getSex() + \u0026#34;, 得分为 ： \u0026#34; + s.getScore()); } System.out.println(\u0026#34;-------------------\u0026#34;); } @Override public void printAverageScore(ArrayList\u0026lt;Student\u0026gt; students) { double total = 0; for (int i = 0; i \u0026lt; students.size(); i++) { Student s = students.get(i); total += s.getScore(); } System.out.println(\u0026#34;班级平均分为 ： \u0026#34; + (total/(students.size()))); } } public class StudentOperatorImpl2 implements StudentOperator{ @Override public void printInfo(ArrayList\u0026lt;Student\u0026gt; students) { System.out.println(\u0026#34;==全班全部信息如下==\u0026#34;); int count1 = 0; for (int i = 0; i \u0026lt; students.size(); i++) { Student s = students.get(i); System.out.println(\u0026#34;姓名为 ： \u0026#34; + s.getName() + \u0026#34;, 性别为 ： \u0026#34; + s.getSex() + \u0026#34;, 得分为 ： \u0026#34; + s.getScore()); if(s.getSex()==\u0026#39;男\u0026#39;){ count1+=1; } } System.out.println(\u0026#34;男生人数为 ： \u0026#34; + count1 + \u0026#34;, 女生人数为 ： \u0026#34; + (students.size()-count1)); System.out.println(\u0026#34;班级总人数为 : \u0026#34; + (students.size())); System.out.println(\u0026#34;-------------------\u0026#34;); } @Override public void printAverageScore(ArrayList\u0026lt;Student\u0026gt; students) { double total = 0; double max = students.get(0).getScore(); double min = students.get(0).getScore(); for (int i = 0; i \u0026lt; students.size(); i++) { Student s = students.get(i); total += s.getScore(); if(s.getScore()\u0026gt;max){ max = s.getScore(); } else if(s.getScore()\u0026lt;min){ min = s.getScore(); } } System.out.println(\u0026#34;学生的最高分为 ： \u0026#34; + max + \u0026#34;, 学生的最低分为\u0026#34; + min); System.out.println(\u0026#34;去除最低分和最高分后，班级平均分为 ： \u0026#34; + (total/(students.size()))); } } public class ClassManagement { private ArrayList\u0026lt;Student\u0026gt; students = new ArrayList\u0026lt;\u0026gt;(); StudentOperator so = new StudentOperatorImpl2(); public ClassManagement() { students.add(new Student(\u0026#34;小明\u0026#34;, \u0026#39;男\u0026#39;, 99)); students.add(new Student(\u0026#34;小黄\u0026#34;, \u0026#39;女\u0026#39;, 100)); students.add(new Student(\u0026#34;小白\u0026#34;, \u0026#39;男\u0026#39;, 94)); students.add(new Student(\u0026#34;小亮\u0026#34;, \u0026#39;女\u0026#39;, 90)); } public void printInfo(){ so.printInfo(students); } public void printScore(){ so.printAverageScore(students); } } public class Test { public static void main(String[] args) { ClassManagement cm = new ClassManagement(); cm.printInfo(); cm.printScore(); } } 接口的其他方法：\n/** 1. 默认方法：必须使用 default 修饰，默认会被 public 修饰 * */ default void test1(){ System.out.println(\u0026#34;===默认方法===\u0026#34;); test2(); } /** 2. 私有方法：必须使用 private 修饰，（JDK9开始支持） * 实例方法对象的方法 */ private void test2(){ System.out.println(\u0026#34;===私有方法===\u0026#34;); } /** * 3. 静态方法，必须使用 static 修饰，默认会被 public 修饰 */ public static void test3(){ System.out.println(\u0026#34;===静态方法===\u0026#34;); } 接口的多继承 一个接口可以同时继承多个接口\n一个接口继承多个接口，如果多个接口中存在方法名冲突，则此时不支持多继承\ninterface I{ void test1(); } interface J{ void test1(); } interface C implements I, J{ //报错 } 一个类实现多个接口，如果多个接口存在方法名冲突，则此时不支持多实现\ninterface I{ void test1(); } interface J{ void test1(); } class C implements I, J{ //报错 } 一个类继承了父类，又实现了接口，父类中和接口中有同名的默认方法，实现类会优先使用父类的\nclass Fu{ public void run(){ System.out.println(\u0026#34;===父类的run方法执行了\u0026#34;); } } interface IT{ default void run(){ System.out.println(\u0026#34;===接口IT中的run方法执行了\u0026#34;); } } class Zi extends Fu implements IT{ } public class Demo2 { public static void main(String[] args) { Zi zi = new Zi(); zi.run(); //===父类的run方法执行了 } } 一个类实现多个接口，多个接口中存在同名的默认方法，可以不冲突， 这个类重写该方法即可\ninterface I{ void test1(); } interface J{ void test1(); } //interface C implements I, J{ //报错 // //} class C implements I, J{ @Override public void test1() { } //重写后不会报错 } 内部类 成员内部类 public class Outer { private String outerName; private int age=88; public static int outerNumber; public class Inner{ private String name; public static int number; // JDK16才开始支持 private int age=99; public void test(){ } public void test2(){ System.out.println(outerName); System.out.println(outerNumber); int age = 66; System.out.println(age); System.out.println(this.age); System.out.println(Outer.this.age); } public Inner() { System.out.println(\u0026#34;Inner has been created.\u0026#34;); } public String getName() { return name; } public void setName(String name) { this.name = name; } public static int getNumber() { return number; } public static void setNumber(int number) { Inner.number = number; } } } public static void main(String[] args) { Outer.Inner in = new Outer().new Inner(); in.test2(); /** * Inner has been created. * null * 0 * 66 * 99 * 88 */ } 静态内部类 可以直接访问外部类的静态变量，而不能访问外部类的实例变量\npublic class StaticInner { private String name; // 实例变量，只能由外部对象来访问 public static int age; // 静态变量，可以由类名直接访问 // 静态内部类 public static class Inner { // 在静态内部类中访问外部类的静态变量是合法的 public void test() { System.out.println(age); // 无法在静态内部类中直接访问外部类的实例变量，会导致编译错误 //System.out.println(name); } } } 局部内部类：定义在方法，代码块，构造器中。\n匿名内部类 创建一个类的实例的一种方式，同时定义并实现该类。\npublic class Demo1 { public static void main(String[] args) { Animal cat = new Animal(){ //cat类可以不用单另新创建，实现的同时定义该类即可 @Override public void cry() { System.out.println(\u0026#34;猫喵喵喵的叫~~\u0026#34;); } }; cat.cry(); } } // 用抽象方法实现匿名内部类 abstract class Animal{ public abstract void cry(); } public class Demo2 { public static void main(String[] args) { go(new Swimming() { @Override public void swim() { System.out.println(\u0026#34;狗游的很快！\u0026#34;); } }); } public static void go(Swimming s){ System.out.println(\u0026#34;===GO====\u0026#34;); s.swim(); } } // 用接口实现匿名内部类 interface Swimming{ void swim(); } public class Demo3 { public static void main(String[] args) { JFrame win = new JFrame(\u0026#34;登录界面\u0026#34;); JPanel panel = new JPanel(); win.add(panel); JButton btn = new JButton(\u0026#34;登录\u0026#34;); panel.add(btn); //匿名内部类的实际使用场景 btn.addActionListener(new ActionListener() { @Override public void actionPerformed(ActionEvent e) { JOptionPane.showConfirmDialog(win, \u0026#34;你点击了登录按钮\u0026#34;); } }); win.setSize(400, 800); win.setLocationRelativeTo(null); win.setDefaultCloseOperation(WindowConstants.EXIT_ON_CLOSE); win.setVisible(true); } } 枚举 枚举是一种特殊的类\n枚举类的第一行，只能写一些合法的标识符（名称）， 多个名称用逗号隔开 这些名称，本质是常量，每个常量都会记住枚举类的一个对象 public enum A { X, Y, Z; private String name; public String getName() { return name; } public void setName(String name) { this.name = name; } } public class Test { public static void main(String[] args) { A a1 = A.X; System.out.println(a1); //X A a2 = A.Y; A[] as = A.values(); System.out.println(as); //[Lcom.showguan.Enum.A;@3b07d329 A a3 = A.valueOf(\u0026#34;Z\u0026#34;); System.out.println(a3); //Z System.out.println(a3.ordinal()); //2 次序 } } 枚举类的特点：\n枚举类的第一行只能罗列一些名称，这些名称都是常量，并且每个常量记住的都是枚举类的一个对象 枚举都是最终类，不可以被继承 枚举类中，从第二行开始，可以定义类的其他各种成员 编译器为枚举类新增了几个方法，并且枚举类都是继承 ：java.lang.Enum类的，从enum类也会继承到一些方法 枚举的实际作用：\npublic enum Constant2 { BOY, GIRL; } public static void check(Constant2 sex) { switch (sex) { case BOY: System.out.println(\u0026#34;你是个男孩！\u0026#34;); break; case GIRL: System.out.println(\u0026#34;你是个女孩！\u0026#34;); break; } } public static void main(String[] args) { check(Constant2.BOY); } 泛型 定义类，接口，方法时，同时声明一个或者多个类型变量（如\u0026lt;E\u0026gt;)，成为泛型类，泛型接口，泛型方法，它们统称为泛型。 public class Test { public static void main(String[] args) { ArrayList list = new ArrayList(); list.add(\u0026#34;Java1\u0026#34;); list.add(\u0026#34;Java2\u0026#34;); list.add(\u0026#34;Java3\u0026#34;); list.add(new Cat()); for (int i = 0; i \u0026lt; list.size(); i++) { // Object o = list.get(i); // String s = (String) list.get(i); //报错 Cat()对象时Object类型，不能转换成String类型 // System.out.println(s); } ArrayList\u0026lt;String\u0026gt; list2 = new ArrayList(); //泛型为String list2.add(\u0026#34;Java1\u0026#34;); list2.add(\u0026#34;Java2\u0026#34;); list2.add(\u0026#34;Java3\u0026#34;); // list2.add(new Cat()); //在编译阶段就限制添加对象的类型 ArrayList\u0026lt;Cat\u0026gt; list3 = new ArrayList(); //泛型为Cat() } } 拓展:\npublic class MyArrayList\u0026lt;E, T\u0026gt; //可以多个类型 public class MyArrayList\u0026lt;E, T extends Animal\u0026gt; //指定类型需要继承某个类 泛型接口 public interface Data\u0026lt;E\u0026gt;{ void get(E e); ArrayList\u0026lt;E\u0026gt; getName(String name); } public class TeacherData implements Data\u0026lt;Teacher\u0026gt;{ //指定泛型类型后，重写的方法都会自动换成该类型 @Override public void get(Teacher teacher) { } @Override public ArrayList\u0026lt;Teacher\u0026gt; getName(String name) { return null; } } 使用通配符 ?\npublic static void main(String[] args) { System.out.println(test(\u0026#34;Java\u0026#34;)); Dog d = test(new Dog()); ArrayList\u0026lt;Car\u0026gt; cars = new ArrayList\u0026lt;\u0026gt;(); cars.add(new Car()); cars.add(new Car()); cars.add(new Car()); go(cars); ArrayList\u0026lt;BMW\u0026gt; bmws = new ArrayList\u0026lt;\u0026gt;(); bmws.add(new BMW()); bmws.add(new BMW()); bmws.add(new BMW()); bmws.add(new BMW()); go(bmws); ArrayList\u0026lt;BENZ\u0026gt; benzs = new ArrayList\u0026lt;\u0026gt;(); benzs.add(new BENZ()); benzs.add(new BENZ()); benzs.add(new BENZ()); go(benzs); } public static \u0026lt;T\u0026gt; T test(T t){ return t; } public static void go(ArrayList\u0026lt;? extends Car\u0026gt; cars){ } } API toString()方法和equals() @Override public String toString() { return \u0026#34;Student{\u0026#34; + \u0026#34;name=\u0026#39;\u0026#34; + name + \u0026#39;\\\u0026#39;\u0026#39; + \u0026#34;, age=\u0026#34; + age + \u0026#39;}\u0026#39;; } @Override public boolean equals(Object o) { if (this == o) return true; if (o == null || getClass() != o.getClass()) return false; Student student = (Student) o; return age == student.age \u0026amp;\u0026amp; Objects.equals(name, student.name); } clone() public static void main(String[] args) throws CloneNotSupportedException { Student s1 = new Student(\u0026#34;Kennem\u0026#34;, 21, new double[]{0.0}); System.out.println(s1.toString()); System.out.println(s1.getName()); System.out.println(s1.getAge()); System.out.println(s1); System.out.println(s1.getClass()); System.out.println(s1.getScores()); /** * Student{name=\u0026#39;Kennem\u0026#39;, age=21} * Kennem * 21 * Student{name=\u0026#39;Kennem\u0026#39;, age=21} * class com.showguan.APIObject.Student * [D@27d6c5e0 */ Student s2 = new Student(\u0026#34;Kennem\u0026#34;, 21, new double[]{0.0}); System.out.println(s1.equals(s2)); //true Student s3 = (Student) s1.clone(); System.out.println(s3.getName()); System.out.println(s3.getAge()); System.out.println(s3); System.out.println(s3.getClass()); System.out.println(s3.getScores()); /** * Kennem * 21 * Student{name=\u0026#39;Kennem\u0026#39;, age=21} * class com.showguan.APIObject.Student * [D@4f3f5b24 */ } @Override protected Object clone() throws CloneNotSupportedException { Student tmp = (Student) super.clone(); tmp.scores = tmp.scores.clone(); return tmp; } Objects.\npublic static void main(String[] args) { String s1 = \u0026#34;Java\u0026#34;; String s2 = null; System.out.println(s1.equals(s2)); // System.out.println(s2.equals(s1)); //空指针异常 System.out.println(Objects.equals(s1, s2)); //防止空指针异常 System.out.println(Objects.isNull(s1)); //false System.out.println(Objects.nonNull(s1)); //true System.out.println(Objects.isNull(s2)); //true System.out.println(Objects.nonNull(s2)); //false } 包装类 public static void main(String[] args) { Integer a = Integer.valueOf(12); Integer b = 12; int c = b; ArrayList\u0026lt;Integer\u0026gt; arr = new ArrayList\u0026lt;\u0026gt;(); arr.add(12); arr.add(10); arr.get(1); Integer d = 25; String s1 = Integer.toString(d); System.out.println(s1); String s2 = d.toString(); String s3 = d + \u0026#34;\u0026#34;; System.out.println(s2); System.out.println(s3); String s4 = \u0026#34;29\u0026#34;; // int age = Integer.parseInt(s4); int age = Integer.valueOf(s4); System.out.println(age); String s5 = \u0026#34;99.9\u0026#34;; // double score = Double.parseDouble(s5); double score = Double.valueOf(s5); System.out.println(score+0.1); } StringBuilder 适合多次拼接，修改\npublic static void main(String[] args) { StringBuilder s = new StringBuilder(); s.append(\u0026#34;Java\u0026#34;); s.append(\u0026#34;666\u0026#34;).append(\u0026#34;888\u0026#34;).append(\u0026#34;999\u0026#34;); System.out.println(s); s.reverse(); System.out.println(s); System.out.println(s.length()); String ss = s.toString(); System.out.println(ss); /** * Java666888999 * 999888666avaJ * 13 * 999888666avaJ */ } StringBuffer方法和StringBuilder类似，但是是线程安全的，而StringBuilder是线程不安全的\nStringJoiner StringJoiner sj = new StringJoiner(\u0026#34;,\u0026#34;, \u0026#34;[\u0026#34;, \u0026#34;]\u0026#34;); sj.add(\u0026#34;1\u0026#34;); sj.add(\u0026#34;2\u0026#34;); sj.add(\u0026#34;3\u0026#34;); sj.add(\u0026#34;4\u0026#34;); System.out.println(sj); System public class Main { public static void main(String[] args) { // 主函数入口 // 以下代码块被注释掉，使用 System.exit(0) 可以立即终止程序的执行 // System.exit(0); // 打印分隔线 System.out.println(\u0026#34;----------------\u0026#34;); // 以下代码块被注释掉，用于打印当前时间的毫秒表示 // System.out.println(System.currentTimeMillis()); // 记录程序开始时间 long t1 = System.currentTimeMillis(); // 初始化一个空字符串 String s = \u0026#34;\u0026#34;; // 循环将字符串\u0026#34;abc\u0026#34;追加到字符串s中，重复200000次 for (int i = 0; i \u0026lt; 200000; i++) { s += \u0026#34;abc\u0026#34;; } // 记录程序结束时间 long t2 = System.currentTimeMillis(); // 计算程序执行时间并将结果以秒为单位打印出来 System.out.println((t2 - t1) / 1000.0 + \u0026#34;s\u0026#34;); //4.656s } } BigDecimal public class Main { public static void main(String[] args) { // 主函数入口 // 使用双精度浮点数进行运算 double a = 0.1; double b = 0.2; double c = a + b; // 直接相加 System.out.println(c); // 输出结果 // 使用 BigDecimal 类进行精确运算 BigDecimal a1 = BigDecimal.valueOf(a); // 将双精度浮点数转换为 BigDecimal 类型 BigDecimal b1 = BigDecimal.valueOf(b); // 使用 BigDecimal 的 multiply 方法进行乘法运算 BigDecimal c1 = a1.multiply(b1); System.out.println(c1); // 输出结果 // 使用 BigDecimal 的 add 方法进行加法运算 BigDecimal c2 = a1.add(b1); System.out.println(c2); // 输出结果 // 使用 BigDecimal 的 subtract 方法进行减法运算 BigDecimal c3 = a1.subtract(b1); System.out.println(c3); // 输出结果 // 使用 BigDecimal 的 divide 方法进行除法运算 BigDecimal c4 = a1.divide(b1); System.out.println(c4); // 输出结果 // 使用 BigDecimal 进行除法运算，并设置精确度和舍入模式 BigDecimal i = BigDecimal.valueOf(0.1); BigDecimal j = BigDecimal.valueOf(0.3); BigDecimal k = i.divide(j, 2, RoundingMode.HALF_UP); // 设置精确度为2位小数，采用四舍五入模式 System.out.println(k); // 输出结果，0.33 } } Date parse方法和format方法\nimport java.text.ParseException; import java.text.SimpleDateFormat; import java.util.Date; public class DateFormatExample { public static void main(String[] args) { // 创建一个日期对象 Date d = new Date(); // 定义日期格式 SimpleDateFormat sdf = new SimpleDateFormat(\u0026#34;yyyy年MM月dd日 HH:mm:ss EEE a\u0026#34;); // 格式化当前日期并输出 String rs = sdf.format(d); System.out.println(\u0026#34;当前日期格式化输出: \u0026#34; + rs); // 再次格式化当前日期并输出（可以省略此步骤，仅为展示） String rs2 = sdf.format(d); System.out.println(\u0026#34;再次格式化当前日期: \u0026#34; + rs2); // 将字符串解析为日期对象 String dateStr = \u0026#34;2022-12-12 12:12:11\u0026#34;; SimpleDateFormat sdf2 = new SimpleDateFormat(\u0026#34;yyyy-MM-dd HH:mm:ss\u0026#34;); try { Date d2 = sdf2.parse(dateStr); System.out.println(\u0026#34;解析后的日期: \u0026#34; + d2); } catch (ParseException e) { e.printStackTrace(); } } } public static void main(String[] args) throws ParseException { String start = \u0026#34;2024年12月12日 00:00:00\u0026#34;; String end = \u0026#34;2024年12月12日 00:10:00\u0026#34;; String xj = \u0026#34;2024年12月12日 00:01:18\u0026#34;; String xp = \u0026#34;2024年12月12日 00:10:57\u0026#34;; SimpleDateFormat sdf = new SimpleDateFormat(\u0026#34;yyyy年MM月dd日 HH:mm:ss\u0026#34;); Date startDt = sdf.parse(start); Date endDt = sdf.parse(end); Date xjDt = sdf.parse(xj); Date xpDt = sdf.parse(xp); long startTime = startDt.getTime(); long endTime = endDt.getTime(); long xjTime = xjDt.getTime(); long xpTime = xpDt.getTime(); if(xjTime\u0026gt;=startTime \u0026amp;\u0026amp; xjTime\u0026lt;=endTime){ System.out.println(\u0026#34;小贾你秒杀成功了\u0026#34;); }else{ System.out.println(\u0026#34;小贾你秒杀失败了\u0026#34;); } if(xpTime\u0026gt;=startTime \u0026amp;\u0026amp; xpTime\u0026lt;=endTime){ System.out.println(\u0026#34;小皮你秒杀成功了\u0026#34;); }else{ System.out.println(\u0026#34;小皮你秒杀失败了\u0026#34;); } } Calendar public class Main { public static void main(String[] args) { // 获取当前日期和时间的 Calendar 对象 Calendar now = Calendar.getInstance(); System.out.println(\u0026#34;当前日期和时间：\u0026#34; + now); // 获取当前年份 int year = now.get(Calendar.YEAR); System.out.println(\u0026#34;当前年份：\u0026#34; + year); // 获取一年中的第几天 int days = now.get(Calendar.DAY_OF_YEAR); System.out.println(\u0026#34;一年中的第几天：\u0026#34; + days); // 获取Date对象 Date d = now.getTime(); System.out.println(\u0026#34;Date对象：\u0026#34; + d); // 获取时间戳 long time = now.getTimeInMillis(); System.out.println(\u0026#34;时间戳：\u0026#34; + time); // 设置月份为4月，日期为4月1日 now.set(Calendar.MONTH, Calendar.APRIL); now.set(Calendar.DAY_OF_MONTH, 1); System.out.println(\u0026#34;设置后的日期：\u0026#34; + now.getTime()); // 获取设置后的日期 Date d1 = now.getTime(); System.out.println(\u0026#34;设置后的Date对象：\u0026#34; + d1); // 增加105天 now.add(Calendar.DAY_OF_YEAR, 105); Date d2 = now.getTime(); System.out.println(\u0026#34;增加105天后的日期：\u0026#34; + d2); } } JDK之后新增的时间\n设计更合理，功能丰富，使用更方便 都是不可变对象，修改后会返回新的实践对象，不会丢失最开始的时间 线程安全 能精确到毫秒、纳秒 LocalDate， LocalTime, LocalDateTime LocalDate public static void main(String[] args) { // 获取当前日期 LocalDate ld = LocalDate.now(); System.out.println(ld); // 获取日期的年、月、日、年中的第几天、星期几等信息 int year = ld.getYear(); int month = ld.getMonthValue(); int day = ld.getDayOfMonth(); int dayOfYear = ld.getDayOfYear(); int dayOfWeek = ld.getDayOfWeek().getValue(); System.out.println(year); System.out.println(month); System.out.println(day); System.out.println(dayOfYear); System.out.println(dayOfWeek); // 使用 with 方法设置日期的年、月 LocalDate ld2 = ld.withYear(2077); LocalDate ld3 = ld.withMonth(11); System.out.println(ld2); System.out.println(ld3); // 使用 plus 方法增加日期的天数、月数 LocalDate ld4 = ld.plusDays(2); LocalDate ld5 = ld.plusMonths(3); // 使用 minus 方法减少日期的天数、月数 LocalDate ld6 = ld.minusDays(10); LocalDate ld7 = ld.minusMonths(2); // 使用 of 方法创建指定日期的 LocalDate 对象 LocalDate ld8 = LocalDate.of(2077, 12, 12); // 使用 equals、isAfter、isBefore 方法比较日期 System.out.println(ld5.equals(ld6)); System.out.println(ld5.isAfter(ld6)); System.out.println(ld5.isBefore(ld6)); } LocalTime public static void main(String[] args) { // 0、获取本地时间对象 LocalTime lt = LocalTime.now(); // 获取当前时间 System.out.println(lt); // 1、获取时间中的信息 int hour = lt.getHour(); // 获取小时 int minute = lt.getMinute(); // 获取分钟 int second = lt.getSecond(); // 获取秒 int nano = lt.getNano(); // 获取纳秒 // 2、修改时间：withHour、withMinute、withSecond、withNano LocalTime lt3 = lt.withHour(10); // 设置小时为10 LocalTime lt4 = lt.withMinute(10); // 设置分钟为10 LocalTime lt5 = lt.withSecond(10); // 设置秒为10 LocalTime lt6 = lt.withNano(10); // 设置纳秒为10 // 3、加多少：plusHours、plusMinutes、plusSeconds、plusNanos LocalTime lt7 = lt.plusHours(10); // 增加10小时 LocalTime lt8 = lt.plusMinutes(10); // 增加10分钟 LocalTime lt9 = lt.plusSeconds(10); // 增加10秒 LocalTime lt10 = lt.plusNanos(10); // 增加10纳秒 // 4、减多少：minusHours、minusMinutes、minusSeconds、minusNanos LocalTime lt11 = lt.minusHours(10); // 减少10小时 LocalTime lt12 = lt.minusMinutes(10); // 减少10分钟 LocalTime lt13 = lt.minusSeconds(10); // 减少10秒 LocalTime lt14 = lt.minusNanos(10); // 减少10纳秒 // 5、获取指定时间的LocalTime对象： // public static LocalTime of(int hour, int minute, int second) LocalTime lt15 = LocalTime.of(12, 12, 12); // 创建指定时间的LocalTime对象 LocalTime lt16 = LocalTime.of(12, 12, 12); // 创建指定时间的LocalTime对象 // 6、判断2个时间对象，是否相等，在前还是在后： equals isBefore isAfter System.out.println(lt15.equals(lt16)); // 判断两个时间是否相等 System.out.println(lt15.isAfter(lt)); // 判断lt15是否在lt之后 System.out.println(lt15.isBefore(lt)); // 判断lt15是否在lt之前 } LocalDateTime public static void main(String[] args) { // 获取当前日期和时间 LocalDateTime ldt = LocalDateTime.now(); System.out.println(\u0026#34;当前日期和时间：\u0026#34; + ldt); // 获取日期和时间中的信息 int year = ldt.getYear(); // 年份 int month = ldt.getMonthValue(); // 月份 int day = ldt.getDayOfMonth(); // 日 int hour = ldt.getHour(); // 小时 int minute = ldt.getMinute(); // 分钟 int second = ldt.getSecond(); // 秒 int nano = ldt.getNano(); // 纳秒 System.out.println(\u0026#34;年份：\u0026#34; + year); System.out.println(\u0026#34;月份：\u0026#34; + month); System.out.println(\u0026#34;日：\u0026#34; + day); System.out.println(\u0026#34;小时：\u0026#34; + hour); System.out.println(\u0026#34;分钟：\u0026#34; + minute); System.out.println(\u0026#34;秒：\u0026#34; + second); System.out.println(\u0026#34;纳秒：\u0026#34; + nano); // 设置日期和时间 LocalDateTime ldt2 = ldt.withYear(2025) .withMonth(6) .withDayOfMonth(15) .withHour(18) .withMinute(30) .withSecond(0) .withNano(0); System.out.println(\u0026#34;修改后的日期和时间：\u0026#34; + ldt2); // 增加和减少日期和时间 LocalDateTime ldt3 = ldt.plusDays(10) .plusHours(2) .minusMinutes(15); System.out.println(\u0026#34;增加和减少后的日期和时间：\u0026#34; + ldt3); // 创建指定日期和时间的 LocalDateTime 对象 LocalDateTime ldt4 = LocalDateTime.of(2030, 12, 31, 23, 59, 59); System.out.println(\u0026#34;指定日期和时间：\u0026#34; + ldt4); // 判断两个 LocalDateTime 对象的关系 System.out.println(\u0026#34;当前日期和时间是否在指定日期和时间之后：\u0026#34; + ldt.isAfter(ldt4)); System.out.println(\u0026#34;当前日期和时间是否在指定日期和时间之前：\u0026#34; + ldt.isBefore(ldt4)); } Arrays 对于自定义对象的排序：\n@Override public int compareTo(Student o) { // if(this.age \u0026gt; o.age){ //左边大，正整数 // return 1; // } // else if(this.age \u0026lt; o.age){ //右边大， 负整数 // return -1; // } // return 0; //相等 0 return o.age-this.age; } @Override public String toString() { return \u0026#34;Student{\u0026#34; + \u0026#34;name=\u0026#39;\u0026#34; + name + \u0026#39;\\\u0026#39;\u0026#39; + \u0026#34;, height=\u0026#34; + height + \u0026#34;, age=\u0026#34; + age + \u0026#39;}\u0026#39;; } Student[] students = new Student[4]; students[0] = new Student(\u0026#34;Kenn\u0026#34;, 180, 21); students[1] = new Student(\u0026#34;ken\u0026#34;, 181, 22); students[2] = new Student(\u0026#34;ken\u0026#34;, 189, 22); students[3] = new Student(\u0026#34;k\u0026#34;, 168, 20); Arrays.sort(students); System.out.println(Arrays.toString(students)); Arrays.sort(students, new Comparator\u0026lt;Student\u0026gt;() { @Override public int compare(Student o1, Student o2) { return Integer.compare(o1.getAge(), o2.getAge()); } }); Lambda表达式 Lambda表达式只能简化函数式接口的匿名内部类！\n函数式接口：\n有且仅有一个抽象方法的接口 注意：将来见到的大部分函数式接口，上面都可能会有一个@FunctionalInterface的注解，有该注解的接口必定是函数式接口 // Arrays.sort(students, new Comparator\u0026lt;Student\u0026gt;() { // @Override // public int compare(Student o1, Student o2) { // return Integer.compare(o1.getAge(), o2.getAge()); // } // }); // Arrays.sort(students, (Student o1, Student o2) -\u0026gt;{ // return Double.compare(o1.getHeight(), o2.getHeight()); // }); Arrays.sort(students, (o1, o2) -\u0026gt; { return Double.compare(o1.getHeight(), o2.getHeight()); }); Arrays.sort(students, (o1, o2) -\u0026gt; Double.compare(o1.getHeight(), o2.getHeight())); // Arrays.setAll(prices, new IntToDoubleFunction() { // @Override // public double applyAsDouble(int value) { // return prices[value]*0.8; // } // }); // Arrays.setAll(prices, (int value) -\u0026gt; { // return prices[value]*0.8; // }); // Arrays.setAll(prices, value -\u0026gt; { // return prices[value]*0.8; // }); Arrays.setAll(prices, value -\u0026gt; prices[value]*0.8); 方法引用 方法引用是Java 8引入的一种简洁语法，允许我们使用现有的方法定义来创建Lambda表达式。这种方式使得代码更简洁、易读。方法引用可以看作是Lambda表达式的简化形式，主要用于增强代码的可读性和可维护性。\n静态方法的引用 静态方法引用用于引用类的静态方法。在这个例子中，我们引用了CompareByAge类的静态方法comparByAge。\n// CompareByAge.java public class CompareByAge { public static int comparByAge(Student o1, Student o2) { return o1.getAge() - o2.getAge(); } } // Test.java Student[] students = ... // 假设已经初始化的学生数组 // 使用Lambda表达式排序 Arrays.sort(students, (o1, o2) -\u0026gt; CompareByAge.comparByAge(o1, o2)); // 使用方法引用排序，与上面的作用相同 Arrays.sort(students, CompareByAge::comparByAge); 说明：通过使用CompareByAge::comparByAge方法引用，我们可以简化Lambda表达式。\n实例方法引用 实例方法引用用于引用某个特定对象的实例方法。在这个例子中，我们引用了CompareByHeight类的实例方法comparebyHeight。\npublic class CompareByHeight { public int comparebyHeight(Student o1, Student o2) { return (int) (o2.getHeight() - o1.getHeight()); } } // Test.java CompareByHeight cmpH = new CompareByHeight(); Student[] students = ... // 假设已经初始化的学生数组 // 使用Lambda表达式排序 Arrays.sort(students, (o1, o2) -\u0026gt; cmpH.comparebyHeight(o1, o2)); // 使用方法引用排序，与上面的作用相同 Arrays.sort(students, cmpH::comparebyHeight); 说明：通过使用cmpH::comparebyHeight方法引用，我们可以简化Lambda表达式。\n特定类型的方法引用 特定类型的方法引用用于引用某个特定类型的实例方法。在这个例子中，我们引用了String类的实例方法compareToIgnoreCase。\nString[] names = ... // 假设已经初始化的字符串数组 // 使用Lambda表达式排序 Arrays.sort(names, (o1, o2) -\u0026gt; o1.compareToIgnoreCase(o2)); // 使用方法引用排序，与上面的作用相同 Arrays.sort(names, String::compareToIgnoreCase); 说明：通过使用String::compareToIgnoreCase方法引用，我们可以简化Lambda表达式。\n构造器引用 构造器引用用于引用类的构造方法。在这个例子中，我们引用了Car类的构造方法。\npublic class Car { private String name; private double price; public Car(String name, double price) { this.name = name; this.price = price; } // 省略getter和setter方法 } @FunctionalInterface interface CreateCar { Car create(String name, double price); } // Test.java // 使用匿名内部类 CreateCar cc1 = new CreateCar() { @Override public Car create(String name, double price) { return new Car(name, price); } }; // 使用Lambda表达式 CreateCar cc2 = (name, price) -\u0026gt; new Car(name, price); // 使用构造器引用 CreateCar cc3 = Car::new; 说明：通过使用Car::new构造器引用，我们可以简化Lambda表达式。\n总结 方法引用和构造器引用使得代码更简洁易读。以下是四种常见的引用方式：\n静态方法引用：ClassName::staticMethodName 实例方法引用：instance::instanceMethodName 特定类型的方法引用：ClassName::instanceMethodName 构造器引用：ClassName::new 引用方式减少了样板代码，增强了代码的可读性和可维护性。\n综合案例 Hospital ","permalink":"https://kennems.github.io/posts/tech/java20%E5%A4%A9%E9%80%9F%E6%88%90%E8%BF%9B%E9%98%B6%E8%AF%BE%E7%A8%8B1/","summary":"进阶课程(1) OOP static 静态， 可以修饰成员变量，成员方法 成员变量按照有无static修饰，分为两种 类变量 ： 有static修饰，属于类，在计算机里只","title":"Java20天速成——进阶课程(1)"},{"content":"JAVA 20天速成 有志者事竟成\n没有完完全全的投入，检测，学习是学不到东西的。\n自欺欺人，眼高手低是绝对没有任何作用的。\nJAVA背景信息 JAVA是一门高级编程语言。\n属于ORACLE公司\nJAVA之父——詹姆斯·高斯林\nJAVA主要做互联网系统的开发\n主要技术平台：JAVASE， JAVAEE， JAVAME\nJDK的发展史 Java Development Kit 开发者工具包\n当前使用更多的是JDK-8，JDK-11\n教学只用JDK-17\n技术类网站 ： 安装路径下不要包含中文和空格\n所有的开发工具最好安装到统一目录\n电脑内JAVA安装路径：\nF:\\Java\\jdk17\nF:\\Java\\jdk11\njavac.exe : 编译工具 java.exe : 执行工具\n常用命令\ncls： 清屏 退回到盘符根目录 ： cd\\ 先切换盘符在切换目录 Java 程序要经历的步骤：\n编写、编译（javac), 运行(java) Java代码编写有什么基本要求？\n文件名称和后缀必须是java结尾 文件名称必须与代码的类名称一致 必须使用英文模式下的符号 javac .\\HelloWorld.java\rjava HelloWorld public class Main{ public static void main(String[] args){ System.out.println(\u0026#34;Hello World!\u0026#34;); } } JDK11开始支持java直接运行源代码文件\nJDK 组成 JRE（Java Runtime Environment）：Java的运行环境\nJVM（Java Vitual Machine）：Java虚拟机， 真正运行java程序的地方。\n核心类库：Java自己写好的程序，给程序员调用的\n开发工具：java, javac\nJDK（Java Development Kit）：Java开发工具包（包括上面所有）。\nJava的跨平台、工作原理\n一次编译，处处可用 Path环境变量：用于记住程序路径，方便在命令行窗口的任意目录启动程序\nIDEA管理JAVA程序的结构\nproject（项目，工程） module（模块） package（包） class（类） IDEA快捷键\nmain/psvm sout\nctrl + D 复制当前行到下一行\nctrl + Y 删除所在行，建议用ctrl + x\nctrl + alt + L 格式化代码\nALT + SHIFT + ⬆ | ⬇ 上下移动当前代码\nctrl + /, ctrl + shift + / 对代码进行注释\nshift + enter , ctrl + alt + enter 在当前行下面/上面添加一行\nIDEA常用操作：\n删除类文件 修改类名称 修改模块 导入模块 方法1：\n注：生成imi文件\nmvn idea:module 方法2：\n复制代码到project目录， 之后再导入， 否则只是相关导入，修改module内容会修改源代码\n删除模块 打开工程 关闭工程 JAVA基础语法 1、注释 // 单行注释 /* 多行注释 */ /** 文档注释 * 目标： */ 2、变量 变量就是内存中的一块区域。\n// 二进制表示，前缀 0b 表示二进制 int a1 = 0b01100001; System.out.println(a1); // 输出：97 // 十进制表示 int a2 = 97; System.out.println(a2); // 输出：97 // 八进制表示，前缀 0 表示八进制 int a3 = 0141; System.out.println(a3); // 输出：97 // 十六进制表示，前缀 0x 表示十六进制 int a4 = 0xFA; System.out.println(a4); // 输出：250 // 声明并初始化不同类型的变量 byte a = 10; // byte类型，表示范围为 -128 到 127 short b = 8888; // short类型，表示范围为 -32768 到 32767 int c = 130; // int类型，表示范围为 -2147483648 到 2147483647 long d = 9393939393993L; // long类型，需要在结尾加上L或l，表示范围为 -9223372036854775808 到 9223372036854775807 // 输出不同类型的整数变量 System.out.println(a); // 输出：10 System.out.println(b); // 输出：130 System.out.println(c); // 输出：9393939393993 System.out.println(d); // 输出：8888 // 浮点数类型 float e = 2.17F; // float类型，需要在结尾加上F或f double f = 3.141592657; // double类型，默认为double，可以不加任何标识 // 输出浮点数变量 System.out.println(e); // 输出：2.17 System.out.println(f); // 输出：3.141592657 // 字符类型 char ch = \u0026#39;c\u0026#39;; // char类型，表示单个字符 System.out.println(ch); // 输出：c // 布尔类型 boolean flag = false; // boolean类型，表示true或false System.out.println(flag); // 输出：false // 字符串类型 String st = \u0026#34;string\u0026#34;; // String类型，表示字符串 System.out.println(st); // 输出：string 类型转换 byte a = 10; // 声明并初始化byte类型变量a int b = a; // 将byte类型的变量a赋值给int类型的变量b，发生拓宽转换 System.out.println(b); // 输出：10 int c = 100; // 声明并初始化int类型变量c double d = c; // 将int类型的变量c赋值给double类型的变量d，发生拓宽转换 System.out.println(d); // 输出：100.0 char e = \u0026#39;b\u0026#39;; // 声明并初始化char类型变量e int f = e; // 将char类型的变量e赋值给int类型的变量f，发生拓宽转换 System.out.println(f); // 输出：98（字符\u0026#39;b\u0026#39;对应的ASCII码值） byte a = 10; // 声明并初始化byte类型变量a short b = 20; // 声明并初始化short类型变量b int c = 30; // 声明并初始化int类型变量c long d = 40; // 声明并初始化long类型变量d // 对a、b、c、d进行加法运算，结果存储在long类型变量res1中 long res1 = a + b + c + d; System.out.println(res1); // 输出：100 // 对a、b进行加法运算，并将1.0（double类型）相加，结果存储在double类型变量res2中 double res2 = a + b + 1.0; System.out.println(res2); // 输出：31.0 // 对a、b进行加法运算，结果存储在int类型变量res3中 int res3 = a + b; System.out.println(res3); // 输出：30 byte a1 = 10; // 声明并初始化byte类型变量a1 byte a2 = 20; // 声明并初始化byte类型变量a2 // 对a1、a2进行加法运算，由于byte类型相加可能溢出，因此结果存储在int类型变量res4中 int res4 = a1 + a2; // 进行运算时a1和a2自动转换成int类型，然后相加 System.out.println(res4); // 输出：30 强制类型转换 int a = 1111111; char b = (char) a; // 快捷键， ALT+ENTER System.out.println(b); double c = 99.8; int d = (int) c; // 丢掉小数部分 System.out.println(d); 3、运算符 使用+符号做连接符的情况 int a = 10; // 声明并初始化整数变量a // 使用字符串连接符将字符串 \u0026#34;abc\u0026#34; 和整数变量a 连接起来并打印 System.out.println(\u0026#34;abc\u0026#34; + a); // 输出：\u0026#34;abc10\u0026#34; // 打印整数变量a 加 5 的结果 System.out.println(a + 5); // 输出：15 // 将字符串 \u0026#34;abc\u0026#34;、整数变量a 和字符 \u0026#39;a\u0026#39; 连接起来并打印 System.out.println(\u0026#34;abc\u0026#34; + a + \u0026#39;a\u0026#39;); // 输出：\u0026#34;abc10a\u0026#34; // 将字符 \u0026#39;a\u0026#39; 的ASCII码值（97）和整数变量a 相加，再将结果与字符串 \u0026#34;abc\u0026#34; 连接起来并打印 // 注：字符 \u0026#39;a\u0026#39; 的ASCII码值被当作整数参与运算，然后再将结果转换为字符 System.out.println(\u0026#39;a\u0026#39; + a + \u0026#34;abc\u0026#34;); // 输出：\u0026#34;107abc\u0026#34; // 初始化变量n和m分别为3和5 int n = 3, m = 5; // 计算res的值 // ++m: 先自增m，m变成6，然后返回6 // --m: 先自减m，m变成5，然后返回5 // m--: 先返回m的值5，然后再自减m，m变成4 // ++n: 先自增n，n变成4，然后返回4 // n--: 先返回n的值4，然后再自减n，n变成3 // 计算：6 - 5 + 5 - 4 + 4 + 3 = 9 int res = ++m - --m + m-- - ++n + n-- + 3; System.out.println(res); // 输出res的值 System.out.println(n); // 输出n的值，此时n为3 System.out.println(m); // 输出m的值，此时m为4 // 初始化变量c和d分别为10和5 int c = 10, d = 5; // 计算res2的值 // c++: 先返回c的值10，然后再自增c，c变成11 // ++c: 先自增c，c变成12，然后返回12 // --d: 先自减d，d变成4，然后返回4 // ++d: 先自增d，d变成5，然后返回5 // 计算：10 + 12 - 4 - 5 + 1 + c--，其中c此时为12，然后再自减c，c变成11 // 计算：10 + 12 - 4 - 5 + 1 + 12 = 26 int res2 = c++ + ++c - --d - ++d + 1 + c--; System.out.println(res2); // 输出res2的值 System.out.println(c); // 输出c的值，此时c为11 System.out.println(d); // 输出d的值，此时d为5 逻辑运算 // 定义变量 double size = 9.8; // size的值为9.8 double storage = 16; // storage的值为16 // 第一组条件判断 System.out.println(\u0026#34;original \u0026#34; + storage); // 使用按位与运算符\u0026#34;\u0026amp;\u0026#34;，即使第一个条件不满足，storage也会自增 boolean res11 = size \u0026lt; 8 \u0026amp; storage++ \u0026gt;= 16; // false System.out.println(res11); // 输出false System.out.println(storage); // 输出17.0，因为storage在条件判断之后自增了 // 使用逻辑与运算符\u0026#34;\u0026amp;\u0026amp;\u0026#34;，若第一个条件不满足，则不会执行第二个条件，storage不会自增 boolean res12 = size \u0026lt; 8 \u0026amp;\u0026amp; storage++ \u0026gt;= 16; // false System.out.println(res12); // 输出false System.out.println(storage); // 输出17.0，因为storage没有自增 // 第二组条件判断 System.out.println(\u0026#34;-------------------\u0026#34;); System.out.println(\u0026#34;original \u0026#34; + storage); // 使用按位或运算符\u0026#34;|\u0026#34;，即使第一个条件满足，storage也会自增 boolean res21 = size \u0026gt;= 8 | storage++ \u0026gt;= 8; // true System.out.println(res21); // 输出true System.out.println(storage); // 输出18.0，因为storage在条件判断之后自增了 // 使用逻辑或运算符\u0026#34;||\u0026#34;，若第一个条件满足，则不会执行第二个条件，storage不会自增 boolean res22 = size \u0026gt;= 8 || storage++ \u0026gt;= 16; // true System.out.println(res22); // 输出true System.out.println(storage); // 输出18.0，因为storage没有自增 System.out.println(\u0026#34;-------------------\u0026#34;); // 其他操作 // 使用逻辑非运算符\u0026#34;!\u0026#34;，对true取反，结果为false System.out.println((!true)); // 输出false // 使用按位异或运算符\u0026#34;^\u0026#34;，对两个数的二进制进行异或操作，结果为0 System.out.println((1^1)); // 输出0 int grade = 10; // 定义成绩变量为10 // 使用三元运算符判断成绩是否合格 String res = grade \u0026gt;= 60 ? \u0026#34;成绩合格\u0026#34; : \u0026#34;成绩不合格\u0026#34;; System.out.println(res); // 输出 \u0026#34;成绩不合格\u0026#34;，因为grade的值为10，小于60 // 第一条逻辑表达式 System.out.println(10 \u0026gt; 3 || 10 \u0026gt; 3 \u0026amp;\u0026amp; 10 \u0026lt; 3); // 输出true // 逻辑运算符\u0026#34;\u0026amp;\u0026amp;\u0026#34;的优先级高于\u0026#34;||\u0026#34;，所以先执行10 \u0026gt; 3 \u0026amp;\u0026amp; 10 \u0026lt; 3，结果为false，然后执行10 \u0026gt; 3 || false，结果为true。 // 第二条逻辑表达式 System.out.println((10 \u0026gt; 3 || 10 \u0026gt; 3) \u0026amp;\u0026amp; 10 \u0026lt; 3); // 输出false // 加了括号后，先执行括号内的10 \u0026gt; 3 || 10 \u0026gt; 3，结果为true，然后与10 \u0026lt; 3进行逻辑与运算，结果为false。 输入 // 1. 创建Scanner对象sc，用于从System.in（即标准输入流，通常为控制台）读取用户输入 Scanner sc = new Scanner(System.in); // 2. 输出提示信息，要求用户输入年龄 System.out.println(\u0026#34;Please input your age:\u0026#34;); // 3. 使用Scanner对象sc读取用户输入的整数型年龄，并将其存储在变量age中 int age = sc.nextInt(); // 4. 根据用户输入的年龄计算其出生年份（假设当前为2024年），然后输出结果 System.out.println(\u0026#34;Your birth year is :\u0026#34; + (2024 - age)); // 5. 输出提示信息，要求用户输入姓名 System.out.println(\u0026#34;Please input your name:\u0026#34;); // 6. 使用Scanner对象sc读取用户输入的字符串型姓名，并将其存储在变量name中 String name = sc.next(); // 7. 重复输出用户出生年份（与步骤4相同，此处可能是代码冗余或笔误） System.out.println(\u0026#34;Your birth year is :\u0026#34; + (2024 - age)); // 8. 输出欢迎信息，包含用户输入的姓名 System.out.println(\u0026#34;Welcome: \u0026#34; + name); switch注意事项：\n表达式类型只能是byte, short, int, char, JDK5开始支持枚举， JDK7开始支持String，不支持double，float, long。 case给出的值不允许重复，且只能是字面量，不能是变量 正常使用时需要写break， 否则会出现穿透现象 switch 技巧：运用穿透性合并同样结果的分支。\npublic class SwitchExample { public static void main(String[] args) { int day = 2; String dayType; switch (day) { case 1: case 2: case 3: case 4: case 5: dayType = \u0026#34;工作日\u0026#34;; break; case 6: case 7: dayType = \u0026#34;周末\u0026#34;; break; default: dayType = \u0026#34;无效的日子\u0026#34;; break; } System.out.println(\u0026#34;今天是: \u0026#34; + dayType); } } while\n// 创建一个Random对象用于生成随机数 Random random = new Random(); // 生成1到100之间的随机数作为幸运数字 int luckNumber = random.nextInt(100) + 1; // 创建一个Scanner对象用于接收用户的输入 Scanner sc = new Scanner(System.in); // 提示用户输入猜测的数字 System.out.println(\u0026#34;请输入你猜的数字\u0026#34;); // 循环，直到用户猜中为止 while (true) { // 获取用户输入的猜测数字 int guessNumber = sc.nextInt(); // 判断用户输入的数字与幸运数字的关系，并给出相应提示 if (guessNumber == luckNumber) { // 如果猜中了，输出恭喜信息，并结束循环 System.out.println(\u0026#34;恭喜你，你中了100元大奖\u0026#34;); break; } else if (guessNumber \u0026gt; luckNumber) { // 如果猜的数字太大，提示用户数字太大 System.out.println(\u0026#34;你猜的数字太大了\u0026#34;); } else { // 如果猜的数字太小，提示用户数字太小 System.out.println(\u0026#34;你猜的数字太小了\u0026#34;); } } 数组 //1.标准写法 // 初始化整型数组ages，包含5个元素，分别为10, 20, 30, 40, 50 int[] ages = new int[]{ 10, 20, 30, 40, 50 }; // 初始化双精度浮点型数组scores，包含5个元素，分别为99.9, 88.8, 77.7, 66.6, 55.5 double[] scores = new double[]{ 99.9, 88.8, 77.7, 66.6, 55.5 }; // 输出整型数组ages的引用地址 System.out.println(ages); // 输出双精度浮点型数组scores的引用地址 //2.简化写法 // 使用简化语法初始化整型数组ages2，包含5个元素，分别为10, 20, 30, 40, 50 int[] ages2 = { 10, 20, 30, 40, 50 }; // 使用简化语法初始化双精度浮点型数组scores2，包含5个元素，分别为99.9, 88.8, 77.7, 66.6, 55.5 //3.写法三 int age3[] = new int[10]; Java 内存分配 方法区\n栈\n堆\n本地方法栈\n程序计数器\nint a = 20; int[] arr = new int[3]; 以上两行代码的执行原理：\na是变量，直接放在栈中，a变量中存储的数据就是20这个值 new int[3]是创建一个数组对象，会在堆内存中开辟区存储3个整数 arr是变量，在栈中，arr中存储的是数组对象在堆内存中地址值 Java小案例——双色球 package com.show.test; import java.util.Random; import java.util.Scanner; public class Test4 { public static void main(String[] args) { System.out.println(1); int[] userNumber = userChooseNumber(); // 用户选择号码 int[] luckNumer = createLuckNumber(); // 创建幸运号码 check(userNumber, luckNumer); // 检查用户选择的号码与幸运号码的匹配情况 } // 用户选择号码的方法 public static int[] userChooseNumber() { System.out.println(\u0026#34;Welcome to this select ball system!\u0026#34;); // 欢迎语 int[] numbers = new int[6]; // 存储用户选择的号码数组 Scanner sc = new Scanner(System.in); for (int i = 0; i \u0026lt; 5; i++) { System.out.println(\u0026#34;Please input your No.\u0026#34; + (i + 1) + \u0026#34; ball\u0026#34;); // 提示用户输入号码 while (true) { int n = sc.nextInt(); // 接收用户输入的号码 if (n \u0026lt; 1 || n \u0026gt; 33) { // 判断号码是否在有效范围内 System.out.println(\u0026#34;Your number not in the available zone: [1,33], Please input again\u0026#34;); } else { if (exist(numbers, n)) { // 判断号码是否已经被选择 System.out.println(\u0026#34;Current number has been chosen, Please input again\u0026#34;); } else { numbers[i] = n; // 将号码存入数组 break; } } } System.out.println(\u0026#34;Your input number is :\u0026#34; + numbers[i]); // 输出用户输入的号码 } System.out.println(\u0026#34;Input your last number\u0026#34;); while (true) { int n = sc.nextInt(); if (n \u0026lt; 1 || n \u0026gt; 16) { System.out.println(\u0026#34;Your number is not available, Please input the number between 1 and 16\u0026#34;); } else { numbers[5] = n; // 存储最后一个号码 break; } } System.out.println(\u0026#34;Blow is your input numbers\u0026#34;); printArray(numbers); // 打印用户选择的号码 return numbers; } // 判断数字是否已存在于数组中的方法 public static boolean exist(int[] arr, int x) { for (int i = 0; i \u0026lt; arr.length; i++) { if (arr[i] == x) { return true; } } return false; } // 打印数组的方法 public static void printArray(int[] arr) { for (int i = 0; i \u0026lt; arr.length; i++) { System.out.print(arr[i] + \u0026#34; \u0026#34;); } System.out.println(); } // 创建幸运号码的方法 public static int[] createLuckNumber() { int[] numbers = new int[6]; // 存储幸运号码数组 Random r = new Random(); for (int i = 0; i \u0026lt; 5; i++) { while (true) { int n = r.nextInt(33) + 1; // 生成随机号码 if (exist(numbers, n)) { continue; } else { numbers[i] = n; // 将号码存入数组 break; } } } int n = r.nextInt(16) + 1; numbers[5] = n; // 存储最后一个号码（蓝球） System.out.println(\u0026#34;Blow is the LuckNumber!\u0026#34;); // 输出幸运号码 printArray(numbers); // 打印幸运号码 return numbers; } // 检查用户选择的号码与幸运号码的匹配情况 public static void check(int[] arr1, int[] arr2) { int redCount = 0, blueCount = 0; // 红球匹配数、蓝球匹配数初始化为0 for (int i = 0; i \u0026lt; arr1.length - 1; i++) { if (arr1[i] == arr2[i]) { // 判断红球是否匹配 redCount += 1; } } if (arr1[5] == arr2[5]) { // 判断蓝球是否匹配 blueCount += 1; } // 输出命中的红球数量和蓝球数量 System.out.println(\u0026#34;您命中的红球数量是：\u0026#34; + redCount); System.out.println(\u0026#34;您命中的蓝球数量是：\u0026#34; + blueCount); // 根据命中情况输出不同的中奖信息 if (redCount == 6 \u0026amp;\u0026amp; blueCount == 1) { System.out.println(\u0026#34;恭喜您，中奖1000万，可以开始享受人生了~~~\u0026#34;); } else if (redCount == 6 \u0026amp;\u0026amp; blueCount == 0) { System.out.println(\u0026#34;恭喜您，中奖500万，可以稍微开始享受人生了~~~\u0026#34;); } else if (redCount == 5 \u0026amp;\u0026amp; blueCount == 1) { System.out.println(\u0026#34;恭喜您，中奖3000元，可以出去吃顿小龙虾了~\u0026#34;); } else if (redCount == 5 \u0026amp;\u0026amp; blueCount == 0 || redCount == 4 \u0026amp;\u0026amp; blueCount == 1) { System.out.println(\u0026#34;恭喜您，中了小奖：200元~\u0026#34;); } else if (redCount == 4 \u0026amp;\u0026amp; blueCount == 0 || redCount == 3 \u0026amp;\u0026amp; blueCount == 1) { System.out.println(\u0026#34;中了10元~\u0026#34;); } else if (redCount \u0026lt; 3 \u0026amp;\u0026amp; blueCount == 1) { System.out.println(\u0026#34;中了5元~\u0026#34;); } else { System.out.println(\u0026#34;感谢您对福利事业做出的巨大贡献~~~\u0026#34;); } } } 面向对象 对象就是一张表。\nthis的执行原理 this：就是一个变量，可以用在方法中，来拿到当前对象。\nthis主要用来\npublic class PrintThis { public void printThis(){ System.out.println(this); } } public class Test1 { public static void main(String[] args) { PrintThis t = new PrintThis(); t.printThis();//com.show.thisDemo.PrintThis@3b07d329 System.out.println(t); //com.show.thisDemo.PrintThis@3b07d329 } } public class Student1 { int score; public void check(int score){ if(this.score\u0026gt;score){ System.out.println(\u0026#34;Congratulations!\u0026#34;); }else{ System.out.println(\u0026#34;What\u0026#39;s the pity!\u0026#34;); } } } public static void main(String[] args) { Student1 s1 = new Student1(); s1.score = 10; s1.check(100); } 构造器需要注意的问题 不写无参数构造器时，编译器会自动生成一个无参数构造器 而写了有参数构造器之后，就不会自动生成无参数构造器了， 需要手动写上。 封装 就是用类设计对象处理某一个事物的数据时，应该把要处理的数据，以及处理这些数据的方法，设计到一个对象中去 合理隐藏，合理暴露（get, set方法）\n实例JavaBean 实体类：一种特殊的类\nMovie package com.show.ObjectDemo; public class Movie { // 私有属性 private int id; // 电影ID private String name; // 电影名称 private double price; // 电影票价 private double score; // 电影评分 private String director; // 导演 private String actor; // 主演 private String info; // 电影信息 // 无参构造方法 public Movie() { } // 带参构造方法 public Movie(int id, String name, double price, double score, String director, String actor, String info) { this.id = id; this.name = name; this.price = price; this.score = score; this.director = director; this.actor = actor; this.info = info; } // Getter和Setter方法 public int getId() { return id; } public void setId(int id) { this.id = id; } public String getName() { return name; } public void setName(String name) { this.name = name; } public double getPrice() { return price; } public void setPrice(double price) { this.price = price; } public double getScore() { return score; } public void setScore(double score) { this.score = score; } public String getDirector() { return director; } public void setDirector(String director) { this.director = director; } public String getActor() { return actor; } public void setActor(String actor) { this.actor = actor; } public String getInfo() { return info; } public void setInfo(String info) { this.info = info; } } MovieOperator package com.show.ObjectDemo; public class MovieOperator { // 电影数组 private Movie[] movies; // 构造方法 public MovieOperator(Movie[] movies) { this.movies = movies; } // 打印所有电影信息 public void printAllMovies() { System.out.println(\u0026#34;系统全部电影信息如下————————————————————————————\u0026#34;); for (int i = 0; i \u0026lt; movies.length; i++) { Movie m = movies[i]; System.out.println(\u0026#34;编号：—————————————\u0026#34; + m.getId()); System.out.println(\u0026#34;电影名：—————————————\u0026#34; + m.getName()); System.out.println(\u0026#34;价格：—————————————\u0026#34; + m.getPrice()); System.out.println(\u0026#34;-----------------------\u0026#34;); } } // 根据ID查询电影信息 public void searchMovieById(int id) { for (int i = 0; i \u0026lt; movies.length; i++) { Movie m = movies[i]; if (id == m.getId()) { System.out.println(\u0026#34;存在该电影！\u0026#34;); System.out.println(\u0026#34;编号：—————————————\u0026#34; + m.getId()); System.out.println(\u0026#34;电影名：—————————————\u0026#34; + m.getName()); System.out.println(\u0026#34;价格：—————————————\u0026#34; + m.getPrice()); System.out.println(\u0026#34;导演：—————————————\u0026#34; + m.getDirector()); System.out.println(\u0026#34;演员：—————————————\u0026#34; + m.getActor()); System.out.println(\u0026#34;评分：—————————————\u0026#34; + m.getScore()); System.out.println(\u0026#34;其他信息：—————————————\u0026#34; + m.getInfo()); return; } } System.out.println(\u0026#34;不存在该电影\u0026#34;); } } Test package com.show.ObjectDemo; import java.util.Scanner; public class Test { public static void main(String[] args) { // 创建Movie对象数组，存储电影信息 Movie[] movies = new Movie[4]; movies[0] = new Movie(1, \u0026#34;水门桥\u0026#34;, 38.9, 9.8, \u0026#34;徐克\u0026#34;, \u0026#34;吴京\u0026#34;, \u0026#34;12万人想看\u0026#34;); movies[1] = new Movie(2, \u0026#34;出拳吧\u0026#34;, 39, 7.8, \u0026#34;唐晓白\u0026#34;, \u0026#34;田雨\u0026#34;, \u0026#34;3.5万人想看\u0026#34;); movies[2] = new Movie(3, \u0026#34;月球陨落\u0026#34;, 42, 7.9, \u0026#34;罗兰\u0026#34;, \u0026#34;贝瑞\u0026#34;, \u0026#34;17.9万人想看\u0026#34;); movies[3] = new Movie(4, \u0026#34;一点就到家\u0026#34;, 35, 8.7, \u0026#34;许宏宇\u0026#34;, \u0026#34;刘昊然\u0026#34;, \u0026#34;10.8万人想看\u0026#34;); // 创建MovieOperator对象，用于操作Movie数组 MovieOperator movieOperator = new MovieOperator(movies); System.out.println(\u0026#34;在这里，你可以查询关于最新的电影信息！\u0026#34;); Scanner sc = new Scanner(System.in); while (true) { System.out.println(\u0026#34;输入1查看所有电影信息\u0026#34;); System.out.println(\u0026#34;输入2可以查询某个特定电影的详细信息\u0026#34;); int cmd = sc.nextInt(); switch (cmd) { case 1: movieOperator.printAllMovies(); // 打印所有电影信息 break; case 2: System.out.println(\u0026#34;请输入你需要查询的电影ID\u0026#34;); int id = sc.nextInt(); movieOperator.searchMovieById(id); // 根据ID查询电影信息 break; default: System.out.println(\u0026#34;非法命令，请重新输入\u0026#34;); } } } } 成员变量和局部变量 成员变量：类中， 方法外， 有默认值， 存于堆内存中， 属于整个对象， 与对象同生共死\n局部变量：常见于方法中，无默认值，需要初始化， 存于栈内存中， 属于所属大括号中， 方法调用而生，结束而亡\nAPI 注意事项 同一个包下的程序，可以直接访问 访问其他包下的程序，必须导包才可以访问 自己的程序中调用Java提供的程序，也需要先导包才可以使用 注意Java.lang包下的程序是不需要导包， 可以直接使用 访问多个其他包下的程序，在这些程序名一样的情况下，默认只能只能导入一个程序，另外一个程序必须带包名和类名来访问。 Demo d = new Demo(); d.print(); Demo1 d1 = new Demo1(); d1.print(); com.show.pkgDemo3.Demo1 d2 = new com.show.pkgDemo3.Demo1(); d2.print(); String String name = \u0026#34;Java\u0026#34;; System.out.println(name); String rs1 = new String(); System.out.println(rs1); String rs2 = new String(\u0026#34;NewStringJava\u0026#34;); System.out.println(rs2); String 是不可变的 只要是\u0026quot;...\u0026quot;的方式写出的字符串对象，会存储到字符串常量池中，且相同内容的字符只会存储一份 而new String创建字符串对象时，每次都会new出来一个新对象，放在堆内存中。 String s1 = \u0026#34;abc\u0026#34;; String s2 = \u0026#34;abc\u0026#34;; System.out.println(s1==s2); //true char[] ch = {\u0026#39;1\u0026#39;, \u0026#39;2\u0026#39;, \u0026#39;3\u0026#39;}; String s3 = new String(ch); String s4 = new String(ch); System.out.println(s3==s4); //false String s5 = new String(\u0026#34;abc\u0026#34;); // 实际创建了两个对象，一个在字符串常量池当中 // 另一个在堆内存中 String s6 = \u0026#34;abc\u0026#34;; // 实际创建了0个对象，因为\u0026#34;abc\u0026#34;已经在常量池当中了 System.out.println(s5==s6); //false String s7 = \u0026#34;abc\u0026#34;; String s8 = \u0026#34;a\u0026#34;+\u0026#39;b\u0026#39;+\u0026#34;c\u0026#34;; //编译器会自动处理 System.out.println(s7==s8); //true String s9 = \u0026#34;abc\u0026#34;; String s10 = \u0026#34;ab\u0026#34;; String s11 = s10 + \u0026#34;c\u0026#34;; //而对于变量则不会自动处理 System.out.println(s9==s11); //false ArrayList ArrayList\u0026lt;String\u0026gt; list = new ArrayList\u0026lt;\u0026gt;(); list.add(\u0026#34;heima\u0026#34;); list.add(\u0026#34;Java\u0026#34;); list.add(\u0026#34;爪洼\u0026#34;); System.out.println(list);//[heima, Java, 爪洼] list.add(1, \u0026#34;JAVAJAVA\u0026#34;); System.out.println(list); //[heima, JAVAJAVA, Java, 爪洼] System.out.println(list.get(1));//JAVAJAVA System.out.println(list.size());//4 System.out.println(list.remove(1));//JAVAJAVA System.out.println(list.remove(\u0026#34;Java\u0026#34;)); //true 默认删除第一个出现的元素 System.out.println(list);//[heima, 爪洼] System.out.println(list.set(1, \u0026#34;ZhuaWa\u0026#34;));//爪洼 System.out.println(list);//[heima, ZhuaWa] 综合实践项目——ATM Account package com.showguan; public class Account { private int userId; private String userName; private String cardId; private char sex; private String possword; private double money; private double limit; public int getUserId() { return userId; } public void setUserId(int userId) { this.userId = userId; } public String getUserName() { return userName + (this.sex == \u0026#39;男\u0026#39; ? \u0026#34;先生\u0026#34; : \u0026#34;女士\u0026#34;); } public void setUserName(String userName) { this.userName = userName; } public char getSex() { return sex; } public void setSex(char sex) { this.sex = sex; } public String getPossword() { return possword; } public void setPossword(String possword) { this.possword = possword; } public double getMoney() { return money; } public void setMoney(double money) { this.money = money; } public double getLimit() { return limit; } public void setLimit(double limit) { this.limit = limit; } public String getCardId() { return cardId; } public void setCardId(String cardId) { this.cardId = cardId; } } ATM package com.showguan; import java.util.ArrayList; import java.util.Random; import java.util.Scanner; public class ATM { private ArrayList\u0026lt;Account\u0026gt; accounts = new ArrayList\u0026lt;\u0026gt;(); private Account loginAcc; private Scanner sc = new Scanner(System.in); public void start() { /** * 启动ATM系统，展示欢迎界面 */ while (true) { System.out.println(\u0026#34;欢迎您进入ATM系统！\u0026#34;); System.out.println(\u0026#34;1. 用户登录\u0026#34;); System.out.println(\u0026#34;2. 用户开户\u0026#34;); System.out.println(\u0026#34;请输入你需要进行的操作：\u0026#34;); String command = sc.next(); switch (command) { case \u0026#34;1\u0026#34;: login(); break; case \u0026#34;2\u0026#34;: createAccount(); break; default: System.out.println(\u0026#34;你输入的操作有误，请重新书输入！\u0026#34;); System.out.println(); break; } } } private void createAccount() { System.out.println(\u0026#34;===系统开户操作===\u0026#34;); Account acc = new Account(); System.out.println(\u0026#34;请输入用户名\u0026#34;); String name = sc.next(); acc.setUserName(name); while (true) { System.out.println(\u0026#34;请输入性别：\u0026#34;); char sex = sc.next().charAt(0); if (sex == \u0026#39;男\u0026#39; || sex == \u0026#39;女\u0026#39;) { acc.setSex(sex); break; } else { System.out.println(\u0026#34;你输入的性别有误！请重新输入\u0026#34;); } } while (true) { System.out.println(\u0026#34;请输入您的账户密码：\u0026#34;); String password = sc.next(); System.out.println(\u0026#34;请输入您的确认密码：\u0026#34;); String confirmPassword = sc.next(); if (password.equals(confirmPassword)) { acc.setPossword(password); System.out.println(\u0026#34;密码设置成功！\u0026#34;); break; } else { System.out.println(\u0026#34;两次密码不一致，请重新设置密码！\u0026#34;); } } System.out.println(\u0026#34;请输入您的取现最大额度\u0026#34;); double limit = sc.nextDouble(); acc.setLimit(limit); String cardId = createCardId(); acc.setCardId(cardId); accounts.add(acc); System.out.println(\u0026#34;恭喜你！\u0026#34; + acc.getUserName() + \u0026#34;开户完成, 您的卡号是:\u0026#34; + acc.getCardId()); } private String createCardId() { while (true) { String cardId = \u0026#34;\u0026#34;; Random r = new Random(); for (int i = 0; i \u0026lt; 8; i++) { int data = r.nextInt(10); cardId += data; } Account acc = getAccountByCardID(cardId); if (acc == null) { return cardId; } } } private Account getAccountByCardID(String cardId) { for (int i = 0; i \u0026lt; accounts.size(); i++) { Account acc = accounts.get(i); if (acc.getCardId().equals(cardId)) { return acc; } } return null; } private void login() { System.out.println(\u0026#34;===系统登录===\u0026#34;); if (accounts.size() == 0) { System.out.println(\u0026#34;当前系统内还没有任何账户，请先创建账户再来登录！\u0026#34;); return; } System.out.println(\u0026#34;请输入您的卡号\u0026#34;); String cardId = sc.next(); Account acc = getAccountByCardID(cardId); if (acc == null) { System.out.println(\u0026#34;用户不存在\u0026#34;); } else { while (true) { System.out.println(\u0026#34;请输入用户密码\u0026#34;); String passWord = sc.next(); if (passWord.equals(acc.getPossword())) { System.out.println(\u0026#34;登陆成功！\u0026#34;); loginAcc = acc; showUerCommand(); break; } else { System.out.println(\u0026#34;密码错误！请重新输入\u0026#34;); } } } } private void showUerCommand() { while (true) { System.out.println(loginAcc.getUserName() + \u0026#34;您可以进行如下操作\u0026#34;); System.out.println(\u0026#34;1. 查询账户\u0026#34;); System.out.println(\u0026#34;2. 存款\u0026#34;); System.out.println(\u0026#34;3. 取款\u0026#34;); System.out.println(\u0026#34;4. 转账\u0026#34;); System.out.println(\u0026#34;5. 修改密码\u0026#34;); System.out.println(\u0026#34;6. 退出\u0026#34;); System.out.println(\u0026#34;7. 注销当前账户\u0026#34;); System.out.println(\u0026#34;请选择您要进行的操作：\u0026#34;); String command = sc.next(); switch (command) { case \u0026#34;1\u0026#34;: showloginAccount(); break; case \u0026#34;2\u0026#34;: depositMoney(); break; case \u0026#34;3\u0026#34;: withDrawMoney(); break; case \u0026#34;4\u0026#34;: transferMoney(); break; case \u0026#34;5\u0026#34;: updatePassword(); return; case \u0026#34;6\u0026#34;: System.out.println(\u0026#34;用户\u0026#34; + loginAcc.getUserName() + \u0026#34;成功退出系统！\u0026#34;); return; case \u0026#34;7\u0026#34;: if (deleteAccount()) { return; } break; default: break; } } } private void updatePassword() { System.out.println(\u0026#34;===账号密码修改操作===\u0026#34;); while (true) { System.out.println(\u0026#34;请输入当前账户密码\u0026#34;); String password = sc.next(); if (loginAcc.getPossword().equals(password)) { while (true) { System.out.println(\u0026#34;请输入你要修改为的新密码：\u0026#34;); String newPassword = sc.next(); System.out.println(\u0026#34;请重复你需要修改为的密码：\u0026#34;); String confirmNewPassword = sc.next(); if (newPassword.equals(confirmNewPassword)) { System.out.println(\u0026#34;密码修改成功\u0026#34;); loginAcc.setPossword(newPassword); return; } System.out.println(\u0026#34;两次密码不一致， 请重新输入\u0026#34;); } } else { System.out.println(\u0026#34;您当前输入的密码错误！\u0026#34;); } } } private boolean deleteAccount() { System.out.println(\u0026#34;===销户操作===\u0026#34;); System.out.println(\u0026#34;确定要销户吗？y/n\u0026#34;); String command = sc.next(); switch (command) { case \u0026#34;y\u0026#34;: if (loginAcc.getMoney() == 0) { accounts.remove(loginAcc); System.out.println(\u0026#34;销户成功\u0026#34;); return true; } else { System.out.println(\u0026#34;账户下余额不为0， 不允许销户\u0026#34;); } break; } return false; } private void transferMoney() { System.out.println(\u0026#34;===用户转账===\u0026#34;); if (accounts.size() \u0026lt; 2) { System.out.println(\u0026#34;系统内只有您一个账户，无法转账\u0026#34;); return; } if (loginAcc.getMoney() \u0026lt; 0) { System.out.println(\u0026#34;您自己都没钱了，就别转了吧！\u0026#34;); return; } while (true) { System.out.println(\u0026#34;请您输入对方的卡号:\u0026#34;); String receiveCardID = sc.next(); Account acc = getAccountByCardID(receiveCardID); if (acc == null) { System.out.println(\u0026#34;您输入的卡号不存在！\u0026#34;); } else { String receiveName = \u0026#34;*\u0026#34; + acc.getUserName().substring(1); System.out.println(\u0026#34;请您输入【\u0026#34; + receiveName + \u0026#34;】姓氏\u0026#34;); System.out.println(receiveName); String firstName = sc.next(); if (acc.getUserName().startsWith(firstName)) { System.out.println(\u0026#34;姓氏验证成功！\u0026#34;); while (true) { System.out.println(); System.out.println(\u0026#34;请您输入转让给对方的金额:\u0026#34;); double transfermoney = sc.nextDouble(); if (loginAcc.getMoney() \u0026gt;= transfermoney) { System.out.println(\u0026#34;转账成功！\u0026#34;); loginAcc.setMoney(loginAcc.getMoney() - transfermoney); acc.setMoney(acc.getMoney() + transfermoney); return; } else { System.out.println(\u0026#34;余额不足，无法转账！！最多可转\u0026#34; + loginAcc.getMoney()); } } } else { System.out.println(\u0026#34;对不起， 您认证的姓氏有问题！\u0026#34;); } } } } private void withDrawMoney() { System.out.println(\u0026#34;===取钱操作===\u0026#34;); if (loginAcc.getMoney() \u0026lt; 100) { System.out.println(\u0026#34;您的账户余额不足100元，不允许取钱\u0026#34;); return; } while (true) { System.out.println(\u0026#34;请您输入取款金额：\u0026#34;); double drawMoney = sc.nextDouble(); if (loginAcc.getMoney() \u0026gt;= drawMoney) { if (drawMoney \u0026gt; loginAcc.getLimit()) { System.out.println(\u0026#34;取款金额大于限定额度， 您当前的限定额度为:\u0026#34; + loginAcc.getLimit()); break; } else { loginAcc.setMoney(loginAcc.getMoney() - drawMoney); System.out.println(\u0026#34;取款成功， 取款金额为\u0026#34; + drawMoney + \u0026#34;账户内剩余余额:\u0026#34; + loginAcc.getMoney()); return; } } else { System.out.println(\u0026#34;余额不足， 您当前的账户余额是：\u0026#34; + loginAcc.getMoney()); } } } private void showloginAccount() { System.out.println(\u0026#34;===当前您的账户信息如下===\u0026#34;); System.out.println(\u0026#34;用户名: \u0026#34; + loginAcc.getUserName()); System.out.println(\u0026#34;性别: \u0026#34; + loginAcc.getSex()); System.out.println(\u0026#34;卡号: \u0026#34; + loginAcc.getCardId()); System.out.println(\u0026#34;余额: \u0026#34; + loginAcc.getMoney()); System.out.println(\u0026#34;取现最大额度: \u0026#34; + loginAcc.getLimit()); } private void depositMoney() { System.out.println(\u0026#34;==存款操作==\u0026#34;); System.out.println(\u0026#34;请输入你要存款的金额\u0026#34;); double money = sc.nextDouble(); loginAcc.setMoney(loginAcc.getMoney() + money); System.out.println(\u0026#34;恭喜您\u0026#34; + \u0026#34;存款：\u0026#34; + money + \u0026#34;存款后余额:\u0026#34; + loginAcc.getMoney()); } } Test package com.showguan; public class Test { public static void main(String[] args) { ATM atm = new ATM(); atm.start(); } } ","permalink":"https://kennems.github.io/posts/tech/java20%E5%A4%A9%E9%80%9F%E6%88%90%E5%9F%BA%E7%A1%80%E8%AF%BE%E7%A8%8B/","summary":"JAVA 20天速成 有志者事竟成 没有完完全全的投入，检测，学习是学不到东西的。 自欺欺人，眼高手低是绝对没有任何作用的。 JAVA背景信息 JAVA是一门","title":"Java20天速成——基础课程"},{"content":"Acwing算法学习 [TOC]\n第一章 课上：学思想\n课下：背代码\n题目，一道题写好几遍\n理解没有任何意义，体力活+脑力活\n记忆力 毅力/自制力\n沉下心背东西\n快速排序算法模板 —— 模板题 AcWing 785. 快速排序 分治\n1、确定分界点，l、r、（l+r)/2 随机\n2、调整区间，分为两边，左边小于等于x,右边大于等于x\n3、递归处理左右两段\nvoid quick_sort(int q[], int l, int r) { if (l \u0026gt;= r) return; int i = l - 1, j = r + 1, x = q[l + r \u0026gt;\u0026gt; 1]; while (i \u0026lt; j) { do i ++ ; while (q[i] \u0026lt; x); do j -- ; while (q[j] \u0026gt; x); if (i \u0026lt; j) swap(q[i], q[j]); } quick_sort(q, l, j), quick_sort(q, j + 1, r); } -std=c++11 归并排序算法模板 —— 模板题 AcWing 787. 归并排序 排序稳定：序列中相同的值排序后的相对位置是否发生改变\n时间复杂度有 （nlogn)\n1）确定分界点mid\n2）递归排序两边\n2）归并，合并为一个有序数组\nvoid merge_sort(int q[], int l, int r) { if (l \u0026gt;= r) return; int mid = l + r \u0026gt;\u0026gt; 1; merge_sort(q, l, mid); merge_sort(q, mid + 1, r); int k = 0, i = l, j = mid + 1; while (i \u0026lt;= mid \u0026amp;\u0026amp; j \u0026lt;= r) if (q[i] \u0026lt; q[j]) tmp[k ++ ] = q[i ++ ]; else tmp[k ++ ] = q[j ++ ]; while (i \u0026lt;= mid) tmp[k ++ ] = q[i ++ ]; while (j \u0026lt;= r) tmp[k ++ ] = q[j ++ ]; for (i = l, j = 0; i \u0026lt;= r; i ++, j ++ ) q[i] = tmp[j]; } 整数二分算法模板 —— 模板题 AcWing 789. 数的范围 边界问题\n本质：区间内一半满足一半不满足\nl=mid时加一\nbool check(int x) {/* ... */} // 检查x是否满足某种性质 // 区间[l, r]被划分成[l, mid]和[mid + 1, r]时使用： int bsearch_1(int l, int r) { while (l \u0026lt; r) { int mid = l + r \u0026gt;\u0026gt; 1; if (check(mid)) r = mid; // check()判断mid是否满足性质 else l = mid + 1; } return l; } // 区间[l, r]被划分成[l, mid - 1]和[mid, r]时使用： int bsearch_2(int l, int r) { while (l \u0026lt; r) { int mid = l + r + 1 \u0026gt;\u0026gt; 1; if (check(mid)) l = mid; else r = mid - 1; } return l; } 浮点数二分算法模板 —— 模板题 AcWing 790. 数的三次方根 浮点数二分，比较对应整数二分\nbool check(double x) {/* ... */} // 检查x是否满足某种性质 double bsearch_3(double l, double r) { const double eps = 1e-6; // eps 表示精度，取决于题目对精度的要求 while (r - l \u0026gt; eps) { double mid = (l + r) / 2; if (check(mid)) r = mid; else l = mid; } return l; } 高精度加法 —— 模板题 AcWing 791. 高精度加法 // C = A + B, A \u0026gt;= 0, B \u0026gt;= 0 vector\u0026lt;int\u0026gt; add(vector\u0026lt;int\u0026gt; \u0026amp;A, vector\u0026lt;int\u0026gt; \u0026amp;B) { if (A.size() \u0026lt; B.size()) return add(B, A); vector\u0026lt;int\u0026gt; C; int t = 0; for (int i = 0; i \u0026lt; A.size(); i ++ ) { t += A[i]; if (i \u0026lt; B.size()) t += B[i]; C.push_back(t % 10); t /= 10; } if (t) C.push_back(t); return C; } 高精度减法 —— 模板题 AcWing 792. 高精度减法 // C = A - B, 满足A \u0026gt;= B, A \u0026gt;= 0, B \u0026gt;= 0 vector\u0026lt;int\u0026gt; sub(vector\u0026lt;int\u0026gt; \u0026amp;A, vector\u0026lt;int\u0026gt; \u0026amp;B) { vector\u0026lt;int\u0026gt; C; for (int i = 0, t = 0; i \u0026lt; A.size(); i ++ ) { t = A[i] - t; if (i \u0026lt; B.size()) t -= B[i]; C.push_back((t + 10) % 10); if (t \u0026lt; 0) t = 1; else t = 0; } while (C.size() \u0026gt; 1 \u0026amp;\u0026amp; C.back() == 0) C.pop_back(); return C; } 高精度乘低精度 —— 模板题 AcWing 793. 高精度乘法 // C = A * b, A \u0026gt;= 0, b \u0026gt; 0 vector\u0026lt;int\u0026gt; mul(vector\u0026lt;int\u0026gt; \u0026amp;A, int b) { vector\u0026lt;int\u0026gt; C; int t = 0; for (int i = 0; i \u0026lt; A.size() || t; i ++ ) { if (i \u0026lt; A.size()) t += A[i] * b; C.push_back(t % 10); t /= 10; } return C; } 高精度除以低精度 —— 模板题 AcWing 794. 高精度除法 // A / b = C ... r, A \u0026gt;= 0, b \u0026gt; 0 vector\u0026lt;int\u0026gt; div(vector\u0026lt;int\u0026gt; \u0026amp;A, int b, int \u0026amp;r) { vector\u0026lt;int\u0026gt; C; r = 0; for (int i = A.size() - 1; i \u0026gt;= 0; i -- ) { r = r * 10 + A[i]; C.push_back(r / b); r %= b; } reverse(C.begin(), C.end()); while (C.size() \u0026gt; 1 \u0026amp;\u0026amp; C.back() == 0) C.pop_back(); return C; } 一维前缀和 —— 模板题 AcWing 795. 前缀和 快速求区间和\nS[i] = a[1] + a[2] + ... a[i] a[l] + ... + a[r] = S[r] - S[l - 1] 从1开始，便于处理边界 二维前缀和 —— 模板题 AcWing 796. 子矩阵的和 S[i, j] = 第i行j列格子左上部分所有元素的和 以(x1, y1)为左上角，(x2, y2)为右下角的子矩阵的和为： S[x2, y2] - S[x1 - 1, y2] - S[x2, y1 - 1] + S[x1 - 1, y1 - 1] 一维差分 —— 模板题 AcWing 797. 差分 给区间[l, r]中的每个数加上c： B[l] += c, B[r + 1] -= c 二维差分 —— 模板题 AcWing 798. 差分矩阵/二维差分 给以(x1, y1)为左上角，(x2, y2)为右下角的子矩阵中的所有元素加上c： S[x1, y1] += c, S[x2 + 1, y1] -= c, S[x1, y2 + 1] -= c, S[x2 + 1, y2 + 1] += c 双指针算法 —— 模板题 AcWIng 799. 最长连续不重复子序列, AcWing 800. 数组元素的目标和 __滑动窗口？ 核心：把O(n^2)算法优化为O(n)\nfor (int i = 0, j = 0; i \u0026lt; n; i ++ ) { while (j \u0026lt; i \u0026amp;\u0026amp; check(j, i)) j ++ ; // 具体问题的逻辑 } 常见问题分类： (1) 对于一个序列，用两个指针维护一段区间 (2) 对于两个序列，维护某种次序，比如归并排序中合并两个有序序列的操作 位运算 —— 模板题 AcWing 801. 二进制中1的个数 原码，反码，补码 求n二进制表示中第k位数字: n \u0026gt;\u0026gt; k \u0026amp; 1 返回n的最后一位1：lowbit(n) = n \u0026amp; -n 树状数组基本操作 整数离散化 —— 模板题 AcWing 802. 区间和 vector\u0026lt;int\u0026gt; alls; // 存储所有待离散化的值 sort(alls.begin(), alls.end()); // 将所有值排序 alls.erase(unique(alls.begin(), alls.end())返回去重后数组末尾端点, alls.end()); // 去掉重复元素 // 二分求出x对应的离散化的值 int find(int x) // 找到第一个大于等于x的位置 { int l = 0, r = alls.size() - 1; while (l \u0026lt; r) { int mid = l + r \u0026gt;\u0026gt; 1; if (alls[mid] \u0026gt;= x) r = mid; else l = mid + 1; } return r + 1; // 映射到1, 2, ...n } 区间合并 —— 模板题 AcWing 803. 区间合并 // 将所有存在交集的区间合并 贪心 void merge(vector\u0026lt;PII\u0026gt; \u0026amp;segs) { vector\u0026lt;PII\u0026gt; res; sort(segs.begin(), segs.end()); //区间左端点排序 int st = -2e9, ed = -2e9; for (auto seg : segs) if (ed \u0026lt; seg.first) { if (st != -2e9) res.push_back({st, ed}); st = seg.first, ed = seg.second; } else ed = max(ed, seg.second); if (st != -2e9) res.push_back({st, ed}); segs = res; } 作者：yxc 链接：https://www.acwing.com/blog/content/277/ 来源：AcWing 著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。\n第二章 数据结构，以数组模拟的形式\n指针+结构体 ： 面试题\n单链表 —— 模板题 AcWing 826. 单链表 邻接表-存储树和图 静态链表\n下标从0开始\n// head存储链表头，e[]存储节点的值，ne[]存储节点的next指针，idx表示当前用到了哪个节点 int head, e[N], ne[N], idx; // 初始化 void init() { head = -1; idx = 0; } // 在链表头插入一个数a void insert(int a) { e[idx] = a, ne[idx] = head, head = idx ++ ; } // 插入下标k后面 void add(int k,int x) { e[idx]= x, ne[idx] = ne[k], ne[k] = idx++ ; } // 将头结点删除，需要保证头结点存在 void remove() { head = ne[head]; } // 将k后面的点删掉 void remove(int k) { ne[k] = ne[ne[k]]; } 双链表 —— 模板题 AcWing 827. 双链表 优化某些问题\n// e[]表示节点的值，l[]表示节点的左指针，r[]表示节点的右指针，idx表示当前用到了哪个节点 int e[N], l[N], r[N], idx; // 初始化 void init() { //0是左端点，1是右端点 r[0] = 1, l[1] = 0; idx = 2; } // 在节点a的右边插入一个数x void insert(int a, int x) { e[idx] = x; l[idx] = a, r[idx] = r[a]; l[r[a]] = idx, r[a] = idx ++ ; } // 删除节点a void remove(int a) { l[r[a]] = l[a]; r[l[a]] = r[a]; } 栈 —— 模板题 AcWing 828. 模拟栈 // tt表示栈顶 int stk[N], tt = 0; // 向栈顶插入一个数 stk[ ++ tt] = x; // 从栈顶弹出一个数 tt -- ; // 栈顶的值 stk[tt]; // 判断栈是否为空 if (tt \u0026gt; 0) { } 队列 —— 模板题 AcWing 829. 模拟队列 普通队列\n// hh 表示队头，tt表示队尾 int q[N], hh = 0, tt = -1; // 向队尾插入一个数 q[ ++ tt] = x; // 从队头弹出一个数 hh ++ ; // 队头的值 q[hh]; // 判断队列是否为空 if (hh \u0026lt;= tt) { //不空 } 循环队列\n// hh 表示队头，tt表示队尾的后一个位置 int q[N], hh = 0, tt = 0; // 向队尾插入一个数 q[tt ++ ] = x; if (tt == N) tt = 0; // 从队头弹出一个数 hh ++ ; if (hh == N) hh = 0; // 队头的值 q[hh]; // 判断队列是否为空 if (hh != tt) { } 单调栈 —— 模板题 AcWing 830. 单调栈 常见模型：找出每个数左边离它最近的比它大/小的数 int tt = 0; for (int i = 1; i \u0026lt;= n; i ++ ) { while (tt \u0026amp;\u0026amp; check(stk[tt], i)) tt -- ; stk[ ++ tt] = i; } 单调队列 —— 模板题 AcWing 154. 滑动窗口 常见模型：找出滑动窗口中的最大值/最小值 int hh = 0, tt = -1; for (int i = 0; i \u0026lt; n; i ++ ) { while (hh \u0026lt;= tt \u0026amp;\u0026amp; check_out(q[hh])) hh ++ ; // 判断队头是否滑出窗口 while (hh \u0026lt;= tt \u0026amp;\u0026amp; check(q[tt], i)) tt -- ; q[ ++ tt] = i; } KMP —— 模板题 AcWing 831. KMP字符串 用模板串来匹配模式串，找到模式串\ns的真前缀以及真后缀是指不等于s的前缀以及后缀，即至少是s[1n-2]或s[0n-1]\nne[i] : 以i结尾的串中 最长真前缀与真后缀相等的串 的长度，如果没有则为0。\n//前缀h vector\u0026lt;int\u0026gt; prefix_function(string s) { int n = (int)s.length(); vector\u0026lt;int\u0026gt; pi(n); for (int i = 1; i \u0026lt; n; i++) { int j = pi[i - 1]; while (j \u0026gt; 0 \u0026amp;\u0026amp; s[i] != s[j]) j = pi[j - 1]; if (s[i] == s[j]) j++; pi[i] = j; } return pi; } 实际使用范例（下面这个例子字符串从1开始）\n// 求Next数组： // ne[i] 存储真前缀和真后缀相等的长度，所以至少从2开始： //abcab,从b开始才有真前缀 // s[]是模式串，p[]是模板串, n是s的长度，m是p的长度 for (int i = 2, j = 0; i \u0026lt;= m; i ++ ) { while (j \u0026amp;\u0026amp; p[i] != p[j + 1]) j = ne[j]; if (p[i] == p[j + 1]) j ++ ; ne[i] = j; } // 匹配 for (int i = 1, j = 0; i \u0026lt;= n; i ++ ) { while (j \u0026amp;\u0026amp; s[i] != p[j + 1]) j = ne[j]; if (s[i] == p[j + 1]) j ++ ; if (j == m) { j = ne[j]; // 匹配成功后的逻辑 } } Trie树 —— 模板题 AcWing 835. Trie字符串统计 int son[N][26], cnt[N], idx; // 0号点既是根节点，又是空节点 // son[][]存储树中每个节点的子节点 // cnt[]存储以每个节点结尾的单词数量 // 插入一个字符串 void insert(char *str) { int p = 0; for (int i = 0; str[i]; i ++ ) { int u = str[i] - \u0026#39;a\u0026#39;; if (!son[p][u]) son[p][u] = ++ idx; p = son[p][u]; } cnt[p] ++ ; } // 查询字符串出现的次数 int query(char *str) { int p = 0; for (int i = 0; str[i]; i ++ ) { int u = str[i] - \u0026#39;a\u0026#39;; if (!son[p][u]) return 0; p = son[p][u]; } return cnt[p]; } 并查集 —— 模板题 AcWing 836. 合并集合, AcWing 837. 连通块中点的数量 按秩合并\n字符按字符串读入\n(1)朴素并查集：\nint p[N]; //存储每个点的祖宗节点 // 返回x的祖宗节点 int find(int x) { if (p[x] != x) p[x] = find(p[x]); return p[x]; } // 初始化，假定节点编号是1~n for (int i = 1; i \u0026lt;= n; i ++ ) p[i] = i; // 合并a和b所在的两个集合： p[find(a)] = find(b); (2)维护size的并查集：\nint p[N], size[N]; //p[]存储每个点的祖宗节点, size[]只有祖宗节点的有意义，表示祖宗节点所在集合中的点的数量 // 返回x的祖宗节点 int find(int x) { if (p[x] != x) p[x] = find(p[x]); return p[x]; } // 初始化，假定节点编号是1~n for (int i = 1; i \u0026lt;= n; i ++ ) { p[i] = i; size[i] = 1; } // 合并a和b所在的两个集合： p[find(a)] = find(b); size[b] += size[a]; (3)维护到祖宗节点距离的并查集：\nint p[N], d[N]; //p[]存储每个点的祖宗节点, d[x]存储x到p[x]的距离 // 返回x的祖宗节点 int find(int x) { if (p[x] != x) { int u = find(p[x]); d[x] += d[p[x]]; p[x] = u; } return p[x]; } // 初始化，假定节点编号是1~n for (int i = 1; i \u0026lt;= n; i ++ ) { p[i] = i; d[i] = 0; } // 合并a和b所在的两个集合： p[find(a)] = find(b); d[find(a)] = distance; // 根据具体问题，初始化find(a)的偏移量 堆 —— 模板题 AcWing 838. 堆排序, AcWing 839. 模拟堆 维护集合的数据结构 （大根堆，父节点值不小于子节点值）\n// h[N]存储堆中的值, h[1]是堆顶，x的左儿子是2x, 右儿子是2x + 1 // pos[k]存储第k个插入的点在堆中的位置 // ord[k]存储堆中下标是k的点是第几个插入的 int h[N], ph[N], hp[N], size; // 交换两个点，及其映射关系 void heap_swap(int a, int b) { //swap(ph[hp[a]],ph[hp[b]]); 根据题意 //swap(hp[a], hp[b]); swap(h[a], h[b]); } void down(int u) { int t = u; if (u * 2 \u0026lt;= size \u0026amp;\u0026amp; h[u * 2] \u0026lt; h[t]) t = u * 2; if (u * 2 + 1 \u0026lt;= size \u0026amp;\u0026amp; h[u * 2 + 1] \u0026lt; h[t]) t = u * 2 + 1; if (u != t) { heap_swap(u, t); down(t); } } void up(int u) { while (u / 2 \u0026amp;\u0026amp; h[u] \u0026lt; h[u / 2]) { heap_swap(u, u / 2); u \u0026gt;\u0026gt;= 1; } } // O(n)建堆 for (int i = n / 2; i; i -- ) down(i); heap[++size] = x; up(size); //添加元素 heap[1]; //堆顶元素 heap[1]=heap[size]; size--; down(1);//删除第size个结点 heap[k]=heap[size]; size---; down(k);up(k);//删除第k个结点 heap[k]=x; down(k); up(k); //将第k个元素赋值为x 一般哈希 —— 模板题 AcWing 840. 模拟散列表 (1) 拉链法 int h[N], e[N], ne[N], idx; // 向哈希表中插入一个数 void insert(int x) { int k = (x % N + N) % N; e[idx] = x; ne[idx] = h[k]; h[k] = idx ++ ; } // 在哈希表中查询某个数是否存在 bool find(int x) { int k = (x % N + N) % N; for (int i = h[k]; i != -1; i = ne[i]) if (e[i] == x) return true; return false; } (2) 开放寻址法 int h[N]; // 如果x在哈希表中，返回x的下标；如果x不在哈希表中，返回x应该插入的位置 int find(int x) { int t = (x % N + N) % N; while (h[t] != null \u0026amp;\u0026amp; h[t] != x) { t ++ ; if (t == N) t = 0; } return t; } 字符串哈希 —— 模板题 AcWing 841. 字符串哈希 核心思想：将字符串看成P进制数，P的经验值是131或13331，取这两个值的冲突概率低 小技巧：取模的数用2^64，这样直接用unsigned long long存储，溢出的结果就是取模的结果。\ntypedef unsigned long long ULL; const int P = 131 or 13331 ; ULL h[N], p[N]; // h[k]存储字符串前k个字母的哈希值, p[k]存储 P^k mod 2^64 // 初始化 p[0] = 1; for (int i = 1; i \u0026lt;= n; i ++ ) { h[i] = h[i - 1] * P + str[i]; p[i] = p[i - 1] * P; } // 计算子串 str[l ~ r] 的哈希值 ULL get(int l, int r) { return h[r] - h[l - 1] * p[r - l + 1]; } C++ STL简介 所有容器都有size() empty() vector, 变长数组，倍增的思想 size() 返回元素个数 empty() 返回是否为空 clear() 清空 front()/back() push_back()/pop_back() begin()/end() [] 支持比较运算，按字典序 vector\u0026lt;int\u0026gt; a(10,2); a.empty(); pair\u0026lt;int, int\u0026gt; first, 第一个元素 second, 第二个元素 支持比较运算，以first为第一关键字，以second为第二关键字（字典序） pair\u0026lt;int,int\u0026gt; p; p=make_pair(1,1); p={1,1}; string，字符串 size()/length() 返回字符串长度 empty() clear() substr(起始下标，(子串长度)) 返回子串 c_str() 返回字符串所在字符数组的起始地址 strcpy(c,s.c_str());//c_str()的使用方法 queue, 队列 没有clear函数 清空用新建queue size() empty() push() 向队尾插入一个元素 front() 返回队头元素 back() 返回队尾元素 pop() 弹出队头元素 priority_queue, 优先队列，默认是大根堆 push() 插入一个元素 top() 返回堆顶元素 pop() 弹出堆顶元素 定义成小根堆的方式：priority_queue\u0026lt;int, vector\u0026lt;int\u0026gt;, greater\u0026lt;int\u0026gt;\u0026gt; q; stack, 栈 size() empty() push() 向栈顶插入一个元素 top() 返回栈顶元素 pop() 弹出栈顶元素 deque, 双端队列 size() empty() clear() front()/back() push_back()/pop_back() push_front()/pop_front() begin()/end() [] set, map, multiset, multimap, 基于平衡二叉树（红黑树），动态维护有序序列 size() empty() clear() begin()/end() ++, -- 返回前驱和后继，时间复杂度 O(logn) set/multiset insert() 插入一个数 find() 查找一个数 count() 返回某一个数的个数 erase() (1) 输入是一个数x，删除所有x O(k + logn) (2) 输入一个迭代器，删除这个迭代器 lower_bound()/upper_bound() lower_bound(x) 返回大于等于x的最小的数的迭代器 upper_bound(x) 返回大于x的最小的数的迭代器 map/multimap insert() 插入的数是一个pair erase() 输入的参数是pair或者迭代器 find() [] 注意multimap不支持此操作。 时间复杂度是 O(logn) lower_bound()/upper_bound() unordered_set, unordered_map, unordered_multiset, unordered_multimap, 哈希表 和上面类似，增删改查的时间复杂度是 O(1) 不支持 lower_bound()/upper_bound()， 迭代器的++，-- bitset, 圧位 bitset\u0026lt;10000\u0026gt; s; ~, \u0026amp;, |, ^ \u0026gt;\u0026gt;, \u0026lt;\u0026lt; ==, != [] count() 返回有多少个1 none() 判断是否全为0 any() 判断是否至少有一个1 set() 把所有位置成1 set(k, v) 将第k位变成v reset() 把所有位变成0 flip() 等价于~ flip(k) 把第k位取反 作者：yxc 链接：https://www.acwing.com/blog/content/404/ 来源：AcWing 著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。\n第三章 树与图的存储 树是一种特殊的图: 无环连通图，与图的存储方式相同。 对于无向图中的边ab，存储两条有向边a-\u0026gt;b, b-\u0026gt;a。 因此我们可以只考虑有向图的存储。\n(1) 邻接矩阵：g[a][b] 存储边a-\u0026gt;b (2) 邻接表： // 对于每个点k，开一个单链表，存储k所有可以走到的点。h[k]存储这个单链表的头结点 int h[N], e[N], ne[N], idx; // 添加一条边a-\u0026gt;b void add(int a, int b) { e[idx] = b, ne[idx] = h[a], h[a] = idx ++ ; } // 初始化 idx = 0; memset(h, -1, sizeof h); 树与图的遍历 时间复杂度 O(n+m)O(n+m), nn 表示点数，mm 表示边数\n(1) 深度优先遍历 —— 模板题 AcWing 846. 树的重心 int dfs(int u) { st[u] = true; // st[u] 表示点u已经被遍历过 for (int i = h[u]; i != -1; i = ne[i]) { int j = e[i]; if (!st[j]) dfs(j); } } (2) 宽度优先遍历 —— 模板题 AcWing 847. 图中点的层次 queue\u0026lt;int\u0026gt; q; st[1] = true; // 表示1号点已经被遍历过 q.push(1); while (q.size()) { int t = q.front(); q.pop(); for (int i = h[t]; i != -1; i = ne[i]) { int j = e[i]; if (!st[j]) { st[j] = true; // 表示点j已经被遍历过 q.push(j); } } } 拓扑排序 —— 模板题 AcWing 848. 有向图的拓扑序列 时间复杂度 O(n+m)O(n+m), nn 表示点数，mm 表示边数\nbool topsort() { int hh = 0, tt = -1; // d[i] 存储点i的入度 for (int i = 1; i \u0026lt;= n; i ++ ) if (!d[i]) q[ ++ tt] = i; while (hh \u0026lt;= tt) { int t = q[hh ++ ]; for (int i = h[t]; i != -1; i = ne[i]) { int j = e[i]; if (-- d[j] == 0) q[ ++ tt] = j; } } // 如果所有点都入队了，说明存在拓扑序列；否则不存在拓扑序列。 return tt == n - 1; } 最短路 单源最短路\n所有边权均为正：朴素Dijkstra O(n^2)；堆优化版的Dijkstra(mlogn)\n存在负权变：Bellman-Ford O(nm) ； SPFA（队列优化Bellman-Ford) 一般：O(m) 最坏 O(nm)\n多元汇最短路：Floyed算法 O(n^3)\n朴素dijkstra算法 —— 模板题 AcWing 849. Dijkstra求最短路 I 基于贪心 时间复杂是 O(n^2+m), n 表示点数，m 表示边数\nint g[N][N]; // 存储每条边， int dist[N]; // 存储1号点到每个点的最短距离 bool st[N]; // 存储每个点的最短路是否已经确定 // 求1号点到n号点的最短路，如果不存在则返回-1 int dijkstra() { memset(dist, 0x3f, sizeof dist); dist[1] = 0; for (int i = 0; i \u0026lt; n - 1; i ++ ) { int t = -1; // 在还未确定最短路的点中，寻找距离最小的点 for (int j = 1; j \u0026lt;= n; j ++ ) if (!st[j] \u0026amp;\u0026amp; (t == -1 || dist[t] \u0026gt; dist[j])) t = j; // 用t更新其他点的距离 for (int j = 1; j \u0026lt;= n; j ++ ) dist[j] = min(dist[j], dist[t] + g[t][j]); st[t] = true; } if (dist[n] == 0x3f3f3f3f) return -1; return dist[n]; } 堆优化版dijkstra —— 模板题 AcWing 850. Dijkstra求最短路 II 时间复杂度 O(mlogn), n 表示点数，m 表示边数\ntypedef pair\u0026lt;int, int\u0026gt; PII; int n; // 点的数量 int h[N], w[N], e[N], ne[N], idx; // 邻接表存储所有边 int dist[N]; // 存储所有点到1号点的距离 bool st[N]; // 存储每个点的最短距离是否已确定 // 求1号点到n号点的最短距离，如果不存在，则返回-1 int dijkstra() { memset(dist, 0x3f, sizeof dist); dist[1] = 0; priority_queue\u0026lt;PII, vector\u0026lt;PII\u0026gt;, greater\u0026lt;PII\u0026gt;\u0026gt; heap; heap.push({0, 1}); // first存储距离，second存储节点编号 while (heap.size()) { auto t = heap.top(); heap.pop(); int ver = t.second, distance = t.first; if (st[ver]) continue; st[ver] = true; for (int i = h[ver]; i != -1; i = ne[i]) { int j = e[i]; if (dist[j] \u0026gt; distance + w[i]) { dist[j] = distance + w[i]; heap.push({dist[j], j}); } } } if (dist[n] == 0x3f3f3f3f) return -1; return dist[n]; } Bellman-Ford算法 —— 模板题 AcWing 853. 有边数限制的最短路 时间复杂度 O(nm), n 表示点数，m表示边数 注意在模板题中需要对下面的模板稍作修改，加上备份数组，详情见模板题。\nint n, m; // n表示点数，m表示边数 int dist[N]; // dist[x]存储1到x的最短路距离 struct Edge // 边，a表示出点，b表示入点，w表示边的权重 { int a, b, w; }edges[M]; // 求1到n的最短路距离，如果无法从1走到n，则返回-1。 int bellman_ford() { memset(dist, 0x3f, sizeof dist); dist[1] = 0; // 如果第n次迭代仍然会松弛三角不等式，就说明存在一条长度是n+1的最短路径，由抽屉原理，路径中至少存在两个相同的点，说明图中存在负权回路。 for (int i = 0; i \u0026lt; n; i ++ ) { for (int j = 0; j \u0026lt; m; j ++ ) { int a = edges[j].a, b = edges[j].b, w = edges[j].w; if (dist[b] \u0026gt; dist[a] + w) dist[b] = dist[a] + w; } } if (dist[n] \u0026gt; 0x3f3f3f3f / 2) return -1; return dist[n]; } spfa 算法（队列优化的Bellman-Ford算法） —— 模板题 AcWing 851. spfa求最短路 时间复杂度 平均情况下 O(m)，最坏情况下 O(nm), n 表示点数，m 表示边数\nint n; // 总点数 int h[N], w[N], e[N], ne[N], idx; // 邻接表存储所有边 int dist[N]; // 存储每个点到1号点的最短距离 bool st[N]; // 存储每个点是否在队列中 // 求1号点到n号点的最短路距离，如果从1号点无法走到n号点则返回-1 int spfa() { memset(dist, 0x3f, sizeof dist); dist[1] = 0; queue\u0026lt;int\u0026gt; q; q.push(1); st[1] = true; while (q.size()) { auto t = q.front(); q.pop(); st[t] = false; for (int i = h[t]; i != -1; i = ne[i]) { int j = e[i]; if (dist[j] \u0026gt; dist[t] + w[i]) { dist[j] = dist[t] + w[i]; if (!st[j]) // 如果队列中已存在j，则不需要将j重复插入 { q.push(j); st[j] = true; } } } } if (dist[n] == 0x3f3f3f3f) return -1; return dist[n]; } spfa判断图中是否存在负环 —— 模板题 AcWing 852. spfa判断负环 时间复杂度是 O(nm), n 表示点数，m 表示边数\nint n; // 总点数 int h[N], w[N], e[N], ne[N], idx; // 邻接表存储所有边 int dist[N], cnt[N]; // dist[x]存储1号点到x的最短距离，cnt[x]存储1到x的最短路中经过的点数 bool st[N]; // 存储每个点是否在队列中 // 如果存在负环，则返回true，否则返回false。 bool spfa() { // 不需要初始化dist数组 // 原理：如果某条最短路径上有n个点（除了自己），那么加上自己之后一共有n+1个点，由抽屉原理一定有两个点相同，所以存在环。 queue\u0026lt;int\u0026gt; q; for (int i = 1; i \u0026lt;= n; i ++ ) { q.push(i); st[i] = true; } while (q.size()) { auto t = q.front(); q.pop(); st[t] = false; for (int i = h[t]; i != -1; i = ne[i]) { int j = e[i]; if (dist[j] \u0026gt; dist[t] + w[i]) { dist[j] = dist[t] + w[i]; cnt[j] = cnt[t] + 1; if (cnt[j] \u0026gt;= n) return true; // 如果从1号点到x的最短路中包含至少n个点（不包括自己），则说明存在环 if (!st[j]) { q.push(j); st[j] = true; } } } } return false; } floyd算法 —— 模板题 AcWing 854. Floyd求最短路 时间复杂度是 O(n3)O(n3), nn 表示点数 初始化： for (int i = 1; i \u0026lt;= n; i ++ ) for (int j = 1; j \u0026lt;= n; j ++ ) if (i == j) d[i][j] = 0; else d[i][j] = INF; // 算法结束后，d[a][b]表示a到b的最短距离 void floyd() { for (int k = 1; k \u0026lt;= n; k ++ ) for (int i = 1; i \u0026lt;= n; i ++ ) for (int j = 1; j \u0026lt;= n; j ++ ) d[i][j] = min(d[i][j], d[i][k] + d[k][j]); } 最小生成树（无向图） Prim : 朴素版Prim O(n^2)(稠密图) ; 堆优化版Prim O(mlogn)(一般不会用)\nKruskal : O(mlogm)(稀疏图)\n朴素版prim算法 —— 模板题 AcWing 858. Prim算法求最小生成树 时间复杂度是 O(n^2+m), n 表示点数，m 表示边数\n初始化距离为正无穷，迭代所有点，找到集合中最近的点，更新它到集合的距离，把t加到集合中。\nint n; // n表示点数 int g[N][N]; // 邻接矩阵，存储所有边 int dist[N]; // 存储其他点到当前最小生成树的距离 bool st[N]; // 存储每个点是否已经在生成树中 // 如果图不连通，则返回INF(值是0x3f3f3f3f), 否则返回最小生成树的树边权重之和 int prim() { memset(dist, 0x3f, sizeof dist); int res = 0; for (int i = 0; i \u0026lt; n; i ++ ) { int t = -1; for (int j = 1; j \u0026lt;= n; j ++ ) if (!st[j] \u0026amp;\u0026amp; (t == -1 || dist[t] \u0026gt; dist[j])) t = j; if (i \u0026amp;\u0026amp; dist[t] == INF) return INF; if (i) res += dist[t]; st[t] = true; for (int j = 1; j \u0026lt;= n; j ++ ) dist[j] = min(dist[j], g[t][j]); } return res; } Kruskal算法 —— 模板题 AcWing 859. Kruskal算法求最小生成树 时间复杂度是 O(mlogm), n 表示点数，m 表示边数\nint n, m; // n是点数，m是边数 int p[N]; // 并查集的父节点数组 struct Edge // 存储边 { int a, b, w; // 重载小于号运算符 // 用于比较两个Edge对象的大小关系 bool operator \u0026lt; (const Edge \u0026amp;W) const { return w \u0026lt; W.w; // 如果当前对象的边权小于W对象的边权，返回true，否则返回false } }edges[M]; int find(int x) // 并查集核心操作 { if (p[x] != x) p[x] = find(p[x]); return p[x]; } int kruskal() { sort(edges, edges + m); for (int i = 1; i \u0026lt;= n; i ++ ) p[i] = i; // 初始化并查集 int res = 0, cnt = 0; for (int i = 0; i \u0026lt; m; i ++ ) { int a = edges[i].a, b = edges[i].b, w = edges[i].w; a = find(a), b = find(b); if (a != b) // 如果两个连通块不连通，则将这两个连通块合并 { p[a] = b; res += w; cnt ++ ; } } if (cnt \u0026lt; n - 1) return INF; return res; } 染色法（本质dfs)判别二分图 —— 模板题 AcWing 860. 染色法判定二分图 给定一个 n 个点m条边的无向图，图中可能存在重边和自环。请你判断这个图是否是二分图。\n时间复杂度是 O(n+m), n 表示点数，m 表示边数\nint n; // n表示点数 int h[N], e[M], ne[M], idx; // 邻接表存储图 int color[N]; // 表示每个点的颜色，-1表示为染色，0表示白色，1表示黑色 // 参数：u表示当前节点，c表示当前点的颜色 bool dfs(int u, int c) { color[u] = c; for (int i = h[u]; i != -1; i = ne[i]) { int j = e[i]; if (color[j] == -1) { if (!dfs(j, !c)) return false; } else if (color[j] == c) return false; } return true; } bool check() { memset(color, -1, sizeof color); bool flag = true; for (int i = 1; i \u0026lt;= n; i ++ ) if (color[i] == -1) if (!dfs(i, 0)) { flag = false; break; } return flag; } 匈牙利算法 —— 模板题 AcWing 861. 二分图的最大匹配 时间复杂度最坏是 O(nm)，实际运行时间一般远小于O(nm)， n 表示点数，m 表示边数\n做错一件事，错过一件事\nint n1, n2; // n1表示第一个集合中的点数，n2表示第二个集合中的点数 int h[N], e[M], ne[M], idx; // 邻接表存储所有边，匈牙利算法中只会用到从第二个集合指向第一个集合的边，所以这里只用存一个方向的边 int match[N]; // 存储第二个集合中的每个点当前匹配的第一个集合中的点是哪个 bool st[N]; // 表示第二个集合中的每个点是否已经被遍历过 bool find(int x) { for (int i = h[x]; i != -1; i = ne[i]) { int j = e[i]; if (!st[j]) { st[j] = true; if (match[j] == 0 || find(match[j])) { match[j] = x; return true; } } } return false; } // 求最大匹配数，依次枚举第一个集合中的每个点能否匹配第二个集合中的点 int res = 0; for (int i = 1; i \u0026lt;= n1; i ++ ) { memset(st, false, sizeof st); if (find(i)) res ++ ; } 作者：yxc 链接：https://www.acwing.com/blog/content/405/ 来源：AcWing 著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。\n第四章 试除法判定质数 —— 模板题 AcWing 866. 试除法判定质数 质数：大于1的整数中，如果只包含1和本身两个约束，称为质数（素数）\n（1）判定，试除法\n（2）分解质因数\nbool is_prime(int x) { if (x \u0026lt; 2) return false; for (int i = 2; i \u0026lt;= x / i; i ++ ) if (x % i == 0) return false; return true; } 试除法分解质因数 —— 模板题 AcWing 867. 分解质因数 void divide(int x) { for (int i = 2; i \u0026lt;= x / i; i ++ ) if (x % i == 0) { int s = 0; while (x % i == 0) x /= i, s ++ ; cout \u0026lt;\u0026lt; i \u0026lt;\u0026lt; \u0026#39; \u0026#39; \u0026lt;\u0026lt; s \u0026lt;\u0026lt; endl; } if (x \u0026gt; 1) cout \u0026lt;\u0026lt; x \u0026lt;\u0026lt; \u0026#39; \u0026#39; \u0026lt;\u0026lt; 1 \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; endl; } 朴素筛法求素数 —— 模板题 AcWing 868. 筛质数 int primes[N], cnt; // primes[]存储所有素数 bool st[N]; // st[x]存储x是否被筛掉 void get_primes(int n) { for (int i = 2; i \u0026lt;= n; i ++ ) { if (st[i]) continue; primes[cnt ++ ] = i; for (int j = i; j \u0026lt;= n; j += i) st[j] = true; } } 线性筛法求素数 —— 模板题 AcWing 868. 筛质数 被最小质因子筛掉\nint primes[N], cnt; // primes[]存储所有素数 bool st[N]; // st[x]存储x是否被筛掉 void get_primes(int n) { for (int i = 2; i \u0026lt;= n; i ++ ) { if (!st[i]) primes[cnt ++ ] = i; for (int j = 0; primes[j] \u0026lt;= n / i; j ++ ) { st[primes[j] * i] = true; if (i % primes[j] == 0) break; } } } 试除法求所有约数 —— 模板题 AcWing 869. 试除法求约数 int范围内约数个数最多为1500个左右\nvector\u0026lt;int\u0026gt; get_divisors(int x) { vector\u0026lt;int\u0026gt; res; for (int i = 1; i \u0026lt;= x / i; i ++ ) if (x % i == 0) { res.push_back(i); if (i != x / i) res.push_back(x / i); } sort(res.begin(), res.end()); return res; } 约数个数和约数之和 —— 模板题 AcWing 870. 约数个数, AcWing 871. 约数之和 如果 N = p1^c1 * p2^c2 * ... *pk^ck 约数个数： (c1 + 1) * (c2 + 1) * ... * (ck + 1) 约数之和： (p1^0 + p1^1 + ... + p1^c1) * ... * (pk^0 + pk^1 + ... + pk^ck) 欧几里得算法 —— 模板题 AcWing 872. 最大公约数 int gcd(int a, int b) { return b ? gcd(b, a % b) : a; } 求欧拉函数 —— 模板题 AcWing 873. 欧拉函数 欧拉函数公式（容斥原理) : n*(1-p1)*(1-p2)\u0026hellip;(1-pk)\nint phi(int x) { int res = x; for (int i = 2; i \u0026lt;= x / i; i ++ ) if (x % i == 0) { res = res / i * (i - 1); while (x % i == 0) x /= i; } if (x \u0026gt; 1) res = res / x * (x - 1); return res; } 筛法求欧拉函数 —— 模板题 AcWing 874. 筛法求欧拉函数 O(n) 线性求所有数的欧拉函数\n应用：欧拉定理：a与n互质 a^φ(n)=1(mod n)\nint primes[N], cnt; // primes[]存储所有素数 int euler[N]; // 存储每个数的欧拉函数 bool st[N]; // st[x]存储x是否被筛掉 void get_eulers(int n) { euler[1] = 1; for (int i = 2; i \u0026lt;= n; i ++ ) { if (!st[i]) { primes[cnt ++ ] = i; euler[i] = i - 1; } for (int j = 0; primes[j] \u0026lt;= n / i; j ++ ) { int t = primes[j] * i; st[t] = true; if (i % primes[j] == 0) { euler[t] = euler[i] * primes[j]; break; } euler[t] = euler[i] * (primes[j] - 1); } } } 快速幂 —— 模板题 AcWing 875. 快速幂 求 m^k mod p，时间复杂度 O(logk)。\nint qmi(int m, int k, int p) { int res = 1 % p, t = m; while (k) { if (k\u0026amp;1) res = res * t % p; t = t * t % p; k \u0026gt;\u0026gt;= 1; } return res; } 扩展欧几里得算法 —— 模板题 AcWing 877. 扩展欧几里得算法 // 求x, y，使得ax + by = gcd(a, b) int exgcd(int a, int b, int \u0026amp;x, int \u0026amp;y) { if (!b) { x = 1; y = 0; return a; } int d = exgcd(b, a % b, y, x); y -= (a/b) * x; return d; } 高斯消元 —— 模板题 AcWing 883. 高斯消元解线性方程组 O(n^3)时间内解n个方程n个未知数的解。\n解：无解 ； 无穷多组解 ； 唯一解 ；\n完美阶梯型：唯一解 *0=*非零 ： *无解 0=0 ： 无穷多组解 高斯消元：\n枚举每一列c：\n找到绝对值最大的一行 将该行换到最上面 将该行第一个数变成1 将下面所有行的第c列消成0 // a[N][N]是增广矩阵 int gauss() { int c, r; for (c = 0, r = 0; c \u0026lt; n; c ++ ) { int t = r; for (int i = r; i \u0026lt; n; i ++ ) // 找到绝对值最大的行 if (fabs(a[i][c]) \u0026gt; fabs(a[t][c])) t = i; if (fabs(a[t][c]) \u0026lt; eps) continue; for (int i = c; i \u0026lt;= n; i ++ ) swap(a[t][i], a[r][i]); // 将绝对值最大的行换到最顶端 for (int i = n; i \u0026gt;= c; i -- ) a[r][i] /= a[r][c]; // 将当前上的首位变成1 for (int i = r + 1; i \u0026lt; n; i ++ ) // 用当前行将下面所有的列消成0 if (fabs(a[i][c]) \u0026gt; eps) for (int j = n; j \u0026gt;= c; j -- ) a[i][j] -= a[r][j] * a[i][c]; r ++ ; } if (r \u0026lt; n) { for (int i = r; i \u0026lt; n; i ++ ) if (fabs(a[i][n]) \u0026gt; eps) return 2; // 无解 return 1; // 有无穷多组解 } for (int i = n - 1; i \u0026gt;= 0; i -- ) for (int j = i + 1; j \u0026lt; n; j ++ ) a[i][n] -= a[i][j] * a[j][n]; return 0; // 有唯一解 } 递归法求组合数 —— 模板题 AcWing 885. 求组合数 I 十万 1\u0026lt;b\u0026lt;a\u0026lt;2000 O(n^2)\n// c[a][b] 表示从a个苹果中选b个的方案数 for (int i = 0; i \u0026lt; N; i ++ ) for (int j = 0; j \u0026lt;= i; j ++ ) if (!j) c[i][j] = 1; else c[i][j] = (c[i - 1][j] + c[i - 1][j - 1]) % mod; 通过预处理逆元的方式求组合数 —— 模板题 AcWing 886. 求组合数 II 一万 1\u0026lt;b\u0026lt;a\u0026lt;10^5 O(logn)\n首先预处理出所有阶乘取模的余数fact[N]，以及所有阶乘取模的逆元infact[N] 如果取模的数是质数，可以用费马小定理求逆元 int qmi(int a, int k, int p) // 快速幂模板 { int res = 1; while (k) { if (k \u0026amp; 1) res = (LL)res * a % p; a = (LL)a * a % p; k \u0026gt;\u0026gt;= 1; } return res; } // 预处理阶乘的余数和阶乘逆元的余数 fact[0] = infact[0] = 1; for (int i = 1; i \u0026lt; N; i ++ ) { fact[i] = (LL)fact[i - 1] * i % mod; infact[i] = (LL)infact[i - 1] * qmi(i, mod - 2, mod) % mod; } ll C(ll n,ll m){ if(m\u0026gt;n) return 0ll; return fact[n]*infact[m]%mod*infact[n-m]%mod; } Lucas定理 —— 模板题 AcWing 887. 求组合数 III 组合数，1\u0026lt;b\u0026lt;a\n若p是质数，则对于任意整数 1 \u0026lt;= m \u0026lt;= n，有： C(n, m) = C(n % p, m % p) * C(n / p, m / p) (mod p) int qmi(int a, int k) // 快速幂模板 { int res = 1; while (k) { if (k \u0026amp; 1) res = (LL)res * a % p; a = (LL)a * a % p; k \u0026gt;\u0026gt;= 1; } return res; } int C(int a, int b) // 通过定理求组合数C(a, b) { int res = 1; for (int i = 1, j = a; i \u0026lt;= b; i ++, j -- ) { res = (LL)res * j % p; res = (LL)res * qmi(i, p - 2) % p; } return res; } int lucas(LL a, LL b) { if (a \u0026lt; p \u0026amp;\u0026amp; b \u0026lt; p) return C(a, b); return (LL)C(a % p, b % p) * lucas(a / p, b / p) % p; } 分解质因数法求组合数 —— 模板题 AcWing 888. 求组合数 IV 当我们需要求出组合数的真实值，而非对某个数的余数时，分解质因数的方式比较好用：\n1. 筛法求出范围内的所有质数 2. 通过 C(a, b) = a! / b! / (a - b)! 这个公式求出每个质因子的次数。 n! 中p的次数是 n / p + n / p^2 + n / p^3 + ... 3. 用高精度乘法将所有质因子相乘 int primes[N], cnt; // 存储所有质数 int sum[N]; // 存储每个质数的次数 bool st[N]; // 存储每个数是否已被筛掉 void get_primes(int n) // 线性筛法求素数 { for (int i = 2; i \u0026lt;= n; i ++ ) { if (!st[i]) primes[cnt ++ ] = i; for (int j = 0; primes[j] \u0026lt;= n / i; j ++ ) { st[primes[j] * i] = true; if (i % primes[j] == 0) break; } } } int get(int n, int p) // 求n！中的次数 { int res = 0; while (n) { res += n / p; n /= p; } return res; } vector\u0026lt;int\u0026gt; mul(vector\u0026lt;int\u0026gt; a, int b) // 高精度乘低精度模板 { vector\u0026lt;int\u0026gt; c; int t = 0; for (int i = 0; i \u0026lt; a.size(); i ++ ) { t += a[i] * b; c.push_back(t % 10); t /= 10; } while (t) { c.push_back(t % 10); t /= 10; } return c; } get_primes(a); // 预处理范围内的所有质数 for (int i = 0; i \u0026lt; cnt; i ++ ) // 求每个质因数的次数 { int p = primes[i]; sum[i] = get(a, p) - get(b, p) - get(a - b, p); } vector\u0026lt;int\u0026gt; res; res.push_back(1); for (int i = 0; i \u0026lt; cnt; i ++ ) // 用高精度乘法将所有质因子相乘 for (int j = 0; j \u0026lt; sum[i]; j ++ ) res = mul(res, primes[i]); 卡特兰数 —— 模板题 AcWing 889. 满足条件的01序列 给定n个0和n个1，它们按照某种顺序排成长度为2n的序列，满足任意前缀中0的个数都不少于1的个数的序列的数量为： $$ Cat(n) = C(2n, n) / (n + 1) $$\n容斥原理 找1~n中能至少被素数p1,p2,\u0026hellip;,pn一个整除的整数有多少个。\n位运算对应容斥原理集合，1~n中能被x整除的个数为n/x，奇数加上，偶数减去\nNIM(尼姆)游戏 —— 模板题 AcWing 891. Nim游戏 给定N堆物品，第i堆物品有Ai个。两名玩家轮流行动，每次可以任选一堆，取走任意多个物品，可把一堆取光，但不能不取。取走最后一件物品者获胜。两人都采取最优策略，问先手是否必胜。\n我们把这种游戏称为NIM博弈。把游戏过程中面临的状态称为局面。整局游戏第一个行动的称为先手，第二个行动的称为后手。若在某一局面下无论采取何种行动，都会输掉游戏，则称该局面必败。 所谓采取最优策略是指，若在某一局面下存在某种行动，使得行动后对面面临必败局面，则优先采取该行动。同时，这样的局面被称为必胜。我们讨论的博弈问题一般都只考虑理想情况，即两人均无失误，都采取最优策略行动时游戏的结果。 NIM博弈不存在平局，只有先手必胜和先手必败两种情况。\n定理： NIM博弈先手必胜，当且仅当 A1 ^ A2 ^ … ^ An != 0\n公平组合游戏ICG 若一个游戏满足：\n由两名玩家交替行动； 在游戏进程的任意时刻，可以执行的合法行动与轮到哪名玩家无关； 不能行动的玩家判负； 则称该游戏为一个公平组合游戏。 NIM博弈属于公平组合游戏，但城建的棋类游戏，比如围棋，就不是公平组合游戏。因为围棋交战双方分别只能落黑子和白子，胜负判定也比较复杂，不满足条件2和条件3。\n有向图游戏 给定一个有向无环图，图中有一个唯一的起点，在起点上放有一枚棋子。两名玩家交替地把这枚棋子沿有向边进行移动，每次可以移动一步，无法移动者判负。该游戏被称为有向图游戏。 任何一个公平组合游戏都可以转化为有向图游戏。具体方法是，把每个局面看成图中的一个节点，并且从每个局面向沿着合法行动能够到达的下一个局面连有向边。\nMex运算 设S表示一个非负整数集合。定义mex(S)为求出不属于集合S的最小非负整数的运算，即： mex(S) = min{x}, x属于自然数，且x不属于S\nSG函数 在有向图游戏中，对于每个节点x，设从x出发共有k条有向边，分别到达节点y1, y2, …, yk，定义SG(x)为x的后继节点y1, y2, …, yk 的SG函数值构成的集合再执行**mex(S)**运算的结果，即： SG(x) = mex({SG(y1), SG(y2), …, SG(yk)}) 特别地，整个有向图游戏G的SG函数值被定义为有向图游戏起点s的SG函数值，即SG(G) = SG(s)。\nint sg(int x){ if (f[x] != -1) return f[x]; unordered_set\u0026lt;int\u0026gt; S; for(int i = 0; i \u0026lt; m; i++ ) { int sum = s[i]; if (x \u0026gt;= sum) S.insert(sg(x - sum)); } for (int i=0; ; i++ ) if (!S.count(i)) return f[x] = i; } 有向图游戏的和 —— 模板题 AcWing 893. 集合-Nim游戏 设G1, G2, …, Gm 是m个有向图游戏。定义有向图游戏G，它的行动规则是任选某个有向图游戏Gi，并在Gi上行动一步。G被称为有向图游戏G1, G2, …, Gm的和。 有向图游戏的和的SG函数值等于它包含的各个子游戏SG函数值的异或和，即： SG(G) = SG(G1) ^ SG(G2) ^ … ^ SG(Gm)\n定理 有向图游戏的某个局面必胜，当且仅当该局面对应节点的SG函数值大于0。 有向图游戏的某个局面必败，当且仅当该局面对应节点的SG函数值等于0。\n作者：yxc 链接：https://www.acwing.com/blog/content/406/ 来源：AcWing 著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。\n时空复杂度分析 当处理ACM或笔试题时，通常时间限制为1秒或2秒。在这种情况下，C++代码中的操作次数应控制在10^7 到 10^8之间，这是最佳范围。\n以下是在不同数据规模下，代码的时间复杂度和算法选择的指导：\nn ≤ 30：指数级别，使用DFS+剪枝，状态压缩DP。 n ≤ 100：O(n^3)，适用于Floyd、DP、高斯消元。 n ≤ 1000：O(n^2)或O(n^2*logn)，适用于DP、分治、高斯消元、朴素版Dijkstra、朴素版Prim、Bellman-Ford。 n ≤ 10000：O(n * √n)，适用于块状链表、分块、莫队。 n ≤ 100000：O(nlogn)，适用于各种排序、线段树、树状数组、集合/映射、堆、拓扑排序、Dijkstra+堆、Prim、Kruskal、SPFA、求凸包、求半平面交、二分、CDQ分治、整体二分、后缀数组、树链剖分、动态树。 n \u0026lt; 1000000：O(n)或常数较小的O(nlogn)，适用于单调队列、哈希映射、双指针扫描、BFS、并查集、KMP、AC自动机、常数较小的O(nlogn)的做法（如排序、树状数组、堆、Dijkstra、SPFA）。 n \u0026lt; 10000000：O(n)，适用于双指针扫描、KMP、AC自动机、线性筛素数。 n ≤ 10^9：O(n√n)，适用于判断质数。 n ≤ 10^18：O(logn)，适用于最大公约数、快速幂、数位DP。 n ≤ 10^1000：O((logn)^2)，适用于高精度加减乘除。 n ≤ 10^100000：O(logk × loglogk)，其中k表示位数，适用于高精度加减、FFT/NTT。 动态规划计算量 ： 状态数 * 状态转移数量\n1 Byte = 8 bit\n1KB = 1024 Byte\n1MB = 102410241024 Byte\n1GB = 1024 * 1024 * 1024 Byte\nint 4 Byte\nchar 1 Byte\ndouble, long long 8 Byte\n动态规划 常见模型\n背包 九讲 01背包 每件物品最多可以用一次\n体积从大到小的原因 ： 如果从小到大，则f[j-w[i]]+v[i]实际是f[i-1][j-w[i]]+v[i]，需要的是上一维度f[i-1]维度，所以从大到小可以使用上一维度的，因为这一维度的还没有被计算到。\nfor(int i=1;i\u0026lt;=N;i++){ for(int j=V;j\u0026gt;=w[i];j--){ f[j]=max(f[j],f[j-w[i]]+v[i]); } } 完全背包 每件物品可以用无限次\nfor(int i=1;i\u0026lt;=N;i++){ for(int j=w[i];j\u0026lt;=V;j++){ f[j]=max(f[j],f[j-w[i]]+v[i]); } } 多重背包 每件物品特定数量\n二进制优化 for(int i=1;i\u0026lt;=N;i++){ cin\u0026gt;\u0026gt;a\u0026gt;\u0026gt;b\u0026gt;\u0026gt;c; //权重a,价值b，数量c int k=1; while(k\u0026lt;=c){ cnt++; c-=k; w[cnt]=k*a; v[cnt]=k*b; k*=2; } if(c){ cnt++; w[cnt]=c*a; v[cnt]=c*b; } } //之后用01背包 单调队列优化 for(int i=1;i\u0026lt;=N;i++){ // 遍历每件物品 memcpy(g, f, sizeof g); // 将上一轮的最优解拷贝给g数组 for(int r=0;r\u0026lt;v[i];r++){ // 遍历余数r（用于优化循环） int h=0,t=-1; // 滑动窗口的起始索引和结束索引 for(int l=r;l\u0026lt;=V;l+=v[i]){ // 遍历背包容量，间隔为当前物品体积 while(h\u0026lt;=t \u0026amp;\u0026amp; l-q[h]\u0026gt;s[i]*v[i]) h++; // 如果窗口左边界超出限制，则左边界右移 while(h\u0026lt;=t \u0026amp;\u0026amp; g[q[t]] + (l-q[t])/v[i]*w[i]\u0026lt;=g[l]) t--; // 保持窗口单调性，将窗口内不符合条件的解移除 q[++t] = l; // 将当前状态的背包容量加入窗口 f[l] = g[q[h]] + (l-q[h])/v[i]*w[i]; // 更新当前状态的最优解 } } } 分组背包 若干组，一组只能选一个\nfor(int i=1;i\u0026lt;=N;i++){ for(int j=V;j\u0026gt;=0;j--){ for(int k=1;k\u0026lt;=s[i];k++){ if(w[i][k]\u0026lt;=j){ f[j]=max(f[j],f[j- w[i][k] ]+v[i][k]); } } } } 混合背包 转换成01背包问题\nfor(int i=1;i\u0026lt;=N;i++){ cin\u0026gt;\u0026gt;a\u0026gt;\u0026gt;b\u0026gt;\u0026gt;s; if(s==-1) s=1; else if(s==0) s=V/a; k=1; while(k\u0026lt;=s){ s-=k; cnt++; v[cnt] = k*a; w[cnt] = k*b; k*=2; } if(s){ cnt++; v[cnt] = s*a; w[cnt] = s*b; } } for(int i=1;i\u0026lt;=cnt;i++){ for(int j=V;j\u0026gt;=v[i];j--){ f[j] = max(f[j], f[j-v[i]]+w[i]); } } 二维费用的背包问题 采用两层循环\ncin\u0026gt;\u0026gt;N\u0026gt;\u0026gt;V\u0026gt;\u0026gt;W; for(int i=1;i\u0026lt;=N;i++){ cin\u0026gt;\u0026gt;v\u0026gt;\u0026gt;m\u0026gt;\u0026gt;w; for(int j=V;j\u0026gt;=v;j--){ for(int k=W;k\u0026gt;=m;k--){ f[j][k] = max(f[j][k], f[j-v][k-m] + w); } } } cout\u0026lt;\u0026lt;f[V][W]\u0026lt;\u0026lt;endl; 线性dp 数字三角形 for(int i=1;i\u0026lt;=n;i++){ for(int j=1;j\u0026lt;=i;j++){ a[i][j]+=max(a[i-1][j],a[i-1][j-1]); } } LIS for(int i=1;i\u0026lt;=n;i++){ for(int j=1;j\u0026lt;i;j++){ if(a[j]\u0026lt;a[i]) f[i]=max(f[j]+1,f[i]); } } for(int i=1;i\u0026lt;=n;i++){ ma=max(f[i],ma); } LCS for(int i=1;i\u0026lt;=n;i++){ for(int j=1;j\u0026lt;=m;j++){ f[i][j]=max(f[i-1][j],f[i][j-1]); if(a[i]==b[j]) f[i][j]=f[i-1][j-1]+1; } } 区间dp 石子合并 memset(f, 0x3f, sizeof f); for(int len=2;len\u0026lt;=n;len++){ for(int i=1;i+len-1\u0026lt;=n;i++){ int j=i+len-1; if (len == 1) { f[i][j] = 0; // 边界初始化 continue; } for(int k=i;k\u0026lt;j;k++){ f[l][r]=min(f[l][r],f[l][k]+f[k+1][r]+s[r]-s[l-1]); } } } cout\u0026lt;\u0026lt;f[1][n]; 数位统计dp 状态表示\n分情况讨论\n状态压缩 dp 蒙德里安的梦想\n最短Hamilton距离\n树形dp 没有上司的舞会\n记忆化 滑雪\n#include\u0026lt;bits/stdc++.h\u0026gt; using namespace std; #define ll long long const int maxn=1e4; ll f[maxn][maxn],g[maxn][maxn]; //distance struct node{ ll i,j,num; }a[maxn]; struct cmp { bool operator () (node x,node y){ return x.num\u0026gt;y.num; } }; int main() { ios::sync_with_stdio(false); cin.tie(0); cout.tie(0); ll n,m,ma=-1; cin\u0026gt;\u0026gt;n\u0026gt;\u0026gt;m; priority_queue\u0026lt;node, vector\u0026lt;node\u0026gt;,cmp\u0026gt;pq; for(ll i=1;i\u0026lt;=n;i++){ for(ll j=1;j\u0026lt;=m;j++){ f[i][j]=1; node a; a.i=i; a.j=j; cin\u0026gt;\u0026gt;a.num; g[i][j]=a.num; pq.push(a); } } while(!pq.empty()){ node t=pq.top(); pq.pop(); ll i=t.i; ll j=t.j; ll nu=t.num; if(g[i-1][j]\u0026lt;nu) f[i][j]=max(f[i][j],f[i-1][j]+1); if(g[i+1][j]\u0026lt;nu) f[i][j]=max(f[i][j],f[i+1][j]+1); if(g[i][j-1]\u0026lt;nu) f[i][j]=max(f[i][j],f[i][j-1]+1); if(g[i][j+1]\u0026lt;nu) f[i][j]=max(f[i][j],f[i][j+1]+1); ma=max(ma,f[i][j]); } cout\u0026lt;\u0026lt;ma\u0026lt;\u0026lt;endl; return 0; } 习题课 ","permalink":"https://kennems.github.io/posts/tech/acwing/","summary":"Acwing算法学习 [TOC] 第一章 课上：学思想 课下：背代码 题目，一道题写好几遍 理解没有任何意义，体力活+脑力活 记忆力 毅力/自制力 沉下心背东西 快速排","title":"Acwing算法学习"},{"content":"算法笔记（二）——数据结构(Python实现) 数据结构 单链表 N = int(1e5+10) e=[0]*N ne=[0]*N head=-1 idx=1 def insert(x): global idx, head e[idx]=x ne[idx]=head head=idx idx+=1 def add(k, x): global idx e[idx]=x ne[idx]=ne[k] ne[k]=idx idx+=1 def remove(k): global idx, head if k==0: head = ne[head] else: ne[k]=ne[ne[k]] n = int(input()) for _ in range(n): s = input().split() op=s[0] if op==\u0026#39;H\u0026#39;: insert(int(s[1])) elif op==\u0026#39;I\u0026#39;: add(int(s[1]), int(s[2])) else: remove(int(s[1])) i=head while i!=-1: print(e[i], end=\u0026#39; \u0026#39;) i=ne[i] 双链表 N = int(1e5+10) e=[0]*N l=[0]*N r=[0]*N idx=0 def init(): global idx r[2]=1 l[1]=2 idx=3 def insert(k, x): global idx e[idx]=x l[idx]=k r[idx]=r[k] l[r[k]]=idx r[k]=idx idx+=1 def remove(k): l[r[k]]=l[k] r[l[k]]=r[k] init() m=int(input()) for _ in range(m): s=input().split() if s[0]==\u0026#39;L\u0026#39;: x=int(s[1]) insert(2,x) elif s[0]==\u0026#39;R\u0026#39;: x=int(s[1]) insert(l[1],x) elif s[0]==\u0026#39;D\u0026#39;: k=int(s[1])+2 remove(k) elif s[0]==\u0026#39;IL\u0026#39;: k=int(s[1])+2 x=int(s[2]) insert(l[k],x) elif s[0]==\u0026#39;IR\u0026#39;: k=int(s[1])+2 x=int(s[2]) insert(k,x) i=2 while i!=0: if i==2 or i==1: i=r[i] continue print(e[i],end=\u0026#34; \u0026#34;) i=r[i] 栈 N = int(1e5+10) # 假设N的值为100 stk = [0] * N tt = 0 # 向栈顶插入一个数 tt += 1 stk[tt] = x # 从栈顶弹出一个数 tt -= 1 # 栈顶的值 stk[tt] # 判断栈是否为空 if tt \u0026gt; 0: pass 队列 N = 100 # 假设N的值为100 q = [0] * N hh = 0 tt = -1 # 向队尾插入一个数 tt += 1 q[tt] = x # 从队头弹出一个数 hh += 1 # 队头的值 q[hh] # 判断队列是否为空 if hh \u0026lt;= tt: pass N = 100 # 假设N的值为100 q = [0] * N hh = 0 tt = 0 # 向队尾插入一个数 q[tt] = x tt += 1 if tt == N: tt = 0 # 从队头弹出一个数 hh += 1 if hh == N: hh = 0 # 队头的值 q[hh] # 判断队列是否为空 if hh != tt: pass 单调栈 tt = 0 stk = [0] * (n + 1) for i in range(1, n + 1): while tt and check(stk[tt], i): tt -= 1 stk[tt + 1] = i tt += 1 单调队列 n = 10 # 假设n的值为10 hh = 0 tt = -1 q = [0] * n for i in range(n): while hh \u0026lt;= tt and check_out(q[hh]): hh += 1 while hh \u0026lt;= tt and check(q[tt], i): tt -= 1 q[tt + 1] = i tt += 1 N = int(1e6+10) q=[0 for _ in range(N)] n,k=map(int, input().split()) a=[0]+[int(x) for x in input().split()] hh,tt=0,-1 for i in range(1,n+1): if hh\u0026lt;=tt and i-q[hh]+1\u0026gt;k: hh+=1 while hh\u0026lt;=tt and a[q[tt]] \u0026gt;= a[i]: tt-=1 tt+=1 q[tt]=i if i \u0026gt;= k: print(a[q[hh]], end=\u0026#34; \u0026#34;) print() hh,tt=0,-1 for i in range(1,n+1): if hh\u0026lt;=tt and i-q[hh]+1\u0026gt;k: hh+=1 while hh\u0026lt;=tt and a[q[tt]] \u0026lt;= a[i]: tt-=1 tt+=1 q[tt]=i if i\u0026gt;=k: print(a[q[hh]], end=\u0026#34; \u0026#34;) KMP m = len(p) # 假设p为模板串，长度为m n = len(s) # 假设s为模式串，长度为n ne = [0] * (m + 1) # 初始化ne数组 # 求Next数组 j = 0 for i in range(2, m + 1): while j and p[i] != p[j + 1]: j = ne[j] if p[i] == p[j + 1]: j += 1 ne[i] = j # 匹配 j = 0 for i in range(1, n + 1): while j and s[i] != p[j + 1]: j = ne[j] if s[i] == p[j + 1]: j += 1 if j == m: j = ne[j] # 匹配成功后的逻辑 n = int(input()) p = \u0026#39; \u0026#39; + input() m = int(input()) s = \u0026#39; \u0026#39; + input() ne = [0]*(n+1) j = 0 for i in range(2, n+1): while j and p[i]!=p[j+1]: j = ne[j] if p[i]==p[j+1]: j += 1 ne[i] = j j = 0 res = [] for i in range(1, m+1): while j and s[i]!=p[j+1]: j = ne[j] if s[i]==p[j+1]: j += 1 if j==n: res.append(i-j) j = ne[j] print(*res, sep=\u0026#39; \u0026#39;) Z函数 def z_function(s): n = len(s) z = [0] * n l, r = 0, 0 for i in range(1, n): if i \u0026lt;= r and z[i - l] \u0026lt; r - i + 1: z[i] = z[i - l] else: z[i] = max(0, r - i + 1) while i + z[i] \u0026lt; n and s[z[i]] == s[i + z[i]]: z[i] += 1 if i + z[i] - 1 \u0026gt; r: l = i r = i + z[i] - 1 return z Tire N = 100010 son = [[0] * 26 for _ in range(N)] cnt = [0] * N idx = 0 # 0号点既是根节点，又是空节点 # son[][]存储树中每个节点的子节点 # cnt[]存储以每个节点结尾的单词数量 # 插入一个字符串 def insert(s): global idx p = 0 for i in range(len(s)): u = ord(s[i]) - ord(\u0026#39;a\u0026#39;) if not son[p][u]: idx += 1 son[p][u] = idx p = son[p][u] cnt[p] += 1 # 查询字符串出现的次数 def query(s): p = 0 for i in range(len(s)): u = ord(s[i]) - ord(\u0026#39;a\u0026#39;) if not son[p][u]: return 0 p = son[p][u] return cnt[p] 马拉车（字符串回文串算法） class Solution: # 推荐教学视频 ：https://www.bilibili.com/video/BV1Sx4y1k7jG/?spm_id_from=333.337.search-card.all.click\u0026amp;vd_source=a4a2b56f746715b34521bfb853094cf4 def longestPalindrome(self, s: str) -\u0026gt; str: s = \u0026#39;#\u0026#39; + \u0026#39;#\u0026#39;.join(list(s)) + \u0026#39;#\u0026#39; n = len(s) p = [0]*n #每个点的 最长回文字串 能到的 两侧长度 c, r = 0, 0 # 右边能到达最远的蘑菇的位置 和 其最右边能达到的位置 for i in range(n): if i\u0026lt;=r: p[i] = min(r-i, p[c + c-i]) # 由已知条件得到当前位置能达到的最大右侧距离( 需要取min(镜像位置的值, 当前最大蘑菇能覆盖到的最大值) ) while i+p[i]+1 \u0026lt; n and s[i-p[i]-1] == s[i+p[i]+1]: p[i]+=1 if p[i]+i \u0026gt; r: r = p[i] + i c = i ma = max(p) idx = p.index(ma) return s[idx-ma+1:idx+ma+1:2] 并查集 N = 1000005 # 假设N的值为1000005 p = [0] * N # 初始化p数组 # 返回x的祖宗节点 def find(x): if p[x] != x: p[x] = find(p[x]) return p[x] \u0026#39;\u0026#39;\u0026#39; 非递归写法 def find(x): while p[x]!=x: p[x] = p[p[x]] x = p[x] return x \u0026#39;\u0026#39;\u0026#39; # 初始化，假定节点编号是1~n for i in range(1, n + 1): p[i] = i # 合并a和b所在的两个集合 p[find(a)] = find(b) 维护size信息\n# Python中没有类似于C++的数组声明方式，我们直接使用列表来代替 p = [i for i in range(N)] size = [1] * N # 返回x的祖宗节点 def find(x): if p[x] != x: p[x] = find(p[x]) return p[x] # 初始化，假定节点编号是1~n n = N # 假设n是提前定义好的 for i in range(1, n + 1): p[i] = i size[i] = 1 # 合并a和b所在的两个集合 p[find(a)] = find(b) size[b] += size[a] 维护到祖宗节点距离的并查集\n# Python中没有类似于C++的数组声明方式，我们直接使用列表来代替 p = [i for i in range(N)] d = [0] * N # 返回x的祖宗节点 def find(x): if p[x] != x: u = find(p[x]) d[x] += d[p[x]] p[x] = u return p[x] # 初始化，假定节点编号是1~n n = N # 假设n是提前定义好的 for i in range(1, n + 1): p[i] = i d[i] = 0 # 合并a和b所在的两个集合 p[find(a)] = find(b) d[find(a)] = distance # 根据具体问题，初始化find(a)的偏移量 题目大意\nAlice 和 Bob 玩了一个古老的格子游戏。游戏在一个 n×n 的点阵上进行，玩家轮流在相邻的点之间画线，分别是红边和蓝边。玩家在画出一条封闭的圈（面积不限）时游戏结束，该玩家获胜。题目要求判断游戏在第几步结束（即画出封闭圈），若 m 步之后也没有结束，则输出 \u0026ldquo;draw\u0026rdquo;。 实现思路\n输入与初始化：读取输入的点阵大小 n 和已画的 m 条边。初始化一个数组 p 作为并查集，p[i] 表示点 i 的父节点。 并查集的查找函数：定义一个 find 函数用于查找点的根节点，同时进行路径压缩以优化查找效率。 处理每条边： ​ 将二维坐标转换为一维标识。 ​ 根据边的方向（向右或向下）计算出连接的两个点。 ​ 使用并查集查找这两个点的根节点，判断它们是否属于同一个集合。如果是同一个集合，则说明形成了封闭圈，输出当前步骤并结束程序。 ​ 如果不属于同一个集合，则将两个点合并。 输出结果：如果遍历完所有边后仍未形成封闭圈，则输出 \u0026ldquo;draw\u0026rdquo;。 from sys import stdin input = lambda:stdin.readline().strip() def find(x): while p[x] != x: p[x] = p[p[x]] x = p[x] return x n, m = map(int, input().split()) p = [i for i in range(n*n+1)] for i in range(1, m+1): x, y, op = input().split() x, y = map(int, (x, y)) a = (x-1)*n + y - 1 if op==\u0026#39;D\u0026#39;: b = x*n + y - 1 else: b = (x-1)*n + y pa, pb = find(a), find(b) if pa == pb: print(i) exit() p[pa] = pb print(\u0026#39;draw\u0026#39;) 堆 # h[N] 存储堆中的值, h[1]是堆顶，x的左儿子是2x, 右儿子是2x + 1 # ph pos[k] 存储第k个插入的点在堆中的位置 # hp ord[k] 存储堆中下标是k的点是第几个插入的 N = 1000005 # 假设N的值为1000005 h = [0] * N # 初始化h数组 ph = [0] * N # 初始化ph数组 hp = [0] * N # 初始化hp数组 size = 0 # 初始化size为0 # 交换两个点，及其映射关系 def heap_swap(a, b): ph[hp[a]], ph[hp[b]] = ph[hp[b]], ph[hp[a]] hp[a], hp[b] = hp[b], hp[a] h[a], h[b] = h[b], h[a] def down(u): t = u if u * 2 \u0026lt;= size and h[u * 2] \u0026lt; h[t]: t = u * 2 if u * 2 + 1 \u0026lt;= size and h[u * 2 + 1] \u0026lt; h[t]: t = u * 2 + 1 if u != t: heap_swap(u, t) down(t) def up(u): while u // 2 and h[u] \u0026lt; h[u // 2]: heap_swap(u, u // 2) u \u0026gt;\u0026gt;= 1 # O(n)建堆 for i in range(n // 2, 0, -1): down(i) def add_element(x): global size size += 1 h[size] = x ph[size] = size hp[size] = size up(size) def get_heap_top(): return h[1] def delete_element(k): global size heap_swap(k, size) size -= 1 down(k) up(k) def update_element(k, x): h[k] = x down(k) up(k) # 添加元素 add_element(x) # 堆顶元素 heap_top = get_heap_top() # 删除第size个节点 delete_element(1) # 删除第k个节点 delete_element(k) # 将第k个元素赋值为x update_element(k, x) import sys from heapq import * input = lambda:sys.stdin.readline().strip() n = int(input()) cnt = 1 d = dict() h = [] for i in range(n): op = input().split() if op[0]==\u0026#39;I\u0026#39;: v = int(op[1]) heappush(h, v) d[cnt] = v; cnt+=1 elif op[0]==\u0026#39;D\u0026#39;: k = int(op[1]) if d[k]==0: continue v = d[k]; d[k]=0 h.remove(v) heapify(h) elif op[0]==\u0026#39;C\u0026#39;: k = int(op[1]) x = int(op[2]) if d[k]==0: continue v = d[k]; d[k]=x h.remove(v) heapify(h) heappush(h, x) elif op[0]==\u0026#39;DM\u0026#39;: heappop(h) elif op[0]==\u0026#39;PM\u0026#39;: print(h[0]) 动态中位数 import sys from heapq import * input = lambda:sys.stdin.readline().strip() p = int(input()) for _ in range(p): id, m = map(int, input().split()) print(id, (m+1)//2) cnt1, cnt2 = 0, 0 hl, hu = [], [] while m: a = list(map(int, input().split())) m -= len(a) for i in range(len(a)): if len(hl)==0 or len(hl)==len(hu): heappush(hu, -a[i]) tmp = -heappop(hu) heappush(hl, tmp) else: heappush(hl, a[i]) tmp = heappop(hl) heappush(hu, -tmp) cnt1+=1 if cnt1\u0026amp;1: print(hl[0], end=\u0026#34; \u0026#34;) cnt2+=1 if cnt2%10==0 and m!=0: print() print() 哈希 (1)拉链法 N = 1000005 # 假设N的值为1000005 h = [-1] * N # 初始化h数组为-1 e = [0] * N # 初始化e数组 ne = [0] * N # 初始化ne数组 idx = 0 # 初始化idx为0 # 向哈希表中插入一个数 def insert(x): k = (x % N + N) % N e[idx] = x ne[idx] = h[k] h[k] = idx idx += 1 # 在哈希表中查询某个数是否存在 def find(x): k = (x % N + N) % N i = h[k] while i != -1: if e[i] == x: return True i = ne[i] return False N = 100003 e, ne, h = [0]*N, [0]*N, [-1]*N idx = 0 def insert(x): global idx k = (x%N + N)%N e[idx] = x ne[idx] = h[k] h[k] = idx idx+=1 def query(x): k = (x%N + N)%N i = h[k] while i!=-1: if e[i]==x: return True i = ne[i] return False n = int(input()) for i in range(n): s = input().split() op, k = s[0], int(s[1]) if op==\u0026#39;I\u0026#39;: insert(k) else: if query(k): print(\u0026#34;Yes\u0026#34;) else: print(\u0026#34;No\u0026#34;) (2) 开放寻址法 N = 1000005 # 假设N的值为1000005 h = [0] * N # 初始化h数组 # 如果x在哈希表中，返回x的下标；如果x不在哈希表中，返回x应该插入的位置 def find(x): t = (x % N + N) % N while h[t] != 0 and h[t] != x: t += 1 if t == N: t = 0 return t 字符串哈希 这段代码实现了字符串的哈希算法，用于快速计算子串的哈希值。下面我来解释一下：\n题目大意： 这段代码实现了字符串哈希算法，可以用于快速计算给定字符串中任意子串的哈希值。\n实现思路：\n首先定义了两个数组 h 和 p，分别用于存储字符串的哈希值和幂次值。 对于字符串的每个位置，计算其对应的哈希值并存储在数组 h 中。同时计算幂次值并存储在数组 p 中。 字符串的哈希值由以下公式计算得到：$h[i] = h[i - 1] \\times P + \\text{ord}(str[i])$其中，$P$是一个预先定义的质数（例如 131 或 13331），$\\text{ord}(str[i])$ 表示字符串中第 $i$ 个字符的 ASCII 值。 计算子串 $str[l:r]$ 的哈希值时，使用以下公式：$ \\text{get}(l, r) = h[r] - h[l - 1] \\times p[r - l + 1] $其中，$h[r]$ 是子串起始位置到结束位置的哈希值，$h[l - 1]$ 是子串起始位置前一个位置的哈希值，$p[r - l + 1]$ 是子串长度对应的幂次值。 总体来说，这段代码实现了字符串哈希算法，用于快速计算给定字符串中任意子串的哈希值。\nh 数组存储了字符串的哈希值，即从字符串的起始位置到当前位置的子串的哈希值。 h[i] 表示字符串从第一个字符到第 i 个字符（包括第 i 个字符）的子串的哈希值。 p[i] 表示幂次值，即 $P^i$ 的值，其中 $P$ 是一个预先定义的质数。 p 数组存储了幂次值，用于计算子串的哈希值时使用。 import sys input = lambda:sys.stdin.readline().strip() mod = 1\u0026lt;\u0026lt;64 def get(l, r): return (h[r] - h[l-1]*p[r-l+1])%mod N = int(1e5) + 10 P = 131 p = [0]*N h = [0]*N n, m = map(int, input().split()) s = \u0026#39; \u0026#39; + input() p[0] = 1 for i in range(1, n+1): h[i] = (h[i-1]*P + ord(s[i]))%mod p[i] = (p[i-1]*P)%mod for i in range(m): l1, r1, l2, r2 = map(int, input().split()) if get(l1, r1) == get(l2, r2): print(\u0026#34;Yes\u0026#34;) else: print(\u0026#34;No\u0026#34;) 树状数组 楼兰图腾\nimport sys input=lambda:sys.stdin.readline() M = 200010 suml, sumg = 0, 0 tr = [0]*M n = int(input()) a = [0]+[int(_) for _ in input().split()] def lowbit(x): return x\u0026amp;-x def add(x,v): while x\u0026lt;M: tr[x]+=v x+=lowbit(x) def query(x): res = 0 while x: res+=tr[x] x-=lowbit(x) return res for i in range(1,n+1): y=a[i] lw = query(y-1) lwr = y-1-lw # the lower element on the right side gr = query(n)-query(y) grr = (n-y) - gr suml += (lw*lwr) sumg += (gr*grr) add(y,1) print(sumg, suml) 线段树 \\1265. 数星星 题目大意：给定一些星星的坐标，以平面直角坐标系表示，需要统计每个星星的等级，即在该星星左下方（含正左、正下）的星星数量。\n实现思路：\n使用线段树来维护每个星星的等级。 构建线段树，初始时所有节点值都为0。 读入每个星星的坐标，通过查询线段树统计该星星左边（含正左）的星星数量，即为该星星的等级。 更新线段树的值，将当前星星的横坐标位置对应的节点值加1。 统计每个等级的星星数量，输出结果。 import sys input = lambda:sys.stdin.readline() N = 15010 M = 32010 tr = [0]*(M*4) level = [0]*N def pushup(u): tr[u] = tr[u \u0026lt;\u0026lt; 1] + tr[u \u0026lt;\u0026lt; 1 | 1] def build(u, l, r): if l == r: tr[u] = 0 else: mid = (l + r) \u0026gt;\u0026gt; 1 build(u \u0026lt;\u0026lt; 1, l, mid) build(u \u0026lt;\u0026lt; 1 | 1, mid + 1, r) pushup(u) def query(u, l, r, ql, qr): if l \u0026gt;= ql and r \u0026lt;= qr: return tr[u] mid = (l + r) \u0026gt;\u0026gt; 1 if mid==l and mid==r: return 0 res = 0 if ql \u0026lt;= mid: res += query(u \u0026lt;\u0026lt; 1, l, mid, ql, qr) if qr \u0026gt; mid: res += query(u \u0026lt;\u0026lt; 1 | 1, mid + 1, r, ql, qr) return res def modify(u, x, l, r, val): if l == r: tr[u] += val else: mid = (l + r) \u0026gt;\u0026gt; 1 if x \u0026lt;= mid: modify(u \u0026lt;\u0026lt; 1, x, l, mid, val) else: modify(u \u0026lt;\u0026lt; 1 | 1, x, mid + 1, r, val) pushup(u) l, r = 0, 32000 build(1, l, r) n = int(input()) for i in range(n): x, _ = map(int, input().split()) t = query(1, l, r, 0, x) level[t]+=1 modify(1, x, l, r, 1) for i in range(n): print(level[i]) 最大数 import sys input = lambda:sys.stdin.readline().strip() m = int(2e5)+2 tr = [0]*(m*4) def pushup(u): tr[u] = max(tr[u\u0026lt;\u0026lt;1], tr[u\u0026lt;\u0026lt;1|1]) def modify(u, l, r, x, v): if l==r: tr[u] = v else: mid = l+r\u0026gt;\u0026gt;1 if x\u0026lt;=mid: modify(u\u0026lt;\u0026lt;1, l, mid, x, v) else: modify(u\u0026lt;\u0026lt;1|1, mid+1, r, x, v) pushup(u) def query(u, l, r, ql, qr): if l\u0026gt;=ql and r\u0026lt;=qr: return tr[u] if l==r: return 0 res = 0 mid = l+r\u0026gt;\u0026gt;1 if ql\u0026lt;=mid: res = query(u\u0026lt;\u0026lt;1, l, mid, ql, qr) if qr\u0026gt;mid: res = max(res, query(u\u0026lt;\u0026lt;1|1, mid+1, r, ql, qr)) return res m, p = map(int, input().split()) n, pre = 0, 0 for i in range(m): op, x = input().split() x = int(x) if op==\u0026#39;Q\u0026#39;: pre = query(1, 1, m, n-x+1, n) print(pre) else: n += 1 modify(1, 1, m, n, (x+pre)%p) \\243. 一个简单的整数问题2 import sys input = lambda:sys.stdin.readline().strip() N = int(1e5)+10 M = 1\u0026lt;\u0026lt;N.bit_length() + 1 tr = [0]*M add = [0]*M def pushup(u): tr[u] = tr[u\u0026lt;\u0026lt;1] + tr[u\u0026lt;\u0026lt;1|1] def pushdown(u, ln, rn): if add[u]: lazy(u\u0026lt;\u0026lt;1, add[u], ln) lazy(u\u0026lt;\u0026lt;1|1, add[u], rn) add[u] = 0 def lazy(u, v, n): tr[u] += v*n add[u] += v def build(u, l, r): if l==r: tr[u] = w[l] else: mid = l+r\u0026gt;\u0026gt;1 build(u\u0026lt;\u0026lt;1, l, mid) build(u\u0026lt;\u0026lt;1|1, mid+1, r) pushup(u) add[u] = 0 def modify(u, l, r, ml, mr, v): if l\u0026gt;=ml and r\u0026lt;=mr: lazy(u, v, r-l+1) else: mid = l+r\u0026gt;\u0026gt;1 pushdown(u, mid-l+1, r-mid) if ml \u0026lt;= mid: modify(u\u0026lt;\u0026lt;1, l, mid, ml, mr, v) if mr \u0026gt; mid: modify(u\u0026lt;\u0026lt;1|1, mid+1, r, ml, mr, v) pushup(u) def query(u, l, r, ql, qr): if l\u0026gt;=ql and r\u0026lt;=qr: return tr[u] mid = l+r\u0026gt;\u0026gt;1 pushdown(u, mid-l+1, r-mid) res = 0 if ql\u0026lt;=mid: res = query(u\u0026lt;\u0026lt;1, l, mid, ql, qr) if qr\u0026gt;mid: res += query(u\u0026lt;\u0026lt;1|1, mid+1, r, ql, qr) return res # 主程序开始 n, m = map(int, input().split()) # 输入节点数量n和操作数量m w = list(map(int, input().split())) # 输入节点的初始权值 build(1, 0, n-1) res = [] # 存储查询结果 while m: m -= 1 op, opt = input().split(maxsplit=1) if op == \u0026#39;Q\u0026#39;: l, r = map(int, opt.split()) l-=1; r-=1 res.append(str(query(1, 0, n-1, l, r))) # 查询区间和并将结果添加到res列表中 else: l, r, val = map(int, opt.split()) l-=1; r-=1 modify(1, 0, n-1, l, r, val) # 修改区间的值 print(\u0026#34;\\n\u0026#34;.join(res)) # 输出查询结果 维护序列 题目大意：给定一个长度为 n 的数列 𝑎𝑖，有三种操作：1. 格式1 t g c，将区间 [t, g] 内的数乘以 c；2. 格式2 t g c，将区间 [t, g] 内的数加上 c；3. 格式3 t g，求区间 [t, g] 内数的和，并输出结果模 p 的值。\n实现思路：\n使用线段树来维护区间和，每个节点保存区间内数的和。 对于每种操作，根据操作类型分别进行处理。 对于格式1和格式2，采用延迟标记来实现区间修改。对于格式3，采用递归的方式查询区间和。 实现具体的操作函数，包括建树、修改和查询。 循环读入每个操作并进行处理，最后输出查询结果。 import sys input = lambda: sys.stdin.readline().strip() N = int(1e5) + 1 M = 1 \u0026lt;\u0026lt; N.bit_length() + 1 tr = [0] * M add = [0] * M mul = [0] * M def lazy(u, n, ad, mu): tr[u] = (tr[u] * mu + n * ad) % p add[u] = (add[u] * mu + ad) % p mul[u] = (mul[u] * mu) % p def pushup(u): tr[u] = tr[u \u0026lt;\u0026lt; 1] + tr[u \u0026lt;\u0026lt; 1 | 1] def pushdown(u, ln, rn): if add[u] != 0 or mul[u] != -1: lazy(u \u0026lt;\u0026lt; 1, ln, add[u], mul[u]) lazy(u \u0026lt;\u0026lt; 1 | 1, rn, add[u], mul[u]) add[u] = 0 mul[u] = 1 def build(u, l, r): if l == r: tr[u] = w[l] else: mid = l + r \u0026gt;\u0026gt; 1 build(u \u0026lt;\u0026lt; 1, l, mid) build(u \u0026lt;\u0026lt; 1 | 1, mid + 1, r) pushup(u) add[u] = 0 mul[u] = 1 def modify(u, l, r, ml, mr, ad, mu): if l \u0026gt;= ml and r \u0026lt;= mr: lazy(u, r - l + 1, ad, mu) else: mid = l + r \u0026gt;\u0026gt; 1 pushdown(u, mid - l + 1, r - mid) if ml \u0026lt;= mid: modify(u \u0026lt;\u0026lt; 1, l, mid, ml, mr, ad, mu) if mr \u0026gt; mid: modify(u \u0026lt;\u0026lt; 1 | 1, mid + 1, r, ml, mr, ad, mu) pushup(u) def query(u, l, r, ql, qr): if l \u0026gt;= ql and r \u0026lt;= qr: return tr[u] mid = l + r \u0026gt;\u0026gt; 1 pushdown(u, mid - l + 1, r - mid) res = 0 if ql \u0026lt;= mid: res += query(u \u0026lt;\u0026lt; 1, l, mid, ql, qr) if qr \u0026gt; mid: res += query(u \u0026lt;\u0026lt; 1 | 1, mid + 1, r, ql, qr) return res % p n, p = map(int, input().split()) w = [0] + list(map(int, input().split())) m = int(input()) build(1, 1, n) res = [] for i in range(m): op, par = input().split(maxsplit=1) if op == \u0026#34;1\u0026#34;: l, r, mu = map(int, par.split()) modify(1, 1, n, l, r, 0, mu) elif op == \u0026#34;2\u0026#34;: l, r, ad = map(int, par.split()) modify(1, 1, n, l, r, ad, 1) else: l, r = map(int, par.split()) res.append(str(query(1, 1, n, l, r))) print(*res, sep=\u0026#34;\\n\u0026#34;) \\246. 区间最大公约数 from math import gcd from sys import stdin input = stdin.readline def pushup(u): tr[u] = tr[u\u0026lt;\u0026lt;1] + tr[u\u0026lt;\u0026lt;1|1] gd[u] = gcd(gd[u\u0026lt;\u0026lt;1], gd[u\u0026lt;\u0026lt;1|1]) def build(u, l, r): if l==r: tr[u] = gd[u] = arr[l]-arr[l-1] else: mid = l+r\u0026gt;\u0026gt;1 build(u\u0026lt;\u0026lt;1, l, mid) build(u\u0026lt;\u0026lt;1|1, mid+1, r) pushup(u) def modify(u, l, r, x, v): if l==r: tr[u] += v gd[u] += v else: mid = l+r\u0026gt;\u0026gt;1 if x\u0026lt;=mid: modify(u\u0026lt;\u0026lt;1, l, mid, x, v) else: modify(u\u0026lt;\u0026lt;1|1, mid+1, r, x, v) pushup(u) def query(u, l, r, ql, qr): if l\u0026gt;=ql and r\u0026lt;=qr: return (tr[u], gd[u]) mid = l+r\u0026gt;\u0026gt;1 a, b = [0, 0], [0, 0] if ql\u0026lt;=mid: a = query(u\u0026lt;\u0026lt;1, l, mid, ql, qr) if qr\u0026gt;mid: b = query(u\u0026lt;\u0026lt;1|1, mid+1, r, ql, qr) return (a[0]+b[0], gcd(a[1], b[1])) n, m = map(int, input().split()) arr = [0] + list(map(int, input().split())) M = 1\u0026lt;\u0026lt;n.bit_length() + 1 tr = [0]*M gd = [0]*M build(1, 1, n) res = [] for i in range(m): op, par = input().split(maxsplit=1) if op==\u0026#39;Q\u0026#39;: l, r = map(int, par.split()) ans = gcd(query(1, 1, n, 1, l)[0], query(1, 1, n, l+1, r)[1]) if l+1\u0026lt;=r else query(1, 1, n, 1, l)[0] res.append(str(ans)) else: l, r, v = map(int, par.split()) modify(1, 1, n, l, v) if r+1\u0026lt;=n: modify(1, 1, n, r+1, -v) print(*res, sep=\u0026#39;\\n\u0026#39;) 类实现线段树 # 定义树节点，l,r, val表示该节点记录的是区间[l, r]的最大值是val class Tree(): def __init__(self): self.l = 0 self.r = 0 self.lazy = 0 self.val = 0 # 二叉树是堆形式，可以用一维数组存储，注意数组长度要开4倍空间 tree = [Tree() for i in range(10*4)] # 建树，用cur\u0026lt;\u0026lt;1访问左子树，cur\u0026lt;\u0026lt;1|1访问右子树，位运算操作很方便 def build(cur, l, r): tree[cur].l, tree[cur].r, tree[cur].lazy, tree[cur].val = l, r, 0, 0 # 当l==r的时候结束递归 if l \u0026lt; r: mid = l + r \u0026gt;\u0026gt; 1 build(cur\u0026lt;\u0026lt;1, l, mid) build(cur\u0026lt;\u0026lt;1|1, mid+1, r) # 当子节点计算完成后，用子节点的值来更新自己的值 def pushup(cur): tree[cur].val = max(tree[cur\u0026lt;\u0026lt;1].val, tree[cur\u0026lt;\u0026lt;1|1].val) # 单点更新 def add(cur, x, v): if tree[cur].l == tree[cur].r: tree[cur].val += v else: mid = tree[cur].r + tree[cur].l \u0026gt;\u0026gt; 1 if x \u0026gt; mid: add(cur\u0026gt;\u0026gt;1|1, x, v) else: add(cur\u0026lt;\u0026lt;1, x, v) pushup(cur) # 将lazy标记向下传递一层 def pushdown(cur): if tree[cur].lazy: lazy = tree[cur].lazy tree[cur\u0026lt;\u0026lt;1].lazy += lazy tree[cur\u0026lt;\u0026lt;1|1].lazy += lazy tree[cur\u0026lt;\u0026lt;1].val += lazy tree[cur\u0026lt;\u0026lt;1|1].val += lazy tree[cur].lazy = 0 # 区间更新 def update(cur, l, r, v): if l \u0026lt;= tree[cur].l and tree[cur].r \u0026lt;= r: tree[cur].lazy += v tree[cur].val += v return if r \u0026lt; tree[cur].l or l \u0026gt; tree[cur].r: return if tree[cur].lazy: pushdown(cur) update(cur\u0026lt;\u0026lt;1, l, r, v) update(cur\u0026lt;\u0026lt;1|1, l, r, v) pushup(cur) # 区间查询 def query(cur, l, r): if l \u0026lt;= tree[cur].l and tree[cur].r \u0026lt;= r: return tree[cur].val if tree[cur].l \u0026gt; r or tree[cur].r \u0026lt; l: return 0 if tree[cur].lazy: pushdown(cur) return max(query(cur\u0026lt;\u0026lt;1, l, r), query(cur\u0026lt;\u0026lt;1|1)) # 测试 # ----- # --- # ------- # -- # -- build(1, 1, 10) update(1, 1, 5, 1) update(1, 7, 10, 1) update(1, 2, 8, 1) update(1, 3, 4, 1) update(1, 9, 10, 1) print(query(1, 1, 10)) def pushup(u): tr[u] = tr[u \u0026lt;\u0026lt; 1] + tr[u \u0026lt;\u0026lt; 1 | 1] def build(u, l, r): if l == r: tr[u] = 0 else: mid = (l + r) \u0026gt;\u0026gt; 1 build(u \u0026lt;\u0026lt; 1, l, mid) build(u \u0026lt;\u0026lt; 1 | 1, mid + 1, r) pushup(u) def query(u, l, r, ql, qr): if l \u0026gt;= ql and r \u0026lt;= qr: return tr[u] mid = (l + r) \u0026gt;\u0026gt; 1 if mid==l and mid==r: return 0 res = 0 if ql \u0026lt;= mid: res = query(u \u0026lt;\u0026lt; 1, l, mid, ql, qr) if qr \u0026gt; mid: res += query(u \u0026lt;\u0026lt; 1 | 1, mid + 1, r, ql, qr) return res def modify(u, x, l, r, val): if l == r: tr[u] += val else: mid = (l + r) \u0026gt;\u0026gt; 1 if x \u0026lt;= mid: modify(u \u0026lt;\u0026lt; 1, x, l, mid, val) else: modify(u \u0026lt;\u0026lt; 1 | 1, x, mid + 1, r, val) pushup(u) 搜索深入 池塘计数 import sys from collections import deque input = lambda:sys.stdin.readline().strip() N = int(1e3+10) M = N*N g = [0]*N cnt=0 vis = [ [False]*N for _ in range(N) ] def bfs(x, y): q=deque() q.append( (x,y) ) while q: tx, ty = q[0] q.popleft() for i in range(-1, 2): for j in range(-1, 2): if i==0 and j==0: continue xx, yy = tx+i, ty+j if xx\u0026lt;0 or xx\u0026gt;=n or yy\u0026lt;0 or yy\u0026gt;=m or vis[xx][yy] or g[xx][yy]==\u0026#39;.\u0026#39;: continue vis[xx][yy]=True q.append( (xx,yy) ) n, m = map(int, input().split()) for i in range(n): g[i]=input() for i in range(n): for j in range(m): if g[i][j]!=\u0026#39;W\u0026#39; or vis[i][j]: continue bfs(i, j) cnt+=1 print(cnt) 城堡问题 import sys from collections import deque input = lambda:sys.stdin.readline().strip() N = 55 g = [] vis = [[False]*N for _ in range(N)] area = 0 cnt=0 def bfs(x, y): vis[x][y]=True q = deque() q.append((x, y)) dx, dy = [0, -1, 0, 1], [-1, 0, 1, 0] ans=1 while q: tx, ty = q.popleft() for i in range(4): xx = tx+dx[i] yy = ty+dy[i] if xx\u0026lt;0 or xx\u0026gt;=n or yy\u0026lt;0 or yy\u0026gt;=m or vis[xx][yy]: continue if (g[tx][ty]\u0026gt;\u0026gt;i)\u0026amp;1: continue ans+=1 vis[xx][yy]=True q.append((xx,yy)) return ans n, m = map(int, input().split()) for _ in range(n): g.append(list(map(int, input().split()))) for i in range(n): for j in range(m): if vis[i][j]: continue area = max(area, bfs(i, j)) cnt+=1 print(cnt) print(area) 山峰和山谷 import sys from collections import deque N = 1010 g = [] vis = [[0]*N for _ in range(N)] pek, val = 0, 0 def bfs(x, y): global higher, lower vis[x][y]=True q = deque() q.append((x,y)) while q: tx,ty = q.popleft() for i in range(-1, 2): for j in range(-1, 2): if i==0 and j==0: continue xx, yy = tx+i, ty+j if xx\u0026lt;0 or xx\u0026gt;=n or yy\u0026lt;0 or yy\u0026gt;=n: continue if g[xx][yy]!=g[tx][ty]: if g[xx][yy]\u0026gt;g[tx][ty]: higher=True elif g[xx][yy]\u0026lt;g[tx][ty]: lower=True elif not vis[xx][yy]: vis[xx][yy]=True q.append((xx,yy)) higher, lower = False, False n = int(input()) for _ in range(n): g.append(list(map(int, input().split()))) # print(g) for i in range(n): for j in range(n): if vis[i][j]: continue higher, lower = False, False bfs(i, j) if not higher:pek+=1 if not lower:val+=1 print(pek, val) BFS P1038 [NOIP2003 提高组] 神经网络 题目大意：兰兰提出了一个神经网络模型，该模型可以表示为一个有向图，图中的节点称为神经元，节点之间的连接代表神经元之间的联系。神经元按照一定的顺序排列，构成整个神经网络。每个神经元都有一个状态和阈值，当神经元处于兴奋状态时，会向其他神经元传送信号。\n实现思路：\n首先，根据输入的网络结构信息，构建神经元之间的连接关系。使用字典g来表示神经元之间的连接关系，以及字典wei来表示连接神经元之间的边的权值。 然后，根据输入的初始状态和阈值信息，初始化神经元的状态。同时，记录输入层神经元的初始状态，如果神经元的状态不为0，则将其加入队列q中。 利用广度优先搜索（BFS）算法，遍历神经元，根据模型公式更新每个神经元的状态。同时，更新神经元的状态时，考虑到边的权值以及神经元的阈值。 最后，输出输出层神经元的状态。如果输出层神经元的最后状态均小于等于0，则输出\u0026quot;NULL\u0026quot;，否则按照编号从小到大顺序输出输出层神经元的状态。 from collections import deque, defaultdict maxn = 1e3 + 10 c = [0] * int(maxn) u = [0] * int(maxn) wei = defaultdict(lambda: defaultdict(int)) vis = [False] * int(maxn) beginer = [False] * int(maxn) g = defaultdict(list) n, p = map(int, input().split()) en = [] q = deque() for i in range(1, n + 1): c[i], u[i] = map(int, input().split()) if c[i] != 0: q.append(i) beginer[i] = True else: en.append(i) if not en: for i in range(1, n + 1): print(i, c[i]) exit() for _ in range(p): s, e, w = map(int, input().split()) g[s].append(e) wei[s][e] = w while q: t = q.popleft() if not beginer[t]: c[t] -= u[t] base = c[t] if base \u0026gt; 0: for j in g[t]: c[j] += base * wei[t][j] if not vis[j]: q.append(j) vis[j] = True ans = 0 for i in en: if c[i] \u0026gt; 0 and not g[i]: print(i, c[i]) ans += 1 if not ans: print(\u0026#34;NULL\u0026#34;) ","permalink":"https://kennems.github.io/posts/tech/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0%E4%BA%8C%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84python%E5%AE%9E%E7%8E%B0/","summary":"算法笔记（二）——数据结构(Python实现) 数据结构 单链表 N = int(1e5+10) e=[0]*N ne=[0]*N head=-1 idx=1 def insert(x): global idx, head e[idx]=x ne[idx]=head head=idx idx+=1 def add(k, x): global idx e[idx]=x ne[idx]=ne[k] ne[k]=idx idx+=1 def remove(k): global idx, head if k==0: head = ne[head] else: ne[k]=ne[ne[k]] n = int(input())","title":"算法笔记（二）——数据结构(Python实现)"},{"content":"算法笔记（三）——图论（Python实现） 图论 树的存储 邻接矩阵 # 创建一个二维列表表示邻接矩阵 n = 10 # 顶点数量 g = [[0] * n for _ in range(n)] # 添加一条边a-\u0026gt;b def add_edge(a, b): g[a][b] = 1 # 初始化 g = [[0] * n for _ in range(n)] 邻接表 # 创建一个列表表示邻接表 n = 10 # 顶点数量 h = [-1] * n e = [0] * n ne = [0] * n idx = 0 # 添加一条边a-\u0026gt;b def add_edge(a, b): global idx e[idx] = b ne[idx] = h[a] h[a] = idx idx += 1 # 初始化 idx = 0 h = [-1] * n 树和图的存储 # 邻接表表示的图 N = 100010 # 根据具体需求设置合适的最大节点数量 # 对于每个点k，开一个单链表，存储k所有可以走到的点。h[k]存储这个单链表的头结点 h = [-1] * N # 存储边的目标节点 e = [0] * N # 存储下一条边的索引 ne = [0] * N # 边的索引 idx = 0 # 添加一条边a-\u0026gt;b def add(a, b): global idx e[idx] = b ne[idx] = h[a] h[a] = idx idx += 1 # 初始化 idx = 0 for i in range(N): h[i] = -1 树和图的遍历 DFS def dfs(u): st[u] = True i = h[u] while i!=-1: j = e[i] if not st[j]: dfs(j) i = ne[i] BFS from collections import deque q = deque() st[1] = True q.append(1) while q: t = q.popleft() i = h[t] while i!=-1: j=e[i] if not st[j]: st[j] = True q.append(j) i=ne[i] 拓扑排序 from sys import stdin from collections import deque input = lambda:stdin.readline().strip() def topsort(): q = deque() res = [] for i in range(1, n+1): if ind[i]==0: res.append(i) q.append(i) while q: u = q.popleft() for v in g[u]: ind[v] -= 1 if ind[v]==0: q.append(v) res.append(v) return res n = int(input()) ind = [0]*(n+1) g = [[] for _ in range(n+1)] for i in range(1, n+1): a = list(map(int, input().split())) for j in range(len(a)-1): g[i].append(a[j]) ind[a[j]]+=1 res = topsort() print(*res, sep=\u0026#39; \u0026#39;) 奖金 from sys import stdin from collections import deque def topsort(): res = [] q = deque() ans = 0 for i in range(1, n+1): if ind[i]==0: res.append(i) q.append((i, 100)) ans += 100 while q: u, m = q.popleft() for v in g[u]: ind[v] -= 1 if ind[v]==0: q.append((v, m+1)) res.append(v) ans += m+1 if len(res)==n: print(ans) else: print(\u0026#34;Poor Xed\u0026#34;) n, m = map(int, input().split()) ind = [0]*(n+1) g = [[] for _ in range(n+1)] for i in range(m): a, b = map(int, input().split()) ind[a] += 1 g[b].append(a) topsort() LCA def lca(x,y): if dep[x] \u0026lt; dep[y]: x,y = y,x d = dep[x]-dep[y] while d: # 循环直到深度差为 0 v = d \u0026amp; -d # 获取 d 的最低位的 1 所在的位置 i = v.bit_length() - 1 # 计算最低位的位置索引 x = fa[i][x] # 将节点 x 上移到和节点 y 同一深度 d -= v # 更新深度差 if x==y: return x for k in range(K-1, -1, -1): if fa[k][x] != fa[k][y]: x = fa[k][x] y = fa[k][y] return fa[0][x] # 初始化深度以及父节点信息 dep[x]=dep[val]+1 dep[y]=dep[val]+1 fa[0][x] = val fa[0][y] = val for k in range(K-1): fa[k+1][x] = fa[k][fa[k][x]] # 自己的第2^(1+1)级父亲即为 自己的第2^(1)级父亲 的第2^(1)级父亲 fa[k+1][y] = fa[k][fa[k][y]] 祖孙询问 from sys import stdin from collections import deque, defaultdict from math import inf K = 17 N = int(4*10e4) + 10 dep = [inf]*(N) fa = [[0]*N for _ in range(K)] def bfs(): dep[0] = 0; dep[root] = 1 q = deque([root]) while q: u = q.popleft() for v in g[u]: if dep[v] \u0026gt; dep[u] + 1: dep[v] = dep[u] + 1 q.append(v) fa[0][v] = u for k in range(1, K-1): fa[k][v] = fa[k-1][fa[k-1][v]] def lca(x, y): if dep[x] \u0026lt; dep[y]: x, y = y, x d = dep[x] - dep[y] while d: v = d \u0026amp; -d i = v.bit_length() - 1 x = fa[i][x] d -= v if x==y: return x for k in range(K-1, -1, -1): if fa[k][x] != fa[k][y]: x = fa[k][x] y = fa[k][y] return fa[0][x] n = int(input()) g = defaultdict(list) for i in range(n): a, b = map(int, input().split()) if b==-1: root = a else: g[a].append(b) g[b].append(a) bfs() # print(dep) m = int(input()) for i in range(m): x, y = map(int, input().split()) res = lca(x, y) if res == x and res != y: print(1) elif res == y and res != x: print(2) else: print(0) 最短路 单元最短路\n​\t所有边权为正：\n​\t朴素版Dijkstra $O(n^2)$,堆优化版的Dijkstra $O(mlogn)$, ​\t存在负权边\n​\tBellman-Ford $O(nm)$, SPFA 队列优化的Bellman-Ford, 一般情况：$O(m)$ 最坏情况：$O(nm)$ 多元汇最短路：\n​\tFloyed $O(n^3)$ 朴素Dijkstra Dijkstra不能处理负权边：\nN = int(5e2)+10 INF = 0x3f3f3f3f g = [[INF]*N for _ in range(N)] #g = defaultdict(lambda:defaultdict(lambda:INF)) 同样的效果 dis = [INF]*N st = [False]*N def dijkstra(): dis[1]=0 for i in range(n-1): t=-1 for j in range(1,n+1): if not st[j] and (t==-1 or dis[j]\u0026lt;dis[t]): t=j for j in range(1,n+1): dis[j]=min(dis[j], dis[t] + g[t][j]) st[t]=True if dis[n]==INF: return -1 return dis[n] n, m = map(int, input().split()) for _ in range(m): x, y, z = map(int ,input().split()) g[x][y] = min(g[x][y], z) print(dijkstra()) 堆优化版Dijkstra from heapq import * import sys input = lambda:sys.stdin.readline().strip() N = 150010 INF = 0x3f3f3f3f e, ne, head, w, dis= [0]*N, [0]*N, [-1]*N, [0]*N, [INF]*N st = [False]*N idx=0 def add(a, b, x): global idx e[idx]=b w[idx]=x ne[idx]=head[a] head[a]=idx idx+=1 def dijkstra(): dis[1]=0 h=[] heappush(h, (0,1)) while h: dist, ver = heappop(h) if st[ver]: continue st[ver]=True i=head[ver] while i!=-1: j=e[i] if not st[j] and dis[j]\u0026gt;dist+w[i]: dis[j]=dist+w[i] heappush(h, (dis[j], j)) i=ne[i] if dis[n]==INF: print(-1) else: print(dis[n]) n, m = map(int, input().split()) for _ in range(m): x, y, z = map(int, input().split()) add(x,y,z) dijkstra() 另一种写法 from sys import stdin from math import inf from collections import deque, defaultdict from heapq import heappush, heappop input = lambda:stdin.readline().strip() def dijkstra(): h = [(0, 1)] dis[1] = 0 while h: dist, ver = heappop(h) if vis[ver]: continue vis[ver] = True for nx, z in g[ver]: if dis[nx] \u0026gt; dis[ver] + z: dis[nx] = dis[ver] + z heappush(h, (dis[nx], nx)) return dis[n] n, m = map(int, input().split()) dis = [inf]*(n+1) vis = [False]*(n+1) g = defaultdict(list) for i in range(m): x, y, z = map(int, input().split()) g[x].append((y, z)) res = dijkstra() print(res if res != inf else -1) Bellman-Ford # n表示点数，m表示边数 dist = [float(\u0026#39;inf\u0026#39;)] * (n + 1) # dist[x]存储1到x的最短路距离 # 边，a表示出点，b表示入点，w表示边的权重 edges = [] # 求1到n的最短路距离，如果无法从1走到n，则返回-1。 def bellman_ford(): dist[1] = 0 # 如果第n次迭代仍然会松弛三角不等式，就说明存在一条长度是n+1的最短路径，由抽屉原理，路径中至少存在两个相同的点，说明图中存在负权回路。 for i in range(n): for j in range(m): a, b, w = edges[j][\u0026#39;a\u0026#39;], edges[j][\u0026#39;b\u0026#39;], edges[j][\u0026#39;w\u0026#39;] if dist[b] \u0026gt; dist[a] + w: dist[b] = dist[a] + w if dist[n] \u0026gt; float(\u0026#39;inf\u0026#39;) / 2: return -1 return dist[n] SPFA from collections import defaultdict, deque import sys input = lambda:sys.stdin.readline().strip() N, INF = int(1e5+10), 0x3f3f3f3f dis, st = [INF]*N, [False]*N g=defaultdict(list) def spfa(): q=deque() q.append(1) st[1]=True dis[1]=0 while q: x=q.popleft() st[x]=False for y, z in g[x]: if dis[y]\u0026gt;dis[x]+z: dis[y]=dis[x]+z if not st[y]: st[y]=True q.append(y) if dis[n]==INF: print(\u0026#39;impossible\u0026#39;) else: print(dis[n]) n, m = map(int, input().split()) for _ in range(m): x, y, z = map(int, input().split()) g[x].append((y, z)) spfa() 判断负环 from sys import stdin from collections import deque, defaultdict from math import inf input = lambda:stdin.readline().strip() def spfa(): q = deque() for i in range(1, n+1): q.append(i) st[i] = True while q: x = q.popleft() st[x] = False for y, z in g[x]: if dis[y] \u0026gt; dis[x] + z: dis[y] = dis[x] + z cnt[y] = cnt[x] + 1 if cnt[y] \u0026gt;= n: return True if not st[y]: q.append(y) st[y] = True return False n, m = map(int, input().split()) g = defaultdict(list) cnt = [0]*(n+1) st = [False]*(n+1) dis = [0]*(n+1) for i in range(m): x, y, z = map(int, input().split()) g[x].append((y, z)) res = spfa() print(\u0026#34;Yes\u0026#34; if res else \u0026#34;No\u0026#34;) floyd from sys import stdin from math import inf def floyd(): for k in range(1, n+1): for i in range(1, n+1): for j in range(1, n+1): d[i][j] = min(d[i][j], d[i][k] + d[k][j]) n, m, k = map(int, input().split()) d = [[0 if i==j else inf for i in range(n+1)] for j in range(n+1)] for i in range(m): x, y, z = map(int, input().split()) d[x][y] = min(d[x][y], z) floyd() for i in range(k): x, y = map(int, input().split()) print(d[x][y] if d[x][y]!=inf else \u0026#34;impossible\u0026#34;) Prim from math import inf from sys import stdin def prim(): res = 0 dis[1] = 0 for i in range(n): t = -1 for j in range(1, n+1): if not st[j] and (t==-1 or dis[t] \u0026gt; dis[j]): t = j if i and dis[t]==inf: return inf if i: res += dis[t] st[t] = True for j in range(1, n+1): dis[j] = min(dis[j], g[t][j]) return res n, m = map(int, input().split()) g = [[inf]*(n+1) for _ in range(n+1)] dis = [inf]*(n+1) st = [False]*(n+1) for i in range(m): u, v, w = map(int, input().split()) g[u][v] = g[v][u] = min(w, g[u][v]) res = prim() if res==inf: print(\u0026#34;impossible\u0026#34;) else: print(res) Kruskal import sys input = lambda:sys.stdin.readline().strip() def find(x): while p[x] != x: p[x] = p[p[x]] x = p[x] return x def kruskal(): res, cnt = 0, 0 ans = [] for u, v, w in g: fu, fv = find(u), find(v) if fu != fv: res += w cnt += 1 p[fu] = fv ans.append((u, v, w)) ans.sort() if cnt == n-1: print(res) # print(ans) # 记录选择的是哪些边 else: print(\u0026#34;impossible\u0026#34;) n, m = map(int, input().split()) g = [] p = [i for i in range(n+1)] for i in range(m): u, v, w = map(int, input().split()) g.append((u, v, w)) g.sort(key = lambda e:e[2]) kruskal() 染色法 使用了深度优先搜索算法（DFS）来判断一个图是否是二分图\n二分图：顶点分为两个集合，边仅存在于两个不同的集合中，而集合内部都没有边。\nPython优先使用BFS，因为DFS会出现各种问题，爆栈，段错误（还没搞清楚原因）等\n这段代码使用了染色法来判断一个无向图是否为二分图。下面我来解释一下：\n题目大意： 给定一个无向图，判断是否可以将其顶点集合划分为两个不相交的子集，使得每条边的两个端点分别属于这两个子集。如果可以，则输出\u0026quot;Yes\u0026quot;，否则输出\u0026quot;No\u0026quot;。\n实现思路：\n使用邻接表 g 来表示无向图，其中 g[u] 存储与顶点 u 相连的所有顶点。 定义一个数组 color 来标记每个顶点的染色情况，初始值设为 -1 表示未染色。 定义一个 BFS 函数 bfs(u, c)，其中 u 表示起始顶点，c 表示初始颜色。该函数使用 BFS 遍历图，并将顶点染色，保证相邻顶点颜色不同。 在主体部分，遍历所有顶点，对于每个未染色的顶点，调用 bfs 函数进行染色。如果染色过程中发现相邻顶点颜色相同，则返回 \u0026ldquo;No\u0026rdquo;，表示无法划分为二分图；否则返回 \u0026ldquo;Yes\u0026rdquo;。 import sys from collections import deque, defaultdict input = lambda:sys.stdin.readline().strip() N = int(1e5)+10 g = defaultdict(list) color = [-1]*N def bfs(u, c): color[u] = c q = deque() q.append((u, c)) while q: cur, col = q.popleft() for nx in g[cur]: if color[nx]==-1: color[nx] = 1-col q.append((nx, 1-col)) elif color[nx]==col: return False return True n, m = map(int, input().split()) for i in range(m): u, v = map(int, input().split()) # if u==v: #***自环不能去掉*** # continue if u not in g[v]: g[v].append(u) if v not in g[u]: g[u].append(v) for i in range(1, n+1): if color[i]==-1: if not bfs(i, 0): print(\u0026#34;No\u0026#34;) exit() print(\u0026#34;Yes\u0026#34;) 匈牙利算法 题目大意： 给定一个二分图，其中左侧顶点集合为 (N_1)，右侧顶点集合为 (N_2)，图中存在一些边。需要找到尽可能多的匹配，使得左侧的每个顶点最多与一个右侧的顶点相连，而右侧的每个顶点最多与一个左侧的顶点相连。\n实现思路：\n使用一个二维数组 g 存储图的邻接表表示。其中 g[u] 表示与左侧顶点 u 相连的所有右侧顶点的集合。 定义一个函数 find(x)，用于从左侧顶点 x 开始尝试寻找增广路径，如果找到了增广路径就返回 True，否则返回 False。 在主体部分，遍历左侧的每个顶点，对每个顶点调用 find 函数进行匹配，若成功匹配，则匹配数加一。 from sys import stdin from collections import defaultdict def find(u): for v in g[u]: if not st[v]: st[v] = True if mat[v]==0 or find(mat[v]): mat[v] = u return True return False n1, n2, m = map(int, input().split()) mat = [0]*(n2 + 1) g = defaultdict(list) for i in range(m): u, v = map(int, input().split()) g[u].append(v) res = 0 for i in range(1, n1+1): st = [False]*(n2 + 1) if find(i): res += 1 print(res) DFS之连通性 题意：在一个给定迷宫中，从起点A到终点B是否存在一条路径的问题。迷宫由一个由 '.' 和 '#' 构成的矩阵表示，其中 '.' 表示可通行的格点，'#' 表示不可通行的格点。Extense只能向东南西北四个方向移动到相邻的可通行格点上，而且要求起点和终点都是可通行的。你需要编写一个程序来确定在给定的迷宫中，是否存在一条从A到B的路径。\nimport sys input = lambda:sys.stdin.readline().strip() sys.setrecursionlimit(150000) dir = [(-1, 0), (0, 1), (1, 0), (0, -1)] def dfs(x, y): if g[x][y]==\u0026#39;#\u0026#39; or vis[x][y]: return False if (x, y)==end: return True vis[x][y] = True for i in range(4): a, b = x + dir[i][0], y+dir[i][1] if 0\u0026lt;=a\u0026lt;n and 0\u0026lt;=b\u0026lt;n: if dfs(a, b): return True return False k = int(input()) N = 110 g = [[] for _ in range(N)] for _ in range(k): n = int(input()) vis = [[False]*(n+1) for _ in range(n+1)] for i in range(n): g[i] = list(input()) x1, y1, x2, y2 = map(int, input().split()) end = (x2, y2) if dfs(x1, y1): print(\u0026#34;YES\u0026#34;) else: print(\u0026#34;NO\u0026#34;) 魔板 题目大意：给定一个 8 个格子的魔板，每个格子有一种颜色，用 1 到 8 的整数表示。有三种基本操作可以改变魔板的状态：A：交换上下两行；B：将最右边的一列插入到最左边；C：魔板中央对的4个数作顺时针旋转。现在给定一个目标状态，求用最少的基本操作完成基本状态到目标状态的转换，并输出基本操作序列。\n实现思路：\n首先实现三种基本操作 A、B、C 的函数。 使用广度优先搜索（BFS）算法来找到从基本状态到目标状态的最短操作序列。 使用一个队列存储待处理状态，并使用一个字典记录每个状态的前驱状态和执行的操作。 在每一步中，尝试对当前状态进行三种基本操作，得到新的状态，如果新状态未被访问过，则将其加入队列，并记录其前驱状态和操作。 当找到目标状态时，根据前驱状态回溯得到最短操作序列。 输出最短操作序列的长度和具体操作序列。 from collections import deque def A(t): return t[::-1] def B(t): return t[3] + t[:3] + t[5:] + t[4] def C(t): return t[0] + t[6] + t[1] + t[3] + t[4] + t[2] + t[5] + t[7] pre = dict() def bfs(): q = deque() q.append(st) while q: t = q.popleft() if t==ed: break m = [A(t), B(t), C(t)] for i in range(3): if m[i] not in pre: pre[m[i]] = (chr(65+i), t) q.append(m[i]) nums = input().split() ed = \u0026#39;\u0026#39;.join(nums) st = \u0026#34;12345678\u0026#34; bfs() cnt = 0 res = \u0026#34;\u0026#34; while ed != st: cnt+=1 res = pre[ed][0] + res ed = pre[ed][1] print(cnt) if cnt: print(res) 单词接龙 题目大意：给定一组单词和一个开头的字母，要求找出以这个字母开头的最长的“龙”，每个单词最多被使用两次。在构成龙时，两个单词相连时，它们的重合部分合并为一部分，但重合部分的长度必须大于等于1且小于两个单词的长度。\n实现思路：\n首先读入输入数据，包括单词数 n、n 个单词以及开头的字母。 构建一个字典 g，用于存储每个单词对应的可连接的单词以及对应的重合部分的长度。 对于每一对单词，比较它们的重合部分，如果符合条件，则将其加入字典 g 中。 使用深度优先搜索（DFS）来搜索以开头字母开头的最长的“龙”。 在搜索过程中，使用一个字典 cnt 来记录每个单词的使用次数，每个单词最多只能被使用两次。 递归搜索每个可连接的单词，并更新最长“龙”的长度。 最终输出最长“龙”的长度。 from collections import defaultdict n = int(input()) wds = [] for i in range(n): wds.append(input()) st = input() g = {w:[] for w in wds} for i in range(n): for j in range(n): for k in range(1, min( len(wds[i]), len(wds[j]) )): if wds[i][-k:] == wds[j][:k]: g[wds[i]].append((wds[j], k)) cnt = defaultdict(int) def dfs(dra, x): global ans cnt[x] += 1 ans = max(ans, len(dra)) for nx, k in g[x]: if cnt[nx] \u0026lt; 2: dfs(dra + nx[k:], nx) cnt[x] -= 1 ans = 0 for w in wds: if w[0] == st: dfs(w, w) print(ans) 分成互质组 题目大意：给定 n 个正整数，要求将它们分组，使得每组中任意两个数互质。求最少需要分成多少个组。\n实现思路：\n首先读入输入数据，包括正整数的个数 n 和 n 个正整数。 使用深度优先搜索（DFS）来搜索分组的方法。 构建一个列表 g，用于存储分组情况，每个分组是一个列表，列表中存储分组中的数。 编写 DFS 函数，在函数中递归尝试将当前数放入已有的分组或新建一个分组。 在递归过程中，如果当前数可以和某个分组中的所有数互质，则将当前数加入该分组，并继续递归。 如果当前数无法加入任何分组，则新建一个分组，并继续递归。 当所有数都被分组完毕时，更新最少需要的组数。 最终输出最少需要的组数。 from math import gcd n = int(input()) a = list(map(int, input().split())) g = [] def dfs(u, i): global ans if i==n: ans = min(ans, u) return if u\u0026gt;=ans: return for j in range(u): cnt = sum(1 for k in g[j] if gcd(a[i], k)==1) if cnt==len(g[j]): g[j].append(a[i]) dfs(u, i+1) g[j].pop() g.append([a[i]]) dfs(u+1, i+1) g.pop() ans = n dfs(0, 0) print(ans) 迭代加深 加成序列 题目大意：给定一个整数 n，找出满足以下条件的最小长度的“加成序列”：序列的第一个元素为1，最后一个元素为 n，序列中的元素满足每个元素都可以表示为序列中其他两个元素的和。\n实现思路：\n定义一个深度优先搜索（DFS）函数 dfs，用于搜索符合条件的加成序列。 在 dfs 函数中，使用一个列表 path 来记录当前搜索的加成序列，初始化 path[0] = 1。 递归地搜索加成序列的下一个元素，使得新的元素是前面元素的两两相加的结果，并满足条件 path[u] \u0026lt;= n，其中 u 表示当前搜索的位置。 如果搜索成功，即找到了符合条件的加成序列，返回 True；否则返回 False。 在主程序中，不断读取输入的 n，并通过调用 dfs 函数来搜索符合条件的加成序列。 输出满足条件的加成序列。 def dfs(u): if u==dep: return path[u-1]==n vis = [False]*(n+1) for i in range(u-1, -1, -1): for j in range(i, -1, -1): s = path[i] + path[j] if s\u0026gt;n or s\u0026lt;=path[u-1] or vis[s]: continue vis[s] = True path[u] = s if dfs(u+1): return True return False path = [0]*(110) path[0] = 1 while True: n = int(input()) if not n: break dep = 1 while not dfs(1): dep += 1 print(*path[:dep]) 双向DFS 送礼物 题目大意：达达帮翰翰送礼物，他一次可以搬动的重量之和不超过 W，一共有 N 个礼物，其中第 i 个礼物的重量是 G[i]。求达达在他的力气范围内一次性能搬动的最大重量。\n实现思路：\n定义两个深度优先搜索（DFS）函数 dfs1 和 dfs2，用于求解达达一次性能搬动的最大重量。 dfs1 函数用于遍历前一半的礼物，求得所有可能的搬动重量之和，并存储在集合 wgh 中。 dfs2 函数用于遍历后一半的礼物，并通过二分查找在 wgh 中找到合适的搬动重量，求得最大重量。 在主程序中，首先读入输入的 W 和 N，然后读入 N 个礼物的重量，并按照重量从大到小排序。 调用 dfs1 和 dfs2 函数求解最大重量，并输出结果。 def dfs1(u, tot): if u\u0026gt;k: wgh.add(tot) return if tot + a[u] \u0026lt;= w: dfs1(u+1, tot + a[u]) dfs1(u+1, tot) def dfs2(u, tot): global ans if u\u0026gt;=n: l, r = 0, cnt-1 while l\u0026lt;r: mid = (l+r+1)\u0026gt;\u0026gt;1 if wgh[mid] + tot \u0026lt;= w: l = mid else: r = mid - 1 ans = max(ans, wgh[r] + tot) return if a[u] + tot \u0026lt;= w: dfs2(u+1, a[u] + tot) dfs2(u+1, tot) w, n = map(int, input().split()) a = [] for i in range(n): a.append(int(input())) a.sort(reverse = True) wgh = set() k = n//2 dfs1(0, 0) wgh = sorted(list(wgh)) cnt = len(wgh) ans = -1 dfs2(k+1, 0) print(ans) 37. 解数独 \\166. 数独 题目大意：数独是一种益智游戏，要求填写一个9×9的网格，使得每行、每列、每个3×3的九宫格内数字1∼9均恰好出现一次。\n实现思路：该实现采用深度优先搜索（DFS）的方法解决数独问题。首先，通过将每个数字映射到二进制位来进行位运算，以便快速获取已填充数字的状态。然后，利用DFS递归填充数独中的空白格子，优先选择当前空白格子填充数字的选择空间较小的位置。递归的终止条件是所有空白格子都填充完毕。\nimport sys N = 9 M = 1 \u0026lt;\u0026lt; N row, col, cell = [0] * N, [0] * N, [[0] * 3 for _ in range(3)] mp = dict() ones = [0] * M for i in range(N): mp[1 \u0026lt;\u0026lt; i] = i for i in range(1 \u0026lt;\u0026lt; N): for j in range(N): ones[i] += (i \u0026gt;\u0026gt; j) \u0026amp; 1 def lowbit(x): return x \u0026amp; -x def get(x, y): return row[x] \u0026amp; col[y] \u0026amp; cell[x // 3][y // 3] def draw(x, y, t, flag): global st, row, col, cell if flag: st[x * N + y] = chr(49 + t) else: st[x * N + y] = \u0026#34;.\u0026#34; v = 1 \u0026lt;\u0026lt; t if not flag: v = -v row[x] -= v col[y] -= v cell[x // 3][y // 3] -= v def dfs(cnt): global st if not cnt: return True minv = 10 for i in range(N): for j in range(N): if st[i * N + j] == \u0026#34;.\u0026#34;: state = get(i, j) if ones[state] \u0026lt; minv: minv = ones[state] x, y = i, j i = get(x, y) while i: t = mp[lowbit(i)] draw(x, y, t, True) if dfs(cnt - 1): return True draw(x, y, t, False) i -= lowbit(i) return False while True: st = sys.stdin.readline().strip() if st == \u0026#34;end\u0026#34;: break st = list(st) cnt = 0 for i in range(N): row[i] = col[i] = M - 1 for i in range(3): for j in range(3): cell[i][j] = M - 1 for i in range(N): for j in range(N): if st[i * N + j] != \u0026#34;.\u0026#34;: t = int(st[i * N + j]) - 1 draw(i, j, t, True) else: cnt += 1 dfs(cnt) print(\u0026#34;\u0026#34;.join(st)) 最短路 188. 武士风度的牛 题目大意：农民 John 想交易他的一头被 Don 称为 The Knight 的牛。这头牛有特殊能力，可以按照象棋中马的走法跳跃。农场被表示为一个二维坐标图，其中包含了树、灌木、石头以及草的位置。The Knight 起始位置为 K，草的位置为 H。任务是确定 The Knight 要跳多少次才能到达草的位置。\n实现思路：\n首先解析输入，得到农场的列数和行数，以及地图信息，包括障碍物和目标位置（草的位置）。 使用广度优先搜索（BFS）算法来找到从起始位置到达目标位置的最短路径。 初始化一个队列，并将起始位置加入队列中。 在循环中，每次从队列中取出一个位置，并尝试向八个方向跳跃（象棋中马的所有可能走法），如果跳跃后的位置合法且没有障碍物且未被访问过，则将该位置加入队列，并标记为已访问。 当取出的位置为目标位置时，输出跳跃的次数，即最短路径的长度，然后退出循环。 如果队列为空仍未找到目标位置，则说明数据保证一定有解，不需要处理这种情况。 from collections import deque dir = [(-2, 1), (-1, 2), (1, 2), (2, 1), (2, -1), (1, -2), (-1, -2), (-2, -1)] c, r = map(int, input().split()) g = [[] for _ in range(r)] vis = [[False]*(c+1) for _ in range(r+1)] for i in range(r): g[i] = list(input()) for j, ch in enumerate(g[i]): if ch==\u0026#39;H\u0026#39;: end = (i, j) if ch==\u0026#39;K\u0026#39;: start = (i, j) q = deque() q.append((*start, 0)) while q: x, y, d= q.popleft() if (x, y)==end: print(d) break for i in range(8): a, b = x + dir[i][0], y + dir[i][1] if 0\u0026lt;=a\u0026lt;r and 0\u0026lt;=b\u0026lt;c: if g[a][b]!=\u0026#39;*\u0026#39; and not vis[a][b]: vis[a][b] = True q.append((a, b, d+1)) 多源BFS 题目大意：给定一个 N 行 M 列的 01 矩阵 A，定义矩阵中每个位置与所有值为1的位置的曼哈顿距离。曼哈顿距离为该位置与所有值为1的位置行坐标之差的绝对值与列坐标之差的绝对值之和。\n实现思路：\n首先读入矩阵的行数和列数，以及矩阵本身。 使用BFS（广度优先搜索）来计算每个位置到所有值为1的位置的距离。 初始化一个队列，将所有值为1的位置入队，距离初始化为0。 对队列进行BFS遍历，每次取出队首元素，计算其周围四个方向的位置，若位置合法且为0且未被访问过，则更新距离并入队。 最终输出距离矩阵B。 import sys from collections import deque input = lambda:sys.stdin.readline().strip() N = int(1e3+10) g = [[] for _ in range(N)] dis = [[-1]*N for _ in range(N)] n, m = map(int, input().split()) for i in range(1, n+1): g[i] = [0] + list(input()) q = deque() for i in range(1, n+1): for j in range(1, m+1): if g[i][j] == \u0026#39;1\u0026#39;: q.append((i, j, 0)) dis[i][j] = 0 dx = [1, 0, -1, 0] dy = [0, 1, 0, -1] while q: x, y, d = q.popleft() for i in range(4): xx = x+dx[i]; yy = y+dy[i] if xx\u0026gt;0 and xx\u0026lt;=n and yy\u0026gt;0 and yy\u0026lt;=m: if g[xx][yy] == \u0026#39;0\u0026#39; and dis[xx][yy] == -1: dis[xx][yy] = d+1 q.append((xx, yy, d+1)) for i in range(1, n+1): print(*dis[i][1:m+1]) 双端队列BFS175. 电路维修 题目大意：有一个电路板，由 R 行 C 列的网格组成，每个格点都是电线的接点，每个格子包含一个可旋转的电子元件，电子元件连接一条对角线上的两个接点。达达希望通过旋转最少数量的元件，使电源与发动装置通过若干条短缆相连，但因为某些元件的方向不正确，导致电路板可能处于断路的状态。需要计算最少旋转的次数来使得电源和发动机之间连通。\n实现思路：可以使用广度优先搜索（BFS）来解决此问题。首先，初始化一个二维数组 d 用于存储从起点到每个点的最短距离。然后，利用广度优先搜索的方式遍历电路板的每个格点，如果发现某个格点的状态需要改变（即当前格点的元件方向与所需方向不一致），则更新该格点的状态并将其加入到队列中。最后，返回终点的最短距离即可，如果无法到达终点，则输出 \u0026ldquo;NO SOLUTION\u0026rdquo;。\nimport sys input = lambda:sys.stdin.readline().strip() from collections import deque dire = [(-1, -1), (-1, 1), (1, 1), (1, -1)] mov = [(-1, -1), (-1, 0), (0, 0), (0, -1)] ch = \u0026#34;\\\\/\\\\/\u0026#34; def bfs(): dq = deque() d = [[float(\u0026#39;inf\u0026#39;)]*(c+1) for _ in range(r+1)] d[0][0] = 0 dq.append((0, 0)) while dq: x, y = dq.popleft() for i in range(4): xx, yy = x + dire[i][0], y + dire[i][1] if 0\u0026lt;=xx\u0026lt;=r and 0\u0026lt;=yy\u0026lt;=c: j, k = x+mov[i][0], y + mov[i][1] w = 1 if g[j][k] != ch[i] else 0 if d[xx][yy] \u0026gt; d[x][y] + w: d[xx][yy] = d[x][y] + w if w: dq.append((xx, yy)) else: dq.appendleft((xx, yy)) return -1 if d[r][c] == float(\u0026#39;inf\u0026#39;) else d[r][c] t = int(input()) for _ in range(t): r, c = map(int, input().split()) g = [input() for _ in range(r)] res = bfs() print(res if res != -1 else \u0026#34;NO SOLUTION\u0026#34;) A* 179. 八数码 题目大意：在一个 3×3 的网格中，数字 1∼8 与一个 x 恰好不重不漏地分布在这个网格中。可以通过把 x 与其上、下、左、右四个方向之一的数字交换（如果存在）来改变网格的状态，目标是通过最少的移动次数，使得网格变为正确排列。\n实现思路：使用 A* 算法来解决该问题。首先，定义一个启发函数用于估计当前状态到达目标状态的最小移动次数。然后，利用 A* 算法进行搜索，不断更新当前状态到达目标状态的最小移动次数，并记录每一步的移动操作。最后，输出得到的完整行动记录即可。如果不存在解决方案，则输出 \u0026ldquo;unsolvable\u0026rdquo;。\nfrom heapq import heappush, heappop d = [(-1, 0), (0, 1), (1, 0), (0, -1)] op = \u0026#34;urdl\u0026#34; def heuristic(state): # 启发式 ans = 0 for i, st in enumerate(state): if st==\u0026#39;x\u0026#39;: continue t = int(st)-1 ans += abs(t//3 - i//3) + abs(t%3 - i%3) return ans def astar(): dis, pre = dict(), dict() end = \u0026#34;12345678x\u0026#34; dis[start] = 0 h = [] heappush(h, (heuristic(start), start)) while h: _, state = heappop(h) if state == end: break x, y = divmod(state.index(\u0026#39;x\u0026#39;), 3) src = state for i in range(4): a, b = x+d[i][0], y+d[i][1] if 0\u0026lt;=a\u0026lt;3 and 0\u0026lt;=b\u0026lt;3: ls = list(state) ls[3*x+y], ls[3*a+b] = ls[3*a+b], ls[3*x+y] new_state = \u0026#39;\u0026#39;.join(ls) if new_state not in dis or dis[new_state] \u0026gt; dis[src] + 1: dis[new_state] = dis[src] + 1 pre[new_state] = (op[i], src) heappush(h, (dis[new_state] + heuristic(new_state), new_state)) ans = \u0026#39;\u0026#39; while end != start: ans = pre[end][0] + ans end = pre[end][1] return ans start = \u0026#39;\u0026#39;.join(input().split()) s = start.replace(\u0026#39;x\u0026#39;, \u0026#39;\u0026#39;) cnt = sum(s[i]\u0026gt;s[j] for i in range(8) for j in range(i, 8)) if cnt\u0026amp;1: print(\u0026#34;unsolvable\u0026#34;) else: print(astar()) IDA* 排书 寻找估价函数， 一定小于等于真实值，并越接近真实值\n这道题目要求给定 n 本书，每本书编号为 1 到 n，初始状态下，书是任意排列的。每次操作可以抽取其中连续的一段，再把这段插入到其他某个位置。目标是将书按照 1 到 n 的顺序依次排列。要求计算最少需要多少次操作。\n实现思路：\n首先定义一个函数 f()，用来计算当前状态与目标状态之间的最小操作次数。这个函数通过遍历每对相邻书的编号，判断它们是否连续，如果不连续则需要进行一次操作。最后返回操作次数。 然后定义一个深度优先搜索函数 dfs(u)，其中 u 表示当前搜索的深度。在每次搜索中，我们需要判断当前深度加上到目标状态的最小操作次数是否超过已经得到的最小操作次数，如果超过则直接返回 False，否则继续搜索。 在 dfs 函数中，首先判断如果当前状态已经是目标状态，则直接返回 True。否则，我们遍历所有可能的操作，从中选择一种操作方式，然后递归调用 dfs 函数。 在主程序中，依次读入每组数据，然后进行深度优先搜索，直到得到结果或者搜索深度达到 5。最后根据得到的结果输出最小操作次数或者 \u0026ldquo;5 or more\u0026rdquo;。 def f(): res = 0 for i in range(n-1): if a[i] != a[i+1]-1: res += 1 return (res+2)//3 def dfs(u): global a if u + f() \u0026gt; dep: return False if f()==0: return True for leng in range(n, 0, -1): for l in range(n-leng+1): r = l+leng-1 for k in range(l, r+1): bk = a[:] j = l for i in range(k+1, r+1): a[j] = bk[i] j+=1 for i in range(l, k+1): a[j] = bk[i] j+=1 if dfs(u+1): return True a = bk[:] t = int(input()) while t: t-=1 n = int(input()) a = list(map(int, input().split())) dep = 0 while dep\u0026lt;5 and not dfs(0): dep += 1 if dep \u0026lt; 5: print(dep) else: print(\u0026#34;5 or more\u0026#34;) ","permalink":"https://kennems.github.io/posts/tech/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0%E4%B8%89%E5%9B%BE%E8%AE%BApython%E5%AE%9E%E7%8E%B0/","summary":"算法笔记（三）——图论（Python实现） 图论 树的存储 邻接矩阵 # 创建一个二维列表表示邻接矩阵 n = 10 # 顶点数量 g = [[0] * n for _ in range(n)] # 添加一条边a","title":"算法笔记（三）——图论（Python实现）"},{"content":"算法笔记（四）——数学（Python实现） 数学 试除法判定质数 def check(x): # 判定 if x\u0026lt;2: return False for i in range(2, int(x**0.5)+1): if x%i==0: return False return True n = int(input()) for i in range(n): x = int(input()) if check(x): print(\u0026#34;Yes\u0026#34;) else: print(\u0026#34;No\u0026#34;) 试除法分解质因数 def get(x): #分解 for i in range(2, int(x**0.5)+1): if x%i==0: cnt=0 while x%i==0: x//=i cnt+=1 print(i, cnt, sep=\u0026#39; \u0026#39;) if x\u0026gt;1: print(x, 1, sep=\u0026#39; \u0026#39;) n = int(input()) for i in range(n): x = int(input()) get(x) print() 线性筛法求素数 N = int(1e6+10) primes = [] st = [False]*N def get(n): for i in range(2, n+1): if not st[i]: primes.append(i) for j in range(len(primes)): if i*primes[j]\u0026gt;n: break st[i*primes[j]]=True if i%primes[j]==0: break n = int(input()) get(n) print(len(primes)) 朴素筛法求素数 N = 1000005 # 根据需要修改 primes = [] # 存储所有素数 st = [False] * N # st[x]存储x是否被筛掉 # 筛素数函数 def get_primes(n): global primes global st for i in range(2, n + 1): if not st[i]: primes.append(i) for j in range(i, n + 1, i): st[j] = True # Example usage: # get_primes(100) # print(primes) 试除法求所有约数 def get(x): res = [1] for i in range(2, int(x**0.5)+1): if x%i==0: res.append(i) if i!=x//i: res.append(x//i) if x\u0026gt;1: res.append(x) return sorted(res) n = int(input()) for i in range(n): x = int(input()) res = get(x) print(*res) 约数个数和约数之和 如果 N = p1^c1 * p2^c2 * ... *pk^ck\r约数个数： (c1 + 1) * (c2 + 1) * ... * (ck + 1)\r约数之和： (p1^0 + p1^1 + ... + p1^c1) * ... * (pk^0 + pk^1 + ... + pk^ck) 约数之和 题目大意：给定两个自然数 A 和 B，定义 S 为 A*B 的所有约数之和。求 S mod 9901 的值。\n实现思路：首先，我们需要编写一个快速幂函数 qpow(a, k) 来计算幂运算的结果。然后，定义一个函数 calc(p, k) 来计算 p^k 的结果并对 mod 取余。在主程序中，我们对 A 进行质因数分解，并计算每个质因数的幂次方与 B 的乘积，并累加到最终结果 res 中。最后，输出 res 的值对 mod 9901 取余的结果。\nimport sys input = lambda:sys.stdin.readline().strip() mod = 9901 def qpow(a, k): res = 1 while k: if k\u0026amp;1: res = res*a%mod a = a*a%mod k\u0026gt;\u0026gt;=1 return res def calc(p, k): if k==0: return 1 if k%2==1: return (1+qpow(p, k//2+1)) * calc(p, k//2) % mod return (qpow(p, k)%mod + (1 + qpow(p, (k-1)//2+1)) * calc(p, (k-1)//2)) % mod a, b = map(int, input().split()) res = 1 for i in range(2, a+1): if a\u0026lt;i: break s = 0 while a%i==0: s+=1 a//=i if s: res = res * calc(i, s*b) % mod print(res if a else 0) gcd def gcd(a, b): return gcd(b, a % b) if b else a 求欧拉函数 def get(x): res = x for i in range(2, int(x**0.5)+1): if x%i==0: res = res//i*(i-1) while x%i==0: x//=i if x\u0026gt;1: res = res//x*(x-1) return res n = int(input()) for i in range(n): x = int(input()) print(get(x)) 筛法求欧拉函数 N = int(1e6+10) primes = [] euler = [0]*N st = [False]*N cnt = 0 def get(n): euler[1] = 1 for i in range(2, n+1): if not st[i]: primes.append(i) euler[i] = i-1 for j in range(len(primes)): t = primes[j]*i if t\u0026gt;n: break st[t] = True if i%primes[j]==0: euler[t] = euler[i]*primes[j] break euler[t] = euler[i]*(primes[j]-1) n = int(input()) get(n) for i in range(1,n+1): cnt+=euler[i] print(cnt) 快速幂 # 快速幂函数 def qmi(m, k, p): res, t = 1 % p, m while k: if k \u0026amp; 1: res = res * t % p t = t * t % p k \u0026gt;\u0026gt;= 1 return res # Example usage: # result = qmi(2, 10, 1000000007) # print(result) 拓展欧几里得 # 求 x, y，使得 ax + by = gcd(a, b) def exgcd(a, b, x, y): if b == 0: x[0], y[0] = 1, 0 return a d = exgcd(b, a % b, y, x) y[0] -= (a // b) * x[0] return d # Example usage: # x = [0] # y = [0] # gcd = exgcd(30, 20, x, y) # print(\u0026#34;x:\u0026#34;, x[0], \u0026#34;y:\u0026#34;, y[0], \u0026#34;gcd:\u0026#34;, gcd) P1082 [NOIP2012 提高组] 同余方程 题目描述：求解关于x的同余方程$ax ≡ 1 (mod b)$的最小正整数解。\n实现思路：这个问题可以转化为求解$ax + by = gcd(a, b)$的解，其中x就是我们需要的结果。可以利用扩展欧几里得算法来求解这个方程。具体地，通过递归的方式求解出最大公约数，并且求解出使得$ax + by = gcd(a, b)$成立的整数x和y。然后通过对x取模b的操作得到最小正整数解x。最后输出x即可。\n# 求 x, y，使得 ax + by = gcd(a, b) def exgcd(a, b, x, y): if b == 0: x[0], y[0] = 1, 0 return a d = exgcd(b, a % b, y, x) y[0] -= (a // b) * x[0] return d a, b = map(int, input().split()) x, y = [0], [0] exgcd(a, b, x, y) x = x[0] x = (x%b+b)%b print(x) 递推法求组合数 N = int(2e3)+10 mod = int(1e9)+7 c = [[0]*N for _ in range(N)] def get(n): for i in range(n+1): for j in range(i+1): if j==0: c[i][j] = 1 else: c[i][j] = (c[i-1][j]+c[i-1][j-1])%mod MN = int(2e3) get(MN) n = int(input()) for i in range(n): a, b = map(int, input().split()) print(c[a][b]) 通过预处理逆元的方式求组合数 mod = int(1e9)+7 N = int(2e5)+10 fact, infact = [0]*N, [0]*N def qpow(a, k, p): res = 1 while k: if k\u0026amp;1: res = (res*a)%p a = (a*a)%p k\u0026gt;\u0026gt;=1 return res def init(): fact[0] = infact[0] = 1 for i in range(1, N): fact[i] = (fact[i-1]*i)%mod infact[i] = (infact[i-1]*qpow(i, mod-2, mod))%mod def C(n, m): if n\u0026lt;m: return 0 return (fact[n]*infact[m]%mod*infact[n-m]%mod) init() n = int(input()) for i in range(n): a, b = map(int, input().split()) print(C(a, b)) Lucas定理 p = 1000000007 # 根据需要调整 # 快速幂模板 def qmi(a, k): res = 1 while k: if k \u0026amp; 1: res = (res * a) % p a = (a * a) % p k \u0026gt;\u0026gt;= 1 return res # 通过定理求组合数C(a, b) def C(a, b): res = 1 for i in range(1, b + 1): res = (res * (a - i + 1)) % p res = (res * qmi(i, p - 2)) % p return res # Lucas定理计算组合数 def lucas(a, b): if a \u0026lt; p and b \u0026lt; p: return C(a, b) return (C(a % p, b % p) * lucas(a // p, b // p)) % p # Example usage: # result = lucas(10, 5) # 计算组合数 C(10, 5) # print(result) 分解质因数法求组合数 分解质因数法计算组合数：\n获取小于等于 a 的所有质数。 初始化质数的幂次列表 s。 对每个质数 p，计算在 a!，b! 和 (a-b)! 中 p 的幂次，通过 get(a, p) - get(b, p) - get(a - b, p) 得到组合数分解中 p 的总幂次。 通过快速幂计算每个质数 p 的幂次乘积，最终得到组合数。 def get_primes(n): primes = [] st = [False]*(n+1) for i in range(2, n+1): if not st[i]: primes.append(i) for p in primes: if i*p\u0026gt;n: break st[i*p] = True if i%p==0: break return primes def get(n, p): cnt = 0 while n: cnt += n//p n//=p return cnt def qpow(a, k): res = 1 while k: if k\u0026amp;1: res = res * a a = a*a k\u0026gt;\u0026gt;=1 return res def calc(a, b): primes = get_primes(a) n = len(primes) res = 1 for i, p in enumerate(primes): s = get(a, p) - get(b, p) - get(a-b, p) res *= qpow(p, s) return res a, b = map(int, input().split()) print(calc(a, b)) 高斯消元 eps = 1e-8 # 根据需要调整 # a 是增广矩阵，n 是矩阵维度 def gauss(a, n): c, r = 0, 0 for c in range(n): t = r for i in range(r, n): if abs(a[i][c]) \u0026gt; abs(a[t][c]): t = i if abs(a[t][c]) \u0026lt; eps: continue for i in range(c, n + 1): a[r][i], a[t][i] = a[t][i], a[r][i] for i in range(n, c - 1, -1): a[r][i] //= a[r][c] for i in range(r + 1, n): if abs(a[i][c]) \u0026gt; eps: for j in range(n, c - 1, -1): a[i][j] -= a[r][j] * a[i][c] r += 1 if r \u0026lt; n: for i in range(r, n): if abs(a[i][n]) \u0026gt; eps: return 2 # 无解 return 1 # 有无穷多组解 for i in range(n - 1, -1, -1): for j in range(i + 1, n): a[i][n] -= a[i][j] * a[j][n] return 0 # 有唯一解 # Example usage: # a = [[2, 1, -1, 8], [-3, -1, 2, -11], [-2, 1, 2, -3]] # n = 3 # result = gauss(a, n) # print(result) ","permalink":"https://kennems.github.io/posts/tech/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0%E5%9B%9B%E6%95%B0%E5%AD%A6python%E5%AE%9E%E7%8E%B0/","summary":"算法笔记（四）——数学（Python实现） 数学 试除法判定质数 def check(x): # 判定 if x\u0026lt;2: return False for i in range(2, int(x**0.5)+1): if x%i==0: return False return True n = int(input()) for i in range(n): x = int(input()) if check(x): print(\u0026#34;Yes\u0026#34;) else: print(\u0026#34;No\u0026#34;) 试除法分解","title":"算法笔记（四）——数学（Python实现）"},{"content":"算法笔记（五）——DP（Python实现） DP 数字三角形 f=[] n=int(input()) for _ in range(n): f.append([int(x) for x in input().split()]) for i in range(n-2,-1,-1): for j in range(i+1): f[i][j]=max(f[i+1][j], f[i+1][j+1])+f[i][j] print(f[0][0]) 背包 空间优化成1维之后，只有完全背包问题的体积是从小到大循环的\n01背包 N = int(1e3+10) f=[ 0 for _ in range(N) ] n,v=map(int,input().split()) for i in range(n): vi,wi=map(int,input().split()) for j in range(v, vi-1,-1): f[j]=max(f[j],f[j-vi]+wi) print(f[v]) 多重背包 单调队列 MN = int(2e4+10) f=[0 for _ in range(MN)] q=[0 for _ in range(MN)] g=[0 for _ in range(MN)] N,V = map(int, input().split()) for i in range(N): v,w,s=map(int, input().split()) g=f[:] for j in range(v): hh,tt=0,-1 for k in range(j,V+1,v): while hh\u0026lt;=tt and q[hh]\u0026lt;k-s*v: hh+=1 while hh\u0026lt;=tt and g[q[tt]]+(k-q[tt])//v*w \u0026lt;= g[k]: tt-=1 tt+=1 q[tt]=k f[k]=g[q[hh]]+(k-q[hh])//v*w print(f[V]) 二维费用背包 N = int(1e2+10) f=[[0]*N for _ in range(N)] n,V,M = map(int , input().split()) for i in range(n): v,m,w=map(int , input().split()) for j in range(V,v-1,-1): for k in range(M, m-1, -1): f[j][k]=max(f[j][k], f[j-v][k-m]+w) print(f[V][M]) 宠物小精灵 题目大意：小智在野外捕捉宠物小精灵，他带了一些精灵球和皮卡丘，精灵球可以捕捉小精灵，但每捕捉一个小精灵都会消耗精灵球和减少皮卡丘的体力。现在给定小智拥有的精灵球数量、皮卡丘的初始体力值以及每个小精灵需要的精灵球数量和对皮卡丘造成的伤害数目，问小智最多能捕捉多少个小精灵，并且在这种情况下，皮卡丘的剩余体力值最多是多少。\n实现思路：\n使用动态规划，定义状态 f[i][j] 表示使用 i 个精灵球时，对皮卡丘造成 j 伤害时能够捕捉到的小精灵数量。 遍历每个野生小精灵，更新状态数组 f。 最后输出 f[n][m-1] 表示捕捉到的小精灵数量，然后再计算皮卡丘的剩余体力值。 N = int(1e3+10) M = int(5e2+10) f=[[0]*M for _ in range(N)] n,m,kk = map(int, input().split()) for i in range(kk): v1,v2=map(int, input().split()) for j in range(n, v1-1, -1): for k in range(m-1,v2-1,-1): f[j][k]=max(f[j][k], f[j-v1][k-v2]+1) print(f[n][m-1], end=\u0026#34; \u0026#34;) t=m-1 while t\u0026gt;0 and f[n][m-1]==f[n][t-1]: t-=1 print(m-t) 潜水 最多\n恰好\n最少\n题目大意：潜水员需要使用特殊装备下潜，装备有两种气缸，一种氧气，一种氮气，每个气缸有一定的重量和气体容量。下潜的深度需要一定数量的氧气和氮气。现在给定潜水员需要的氧气和氮气的量，以及每个气缸的氧气、氮气容量和重量，求完成工作所需气缸的总重的最低值。\n实现思路：\n使用动态规划，定义状态 f[i][j] 表示满足氧气需求为 i，氮气需求为 j 时的最小气缸总重量。 遍历每个气缸，更新状态数组 f。 最后输出 f[m][n] 表示完成工作所需的气缸的总重的最低值。 N = int(1e2+10) INF = 0x3f3f3f3f f=[ [INF]*N for _ in range(N) ] f[0][0]=0 m,n=map(int, input().split()) k=int(input()) for i in range(k): a,b,c=map(int, input().split()) for j in range(m,-1,-1): for k in range(n,-1,-1): f[j][k]=min(f[j][k], f[max(j-a, 0)][max(k-b, 0)]+c) print(f[m][n]) 庆功会 题目大意：为了庆祝班级在学校运动会上取得第一名，班主任决定开一场庆功会，并拨款购买奖品犒劳运动员。需要选择购买的奖品，使得购买的奖品的总价值最大，且不超过拨款金额。\n实现思路：\n使用动态规划，定义状态 f[i] 表示拨款金额为 i 时可以购买的奖品的最大总价值。 遍历每个奖品，更新状态数组 f。 最后输出 f[m]，即拨款金额为 m 时可以购买的奖品的最大总价值。 N = int(6e3+10) f=[0 for _ in range(N)] n,m = map(int, input().split()) for i in range(n): v,w,s=map(int, input().split()) for j in range(1,s+1): for k in range(m, v-1, -1): f[k]=max(f[k], f[k-v]+w) print(f[m]) 分组背包 分组背包的顺序：\n物品组 体积 决策 N = int(1e2+10) f=[0 for _ in range(N)] v=[0 for _ in range(N)] w=[0 for _ in range(N)] N,V = map(int, input().split()) for i in range(N): # 物品组 s=int(input()) for j in range(s): v[j],w[j]=map(int, input().split()) for j in range(V,-1,-1): #体积 for k in range(s): #决策 if j\u0026gt;=v[k]: f[j]=max(f[j], f[j-v[k]]+w[k]) print(f[V]) 机器分配 多重背包变种\n题目大意：总公司有M台相同的高效设备，要分给N个分公司。每个分公司根据分配的设备数量能够为国家带来一定的盈利。问如何分配这M台设备才能使国家得到的盈利最大，输出最大盈利值和分配方案。\n实现思路：这是一个经典的背包问题，可以使用动态规划来解决。定义状态dp[i][j]表示前i个分公司中，分配j台设备所能获得的最大盈利。转移方程为dp[i][j] = max(dp[i-1][j-k] + w[i][k])，其中k表示第i个分公司分配的设备数量，0 \u0026lt;= k \u0026lt;= j。最后遍历求解得到最大盈利值，并记录分配方案。\nN = 100 f=[0 for _ in range(N)] w=[[0]*N for _ in range(N)] c=[[0]*N for _ in range(N)] n,m=map(int, input().split()) for i in range(n): w[i]=[0]+[int(x) for x in input().split()] for i in range(n): for j in range(m,-1,-1): for k in range(1,j+1): if f[j-k]+w[i][k] \u0026gt; f[j]: f[j]=f[j-k]+w[i][k] c[i][j]=k print(f[m]) t=m for i in range(n-1,-1,-1): print(i+1, c[i][t]) t-=c[i][t] 金明的预算方案 题目描述：金明想购买物品，其中有主件和附件。每个主件可以有0个、1个或2个附件，附件不能有从属于自己的附件。金明希望在不超过N元（可以等于N元）的前提下，使每件物品的价格与重要度的乘积的总和最大。物品的价格都是10元的整数倍。\n实现思路：这个问题可以使用动态规划来解决。首先，需要将主件和附件分开处理。对于每一个物品，分别考虑不同附件数量的情况，计算可能的价格与重要度乘积的总和，然后更新动态规划数组f。最终，返回f[n]即可得到结果。\nN = 80 M = 32010 f=[0 for _ in range(M)] mas=[[0,0] for _ in range(N)] ser=[[] for _ in range(N)] n,m=map(int,input().split()) for i in range(1,m+1): v,p,q=map(int, input().split()) if q==0: mas[i]=[v,v*p] else: ser[q].append((v, v*p)) for i in range(1,m+1): for j in range(n, -1, -1): for k in range( (1 \u0026lt;\u0026lt; len(ser[i]) )): v,p=mas[i] for l in range(len(ser[i])): if k\u0026gt;\u0026gt;l \u0026amp; 1: v+=ser[i][l][0] p+=ser[i][l][1] if j\u0026gt;=v: f[j]=max(f[j], f[j-v]+p) print(f[n]) 摘花生 N = 105 f=[ [0]*N for _ in range(N)] t=int(input()) for _ in range(t): r,c=map(int, input().split()) for i in range(1,r+1): f[i] = [0] + [int(x) for x in input().split()] for j in range(1,c+1): f[i][j]+=max(f[i-1][j], f[i][j-1]) print(f[r][c]) 最小通行费 N = int(1e3+10) INF = 0x3f3f3f3f f = [[INF]*N for _ in range(N)] f[1][0]=f[0][1]=0 n=int(input()) for i in range(1,n+1): f[i]=[INF]+[int(x) for x in input().split()] for i in range(1,n+1): for j in range(1,n+1): f[i][j]+=min(f[i-1][j],f[i][j-1]) print(f[n][n]) 方格 N = 15 g = [[0]*N for _ in range(N)] f = [[[[0]*N for _ in range(N)] for _ in range(N)] for _ in range(N)] n=int(input()) while True: r,c,x=map(int,input().split()) if r==0 and c==0 and x==0: break g[r][c]=x for i in range(1,n+1): for j in range(1,n+1): for k in range(1,n+1): for l in range(1,n+1): if i==k and j==l: f[i][j][k][l] = max(f[i-1][j][k-1][l], f[i-1][j][k][l-1], f[i][j-1][k-1][l], f[i][j-1][k][l-1]) + g[i][j] else: f[i][j][k][l] = max(f[i-1][j][k-1][l], f[i-1][j][k][l-1], f[i][j-1][k-1][l], f[i][j-1][k][l-1]) + g[i][j] + g[k][l] print(f[n][n][n][n]) N = 55 g=[[0]*N for _ in range(N)] f=[[[[0]*N for _ in range(N)] for _ in range(N)] for _ in range(N)] m,n=map(int, input().split()) for i in range(1,m+1): g[i]=[0]+[int(x) for x in input().split()] for i in range(1,m+1): for j in range(1,n+1): for k in range(1,m+1): for l in range(1,n+1): if i==k and j==l: f[i][j][k][l]=max(f[i-1][j][k-1][l], f[i-1][j][k][l-1], f[i][j-1][k-1][l], f[i][j-1][k][l-1])+g[i][j] else: f[i][j][k][l]=max(f[i-1][j][k-1][l], f[i-1][j][k][l-1], f[i][j-1][k-1][l], f[i][j-1][k][l-1])+g[i][j]+g[k][l] print(f[m][n][m][n]) LIS \u0026amp; LCS LIS N=int(1e3+10) f=[1 for _ in range(N)] a=[] n=int(input()) a=[0]+[int(x) for x in input().split()] for i in range(1,n+1): for j in range(1,i): if a[i]\u0026gt;a[j]: f[i]=max(f[i],f[j]+1) ans = 0 for i in range(1,n+1): ans = max(ans, f[i]) print(ans) LCS N = int(1e3+10) f=[[0]*N for _ in range(N)] a=\u0026#34;\u0026#34; b=\u0026#34;\u0026#34; n,m=map(int, input().split()) a=input() b=input() for i in range(n): for j in range(m): f[i][j]=max(f[i-1][j], f[i][j-1]) if a[i]==b[j]: f[i][j]=f[i-1][j-1]+1 print(f[n-1][m-1]) 回溯寻找所有的最长公共子序列\ndef lcs_length(X, Y): m, n = len(X), len(Y) dp = [[0] * (n + 1) for _ in range(m + 1)] for i in range(1, m + 1): for j in range(1, n + 1): if X[i - 1] == Y[j - 1]: dp[i][j] = dp[i - 1][j - 1] + 1 else: dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]) return dp def find_all_lcs(X, Y, dp): def backtrack(i, j): if i == 0 or j == 0: return {\u0026#34;\u0026#34;} elif X[i - 1] == Y[j - 1]: return {lcs + X[i - 1] for lcs in backtrack(i - 1, j - 1)} else: lcs_set = set() if dp[i - 1][j] \u0026gt;= dp[i][j - 1]: lcs_set.update(backtrack(i - 1, j)) if dp[i][j - 1] \u0026gt;= dp[i - 1][j]: lcs_set.update(backtrack(i, j - 1)) return lcs_set return backtrack(len(X), len(Y)) 最大上升子序列和 import copy a=[] f=[] ans=0 n=int(input()) a=[int(x) for x in input().split()] f=copy.deepcopy(a) for i in range(n): for j in range(i): if a[i]\u0026gt;a[j]: f[i]=max(f[i], f[j]+a[i]) for i in range(n): ans = max(ans, f[i]) print(ans) N = int(1e3+10) f=[0 for _ in range(N)] ans = 0 n=int(input()) a=[0]+[int(x) for x in input().split()] for i in range(1,n+1): f[i]=a[i] for j in range(1,i): if a[i]\u0026gt;a[j]: f[i]=max(f[i], f[j]+a[i]) ans = max(ans, f[i]) print(ans) 最大上升子序列II N = int(1e5+10) INF = 0x3f3f3f3f q=[INF for _ in range(N)] ans=0 n=int(input()) a=[0]+[int(x) for x in input().split()] for i in range(1,n+1): l,r=0,i while l\u0026lt;r: mid = (l+r+1)\u0026gt;\u0026gt;1 if q[mid]\u0026lt;a[i]: l=mid else: r=mid-1 ans = max(ans, l+1) q[l+1]=min(q[l+1], a[i]) print(ans) N = int(1e5+10) q=[0 for _ in range(N)] len = 0 n=int(input()) a=[0]+[int(x) for x in input().split()] for i in range(1, n+1): l,r=0,len while l\u0026lt;r: mid = (l+r+1)\u0026gt;\u0026gt;1 if q[mid]\u0026lt;a[i]: l=mid else: r=mid-1 len=max(len, l+1) q[l+1]=a[i] print(len) N = int(1e5+10) q=[0 for _ in range(N)] len = 0 n=int(input()) a=[0]+[int(x) for x in input().split()] for i in range(1,n+1): l,r=0,len while l\u0026lt;r: mid = (l+r+1)\u0026gt;\u0026gt;1 if q[mid]\u0026gt;=a[i]: r=mid-1 else: l=mid len = max(len, l+1) q[l+1]=a[i] print(len) 二分原则：\n有单调性，并且二分之后能保持单调性\n怪盗基德的滑翔翼 **题意：**怪盗基德需要逃跑，城市中有N幢建筑排成一条线，每幢建筑的高度各不相同。他希望尽可能多地经过不同建筑的顶部，以减缓下降时的冲击力，减少受伤的可能性。他可以选择一个方向逃跑，但不能中途改变方向，且只能从较高的建筑滑翔到较低的建筑。怪盗基德最多可以经过多少幢不同建筑的顶部（包含初始时的建筑）。\n**实现思路：**可以使用动态规划来解决。首先，对于每一座建筑，分别计算以该建筑为终点的最长递增子序列长度，得到从左往右和从右往左的两个最长递增子序列数组。然后将这两个数组对应位置的最大值相加，再减去1（因为初始位置也算一座建筑），即为怪盗基德最多可以经过的不同建筑数量。\nN = int(1e3+10) f=[0 for _ in range(N)] t=int(input()) while t: t-=1 ans=0 n=int(input()) a=[0]+[int(x) for x in input().split()] for i in range(1,n+1): f[i]=1 for j in range(1,i): if a[i]\u0026gt;a[j]: f[i]=max(f[i], f[j]+1) ans = max(ans, f[i]) for i in range(n,0,-1): f[i]=1 for j in range(n,i,-1): if a[i]\u0026gt;a[j]: f[i]=max(f[i], f[j]+1) ans = max(ans, f[i]) print(ans) 登山 N = int(1e3+10) f=[1 for _ in range(N)] g=[1 for _ in range(N)] ans = 0 n=int(input()) a=[0]+[int(x) for x in input().split()] for i in range(1,n+1): for j in range(1,i): if a[i]\u0026gt;a[j]: f[i]=max(f[i], f[j]+1) for i in range(n,0,-1): for j in range(n,i,-1): if a[i]\u0026gt;a[j]: g[i]=max(g[i], g[j]+1) for i in range(1,n+1): ans = max(ans, f[i]+g[i]-1) print(ans) 合唱队形 N = int(1e3+10) f=[1 for _ in range(N)] g=[1 for _ in range(N)] ans = 0 n=int(input()) a=[0]+[int(x) for x in input().split()] for i in range(1,n+1): for j in range(1,i): if a[i]\u0026gt;a[j]: f[i]=max(f[i], f[j]+1) for i in range(n,0,-1): for j in range(n,i,-1): if a[i]\u0026gt;a[j]: g[i]=max(g[i], g[j]+1) for i in range(1,n+1): ans = max(ans, f[i]+g[i]-1) print(n-ans) 友好城市 N = int(5e3+10) a=[(-1,-1)] f=[1 for _ in range(N)] ans = 0 n=int(input()) for i in range(n): x,y=map(int, input().split()) a.append((x,y)) a.sort(key=lambda x:x[0]) for i in range(1,n+1): for j in range(1,i): if a[i][1]\u0026gt;a[j][1]: f[i]=max(f[i], f[j]+1) ans = max(f[i], ans) print(ans) 拦截导弹 贪心证明\n题意：某国为了防御敌国的导弹袭击，发展出一种导弹拦截系统，但有缺陷：每一发炮弹都不能高于前一发的高度。给定导弹依次飞来的高度，计算这套系统最多能拦截多少导弹，并且如果要拦截所有导弹，最少需要配备多少套这种导弹拦截系统。\n实现思路：首先使用动态规划求解最多能拦截的导弹数，然后再利用贪心算法求解最少需要配备的系统数。具体实现时，先从左往右依次计算每个位置能拦截的最大导弹数，然后再从右往左依次计算每个位置能拦截的最大导弹数。接着，利用贪心算法，遍历导弹高度，如果当前高度大于已有系统的高度，则增加系统数；否则，更新已有系统的高度。最终得到最多能拦截的导弹数和最少需要配备的系统数。\nN = int(1e3+10) f=[1 for _ in range(N)] g=[0 for _ in range(N)] ans = 0 cnt = 0 a=[0]+[int(x) for x in input().split()] n=len(a) for i in range(n-1,0,-1): for j in range(n-1,i,-1): if a[i]\u0026gt;=a[j]: f[i]=max(f[i], f[j]+1) ans = max(ans, f[i]) print(ans) for i in range(1, n): k=0 while k\u0026lt;cnt and g[k]\u0026lt;a[i]: k+=1 if k\u0026gt;=cnt: cnt+=1 g[k]=a[i] print(cnt) 导弹防御系统 **题意：**R国更新了导弹防御系统，一套系统的导弹拦截高度要么一直严格单调上升，要么一直严格单调下降。给定即将袭来的一系列导弹的高度，请你求出至少需要多少套防御系统，才能将它们全部击落。\n**实现思路：**可以利用深度优先搜索（DFS）来解决。首先定义两个数组up和down，分别表示上升序列和下降序列。然后使用DFS进行状态搜索，每次尝试将当前导弹加入上升序列或下降序列，并更新当前的防御系统数量。最终得到至少需要的防御系统数量。代码中的dfs函数用于进行状态搜索，尝试将当前导弹加入上升序列或下降序列，并递归调用下一个导弹的处理。最终输出最少需要的防御系统数量。\nN = int(1e2+10) up=[0 for _ in range(N)] down=[0 for _ in range(N)] ans=0 def dfs(u, su, sd): global ans if su + sd\u0026gt;=ans: return if u==n: ans=su+sd return k=0 while k\u0026lt;su and up[k]\u0026gt;=a[u]: k+=1 t=up[k] up[k]=a[u] if k\u0026gt;=su: dfs(u+1, su+1, sd) else: dfs(u+1, su, sd) up[k]=t k=0 while k\u0026lt;sd and down[k]\u0026lt;=a[u]: k+=1 t=down[k] down[k]=a[u] if k\u0026gt;=sd: dfs(u+1, su, sd+1) else: dfs(u+1, su, sd) down[k]=t while True: n=int(input()) ans = n if n==0: break a=[int(x) for x in input().split()] dfs(0,0,0) print(ans) 最长公共上升子序列 题意：熊大妈的奶牛们在小沐沐的指导下研究了最长公共上升子序列，即两个数列中都包含一段位置不一定连续的严格递增的数段，要求找出最长的这样的子序列。现在你需要告诉奶牛们最长公共上升子序列的长度。\n实现思路：可以使用动态规划来解决。定义一个二维数组f，其中f[i][j]表示数列A的前i个元素和数列B的前j个元素中，以数列A的第i个元素和数列B的第j个元素结尾的最长公共上升子序列的长度。然后使用动态规划的方式填表，最终找出最长的公共上升子序列的长度。\n代码中的f[i][j]的状态转移方程如下：\n如果a[i]等于b[j]，则f[i][j]等于f[i-1][j-1]+1（表示在a[i]和b[j]相等的情况下可以构成更长的公共上升子序列）。\n如果a[i]大于b[j]，则f[i][j]等于f[i-1][j]（表示a[i]不在公共上升子序列中）。\n否则，f[i][j]等于f[i][j-1]（表示b[j]不在公共上升子序列中）。\nN = int(3e3+10) f=[[0]*N for _ in range(N)] ans=0 n=int(input()) a=[0]+[int(x) for x in input().split()] b=[0]+[int(x) for x in input().split()] for i in range(1,n+1): maxv=1 for j in range(1,n+1): f[i][j]=f[i-1][j] if a[i]==b[j]: f[i][j]=max(f[i][j], maxv) if a[i]\u0026gt;b[j]: maxv=max(maxv, f[i][j]+1) for i in range(1,n+1): ans = max(ans, f[n][i]) print(ans) 状态机模型 闫氏DP分析法——状态机分析法\n大盗阿福 N = int(1e5+10) t=int(input()) while t: t-=1 f=[[0]*2 for _ in range(N)] n=int(input()) a=[0]+[int(x) for x in input().split()] f[1][0]=0 f[1][1]=a[1] for i in range(2,n+1): f[i][0]=max(f[i-1][1],f[i-1][0]) f[i][1]=max(f[i-1][0], f[i-2][1])+a[i] print(max(f[n][0], f[n][1])) 买卖股票 IV 题目大意：给定一个长度为n的数组，表示一个给定股票在n天内的价格。设计一个算法，计算可以获取的最大利润，最多可以完成k笔交易。每次买入卖出合为一笔交易，且不能同时参与多笔交易。\n实现思路：\n使用动态规划解决该问题，定义一个三维数组f，其中f[i][j][0]表示第i天，已完成j笔交易，并且手上没有股票时的最大利润；f[i][j][1]表示第i天，已完成j笔交易，并且手上有股票时的最大利润。 初始化数组f，将所有位置的利润初始化为负无穷-INF，表示不可达。 遍历股票价格数组，使用动态规划递推出f[i][j][0]和f[i][j][1]，即在第i天已完成j笔交易时的最大利润。 最终，取f[n][k][0]中的最大值作为最终结果，表示第n天已完成k笔交易，并且手上没有股票时的最大利润。 代码实现已给出，其中使用了两重循环来填充动态规划数组f，时间复杂度为O(nk)，因为n的最大值为10^5，k的最大值为100，所以算法的时间复杂度为可接受的范围内。\n这个算法的核心思想是利用动态规划逐步计算出在每一天已完成一定数量交易时的最大利润，然后根据问题要求取得最优解。\nK = 110 INF = 0x3f3f3f3f f=[[[-INF]*2 for _ in range(K)] for _ in range(2)] n,k = map(int ,input().split()) w=[0]+[int(x) for x in input().split()] f[1][0][0]=0 t=0 for i in range(1,n+1): for j in range(k+1): f[t][j][0]=max(f[t^1][j][0], f[t^1][j][1]+w[i]) f[t][j][1]=max(f[t^1][j][1], f[t^1][j-1][0]-w[i]) t^=1 res =max(f[t^1][i][0] for i in range(k+1)) print(res) 股票交易V 题目大意：给定一个整数数组prices，其中第i天的股票价格为prices[i]。设计一个算法计算出在满足约束条件下可以获取的最大利润。约束条件为：卖出股票后，你无法在第二天买入股票（即冷冻期为1天），且不能同时参与多笔交易（必须在再次购买前出售掉之前的股票）。\n实现思路：\n使用动态规划解决该问题，定义一个二维数组f，其中f[i][j]表示第i天的交易状态为j时的最大利润，j有三种状态：0表示持有股票，1表示不持有股票且处于冷冻期，2表示不持有股票且不处于冷冻期。 初始化数组f，将所有位置的利润初始化为负无穷-INF，表示不可达。并且将f[0][2]初始化为0，表示第0天结束时，不持有股票且不处于冷冻期时的最大利润为0。 遍历股票价格数组，使用动态规划递推出f[i][j]，即在第i天的交易状态为j时的最大利润。 最终，取f[n][1]和f[n][2]中的最大值作为最终结果，表示最后一天结束时的最大利润。 代码实现已给出，其中使用了一重循环来填充动态规划数组f，时间复杂度为$O(n)$，因为n的最大值为5000，所以算法的时间复杂度为可接受的范围内。\n这个算法的核心思想是利用动态规划逐步计算出在每一天不同交易状态下的最大利润，然后根据问题要求取得最优解。\nN = int(1e5+10) INF = 0x3f3f3f3f f=[[-INF]*3 for _ in range(N)] n=int(input()) w=[0]+[int(x) for x in input().split()] f[0][2]=0 for i in range(1,n+1): f[i][0]=max(f[i-1][0], f[i-1][2]-w[i]) f[i][1]=f[i-1][0]+w[i] f[i][2]=max(f[i-1][1], f[i-1][2]) print(max(f[n][1], f[n][2])) P1220 关路灯 题意：这个问题是关于优化老张关灯顺序以最小化总功耗的。老张每次在天亮时首先关掉自己所处位置的路灯，然后可以向左或向右关灯。为了最小化总功耗，需要找到一个最优的关灯顺序。\n实现思路：\n首先，我们可以使用动态规划来解决这个问题。我们定义一个三维数组f，其中f[i][j][k]表示从第i盏灯到第j盏灯，老张最后一个关灯位置在第k盏灯时的最小功耗。 然后，我们初始化数组f，将所有位置的功耗都初始化为无穷大INF，表示不可达。 对于每一对路灯i和j，我们通过动态规划递推出f[i][j][0]和f[i][j][1]，分别表示老张从左边或右边走到位置i到j的最小功耗。 最后，我们只需比较f[1][n][0]和f[1][n][1]，取其中较小的值作为最终答案。 使用了三重循环来填充动态规划数组f，时间复杂度为$O(n^3)$，因为n的最大值为50，所以算法的时间复杂度为可接受的范围内。这个算法的核心思想是利用动态规划逐步计算出老张从左或右关灯到达每个位置的最小功耗，然后比较两种情况下的最小功耗，找到最优解。\nmaxn = int(8e2) + 100 INF = 0x3f3f3f3f f = [[[INF] * 2 for _ in range(maxn)] for _ in range(maxn)] a = [0] * (maxn + 1) w = [0] * (maxn + 1) sum = [0] * (maxn + 1) n, r = map(int, input().split()) for i in range(1, n + 1): a[i], w[i] = map(int, input().split()) sum[i] = sum[i - 1] + w[i] f[r][r][0] = f[r][r][1] = 0 for i in range(2, n + 1): for j in range(1, n - i + 2): l = j + i - 1 f[j][l][0] = min(f[j + 1][l][0] + (a[j + 1] - a[j]) * (sum[j] + sum[n] - sum[l]), f[j + 1][l][1] + (a[l] - a[j]) * (sum[j] + sum[n] - sum[l])) f[j][l][1] = min(f[j][l - 1][0] + (a[l] - a[j]) * (sum[j - 1] + sum[n] - sum[l - 1]), f[j][l - 1][1] + (a[l] - a[l - 1]) * (sum[j - 1] + sum[n] - sum[l - 1])) ans = min(f[1][n][0], f[1][n][1]) print(ans) 状态压缩DP 小国王 N = 13 M = 1\u0026lt;\u0026lt;N K = 110 state=[] h=[[] for _ in range(M)] cnt = [0]*M f=[[[0]*M for _ in range(K)] for _ in range(N)] def check(x): global n for i in range(n): if (x\u0026gt;\u0026gt;i)\u0026amp;1 and (x\u0026gt;\u0026gt;i+1)\u0026amp;1: return False return True def count(x): global n cnt=0 for i in range(n): if (x\u0026gt;\u0026gt;i)\u0026amp;1: cnt+=1 return cnt n,m = map(int, input().split()) for i in range(1\u0026lt;\u0026lt;n): if check(i): state.append(i) cnt[i]=count(i) for i in range(len(state)): for j in range(len(state)): a = state[i] b = state[j] if (a\u0026amp;b)==0 and check(a|b): h[i].append(j) f[0][0][0]=1 for i in range(1,n+2): for j in range(m+1): for k in range(len(state)): for t in h[k]: c = cnt[state[k]] if j\u0026gt;=c: f[i][j][state[k]]+=f[i-1][j-c][state[t]] print(f[n+1][m][0]) 愤怒的小鸟 eps = 1e-6 N = 18 M = 1\u0026lt;\u0026lt;18 INF = 0x3f3f3f3f def cmp(a,b): if abs(a-b)\u0026lt;eps: return 0 if a\u0026gt;b: return 1 return -1 t = int(input()) for _ in range(t): f = [INF]*M path = [[0]*N for _ in range(N)] q = [0]*N n,m = map(int, input().split()) for i in range(n): x,y = map(float, input().split()) q[i]=(x,y) for i in range(n): path[i][i]=1\u0026lt;\u0026lt;i #关键点：与其他点的抛物线可能都不合法，所以需要独立出一条抛物线 for j in range(n): x1,y1 = q[i] x2,y2 = q[j] if cmp(x1,x2)==0: continue a = (y1/x1-y2/x2)/(x1-x2) if cmp(a,0)\u0026gt;=0: continue b = y1/x1-a*x1 state=0 for k in range(n): x3,y3 = q[k] if cmp(a*x3*x3+b*x3, y3) == 0: state+=(1\u0026lt;\u0026lt;k) path[i][j]=state f[0]=0 for i in range(1\u0026lt;\u0026lt;n): for j in range(n): if not (i\u0026gt;\u0026gt;j)\u0026amp;1: x=j break for j in range(n): f[i | path[x][j]] = min(f[i | path[x][j]], f[i]+1) print(f[(1\u0026lt;\u0026lt;n)-1]) 集合类状态压缩DP 最短Hamilton距离 N = 22 M = 1\u0026lt;\u0026lt;20 INF = 0x3f3f3f3f f=[[INF]*N for _ in range(M)] w=[[]*N for _ in range(N)] n=int(input()) for i in range(n): w[i]=[int(_) for _ in input().split()] f[1][0]=0 for i in range(1\u0026lt;\u0026lt;n): for j in range(n): if i\u0026gt;\u0026gt;j\u0026amp;1: for k in range(n): if i\u0026gt;\u0026gt;k\u0026amp;1: f[i][j]=min(f[i][j], f[i-(1\u0026lt;\u0026lt;j)][k]+w[k][j]) print(f[(1\u0026lt;\u0026lt;n)-1][n-1]) 区间DP 石子合并 N = 1010 INF = 0x3f3f3f3f f=[[INF]*N for _ in range(N)] s=[0]*N n = int(input()) a=[0]+[int(_) for _ in input().split()] for i in range(1,n+1): f[i][i]=0 s[i]=s[i-1]+a[i] for l in range(2,n+1): for i in range(1,n-l+2): j=i+l-1 for k in range(i,j): f[i][j] = min(f[i][j], f[i][k] + f[k+1][j] + s[j]-s[i-1]) print(f[1][n]) 环形石子合并 N = 410 w=[0]*N s=[0]*N INF = 0x3f3f3f3f f=[[-INF]*N for _ in range(N)] g=[[INF]*N for _ in range(N)] n=int(input()) a= [0]+[int(_) for _ in input().split()] for i in range(1,n+1): w[i] = w[i+n] = a[i] for i in range(1,n*2+1): s[i]=s[i-1]+w[i] for l in range(1,n+1): for i in range(1,n*2-l+2): j=i+l-1 if l==1: f[i][j]=g[i][j]=0 for k in range(i,j): f[i][j] = max(f[i][j], f[i][k]+f[k+1][j]+s[j]-s[i-1]) g[i][j] = min(g[i][j], g[i][k]+g[k+1][j]+s[j]-s[i-1]) minv, maxv = INF, -INF for i in range(1,n+1): minv = min(minv, g[i][i+n-1]) maxv = max(maxv, f[i][i+n-1]) print(minv, maxv, sep=\u0026#39;\\n\u0026#39;) 能量项链 N = 210 w=[0]*N f=[[0]*N for _ in range(N)] n = int(input()) a=[0]+[int(_) for _ in input().split()] for i in range(1,n+1): w[i]=w[i+n]=a[i] for l in range(3,n+2): for i in range(1,n*2-l+2): j=i+l-1 for k in range(i+1,j): f[i][j] = max(f[i][j], f[i][k]+f[k][j]+w[i]*w[k]*w[j]) maxv = -1 for i in range(1,n+1): maxv = max(maxv, f[i][i+n]) print(maxv) 凸多边形的划分 N = 55 INF = 1e30 f=[[INF]*N for _ in range(N)] n = int(input()) w=[0]+[int(_) for _ in input().split()] for i in range(1,n+1): f[i][i+1]=0 for l in range(3,n+1): for i in range(1, n-l+2): j=i+l-1 for k in range(i+1,j): f[i][j] = min(f[i][j], f[i][k]+f[k][j]+w[i]*w[k]*w[j]) print(f[1][n]) 加分二叉树 N = 50 def dfs(l, r): if l\u0026gt;r: return k=root[l][r] print(k,end=\u0026#39; \u0026#39;) dfs(l,k-1) dfs(k+1,r) n = int(input()) w = [0]+[int(_) for _ in input().split()] f=[[0]*N for _ in range(N)] root=[[0]*N for _ in range(N)] for l in range(1,n+1): for i in range(1,n-l+2): j=i+l-1 for k in range(i,j+1): left = 1 if k==i else f[i][k-1] right = 1 if k==j else f[k+1][j] s = left*right+w[k] if i==j: s=w[k] if f[i][j]\u0026lt;s: f[i][j]=s root[i][j]=k print(f[1][n]) dfs(1,n) 树形DP 树的最长路径 注意注意再注意，while循环链不符合要求是需要 i=ne[i]\nimport sys sys.setrecursionlimit(int(1e5+10)) N = 10010*2 e = [0]*N ne = [0]*N w = [0]*N h = [-1]*N idx = 1 ans = -1 def add(a, b, c): global idx e[idx]=b w[idx]=c ne[idx]=h[a] h[a]=idx idx+=1 def dfs(root, father): global ans dis, d1, d2 = 0,0,0 i=h[root] while i!=-1: j = e[i] if j==father: i=ne[i] # 重点 continue d = dfs(j, root)+w[i] dis = max(dis, d) if d\u0026gt;d1: d2=d1 d1=d else: d2 = max(d2, d) i=ne[i] ans = max(ans, d1+d2) return dis n = int(input()) for i in range(n-1): a,b,c = map(int, input().split()) add(a,b,c) add(b,a,c) dfs(1,-1) print(ans) 树的中心 题目大意：给定一棵包含 n 个节点的树，每条边都有一个权值。要求在树中找到一个点，使得该点到树中其他节点的最远距离最近。\n实现思路：\n构建无向图的邻接表，其中每个节点对应一个链表，存储其相邻的节点以及对应的边权值。 使用 DFS 遍历树，分别计算每个节点到其他节点的最长距离 d1 和次长距离 d2，并记录其相邻节点 s1。 再次使用 DFS 遍历树，计算每个节点到其相邻节点的最长距离 up。 最后，遍历所有节点，求出所有节点中最大的 max(up[i], d1[i])，即为所求的最近距离。 N = 10010*2 e = [0]*N ne=[0]*N h=[-1]*N w=[0]*N d1=[0]*N d2=[0]*N s1=[0]*N up=[0]*N idx = 1 def add(a,b,c): global idx e[idx]=b w[idx]=c ne[idx]=h[a] h[a]=idx idx+=1 def dfs1(u, father): i=h[u] while i!=-1: j=e[i] if j==father: i=ne[i] continue dfs1(j,u) dis = d1[j]+w[i] if dis\u0026gt;d1[u]: d2[u]=d1[u] d1[u], s1[u]=dis, j elif dis\u0026gt;d2[u]: d2[u]=dis i=ne[i] def dfs2(u, father): i=h[u] while i!=-1: j=e[i] if j==father: i=ne[i] continue if s1[u]==j: up[j]=max(up[u], d2[u])+w[i] else: up[j]=max(up[u], d1[u])+w[i] i=ne[i] dfs2(j, u) n = int(input()) for i in range(n-1): a,b,c = map(int ,input().split()) add(a,b,c) add(b,a,c) dfs1(1,-1) dfs2(1,-1) ans = 1e10 for i in range(1,n+1): ans = min(ans, max(up[i], d1[i])) print(ans) 数字转换 题目大意：给定一个正整数 n，如果一个数 x 的约数之和 y（不包括 x 本身）比它本身小，那么 x 可以变为 y，y 也可以变为 x。限定所有数字变换在不超过 n 的正整数范围内进行，求不断进行数字变换且不出现重复数字的最多变换步数。\n实现思路：\n首先，对于每个数 i，计算其所有约数之和，并存储在数组 s 中。 然后，遍历所有的数 i，如果约数之和 s[i] 小于 i，则将其作为一个节点添加到有向图中，表示可以从 s[i] 变换到 i。 构建有向图后，使用深度优先搜索（DFS）算法遍历图中的每个节点，并求出每个节点的最长路径长度。 在DFS过程中，使用变量 ans 记录图中最长路径的长度，即最多变换步数。 最后，输出 ans 即可。 N = int(5e4+10) s=[0]*N st=[False]*N e=[0]*N ne=[0]*N h=[-1]*N idx=1 ans = -1 def add(a,b): global idx e[idx]=b ne[idx]=h[a] h[a]=idx idx+=1 def dfs(u): global ans d1,d2=0,0 i=h[u] while i!=-1: j=e[i] dis = dfs(j)+1 if dis\u0026gt;d1: d2,d1=d1,dis elif dis\u0026gt;d2: d2=dis i=ne[i] ans = max(ans, d1+d2) return d1 n = int(input()) for i in range(1,n+1): for j in range(2,n+1): if i\u0026gt;n//j: break s[i*j]+=i for i in range(2,n+1): if s[i]\u0026lt;i: add(s[i], i) st[i]=True # for i in range(1,n+1): # if not st[i]: # dfs(i) dfs(1) print(ans) 没有上司的舞会 题目大意：Ural大学有N名职员，编号为1∼N。他们的关系像一棵以校长为根的树，父节点就是子节点的直接上司。每个职员有一个快乐指数，用整数Hi表示。现在要召开一场周年庆宴会，但没有职员愿意和直接上司一起参会。在满足这个条件的前提下，主办方希望邀请一部分职员参会，使得所有参会职员的快乐指数总和最大，求这个最大值。\n实现思路：\n首先，建立一棵以校长为根的树，使用一个二维数组v来存储树的结构关系，其中v[i]表示第i个职员的直接下属。 使用一个二维数组f来记录每个职员参加和不参加宴会时的最大快乐指数，其中f[i][0]表示第i个职员不参加宴会时的最大快乐指数，f[i][1]表示第i个职员参加宴会时的最大快乐指数。 使用深度优先搜索（DFS）来遍历树的每个节点，计算每个节点不参加和参加宴会时的最大快乐指数。 在DFS过程中，对于每个节点i，首先更新该节点参加宴会时的最大快乐指数f[i][1]为当前节点的快乐指数h[i]，然后遍历当前节点的直接下属，更新当前节点参加和不参加宴会时的最大快乐指数。 最终，取根节点的参加和不参加宴会时的最大快乐指数的较大值作为最终结果。 代码实现已给出，其中使用了深度优先搜索来遍历树的每个节点，时间复杂度为O(N)，因为N的最大值为6000，所以算法的时间复杂度为可接受的范围内。\n这个算法的核心思想是利用深度优先搜索逐步计算出每个节点参加和不参加宴会时的最大快乐指数，然后根据问题要求找到最大的快乐指数。\nimport sys sys.setrecursionlimit(int(1e4)) N = int(7e3) v=[[] for _ in range(N)] f=[[0]*2 for _ in range(N)] st=[False]*N h=[0]*N root=0 def dfs(u): f[u][1]+=h[u] for i in v[u]: dfs(i) f[u][1]+=f[i][0] f[u][0]+=max(f[i][0], f[i][1]) n = int(input()) for i in range(1,n+1): h[i]=int(input()) for i in range(n-1): l,k = map(int, input().split()) v[k].append(l) st[l]=True for i in range(1,n+1): if not st[i]: root=i dfs(root) print(max(f[root][0], f[root][1])) 单调队列优化的DP 最大子序和 题目大意：给定一个长度为n的整数序列，从中找出一段长度不超过m的连续子序列，使得子序列中所有数的和最大。要求输出该序列的最大子序和。\n实现思路：\n首先，将输入的序列进行预处理，计算出前缀和数组s，其中s[i]表示序列的前i个数的和。 使用单调队列来解决该问题。单调队列维护的是前缀和数组s中的下标，队列中的元素按照前缀和的值单调递增。队列中的下标表示的是以该下标结尾的连续子序列的最大和。 遍历序列，对于每个位置i，更新单调队列中的元素，使得队列中的下标符合要求，即满足长度不超过m的连续子序列的条件。 在遍历的过程中，不断更新记录最大子序和的变量ans，最终得到的ans即为所求结果。 代码实现已给出，其中使用了单调队列来维护满足条件的下标，时间复杂度为O(n)，因为n的最大值为300000，所以算法的时间复杂度为可接受的范围内。\n这个算法的核心思想是利用单调队列维护以每个位置结尾的满足条件的子序列的最大和，然后根据问题要求找到最大子序和。\nN = 300010 q, s = [0]*N, [0]*N ans = -2**33 hh, tt = 0, 0 n,m = map(int, input().split()) s = [0]+list(map(int, input().split())) for i in range(1,n+1): s[i]+=s[i-1] for i in range(1,n+1): if q[hh]\u0026lt;i-m: hh+=1 ans = max(ans, s[i]-s[q[hh]]) while hh\u0026lt;=tt and s[q[tt]]\u0026gt;=s[i]: tt-=1 tt+=1 q[tt]=i print(ans) 数位DP 1081\nfrom typing import List N = 35 def init() -\u0026gt; List[List[int]]: f = [[0] * N for _ in range(N)] for i in range(N): for j in range(i + 1): if j == 0: f[i][j] = 1 else: f[i][j] = f[i - 1][j] + f[i - 1][j - 1] return f def dp(n: int, k: int, b: int, f: List[List[int]]) -\u0026gt; int: if n == 0: return 0 nums = [] while n: nums.append(n % b) n //= b res = 0 last = 0 for i in range(len(nums) - 1, -1, -1): x = nums[i] if x \u0026gt; 0: res += f[i][k - last] if x \u0026gt; 1: if k - last - 1 \u0026gt;= 0: res += f[i][k - last - 1] break else: last += 1 if last \u0026gt; k: break if i == 0 and last == k: res += 1 return res def solve(l: int, r: int, k: int, b: int) -\u0026gt; int: f = init() return dp(r, k, b, f) - dp(l - 1, k, b, f) if __name__ == \u0026#34;__main__\u0026#34;: l, r, k, b = map(int, input().split()) print(solve(l, r, k, b)) 记忆化 滑雪 题目大意：Michael喜欢滑雪，并希望知道在一个区域中最长的滑坡。给定一个二维数组表示区域，数组中的每个数字代表点的高度。一个人可以从某个点滑向上下左右相邻四个点之一，当且仅当高度会减小。要求找到最长的滑坡，即从一个高点开始，一直滑到一个低点。\n实现思路：\n使用优先队列（堆）来实现广度优先搜索（BFS）。 首先，初始化一个二维数组f用于存储从每个点出发的最长滑坡距离，初始化优先队列pq用于存储待搜索的点。 将所有点按照高度从小到大加入优先队列pq。 对于优先队列中的每个点，依次向上下左右四个方向搜索，如果下一个点的高度小于当前点，则更新下一个点的最长滑坡距离为当前点的最长滑坡距离加1。 在搜索过程中，不断更新记录最长滑坡距离的变量ma，最终得到的ma即为最长滑坡的长度。 代码实现已给出，其中使用了优先队列pq来进行广度优先搜索，时间复杂度为O(nmlog(nm))，因为n和m的最大值为100，所以算法的时间复杂度为可接受的范围内。\n这个算法的核心思想是利用广度优先搜索逐步计算出从每个点出发的最长滑坡距离，然后根据问题要求找到最长的滑坡。\nfrom heapq import * n, m = map(int, input().split()) f = [[0] * (m + 5) for _ in range(n + 5)] # distance g = [[0] * (m + 5) for _ in range(n + 5)] # store heights pq = [] for i in range(1, n + 1): nums = [0] + list(map(int, input().split())) for j, num in enumerate(nums[1:]): f[i][j] = 1 g[i][j] = num heappush(pq, (num, i, j)) # Push (num, i, j) into the priority queue ma = -1 while pq: num, i, j = heappop(pq) if g[i - 1][j] \u0026lt; num: f[i][j] = max(f[i][j], f[i - 1][j] + 1) if g[i + 1][j] \u0026lt; num: f[i][j] = max(f[i][j], f[i + 1][j] + 1) if g[i][j - 1] \u0026lt; num: f[i][j] = max(f[i][j], f[i][j - 1] + 1) if g[i][j + 1] \u0026lt; num: f[i][j] = max(f[i][j], f[i][j + 1] + 1) ma = max(ma, f[i][j]) print(ma) from functools import lru_cache from sys import stdin input = stdin.readline def solve(matrix): if not matrix: return 0 dirs = [(-1, 0), (0, 1), (1, 0), (0, -1)] @lru_cache(None) def dfs(r, c): res = 1 for dx, dy in dirs: a, b = r + dx, c + dy if 0\u0026lt;= a \u0026lt;m and 0\u0026lt;= b \u0026lt;n and matrix[a][b] \u0026gt; matrix[r][c]: res = max(res, dfs(a, b) + 1) return res m, n = len(matrix), len(matrix[0]) res = 0 for i in range(m): for j in range(n): res = max(res, dfs(i, j)) return res r, c = map(int, input().split()) matrix = [[]for _ in range(r)] for i in range(r): matrix[i] = list(map(int, input().split())) print(solve(matrix)) ","permalink":"https://kennems.github.io/posts/tech/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0%E4%BA%94dppython%E5%AE%9E%E7%8E%B0/","summary":"算法笔记（五）——DP（Python实现） DP 数字三角形 f=[] n=int(input()) for _ in range(n): f.append([int(x) for x in input().split()]) for i in range(n-2,-1,-1): for j in range(i+1): f[i][j]=max(f[i+1][j], f[i+1][j+1])+f[i][j] print(f[0][0]) 背包 空间优化成1维之后，只有完全背包问题的","title":"算法笔记（五）——DP（Python实现）"},{"content":"算法笔记（一）——基础+杂项（Python实现） 基础+杂项 快速排序 def quick_sort(q, l, r): if l\u0026gt;=r: return i,j,x=l-1,r+1,q[(l+r)\u0026gt;\u0026gt;1] while i\u0026lt;j: i+=1 while q[i]\u0026lt;x: i+=1 j-=1 while q[j]\u0026gt;x: j-=1 if i\u0026lt;j: q[i], q[j] = q[j], q[i] quick_sort(q, l, j) quick_sort(q, j+1, r) n=int(input()) arr=list(map(int, input().split())) quick_sort(arr,0,n-1) print(\u0026#34; \u0026#34;.join(map(str, arr))) 归并排序 j = mid+1 !!!\nfrom sys import stdin input = lambda:stdin.readline().strip() def merge_sort(q, l, r): if l\u0026gt;=r: return mid = l+r\u0026gt;\u0026gt;1 merge_sort(q, l, mid); merge_sort(q, mid+1, r) i, j = l, mid+1 tmp = [] while i\u0026lt;=mid and j\u0026lt;=r: if q[i] \u0026lt;= q[j]: tmp.append(q[i]) i += 1 else: tmp.append(q[j]) j += 1 if i\u0026lt;=mid: tmp.extend(q[i:mid+1]) if j\u0026lt;=r: tmp.extend(q[j:r+1]) q[l:r+1] = tmp n = int(input()) arr = list(map(int, input().split())) merge_sort(arr, 0, n-1) print(*arr) 二分 def check(x): # 检查 x 是否满足某种性质 pass # 这里需要根据具体的情况实现 def bsearch_1(l, r): while l \u0026lt; r: mid = (l + r) // 2 if check(mid): r = mid else: l = mid + 1 return l def bsearch_2(l, r): while l \u0026lt; r: mid = (l + r + 1) // 2 if check(mid): l = mid else: r = mid - 1 return l # 示例用法 # 首先定义 check 函数来检查性质 # 然后使用 bsearch_1 或 bsearch_2 来进行二分搜索 最佳牛围栏 题意：n块地，每块地上有奶牛，现在需要用围栏围起一些奶牛， 但至少有f块地，问最终围起的地中牛的数量的平均数的最大值为多少。 浮点数二分最大数量，判断所有数减去当前二分的平均数后，有没有一段长度为f并且是全为正数的，如果有则合法。判断方法：b数组存原数组减去平均数，求前缀和，用前缀和数组求某一段内的和是否为正数即可， 只要长度大于f的所有段都要枚举，但是我们只要求$s[i]-s[0-\u0026gt;i-f]$是否有一个大于0即可，所以只用求$min(s[0:i-f])$即可。注意浮点数二分因为误差需要用eps判断，并且r会稍微大于答案，l会稍微小于答案，题目问的是向下取整最近的整数，所以取r向下取整。 import sys input = lambda:sys.stdin.readline().strip() N = int(1e5+10) a, b = [0]*N, [0]*N n, f = map(int , input().split()) for i in range(1, n+1): a[i] = int(input()) l, r = 0.0, 2e3+10 eps = 1e-6 while r-l \u0026gt; eps: mid = (l+r)/2 s, mi, cur = [0]*N, 1e18, -1e18 for i in range(1, n+1): b[i] = a[i]-mid for i in range(1, n+1): s[i] = s[i-1]+b[i] for i in range(f, n+1): mi = min(mi, s[i-f]) cur = max(cur, s[i]-mi) if cur\u0026gt;=0: l = mid else: r = mid print(int(r*1000)) 浮点数二分 def check(x): # 检查x是否满足某种性质 pass # 这里需要根据具体情况实现check函数 def bsearch_3(l, r): eps = 1e-6 # eps 表示精度，取决于题目对精度的要求 while r - l \u0026gt; eps: mid = (l + r) / 2 if check(mid): r = mid else: l = mid return l 一维前缀和 def prefixSum(arr): n = len(arr) prefixSum = [0] * n prefixSum[0] = arr[0] for i in range(1, n): prefixSum[i] = prefixSum[i-1] + arr[i] for i in range(n): print(prefixSum[i], end=\u0026#34; \u0026#34;) arr = [1, 2, 3, 4, 5] prefixSum(arr) 二维前缀和 import sys # 重定向输入函数为sys.stdin.readline().strip()以去除末尾换行符 input = lambda:sys.stdin.readline().strip() # 读取n、m、q三个整数 n, m, q = map(int, input().split()) # 创建一个n+1行，m+1列的二维列表g，初始值均为0 g = [[0]*(m+1) for _ in range(n+1)] # 读取地图的每一行，并将值转换为整数，存储到g中 for i in range(1, n+1): g[i] = [0] + list(map(int, input().split())) # 计算前缀和，g[i][j]表示以(i,j)为右下角的矩形内所有元素之和 for i in range(1, n+1): for j in range(1, m+1): g[i][j] = (g[i][j] + g[i-1][j] + g[i][j-1] - g[i-1][j-1]) # 针对每个查询，计算给定矩形区域内元素之和 for i in range(q): x1, y1, x2, y2 = map(int, input().split()) # 计算矩形区域内元素之和，利用前缀和的性质 # g[x2][y2]表示右下角坐标为(x2,y2)的矩形内所有元素之和 # g[x1-1][y2]表示右上角坐标为(x1-1,y2)的矩形内所有元素之和 # g[x2][y1-1]表示左下角坐标为(x2,y1-1)的矩形内所有元素之和 # g[x1-1][y1-1]表示左上角坐标为(x1-1,y1-1)的矩形内所有元素之和 # 利用以上四个值，可以求得目标矩形区域内元素之和 print(g[x2][y2] - g[x1-1][y2] - g[x2][y1-1] + g[x1-1][y1-1]) 一维差分 差分和前缀和是逆运算。\n需要计算某一段区间$+-$操作时，运用差分操作 updateRange 需要先构造差分数组\n$s[i] = s[i-1]+a[i]$ 逆运算 $d[i]=a[i]-a[i-1]$ （原数组看作为前缀和数组）\ndef updateRange(B, l, r, c): B[l] += c B[r + 1] -= c def printArray(arr): for i in range(len(arr)): print(arr[i], end=\u0026#34; \u0026#34;) print() n= 5 B = [0] * (n + 1) updateRange(B, 1, 3, 2) updateRange(B, 2, 4, 3) printArray(B) import sys # 重定向输入函数为sys.stdin.readline().strip()以去除末尾换行符 input = lambda:sys.stdin.readline().strip() # 读取n和m两个整数，表示序列长度和操作次数 n, m = map(int, input().split()) # 读取序列a，长度为n，将其转换为整数列表，同时在开头添加0以便处理边界情况 a = [0] + list(map(int, input().split())) # 初始化差分数组d，长度为n+2，初始值均为0 d = [0]*(n+2) # 计算原始序列a中相邻元素的差值，存储到差分数组d中 for i in range(1, n+1): d[i] = a[i] - a[i-1] # 执行m次操作 for i in range(m): # 读取操作参数l、r、c，表示对[l,r]范围内元素增加c l, r, c = map(int, input().split()) # 在差分数组中更新对应区间[l,r]内元素的增量 d[l] += c d[r+1] -= c # 根据差分数组还原原始序列 for i in range(1, n+1): d[i] += d[i-1] # 输出还原后的原始序列 print(*d[1:n+1]) 二维差分 # 从输入中获取网格的行数、列数和操作数量 n, m, q = map(int, input().split()) # 初始化原始网格数组和操作影响数组 g = [[0]*(m+1) for _ in range(n+1)] d = [[0]*(m+2) for _ in range(n+2)] # 填充原始网格数组 for i in range(1, n+1): # 将每行的数据存入二维数组g中 g[i] = [0] + list(map(int, input().split())) # 处理每个操作 for i in range(q): # 获取操作的左上角坐标、右下角坐标和要添加到该区域内的值 x1, y1, x2, y2, c = map(int, input().split()) # 更新操作影响数组 d[x1][y1] += c d[x1][y2+1] -= c d[x2+1][y1] -= c d[x2+1][y2+1] += c # 根据操作影响数组更新原始网格数组 for i in range(1, n+1): for j in range(1, m+1): # 更新操作影响的累积值 d[i][j] = d[i][j] + d[i-1][j] + d[i][j-1] - d[i-1][j-1] # 更新原始网格数组中的值 g[i][j] += d[i][j] # 打印更新后的原始网格数组 for i in range(1, n+1): print(*g[i][1:m+1]) 双指针 for i in range(n): j = 0 while j \u0026lt; i and check(j, i): j += 1 # 具体问题的逻辑 # 常见问题分类： # (1) 对于一个序列，用两个指针维护一段区间 # (2) 对于两个序列，维护某种次序，比如归并排序中合并两个有序序列的操作 位运算 原码，反码，补码 求n二进制表示中第k位数字: n \u0026gt;\u0026gt; k \u0026amp; 1 返回n的最后一位1：lowbit(n) = n \u0026amp; -n 树状数组基本操作 离散化 alls = [] # 存储所有待离散化的值 # 将所有值排序 alls.sort() # 去掉重复元素 alls = list(set(alls)) # 二分求出x对应的离散化的值 def find(x): l, r = 0, len(alls) - 1 while l \u0026lt; r: mid = (l + r) // 2 if alls[mid] \u0026gt;= x: r = mid else: l = mid + 1 return r + 1 # 映射到1, 2, ...n import sys input = lambda:sys.stdin.readline().strip() def find(x): l, r = 0, num while l\u0026lt;r: mid = (l+r+1)\u0026gt;\u0026gt;1 if ls[mid] \u0026lt;= x: l = mid else: r = mid-1 return l N = int(1e5)+10 s = [0]*N ls = [] d = dict() n, m = map(int, input().split()) for i in range(n): x, c = map(int, input().split()) if x not in d: d[x] = c ls.append(x) else: d[x] += c ls.sort() num = len(d) ls = [0] + ls for i in range(1, num+1): s[i] = s[i-1] + d[ls[i]] for i in range(m): l, r = map(int, input().split()) pl, pr = find(l), find(r) if l in d: pl -= 1 print(s[pr] - s[pl]) 区间合并 def merge(segs): segs.sort() # 区间左端点排序 res = [] st, ed = -2e9, -2e9 for seg in segs: if ed \u0026lt; seg[0]: if st != -2e9: res.append((st, ed)) st, ed = seg[0], seg[1] else: ed = max(ed, seg[1]) if st != -2e9: res.append((st, ed)) segs[:] = res n = int(input()) st, ed = -int(2e9), -int(2e9) segs = [] for i in range(n): l, r = map(int, input().split()) segs.append((l, r)) segs.sort() cnt = 0 for seg in segs: s, e = seg if s\u0026gt;ed: st, ed = s, e cnt+=1 else: ed = max(e, ed) print(cnt) 矩阵快速幂 mod = int(1e9) + 7 def mul(a, b): t = [[0]*101 for _ in range(101)] for i in range(1, n+1): for j in range(1, n+1): for k in range(1, n+1): t[i][j] = (t[i][j] + a[i][k]*b[k][j]) % mod return t def qp(a, k): res = [[0]*101 for _ in range(101)] for i in range(1, n+1): res[i][i] = 1 while k: if k\u0026amp;1: res = mul(res, a) a = mul(a, a) k\u0026gt;\u0026gt;=1 return res n, k = map(int, input().split()) a = [[0]*101 for _ in range(101)] for i in range(1, n+1): row = [0] + list(map(int, input().split())) for j in range(1, n+1): a[i][j] = row[j] ans = qp(a, k) for i in range(1, n+1): print(*ans[i][1:n+1], sep=\u0026#39; \u0026#39;) 递归98. 分形之城 t = int(input()) def calc(n, m): if not m: return (0, 0) l, cnt = 1\u0026lt;\u0026lt;(n-1), 1\u0026lt;\u0026lt;(2*n-2) x, y = calc(n-1, m%cnt) z = m//cnt if z==0: return (y, x) if z==1: return (x, y+l) if z==2: return (x+l, y+l) if z==3: return (2*l-1 - y, l-1 - x) for i in range(t): n, a, b = map(int, input().split()) a-=1; b-=1 xa, ya = calc(n, a) xb, yb = calc(n, b) dis = int(( (xa-xb)**2 + (ya-yb)**2 ) ** 0.5 * 10 + 0.5) print(dis) 递推95. 费解的开关 题目大意：游戏规则如下：有 25 盏灯排成 5×5 的方形。每一盏灯都有一个开关，改变某一盏灯的状态会导致其上下左右相邻的灯也改变状态。给定初始状态，判断是否能在 6 步以内使所有的灯都变亮。\n实现思路：首先，我们需要实现一个函数 turn(x, y) 来实现改变灯的状态以及连锁反应。然后，我们对于每个初始状态，采用深度优先搜索或者广度优先搜索的方式来模拟游戏过程，尝试所有可能的开关状态组合，并记录达到目标状态所需的步数。最后，输出结果即可。\nfrom copy import deepcopy dx = [0, 1, 0, -1, 0] dy = [0, 0, 1, 0, -1] g = [[] for _ in range(5)] def turn(x, y): for i in range(5): xx = x+dx[i] yy = y+dy[i] if xx in range(5) and yy in range(5): g[xx][yy] ^= 1 def work(): global g backup = deepcopy(g) ans = float(\u0026#39;inf\u0026#39;) for k in range(1\u0026lt;\u0026lt;5): cur, flag = 0, True g = deepcopy(backup) for i in range(5): if (k\u0026gt;\u0026gt;i)\u0026amp;1: turn(0, i) cur+=1 for i in range(4): for j in range(5): if g[i][j]==0: turn(i+1, j) cur+=1 for i in range(5): if g[4][i]==0: flag = False break if flag: ans = min(ans, cur) return ans t = int(input()) for _ in range(t): for i in range(5): g[i] = [int(_) for _ in list(input())] if _ \u0026lt; t-1: input() res = work() if res\u0026lt;=6:print(res) else:print(-1) ST1273. 天才的记忆 题目大意：有一个长度为 N 的数字序列，编号为 1 到 N，每次询问给出两个数字 A 和 B，要求回答 A 到 B 区间内的最大数。\n实现思路：这是一个典型的区间最值查询问题，可以使用线段树进行求解。首先，需要初始化一个二维数组 f 用于存储区间最大值信息。然后，利用预处理的方式，计算出 log 数组，用于快速计算区间长度的对数。接着，利用动态规划的思想，初始化 f 数组，使得 f[i][0] 等于数字序列中对应位置的值。接下来，利用动态规划的思想，更新 f 数组，使得 f[i][j] 等于区间 [i, i+2^j-1] 内的最大值。最后，对于每个询问，利用预处理的区间最值信息，通过 log 数组快速确定区间长度的对数，然后利用区间最值信息查询区间最大值，即可得到答案。\nimport sys input = lambda:sys.stdin.readline().strip() N = int(2e5)+10 M = 20 f = [[0]*M for _ in range(N)] log = [0]*N def init(): log[0] = -1 for i in range(1, N): log[i] = log[i\u0026gt;\u0026gt;1] + 1 for j in range(M): for i in range(1, n+1): if not j: f[i][j] = w[i] else: if i + (1\u0026lt;\u0026lt;(j-1)) \u0026gt; n: break f[i][j] = max(f[i][j-1], f[i+(1\u0026lt;\u0026lt;(j-1))][j-1]) def query(l, r): leng = r-l+1 k = log[leng] return max(f[l][k], f[r-(1\u0026lt;\u0026lt;k)+1][k]) n = int(input()) w = [0] + list(map(int, input().split())) init() m = int(input()) for i in range(m): l, r = map(int, input().split()) print(query(l, r)) ","permalink":"https://kennems.github.io/posts/tech/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0%E4%B8%80%E5%9F%BA%E7%A1%80+%E6%9D%82%E9%A1%B9python%E5%AE%9E%E7%8E%B0/","summary":"算法笔记（一）——基础+杂项（Python实现） 基础+杂项 快速排序 def quick_sort(q, l, r): if l\u0026gt;=r: return i,j,x=l-1,r+1,q[(l+r)\u0026gt;\u0026gt;1] while i\u0026lt;j: i+=1 while q[i]\u0026lt;x: i+=1 j-=1 while q[j]\u0026gt;x: j-=1 if i\u0026lt;j: q[i], q[j] = q[j], q[i] quick_sort(q, l, j) quick_sort(q, j+1, r) n=int(input()) arr=list(map(int, input().split())) quick_sort(arr,0,n-1) print(\u0026#34; \u0026#34;.join(map(str,","title":"算法笔记（一）——基础+杂项（Python实现）"},{"content":"周赛240407 出师不利，第一题变量名能写错，慢就是快，少就是多，提交之前一定要有万全的检查。\n第二题100242. 满足距离约束且字典序最小的字符串 纯思维题，先花时间想清楚基础问题再想后面的问题。吸取教训，代码一定要写的清晰明了，自己才能更好的看懂并写下去。\nPython 取模运算中余数符号和除数符号一致，并满足：$被除数-除数*商(整除)=余数$\n思路：转换问题，问不超过k，那么用完$k$是最优的，因为用$k$总能使字典序变小(除非原序列全是$a$), 那么就依次枚举，知道不能转换为$a$的情况下将剩余的$k$转换称可以转换成的最小的字典序字母。\nclass Solution: def getSmallestString(self, s: str, k: int) -\u0026gt; str: s = list(s) n = len(s) for i in range(n): d = min(ord(s[i])-ord(\u0026#39;a\u0026#39;), ord(\u0026#39;a\u0026#39;)-ord(s[i])+26) if k\u0026gt;=d: k-=d s[i]=\u0026#39;a\u0026#39; else: num = ord(s[i])-ord(\u0026#39;a\u0026#39;) ch = min((num-k)%26, (num+k)%26) ch = chr(ch+ord(\u0026#39;a\u0026#39;)) s[i] = ch break return \u0026#39;\u0026#39;.join(s) 第三题 3107. 使数组中位数等于 K 的最少操作数 这题比较简答，最后一刻用二分交的，结果右端点取值保守错了一发。\n实际不需要二分，在排好序的序列里，用中位数去靠近中位数更优，所以直接排序计算将前面比k大的和后面比$k$小的计算差值就可以了。\nclass Solution: def minOperationsToMakeMedianK(self, nums: List[int], k: int) -\u0026gt; int: nums.sort() n = len(nums) mid = n // 2 op=abs(nums[mid]-k) for i in range(mid): if nums[i]\u0026gt;k: op += nums[i] - k for i in range(mid+1, n): if nums[i]\u0026lt;k: op += k - nums[i] return op 第四题100244. 带权图里旅途的最小代价 并查集+思维题。如果一些数字相与$(and)$， 如果存在较小的数字二进制位中是$0$，那么就算有再多的数字在这一位上是$1$也没有用了。所以在一个连通块内最小代价就是所有边都走一遍，而连通块可以用并查集来判断。\nclass Solution: def minimumCost(self, n: int, edges: List[List[int]], query: List[List[int]]) -\u0026gt; List[int]: def find(x): if p[x]!=x: p[x]=find(p[x]) return p[x] p={i:i for i in range(n)} dis={} ret=[] for u,v,_ in edges: p[find(u)]=find(v) for u,v,w in edges: pu = find(u) if pu not in dis: dis[pu]=w else: dis[pu]\u0026amp;=w for x,y in query: if x==y: ret.append(0) continue #如果相等一定要continue px, py = find(x), find(y) if px==py: ret.append(dis[px]) else: ret.append(-1) return ret ","permalink":"https://kennems.github.io/posts/tech/%E5%91%A8%E8%B5%9B240407/","summary":"周赛240407 出师不利，第一题变量名能写错，慢就是快，少就是多，提交之前一定要有万全的检查。 第二题100242. 满足距离约束且字典序最小的","title":"LeetCode周赛392(240407)"},{"content":"hugo new content posts/my-first-post.md\n","permalink":"https://kennems.github.io/posts/life/my-first-post/","summary":"hugo new content posts/my-first-post.md","title":"My First Post"},{"content":"VP 周赛 第 389 场周赛 第三题3085. 成为 K 特殊字符串需要删除的最少字符数 双指针优化$O(n)$\n第三题做出来了但做法不优并且错的次数太多了。\n题目大意：给定一个字符串word和一个整数k，定义特殊字符串为满足|freq(word[i]) - freq(word[j])| \u0026lt;= k对于字符串中所有下标i和j都成立的字符串。其中，freq(x)表示字符x在word中的出现频率，|y|表示y的绝对值。要求计算使word成为k特殊字符串所需删除的字符的最小数量。\n实现思路：首先统计word中每个字符的出现频率，然后对频率进行排序。接着遍历频率列表，从最大的频率开始，逐步减少频率，直到满足特殊字符串的条件。在减少频率的过程中，利用一个指针指向频率列表中的当前位置，不断向前移动，更新需要删除的字符数量。最终得到使word成为k特殊字符串所需删除的最小字符数量。\nclass Solution: def minimumDeletions(self, word: str, k: int) -\u0026gt; int: ans = 2e9 cnt = sorted(Counter(word).values()) numFre = len(cnt)-1 delCnt = len(word) right = numFre for cur in range(numFre, -1, -1): delCnt-=cnt[cur] maxFre = cnt[cur]+k while right\u0026gt;cur and cnt[right]\u0026gt;maxFre: delCnt+=cnt[right] right-=1 ans = min(ans, delCnt-(numFre-right)*maxFre) return ans 第四题3086. 拾起 K 个 1 需要的最少行动次数 题目大意：给定一个二进制数组nums，长度为n，以及一个正整数k和非负整数maxChanges。Alice在一个游戏中需要从nums中拾起k个1，游戏开始时，Alice可以选择任意位置站立。Alice可以执行两种行动：一是将一个0改为1，次数不超过maxChanges；二是交换相邻位置的1和0。返回Alice拾取k个1所需的最少行动次数。\n实现思路：首先，统计nums中1的位置，同时记录每个1的前缀和。然后确定最多可以拾取的1的个数，即为maxChanges和当前1的个数的最小值。如果最大变化次数maxChanges足够多，那么不需要交换1的位置，直接计算需要变化的次数即可；否则，利用二分搜索确定需要交换的1的位置，计算交换和变化的次数。最终返回行动次数。\nclass Solution: def minimumMoves(self, nums: List[int], k: int, maxChanges: int) -\u0026gt; int: pos = [] n=len(nums) c=0 for i, v in enumerate(nums): if not v: continue pos.append(i) if c==3: continue c=max(c, 1) if i\u0026gt;0 and nums[i]==nums[i-1]: c = max(2, c) if i\u0026gt;1 and nums[i]==nums[i-1] and nums[i]==nums[i-2]: c = max(3, c) c = min(c, k) if maxChanges\u0026gt;=k-c: return max(0, (k-c)*2)+max(0, c-1) n = len(pos) preSum = list(accumulate(pos, initial = 0)) ret = inf rest = k-maxChanges for right in range(rest, n+1): left = right-rest i=left+right\u0026gt;\u0026gt;1 s1 = pos[i]*(i-left) - (preSum[i]-preSum[left]) s2 = preSum[right]-preSum[i]-pos[i]*(right-i) ret = min(ret, s1+s2) return ret+maxChanges*2 ","permalink":"https://kennems.github.io/posts/tech/vp-%E5%91%A8%E8%B5%9B389/","summary":"VP 周赛 第 389 场周赛 第三题3085. 成为 K 特殊字符串需要删除的最少字符数 双指针优化$O(n)$ 第三题做出来了但做法不优并且错的次数太多了。 题目大","title":"LeetCode周赛VP389"},{"content":"周赛240331 第四题 100240 最小化曼哈顿距离\n题目大意：给定一个二维平面上的点集，求移除其中一个点后，剩余点集中任意两点之间的最大曼哈顿距离的最小值。\n实现思路：首先，对于曼哈顿距离而言，它的定义是两点在各个坐标轴上的差的绝对值之和。所以移除一个点后，影响到最大曼哈顿距离的主要是距离移除点最近的点。我们可以将点的坐标进行转换，将其转换为(x+y)和(x-y)的形式，这样在平面上的曼哈顿距离就可以等效为在转换后的坐标系下的欧几里得距离。然后我们用两个有序集合分别维护x+y和x-y的坐标轴上的值，分别为xset和yset。然后遍历每个点，从点集中移除一个点，更新最大距离，找到最小值。\nfrom sortedcontainers import SortedList class Solution: def minimumDistance(self, points: List[List[int]]) -\u0026gt; int: xset, yset = SortedList(), SortedList() for x, y in points: xset.add(x+y) yset.add(x-y) ans = inf for x, y in points: xx = x+y yy = x-y xset.remove(xx) yset.remove(yy) ans = min( ans, max(xset[-1]-xset[0], yset[-1]-yset[0]) ) xset.add(xx) yset.add(yy) return ans ","permalink":"https://kennems.github.io/posts/tech/%E5%91%A8%E8%B5%9B240331/","summary":"周赛240331 第四题 100240 最小化曼哈顿距离 题目大意：给定一个二维平面上的点集，求移除其中一个点后，剩余点集中任意两点之间的最大曼哈顿距离的最小","title":"LeetCode周赛240331"},{"content":"周赛 24/3/24 第三题 100258 3092. 最高频率的 ID 题目大意：给定两个长度为n的整数数组nums和freq，nums中的每个元素表示一个ID，对应的freq中的元素表示这个ID在集合中此次操作后需要增加或者减少的数目。现要求在每一步操作后，返回出现频率最高的ID数目，若集合为空则为0。 SortedList实现\nfrom sortedcontainers import SortedList class Solution: def mostFrequentIDs(self, nums: List[int], freq: List[int]) -\u0026gt; List[int]: sl = SortedList(key = lambda x : -x) d = defaultdict(int) ret = [] for x,y in zip(nums, freq): if d[x]!=0: sl.remove(d[x]) d[x]+=y sl.add(d[x]) else: d[x]=y sl.add(d[x]) if sl: ret.append(sl[0]) else: ret.append(0) return ret heap 实现\n实现思路： 使用一个字典d来动态记录ID的出现频率，初始化一个空堆heap和结果列表ret。\n遍历nums和freq数组，对于每对nums[i]和freq[i]，更新字典d中对应ID的频率。\n将(-d[x], x)元组加入堆heap，其中-d[x]表示ID x的出现频率的相反数，x表示ID本身。堆按照频率从高到低排序。\n进入循环，检查堆顶元素是否满足当前频率，若不满足则弹出直至满足。\n将当前堆顶元素的频率加入结果列表ret。\n返回结果列表ret。\nclass Solution: def mostFrequentIDs(self, nums: List[int], freq: List[int]) -\u0026gt; List[int]: d = defaultdict(int) heap = [] ret = [] for x,y in zip(nums, freq): d[x]+=y heapq.heappush(heap, (-d[x], x)) while True: tx, ty = heap[0] if -tx != d[ty]: heapq.heappop(heap) continue ret.append(-tx) break return ret 第四题 1002683093. 最长公共后缀查询 Trie树\n题目大意： 给定两个字符串数组wordsContainer和wordsQuery，对于每个wordsQuery[i]，需要从wordsContainer中找到一个与wordsQuery[i]有最长公共后缀的字符串。若有多个满足条件的字符串，选择长度最短的一个，若长度相同则选择在wordsContainer中出现较早的一个。返回一个整数数组ans，其中ans[i]表示wordsContainer中与wordsQuery[i]有最长公共后缀的字符串的下标。\n实现思路：\n初始化一个变量mi记录wordsContainer中最短字符串的长度，并记录其下标为idx。 构建字典trie，用于存储wordsContainer中每个字符串的逆序形式，并记录最短字符串的下标和长度。 遍历wordsQuery，对于每个查询字符串，将其逆序，然后在trie中搜索与之匹配的最长公共后缀，并返回其对应的下标。 将所有查询结果存入结果列表ret，并返回。 class Solution: def stringIndices(self, c: List[str], q: List[str]) -\u0026gt; List[int]: mi = inf idx = -1 ret = [] for i, w in enumerate(c): if len(w)\u0026lt;mi: mi = len(w) idx = i trie = {} #dict for i, w in enumerate(c): w=w[::-1] cur=trie for wi in w: if wi not in cur: cur[wi] = {} cur = cur[wi] if \u0026#39;#\u0026#39; not in cur: cur[\u0026#39;#\u0026#39;] = (i, len(w)) elif len(w)\u0026lt;cur[\u0026#39;#\u0026#39;][1]: cur[\u0026#39;#\u0026#39;] = (i,len(w)) for i, w in enumerate(q): w=w[::-1] cur = trie ans = idx for wi in w: if wi not in cur: break else: cur = cur[wi] ans = cur[\u0026#39;#\u0026#39;][0] ret.append(ans) return ret ","permalink":"https://kennems.github.io/posts/tech/%E5%91%A8%E8%B5%9B240324/","summary":"周赛 24/3/24 第三题 100258 3092. 最高频率的 ID 题目大意：给定两个长度为n的整数数组nums和freq，nums中的每个元素表示一个ID，对应的freq中的元素","title":"LeetCode周赛240324"},{"content":" 欢迎来到我的博客😆！\n{ \u0026#34;name\u0026#34;: \u0026#34;Kennem(周冠）😶‍🌫️\u0026#34;, \u0026#34;Birthday\u0026#34;: \u0026#34;2003-01-15\u0026#34;, \u0026#34;University\u0026#34;: \u0026#34;UPC\u0026#34;, \u0026#34;Address\u0026#34;: \u0026#34;QingDao\u0026#34;, \u0026#34;selfIntroduction\u0026#34;: \u0026#34;这里记录了我的学习笔记，曾经遇到的问题，以及在学习过程中遇到的好用的工具。👍\u0026#34; } ","permalink":"https://kennems.github.io/about/","summary":"欢迎来到我的博客😆！ { \u0026#34;name\u0026#34;: \u0026#34;Kennem(周冠）😶‍🌫️\u0026#34;, \u0026#34;Birthday\u0026#34;: \u0026#34;2003-01-15\u0026#34;, \u0026#34;University\u0026#34;: \u0026#34;UPC\u0026#34;, \u0026#34;Address\u0026#34;: \u0026#34;QingDao\u0026#34;, \u0026#34;selfIntroduction\u0026#34;: \u0026#34;这里记录了我的学习笔记，曾经遇到的问题，以","title":"🙋🏻‍♂️关于"},{"content":"机器学习简介 Different types of Functions\nRegression : The function outputs a scalar(标量）.\npredict the PM2.5 Classification ： Given options (classes), the function outputs the correct one.\nSpam filtering Structured Learning ： create something with structure(image, document)\nExample : YouTube Channel\n1.Function with Unknown Parameters. $$ y=b+wx_1 $$\n2.Define Loss from Training Data Loss is a function of parameters $$ L(b,w) $$\nLoss : how good a set of values is. L is mean absolute error (MAE) $$ e=\\left | y-\\hat{y} \\right | $$\nL is mean square error (MSE) $$ e=(y-\\hat{y})^2 $$\n$$ L=\\frac{1}{N} \\sum_{n}^{}e_n $$\n3.Optimization $$ w^,b^=arg,\\min_{w,b} ,L $$\nGradient Descent\n(Randomly) Pick an initial value ： $$ w^0 $$\nCompute : $$ \\frac {\\partial L} {\\partial w} |_{w=w_0} $$\nNegative : Increase w\nPositive : Decrease w\n$$ \\eta\\frac {\\partial L} {\\partial w} |_{w=w_0} $$\nη：learning rate (hyperparameters)\nUpdate w iteratively Local minima global minima 类似一个参数，推广到多个参数。\nLinear Models Linear models have severe limitation. Model Bias.\nWe need a more flexible model!\ncurve = constant + sum of a set of Hard Sigmoid Function\n$$ y=c\\frac {1} {1+exp(-(b+wx_1))} \\ =csigmoid(b+wx_1) $$\n$$ y=b+\\sum_{i}sigmoid(b_i+w_ix_i) $$\n$$ y=b+\\sum_{i}sigmoid(b_i+\\sum_{j}w_{ij}x_j) $$\n线性代数角度：\n$$ r=b+Wx $$\n$$ a=\\sigma(r) $$\n$$ y=b+c^Ta $$\nLoss\nLoss is a function of parameters L(θ) Loss means how good a set of values is. Optimization of New Model $$ \\theta= \\begin{bmatrix}\n\\theta_1 \\ \\theta_2 \\ \\theta_3 \\ \\dots \\end{bmatrix} $$\n$$ \\theta=arg \\min_\\theta L $$\n(Randomly) Pick initial values θ^0 1 epoch = see all the batched once\nupdate : update θ for each batch\nSigmoid -\u0026gt; ReLU (Rectified Linear Unit) 统称为 Activation function\nNeural Network\n","permalink":"https://kennems.github.io/posts/tech/1.%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E7%AE%80%E4%BB%8B/","summary":"机器学习简介 Different types of Functions Regression : The function outputs a scalar(标量）. predict the PM2.5 Classification ： Given options (classes), the function outputs the correct one. Spam filtering Structured Learning ： create something with structure(image, document) Example : YouTube Channel 1.Function with Unknown Parameters. $$ y=b+wx_1 $$ 2.Define Loss from Training Data Loss is a","title":"1. 机器学习简介"},{"content":"PyTorch PyTorch Tutorial\nPython3中机器学习框架\ndataset = MyDataset(file) dataloader = DataLoader(dataset, batch_size = size , shuffle = True) Training : True Testing : False from torch.utils.data import Dataset, DateLoader class MyDataset(Dataset): def __init__(self, file): # read data \u0026amp; preprocess self.data = ... def __getitem__(self,index): #return one sample at a time return self.data[index] def __len__(self): #return the size of the dataset return len(self.data) dataset = MyDataset(file) dataloader = Dataloader(dataset, batch_size, shuffle = True) shuffle : Training -\u0026gt; true Testing -\u0026gt; false Tersors High-dimensional matrices(arrays)\n.shape() # show the dimension #Directly from data (list or numpy.ndarray) x = torch.tensor([1, -1], [-1, 1]) x = torch.from_numpy(np.array([[1, -1], [-1, 1]])) #Tensor of constant zeros \u0026amp; ones x = torch.zeros([2, 2]) x = torch.ones([1, 2, 5]) x+y x-y y=x.pow(2) y=x.sum() y=x.mean() #Transpose : transpose two specified dimensions x = x.transpose(dim0,dim1) # change the dimension dim0 and dim1 #Squeeze : remove the specified dimension with length 1 x = x.squeeze(1) #unsqueeze expand a new dimension x = x.unsqueeze(1) dim in PyTorch == axis in NumPy\ndimensional\nCheck with.shape()\tCreating Tensors Directly from data (list or numpy.ndarray)\nx = torch.tensor([1, -1], [-1, 1]) x = torch.from_numpy(np.array([[1, -1], [-1, 1]])) Tensor of constant zeros \u0026amp; ones\nx = torch.zeros([2,2]) x = torch.ones([1, 2, 5]) Common Operations addition subtraction power summation mean\ntranspose x.shape x.transpose(0,1) Unsqueeze : expand a new dimension\nx = x.unsqueeze(1) **Cat **: conncatenate multiple tensors 合并多个矩阵\ntorch.cat([x, y, z], dim = 1) Data Type: Using different data types for model and data will case errors.\n32-bit -torch.float\n64-bit -torch.long\nDevice\nTensors \u0026amp; modules will be computed with CPU by default Use .to() to move tensors to appropriate devices CPU x = x.to('cpu')\t- ```py x = x.to('cuda') GPU check if your computer has NVIDIA GPU torch.cuda.is_available() - Multiple GPUs : specify- ``` 'cuda:0', 'cuda:1', 'cuda:2',... Cradient Calculation import torch # 定义一个需要求导的张量 x，并将 requires_grad 参数设置为 True x = torch.tensor([[1., 0.], [-1., 1.]], requires_grad=True) # 计算 x 的平方并对其进行求和，得到张量 z z = x.pow(2).sum() # 对张量 z 进行反向传播，自动计算出 x 的梯度 z.backward() # 输出 x 的梯度 print(x.grad) torch.nn Network Layers Linear Layer (Fully-connected Layer) nn.linear(in_features, out_features) #### Non-linear Activation Functions```pynn.Sigmoid()nn.ReLU() Build your own neural network import torch.nn as nn class MyModel(nn.Module): #initialize your model \u0026amp; define layers def __init__(self): super(MyModel, self).__init__() self.net = nn.Sequential( nn.Linear(10, 32), nn.Sigmoid(), nn.Linear(32,1) ) #compute output of your nn def forward(self, x): return self.next() Loss Functions Mean squared Error (for regression tasks) criterion = nn.MSELoss() Cross Entropy (for classification tasks) 交叉熵 criterion = nn.CrossEntropyLoss() loss = criterion(model_output, expected_value) ### torch.optim- Stochastic Gradient Descent (SGD) - ```py torch.optim.SGD(model.parameters(), lr, momentum = 0) For every batch of data Call optimizer.zero_grad() to reset gradients of model parameters. Call loss.backward() to backpropagate gradients of prediction loss Call optimizer.step() to adjust model parameters Neural Network Training Setup dataset = MyDataSet(file) tr_set = DataLoader(dataset, 16, shuffle = True) model = MyModel().to(device) criterion = nn.MSELoss() optimizer = torch.optim.SGD(model.parameters(), 0.1) Training Loop for epoch in range(n_epochs): # Iterate over n_epochs model.train() # Set the model to training mode for x, y in tr_set: # Iterate over the training set optimizer.zero_grad() # Clear the gradients x, y = x.to(device), y.to(device) # Move data to the device (e.g., GPU) pred = model(x) # Forward pass, compute predictions loss = criterion(pred, y) # Compute the loss loss.backward() # Backward pass, compute gradients optimizer.step() # Update the model\u0026#39;s parameters using the gradients Validation Loop model.eval() # Set the model to evaluation mode total_loss = 0 for x, y in dv_set: # Iterate over the validation set x, y = x.to(device), y.to(device) # Move data to the device with torch.no_grad(): # Disable gradient computation pred = model(x) # Forward pass, compute predictions loss = criterion(pred, y) # Compute the loss total_loss += loss.cpu().item() * len(x) # Accumulate the loss avg_loss = total_loss / len(dv_set) # Calculate the average loss per sample Testing Loop model.eval() # Set the model to evaluation mode preds = [] for x in tt_set: # Iterate over the test set x = x.to(device) # Move data to the device with torch.no_grad(): # Disable gradient computation pred = model(x) # Forward pass, compute predictions preds.append(pred.cpu()) # Append the predictions to the list Data, demo1 Load data : use pandas to load a csv file\ntrain_data = pd.read_cav(\u0026#39;./name.csv\u0026#39;).drop(columns=[\u0026#39;date\u0026#39;]).values x_train, y_train = train_data[:,:-1], train_data[:,:-1] Dataset init : Read data and preproces\ngetitem : Return one sample at a time, In this case, one sample includes a 117 dimensional feature and a label\nlen : Return the size of the dataset. In this case, it is 2699\nclass COVID19Dataset(Dataset): \u0026#39;\u0026#39;\u0026#39; x: np.ndarray 特征矩阵. y: np.ndarray 目标标签, 如果为None,则是预测的数据集 \u0026#39;\u0026#39;\u0026#39; def __init__(self, x, y=None): if y is None: self.y = y else: self.y = torch.FloatTensor(y) self.x = torch.FloatTensor(x) def __getitem__(self, idx): if self.y is None: return self.x[idx] return self.x[idx], self.y[idx] def __len__(self): return len(self.x) Dataloader train_loader = DataLoader(train_dataset, batch_size = 32, shuffle = True, pin_memory = True) Model class My_Model(nn.Module): def __init__(self, input_dim): super(My_Model, self).__init__() # TODO: 修改模型结构, 注意矩阵的维度（dimensions） self.layers = nn.Sequential( nn.Linear(input_dim, 16), nn.ReLU(), nn.Linear(16, 8), nn.ReLU(), nn.Linear(8, 1) ) def forward(self, x): x = self.layers(x) x = x.squeeze(1) # (B, 1) -\u0026gt; (B) return x Criterion criterion = torch.nn.MSELoss(reduction = \u0026#39;mean\u0026#39;) Optimizer optimizer = torch.optim.SGD(model.parameters(), lr = 1e-5, momentum = 0.9) Training Loop Documentation and Common Errors read pytorch tutorial\nColab（highly recommended） ","permalink":"https://kennems.github.io/posts/tech/2.pytorch/","summary":"PyTorch PyTorch Tutorial Python3中机器学习框架 dataset = MyDataset(file) dataloader = DataLoader(dataset, batch_size = size , shuffle = True) Training : True Testing : False from torch.utils.data import Dataset, DateLoader class MyDataset(Dataset): def __init__(self, file): # read data \u0026amp; preprocess self.data = ... def __getitem__(self,index): #return one sample at a time return self.data[index] def __len__(self): #return the size of","title":"2. PyTorch"},{"content":"Officially begin Deep = Many hidden layers\nNeurall Network Find a function in function set.\nGoodness of function Pick the best function\nBackpropagation - Backward Pass(反向传播) 反向的neural network\nRegression Stock Market Forecast Self-driving Car Recommendation Step 1 : Model A set of function\nStep 2 : Goodness of Function $$ \\hat{y}^1代表x^1对应的确切值 $$\nLoss function L： $$ L(f)=L(w,b) ~ Estimated ~ y ~ basedoninputfunction $$\n$$ L(w,b)=\\sum_{n=1}^{10}(\\hat{y}^n-(b+w\\cdot x_{cp}^n))^2 $$\nStep 3 ：Best Function In linear regression, the loss function L is convex.\nOverfitting\nRegularization $$ L(w,b)=\\sum_{n=1}^{10}(\\hat{y}^n-(b+w\\cdot x_{cp}^n))^2+\\lambda\\cdot \\sum(w_i)^2 $$\n不需要考虑bias，调整平滑程度，smooth\nGradient descent Overfitting and Regularization Classification independently and identically distributed(i.i.d) $$ L(h^{train},D_{all})-L(h^{all}, d_{all}) \\leq \\delta\\ we\\ need \\ \\forall h \\in \\H, |L(h,D_{train}) -L(h,D_{all}) | \\leq \\delta/2\\ L(h^{train},D_{all})\\leq L(h^{train},D_{all}) + \\delta/2 $$ 重温数码宝贝：\n模型出现bad的概率： $$ P(D_{train}\\ is\\ bad)\\leq |H| \\cdot 2exp(-2N\\epsilon^2 ) \\ N \\ge \\frac{log(2|H|/\\delta)}{2\\epsilon^2} $$ Tradeoff of Model Complexity\nTraining data for Classification pair\nIdeal Alternatives Function(Model): $$ f(x)\\ x -\u0026gt; g(x)\u0026gt;0~Output=class1\\ else\\ Output=class2 $$\nlossfunction: The number of times of get incotrrect results on training data. $$ L(f) = \\sum_{n}\\delta(f(x^n)\\neq\\hat{y}^n) $$\nFind the best function; Example : Perceptron, SVM Prior $$ P(C_1|x)=\\frac{P(x|C_1)P(C_1)}{P(x|C_1)P(C_1)+P(x|C_2)P(C_2)} $$\nGaussian Maximum Likelihood\n2D array or 3D array mean the array with 2 or 3 axes respectively, but the n-dimensional vector mean the vector of length n.\nLearn something that can really differ you from others.\nLogistics Regression Function Set $$ f_{w,b}=\\sigma(\\sum_{i}w_ix_i)+b $$\nOutput : Between 0 and 1 $$ f_{w,b}(x)=P_{w,b}(C_1|x) $$\n$$ w^,b^=arg\\ \\underset{w,b}{max}L(w,b)\\ 等同于 w^,b^ = arg\\ \\underset{w,b}{min}-lnL(w,b) $$\nCross Entropy: $$ Distribution \\ p: p(x=1)=\\hat{y}^n\\ p(x=0)=1-\\hat{y}^n\\ Distribution \\ q: q(x=1)=f(x^n)\\ q(x=0)=1-f(x^n)\\ H(p,q)=-\\sum_xp(x)ln(q(x)) $$\nLoss Function $$ L(f)=\\sum_nC(f(x^n),\\hat{y}^n)\\ C(f(x^n),\\hat{y}^n)=-[\\hat{y}^nlnf(x^n)+(1-\\hat{y}^n)ln(1-f(x^n))] $$\nUpdate logistic regression 和 linear regression 形式完全相同 $$ w_i\\gets w_i-\\eta \\sum_{n}-(\\hat{y}^n-f_{w,b}(x^n))x_i^n $$\nDiscriminative (logistic) \u0026amp; Generative (Gaussian描述) Generative做了某些假设。\nBenefit of generative model With the assumption of probability distribution, less training data is needed With the assumption of probability distribution, more robust to the noise Priors and class-dependent probabilities can be estimated from different sources. Multi-class Classification SoftMax $$ Softmax(z_i)=\\frac{e^{z_i}}{\\sum_{c=1}^{C} e^{z_c}}\\ 1 \u0026gt; y_i\u0026rsquo; \u0026gt; 0\\ \\sum_iy_i\u0026rsquo;=1 $$\nLimitation of Logistic Regression 只能画一条直线\nFeature Transformation Cascading logistic regression models Optimization Issue 层数较多表现的反而没有层数较少的好\nOver fitting 增加训练资料\nData augmentation\nconstrained model\nLess parameters, sharing parameters Less features Early stopping CNN-\u0026gt;比较没有弹性的model\n分Training Set\nN-fold Cross Validation Optimization Fail H : Hessian\nTayler Series Approximation $$ L(\\theta) \\approx L(\\theta^\\prime)+\\frac{1}{2}(\\theta-\\theta^\\prime)^TH(\\theta-\\theta^\\prime) $$\nH is positive definte = All eigen values are positive -\u0026gt; local minima H is negative definte = All eigen values are negative -\u0026gt; **local ** Some eigen values are positive , and some are negative -\u0026gt; Saddle point 在高维下local minima可能会变成saddle poing\nTips for training : Batch and Momentum Batch 1 epoch = see all the batches once -\u0026gt; shuffle after each epoch\nMomentum Movement not just based on gradient, but previous movement.\nDifferent parameters needs different learning rate $$ \\theta_i^{t+1} \\gets \\theta_i^t-\\frac{\\eta}{\\sigma_i^t}g_i^t\\ \\sigma_i^t=\\sqrt{\\frac{1}{t+1}\\sum_{i=0}^t(g_i^t)^2} $$\nAdagred\nRMSProp $$ \\theta_i^{t+1} \\gets \\theta_i^t-\\frac{\\eta}{\\sigma_i^t}g_i^t\\ \\sigma_i^t = \\sqrt{\\alpha(\\sigma_i^{t-1})^2+(1-\\alpha)(g_i^t)^2} $$\nAdam : RMSProp + Momentum\nLearning Rate Sceduling $$ \\theta_i^{t+1} \\gets \\theta_i^t-\\frac{\\eta^t}{\\sigma_i^t}g_i^t\\ $$\nWarm Up New Optimization ","permalink":"https://kennems.github.io/posts/tech/3.regression-and-classification/","summary":"Officially begin Deep = Many hidden layers Neurall Network Find a function in function set. Goodness of function Pick the best function Backpropagation - Backward Pass(反向传播) 反向的neural network Regression Stock Market Forecast Self-driving Car Recommendation Step 1 : Model A set of function Step 2 : Goodness of Function $$ \\ha","title":"3. Regression and Classification"},{"content":"Convolutional network (CNN) Network的架构调整\n1、All the images to be classified have the same size.\nReceptive filed\nSimplification 1 - Typical Setting all channels : 会看所有的channels\nkernel size : 长和宽 （e.g., 3*3)\nStride : 移动的步长,希望有高度的重叠\npadding : 补值，补充超出范围的值\nEach receptive field has a set of neurons.\nEach receptive field has the neurons with the same set of parameters, which called filter.\nPooling Flatten ","permalink":"https://kennems.github.io/posts/tech/4.cnn/","summary":"Convolutional network (CNN) Network的架构调整 1、All the images to be classified have the same size. Receptive filed Simplification 1 - Typical Setting all channels : 会看所有的channels kernel size : 长和宽 （e.g., 3*3) Stride : 移动的","title":"4. CNN"},{"content":"Spatial Transformer（STN） 处理旋转和放大图形的CNN分类\ninterpolation 插值法 Self-attention Sequence Labeling consider the context -\u0026gt; 参数很大并且容易Over fitting\nSelf-attention会持有整个sequence的信息\ninput : vector\noutput : vector $$ q_i=W^qa^i\\ k_i=W^ka^i\\ v^i=W^va^i $$ Multi-head Self-attention 其中 $$ q_i, k_i, v_i均可以有多个 $$\nSelf-attention for Speech Truncated(截短的) Self-attention\nSelf-attention is the complex version of CNN\nCNN is simplified self-attention\nRecurrent Neural Network(RNN) RNN所做的事情都可以用Self-attention来替代\nSelf-attention更有效率\nRNN\nTransformer Sequence to sequence (Seq2seq) Encoder -\u0026gt; Decoder\nEncoder input some vectors and output some vectors\nDecoder Autoregressive Non-autoregressive Decoder 同时输出BEGIN并且同时输出结果和END\nAdvantage ： parallel, controllable output length\nNAT is usually worse than AT\nEncoder-Decoder Cross Attention\nTeacher Forcing : using the ground truth as input\nCopy Mechanism\nPointer Network Copying Mechanism Guided Attention Beam Search Scheduled Sampling\n","permalink":"https://kennems.github.io/posts/tech/5.transformer/","summary":"Spatial Transformer（STN） 处理旋转和放大图形的CNN分类 interpolation 插值法 Self-attention Sequence Labeling consider the context -\u0026gt; 参数很大并且容易Over fitting Self-attention","title":"5. Transformer"},{"content":" 名称： Sulv\u0026rsquo;s Blog 网址： https://www.sulvblog.cn 图标： https://www.sulvblog.cn/img/Q.gif 描述： 一个记录技术、阅读、生活的博客 ","permalink":"https://kennems.github.io/links/","summary":"名称： Sulv\u0026rsquo;s Blog 网址： https://www.sulvblog.cn 图标： https://www.sulvblog.cn/img/Q.gif 描述： 一个记录技术、阅读、生活的博客","title":"🤝友链"}]