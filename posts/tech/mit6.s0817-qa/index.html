<!DOCTYPE html>
<html lang="zh" dir="auto">

<head><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="index, follow">

<meta name="msvalidate.01" content="DF5FE493CC759E62BFE073BEA8EFD472" />
<title>MIT6.S081(7)-Q&amp;A | Kennem&#39;s Blog</title>
<meta name="keywords" content="MIT6.S081">
<meta name="description" content="MIT6.S081(7)">
<meta name="author" content="ShowGuan">
<link rel="canonical" href="https://kennems.github.io/posts/tech/mit6.s0817-qa/">
<link crossorigin="anonymous" href="/assets/css/stylesheet.915c20762c304dbee6179b74c308e69b9b1fbc661fecb4d1d1007529d55ca598.css" integrity="sha256-kVwgdiwwTb7mF5t0wwjmm5sfvGYf7LTR0QB1KdVcpZg=" rel="preload stylesheet" as="style">
<link rel="icon" href="https://kennems.github.io/img/sun.png">
<link rel="icon" type="image/png" sizes="16x16" href="https://kennems.github.io/img/sun.png">
<link rel="icon" type="image/png" sizes="32x32" href="https://kennems.github.io/img/sun.png">
<link rel="apple-touch-icon" href="https://kennems.github.io/img/sun.png">
<link rel="mask-icon" href="https://kennems.github.io/img/sun.png">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<link rel="alternate" hreflang="zh" href="https://kennems.github.io/posts/tech/mit6.s0817-qa/">
<noscript>
    <style>
        #theme-toggle,
        .top-link {
            display: none;
        }

    </style>
    <style>
        @media (prefers-color-scheme: dark) {
            :root {
                --theme: rgb(29, 30, 32);
                --entry: rgb(46, 46, 51);
                --primary: rgb(218, 218, 219);
                --secondary: rgb(155, 156, 157);
                --tertiary: rgb(65, 66, 68);
                --content: rgb(196, 196, 197);
                --code-block-bg: rgb(46, 46, 51);
                --code-bg: rgb(55, 56, 62);
                --border: rgb(51, 51, 51);
            }

            .list {
                background: var(--theme);
            }

            .list:not(.dark)::-webkit-scrollbar-track {
                background: 0 0;
            }

            .list:not(.dark)::-webkit-scrollbar-thumb {
                border-color: var(--theme);
            }
        }

    </style>
</noscript>

<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.2/dist/katex.min.css" integrity="sha384-MlJdn/WNKDGXveldHDdyRP1R4CTHr3FeuDNfhsLPYrq2t0UBkUdK2jyTnXPEK1NQ" crossorigin="anonymous">

<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.2/dist/katex.min.js" integrity="sha384-VQ8d8WVFw0yHhCk5E8I86oOhv48xLpnDZx5T9GogA/Y84DcCKWXDmSDfn13bzFZY" crossorigin="anonymous"></script>

<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.2/dist/contrib/auto-render.min.js" integrity="sha384-+XBljXPPiv+OzfbB3cVmLHf4hdUFHlWNZN5spNQ7rmHTXpd7WvJum6fIACpNNfIR" crossorigin="anonymous"
    onload="renderMathInElement(document.body);"></script>


<script>
document.addEventListener("DOMContentLoaded", function() {
    renderMathInElement(document.body, {
        delimiters: [
            {left: "$$", right: "$$", display: true},
            {left: "$", right: "$", display: false}
        ]
    });
});
</script>


<link rel="stylesheet" href="https://fonts.cdnfonts.com/css/code-new-roman">
<link rel="preconnect" href="https://fonts.googleapis.com">
<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  

<meta property="og:url" content="https://kennems.github.io/posts/tech/mit6.s0817-qa/">
  <meta property="og:site_name" content="Kennem&#39;s Blog">
  <meta property="og:title" content="MIT6.S081(7)-Q&A">
  <meta property="og:description" content="MIT6.S081(7)">
  <meta property="og:locale" content="zh">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2024-09-12T19:30:13+08:00">
    <meta property="article:modified_time" content="2024-09-12T19:20:13+08:00">
    <meta property="article:tag" content="MIT6.S081">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="MIT6.S081(7)-Q&amp;A">
<meta name="twitter:description" content="MIT6.S081(7)">


<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BreadcrumbList",
  "itemListElement": [
    {
      "@type": "ListItem",
      "position":  1 ,
      "name": "üìöÊñáÁ´†",
      "item": "https://kennems.github.io/posts/"
    }, 
    {
      "@type": "ListItem",
      "position":  2 ,
      "name": "üíªÊäÄÊúØ",
      "item": "https://kennems.github.io/posts/tech/"
    }, 
    {
      "@type": "ListItem",
      "position":  3 ,
      "name": "MIT6.S081(7)-Q\u0026A",
      "item": "https://kennems.github.io/posts/tech/mit6.s0817-qa/"
    }
  ]
}
</script>
<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "MIT6.S081(7)-Q\u0026A",
  "name": "MIT6.S081(7)-Q\u0026A",
  "description": "MIT6.S081(7)",
  "keywords": [
    "MIT6.S081"
  ],
  "articleBody": "MIT6.S081(7)-Q\u0026A Plan: answering your questions Approach: walk through staff solutions start with pgtbl lab because it was the hardest your questions are at bottom of this file\nPgtbl lab comments few lines of code, but difficult-to-debug bugs\nworst case: qemu/xv6 stops running ‚Äúbest‚Äù case: kernel panic hard to debug for staff too there are so many possible reasons why you discovered once we hadn‚Äôt seen yet likely to be the most challenging lab historically the first VM lab is hard this year too, even though we made a new lab to provide a gentler intro to VM Part 1 of pgtbl lab Explain vm output in terms of fig 3-4\npage table 0x0000000087f67000 ..0: pte 0x0000000021fd8c01 pa 0x0000000087f63000 fl 0x0000000000000001 .. ..0: pte 0x0000000021fd8801 pa 0x0000000087f62000 fl 0x0000000000000001 .. .. ..0: pte 0x0000000021fd901f pa 0x0000000087f64000 fl 0x000000000000001f .. .. ..1: pte 0x0000000021fd840f pa 0x0000000087f61000 fl 0x000000000000000f .. .. ..2: pte 0x0000000021fd801f pa 0x0000000087f60000 fl 0x000000000000001f ..255: pte 0x0000000021fd9801 pa 0x0000000087f66000 fl 0x0000000000000001 .. ..511: pte 0x0000000021fd9401 pa 0x0000000087f65000 fl 0x0000000000000001 .. .. ..510: pte 0x0000000021fdd807 pa 0x0000000087f76000 fl 0x0000000000000007 .. .. ..511: pte 0x0000000020001c0b pa 0x0000000080007000 fl 0x000000000000000b\nwhat is entry 0, 1, and 2?\rwhat is 510 and 511?\r- 511: trampoline\r- 510: trapframe\rwhy are the protection bits as they are?\r- 510: RWV\r- 511: XV\r- 1: no U\rare the physical addresses contiguous?\rPart 2 of pgtbl lab Add a kernel page table to each process in prep for Part 3\nexact copy of the kernel_pagetable How hard can this be? hard! some reasons:\nxv6 code specialized to one kernel page table no kvmcreate_page_table() kvminit() isn‚Äôt the full story also mappings in procinit(), and virtio_disk.c cleanup must be done care don‚Äôt free kernel stacks easy to make a small error even small errors are time consuming Two possible approaches to part II\ngeneralize kvminit() create a new per-process kernel page table\rshare kernel_pagetable make the per-process kernel page table share much with kernel_pagetable\r- my solutions takes approach 2; other staff members too approach 1\r- i took approach 2 mostly out of \"laziness\"\rdon't have to think too hard what is in the kernel_pagetable\rdidn't want to write much code\r- not sure it is shorter, though\rapproach 2 has some benefits I didn't realize\r- avoided certain class of bugs (e.g., kernel stacks)\rImplementation approach: small incremental baby steps keep existing code working allows comparing old and new easily allows rolling back easily\nApproach 2\nkvmcreate() copy entries 1..512 add a few devices that live in 0 anything below 1G (i.e., all devices) kvmfree() only entry 0 is worth considering just need to free intermediate pages (see 3-level pic) a bit ugly where to call kvmfree() exit()? freeproc()? scheduler() usertrapret() Part 3 of pgtbl lab map user pgtbl of process into bottom of process‚Äôs kernel page table\ndraw figure why? convenient for kernel programmers can replace copyin with copy_new() copyin_new is just a memmove(), avoid the walkaddr()‚Äôs hardware can do the walks for us mapping user page tables into kernel page table\nkvmmapuser() copies upte into kpte, adjust permissions Using kvmmapuser():\nuserinit() exec() no need to replace kernel page table fork() sbrk() memmove()\nwhy the checks before the memmove()? what does each case cover Syscall lab systems calls look like functions calls BUT they are not function calls\nU/K boundary transition user/usys.pl generates stubs for stubs kernel/syscall.c demultiplexes system calls trace proc.h fork() sysinfo copyout() Util lab primes\nclose fd‚Äôs to terminate correctly xargs setting up argv === Questions ===\nHW\n===\nIn the page table lab, the kernel‚Äôs hardware address translator won‚Äôt allow kernel to dereference user pages. More specifically, if the page table entry has ‚ÄúPTE_U‚Äù bit set, which means user can access it, then kernel won‚Äôt be able to access it through the hardware address translator unless we set ‚ÄúPTE_U‚Äù to false in the per-process kernel page table. Is there a specific reason for this?\n===\nWhy is the kernel not allowed to read memory mapped with the PTE_U flag? To prevent malicious memory from being read?\n===\nIn the last lecture, it was mentioned that even the kernel in supervisor mode could not directly edit anything and everything in the memory. The kernel accesses memory through the kernel page table, and thus is limited. However, couldn‚Äôt the kernel just set the satp register to 0, and then there is no MMU translation, the CPU directly accesses physical addresses. Could that situation not arise? That certainly the case before page tables are set up and paging is enabled.\n===\nA minor question: why the specific order of the trapframe in proc.h (t0..t2, then s0, s1, a0..a7, s2..s11)?\n===\nPGTBL LAB\nI‚Äôm confused why the kernel can directly dereference the pointer in part 3 of pagetable because we have now mapped the user‚Äôs virtual address into the user‚Äôs kernel pagetable. Since it is still a virtual address, doesn‚Äôt it need to just walk the user‚Äôs kernel page table? Or is it because the user code now enters the kernel, and the kernel‚Äôs pagetable directly maps virtual addresses to physical addressses? However, in my implementation, it seems to be that the kernel still maps the same virtual addresses to the same physical addresses as the user‚Äôs page table, , which is not a direct mapping.\n===\nIn the pgtbl lab, during Part 3 (copyin), I ran into an interesting bug while changing a process‚Äôs user mappings. In fork(), I was calling my helper function to copy the user mappings from the process‚Äôs user page table to its kernel page table. When I tried to copy the parent process‚Äôs user page table, running ‚Äúusertests‚Äù in the xv6 kernel just caused it to return and none of the tests were run. However, copying the child‚Äôs user page table worked. Shouldn‚Äôt either instruction be ok, since the child‚Äôs user page table was just copied over from the parent?\n===\nFor the page tables lab, what was the correct way to copy and change the process‚Äôs kernel page table the same way in fork(), exec(), and sbrk()? I tried to copy over a range of entries from the process‚Äôs page table into the process‚Äôs kernel page table directly, but my code was panicking when trying to use mappages() after my change to the 3 functions.\n===\nIf xv6 was written with the modifications from the pgtbl lab, we would not need to worry about switching the pagetables in the trampline code, right? Would there even be a need for the trampoline code to be mapped in the user pages? My understanding was that that code can be mapped in the per-process kernel pgtbls and be used from there during the trap handling. I was also curious about why when a PTE has the PTE_U bit is set, code in supervisor mode cannot access that page table. It is confusing to me because I thought that the kernel has the whole memory mapped and it can modify any virtual address even if some user data lives there. In the last lab, we could even know the exact va that the user pgtbl has for each of the pa that it uses and I think maybe be able to corrupt user‚Äôs data.\n===\nIs there a more efficient way to free each process‚Äôs kernel pagetable? I basically copied the freewalk function and removed the panic for leaves. Although this seemed fast enough for the tests, it still seemed a little slow. When I tried to optimize it by reducing recursion depth, I ran into troubles. Overall, this seems like a computationally intensive task, especially if all physical memory is mapped in the kernel pagetable for all processes. I was a little worried about breaking something, but could I have stopped mapping all physical memory?\n===\nDo operating systems using hierarchical pagetables ever set up the pagetable pages so that the lower parts of the hierachy are (atleast in part) shared?\n===\nFor the pagetable lab, I was trying to implement copyin/copyinstr. However, I got stuck in an infinite loop with the scheduler because the scheduler seemed to have no process that needs to be run. I am curious as to what could happen to the pagetable so that the OS would stop a process from running (especially the main process). What part of the code does the operating system set the state of a process to not running if the pagetable is broken?\n===\nI don‚Äôt understand why when I moved\nw_satp(MAKE_SATP(kernel_pagetable)); sfence_vma();\noutside of\nif(found == 0) { intr_on(); asm volatile(‚Äúwfi‚Äù); }\nin scheduler that everything in part 2 of the page table lab worked. Because before then, it worked to a certain degree, where sometimes it‚Äôd pass and sometimes it‚Äôd fail.\n===\nIn the pagetable lab, is there a significant impact on performance from copying to per-process kernel page tables so frequently? If so, how does this balance out with the improvements that come from being able to directly de-reference user address in kernel space?\n===\nHow are pipes implemented in xv6, and how would the changes to the page tables implemented in the pgtbl lab effect this implementation? Do the per-process page tables hinder each process‚Äô ability to communicate with each other?\n===\nWhy did uvmfree/freewalk originally panic at a leaf, and why did we need to change that.\nWhy does the inclusion of the user PTE_U bit not allow the kernel to access the PTE?\n===\nThe lab mentioned that ‚Äúthe goal of this section and the next is to allow the kernel to directly dereference user pointers.‚Äù However, I didn‚Äôt understand how this adds functionality to the kernel, or why this is an important function for the kernel to be able to do.\n===\nFor the page table lab, I had some questions on access rights. If the user bit is set, does that mean in user mode both read/write/execute options can be performed, or can only read/write/execute be done in kernel mode?\nAlso, are there pages in the kernel page table accessible in user mode?\n===\nIn the pgtbl lab, we added kernel pagetables to each process in order to simplify reading userspace pointers. Was there any reason we couldn‚Äôt do the same for copying data out to userspace? I think you‚Äôd have to be a little careful in exec(), since copyout is used there while setting up the process, but apart from that?\nAlso, one of the challenge exercises for that lab is to remove the PLIC limit. How would you do that‚Äìset up a new pagetable for PLIC access, and switch to that when trying to access PLIC registers?\n===\nI was talking to some friends who solved the pagetable part 3 by using a modified uvmcopy but they needed to limit the pages they were copying to pass the runtime limit. What‚Äôs taking so long in that function? Does the walking make the copy function less optimized for the job?\n===\nQuestion: About the page table lab, when I was debugging my code, I realized for reparent test, I sometimes pass it but I sometimes fail. I fixed this issue by realizing I need to switch back to kernel_pagetable in the scheduler after exiting the process‚Äôs kernal pagetable. I wonder why such mistakes would cause reparent to behave non-deterministaclly? Was there some sort of race condition?\n===\nIn our ‚Äúcopy user page table to kernel page table‚Äù functions in the pagetable lab, why was it necessary to panic when a pagetable entry didn‚Äôt exist or was not valid for a given virtual address? Why couldn‚Äôt we have just skipped that virtual address? More broadly, how could we assume that all of the user page table values that we were copying over were present and valid?\n===\nIt really messes with my head that you have to define a C function for allocating memory (kalloc). This is one of the first things xv6 does in main.c, directly after which it creates the kernel page table (using a call to kalloc). Given the way kalloc works, is the kernel page table always going to be at the ‚Äúend‚Äù address in the kernel‚Äôs virtual memory space since its the first piece of memory to be allocated? And do you have to be careful about using memory prior to calling kinit in main.c?\n===\nThis question is regarding the pgtbl lab. I had some confusion about the exact motivation for the lab, specifically creating a separate kernel page table for each process. I wasn‚Äôt sure what the lab meant by ‚Äúdirectly dereferencing the user address‚Äù. From my understanding, what the kernel currently does to translate the virtual address of the user process is to ‚Äúwalk‚Äù down the user pagetable.\nSo if you essentially combine the kernel page table and user page tables, wouldn‚Äôt you still ‚Äúwalk‚Äù down the new per-process kernel page table to get the physical address? I don‚Äôt understand how this changes anything since the two approaches differ only in which page table the kernel is walking down.\n===\nFor question 1 in the page table lab, was page 1 the guard page? This made sense to me since it has the user flag off so it would cause errors if the user tried to access it. However I believe the textbook said that the guard page will have its valid bit off in which case it would not show up in vmprint.\n====\nWhy does the initial page table ( as printed in vmprint ) have indices 0 and 255?I deduced that these pages should eventually point towards the initial user program data ( text, guard page and stack ) and the trampoline/trapframe respectively. However, the trampoline should be at the very top of the virtual address space, so it should have the highest possible virtual address. Therefore, shouldn‚Äôt the root page table contain pages 0 and 511 rather than 0 and 255?\n====\nVM IN GENERAL\n====\nHow was copyin with per process kernel pagetables exploited, as mentioned in the pgtbl lab?\n===\nThis is less of a question, but I‚Äôd love to hear more about how Xv6 compares to various other operating systems that we might use in our day-to-day lives.\nI don‚Äôt have specific questions, but for example:\nHow does Linux set up its page tables? The lab mentioned this may have changed with Spectre/Meltdown, but what do they do now?\nDo we know how pages/traps are handled in Windows or macOS, or what tradeoffs were made in the design decisions there? I read somewhere that Windows XP source code leaked - did we learn anything interesting from that, or does Microsoft just use standard techniques?\nDoes x86-64 have instructions that significantly simplify or combine or increase performance of particular parts of the pagetable or traps chain of code in interesting ways?\nHow active is the development of OS techniques like syscalls, pagetables, etc.? Are they mostly considered a ‚Äúsolved‚Äù problem by modern operating systems and only really experimented on in research?\n===\nSYSCALL LAB\n===\nCould you possibly walk through the roles of the different places we had to update when we added a new system call? (e.g. user/user.h, user/usys.pl, kernel/syscall.h, and a few others)\nI‚Äôm mostly wondering (1) in what order these are visited when the code is compiled and (2) why there isn‚Äôt a more centralized way to do this? For example, in kernel/syscall.c, why do we need to manually edit both the extern list and the syscalls array beneath it?\n===\nUTIL LAB\n===\nOne of the challenges for the first lab was to add history/tab completion. However, one thing that gave me some trouble was being able to parse single keystrokes (namely the arrow keys). Is there a way to read a single character (not having to press enter)?\n",
  "wordCount" : "2628",
  "inLanguage": "zh",
  "datePublished": "2024-09-12T19:30:13+08:00",
  "dateModified": "2024-09-12T19:20:13+08:00",
  "author":{
    "@type": "Person",
    "name": "ShowGuan"
  },
  "mainEntityOfPage": {
    "@type": "WebPage",
    "@id": "https://kennems.github.io/posts/tech/mit6.s0817-qa/"
  },
  "publisher": {
    "@type": "Organization",
    "name": "Kennem's Blog",
    "logo": {
      "@type": "ImageObject",
      "url": "https://kennems.github.io/img/sun.png"
    }
  }
}
</script>
<script src="https://cdn.jsdelivr.net/npm/jquery@3.5.1/dist/jquery.min.js"></script>
<link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.css" />
<script src="https://cdn.jsdelivr.net/gh/fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.js"></script>




</head>

<body class="" id="top">
<script>
    if (localStorage.getItem("pref-theme") === "dark") {
        document.body.classList.add('dark');
    } else if (localStorage.getItem("pref-theme") === "light") {
        document.body.classList.remove('dark')
    } else if (window.matchMedia('(prefers-color-scheme: dark)').matches) {
        document.body.classList.add('dark');
    }

</script>

<header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="https://kennems.github.io/" accesskey="h" title="Kennem&#39;s Blog (Alt + H)">
                <img src="https://kennems.github.io/img/sun.png" alt="" aria-label="logo"
                    height="35">Kennem&#39;s Blog</a>
            <div class="logo-switches">
                <button id="theme-toggle" accesskey="t" title="(Alt + T)">
                    <svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
                    </svg>
                    <svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <circle cx="12" cy="12" r="5"></circle>
                        <line x1="12" y1="1" x2="12" y2="3"></line>
                        <line x1="12" y1="21" x2="12" y2="23"></line>
                        <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                        <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                        <line x1="1" y1="12" x2="3" y2="12"></line>
                        <line x1="21" y1="12" x2="23" y2="12"></line>
                        <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                        <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
                    </svg>
                </button>
            </div>
        </div>
        <ul id="menu">
            <li>
                <a href="https://kennems.github.io/" title="üè†‰∏ªÈ°µ">
                    <span>üè†‰∏ªÈ°µ</span>
                </a>
            </li>
            <li>
                <a href="https://kennems.github.io/search" title="üîçÊêúÁ¥¢ (Alt &#43; /)" accesskey=/>
                    <span>üîçÊêúÁ¥¢</span>
                </a>
            </li>
            <li>
                <a href="https://kennems.github.io/posts" title="üìöÊñáÁ´†">
                    <span>üìöÊñáÁ´†</span>
                </a>
            </li>
            <li>
                <a href="https://kennems.github.io/archives" title="‚è±Êó∂Èó¥ËΩ¥">
                    <span>‚è±Êó∂Èó¥ËΩ¥</span>
                </a>
            </li>
            <li>
                <a href="https://kennems.github.io/tags" title="üîñÊ†áÁ≠æ">
                    <span>üîñÊ†áÁ≠æ</span>
                </a>
            </li>
            <li>
                <a href="https://kennems.github.io/categories" title="üóÇÔ∏èÂàÜÁ±ª">
                    <span>üóÇÔ∏èÂàÜÁ±ª</span>
                </a>
            </li>
            <li>
                <a href="https://kennems.github.io/about" title="üôãüèª‚Äç‚ôÇÔ∏èÂÖ≥‰∫é">
                    <span>üôãüèª‚Äç‚ôÇÔ∏èÂÖ≥‰∫é</span>
                </a>
            </li>
        </ul>
    </nav>
</header>
<main class="main">

<article class="post-single">
  <header class="post-header">
    <div class="breadcrumbs"><a href="https://kennems.github.io/">‰∏ªÈ°µ</a>&nbsp;¬ª&nbsp;<a href="https://kennems.github.io/posts/">üìöÊñáÁ´†</a>&nbsp;¬ª&nbsp;<a href="https://kennems.github.io/posts/tech/">üíªÊäÄÊúØ</a></div>
    <h1 class="post-title entry-hint-parent">
      MIT6.S081(7)-Q&amp;A
    </h1>
    <div class="post-description">
      MIT6.S081(7)
    </div>
    <div class="post-meta"><span title='2024-09-12 19:30:13 +0800 CST'>2024-09-12</span>&nbsp;¬∑&nbsp;6 ÂàÜÈíü&nbsp;¬∑&nbsp;2628 Â≠ó&nbsp;¬∑&nbsp;updated:&nbsp;2024-09-12&nbsp;¬∑&nbsp;ShowGuan

</div>
    
     <div class="post-password">
        
    </div>
  </header> <aside id="toc-container" class="toc-container wide">
    <div class="toc">
        <details  open>
            <summary accesskey="c" title="(Alt + C)">
                <span class="details">ÁõÆÂΩï</span>
            </summary>

            <div class="inner"><ul>
                    <li>
                        <a href="#mit6s0817-qa" aria-label="MIT6.S081(7)-Q&amp;A">MIT6.S081(7)-Q&amp;A</a>
                    </li>
                </ul>
            </div>
        </details>
    </div>
</aside>
<script>
    let activeElement;
    let elements;
    window.addEventListener('DOMContentLoaded', function (event) {
        checkTocPosition();

        elements = document.querySelectorAll('h1[id],h2[id],h3[id],h4[id],h5[id],h6[id]');
         
         activeElement = elements[0];
         const id = encodeURI(activeElement.getAttribute('id')).toLowerCase();
         document.querySelector(`.inner ul li a[href="#${id}"]`).classList.add('active');
     }, false);

    window.addEventListener('resize', function(event) {
        checkTocPosition();
    }, false);

    window.addEventListener('scroll', () => {
        
        activeElement = Array.from(elements).find((element) => {
            if ((getOffsetTop(element) - window.pageYOffset) > 0 && 
                (getOffsetTop(element) - window.pageYOffset) < window.innerHeight/2) {
                return element;
            }
        }) || activeElement

        elements.forEach(element => {
             const id = encodeURI(element.getAttribute('id')).toLowerCase();
             if (element === activeElement){
                 document.querySelector(`.inner ul li a[href="#${id}"]`).classList.add('active');
             } else {
                 document.querySelector(`.inner ul li a[href="#${id}"]`).classList.remove('active');
             }
         })
     }, false);

    const main = parseInt(getComputedStyle(document.body).getPropertyValue('--article-width'), 10);
    const toc = parseInt(getComputedStyle(document.body).getPropertyValue('--toc-width'), 10);
    const gap = parseInt(getComputedStyle(document.body).getPropertyValue('--gap'), 10);

    function checkTocPosition() {
        const width = document.body.scrollWidth;

        if (width - main - (toc * 2) - (gap * 4) > 0) {
            document.getElementById("toc-container").classList.add("wide");
        } else {
            document.getElementById("toc-container").classList.remove("wide");
        }
    }

    function getOffsetTop(element) {
        if (!element.getClientRects().length) {
            return 0;
        }
        let rect = element.getBoundingClientRect();
        let win = element.ownerDocument.defaultView;
        return rect.top + win.pageYOffset;   
    }
</script>

  <div class="post-content"><h1 id="mit6s0817-qa">MIT6.S081(7)-Q&amp;A<a hidden class="anchor" aria-hidden="true" href="#mit6s0817-qa">#</a></h1>
<p>Plan: answering your questions
Approach:
walk through staff solutions
start with pgtbl lab because it was the hardest
your questions are at bottom of this file</p>
<p>Pgtbl lab comments
few lines of code, but difficult-to-debug bugs</p>
<ul>
<li>worst case: qemu/xv6 stops running</li>
<li>&ldquo;best&rdquo; case: kernel panic
hard to debug for staff too</li>
<li>there are so many possible reasons why</li>
<li>you discovered once we hadn&rsquo;t seen yet
likely to be the most challenging lab</li>
<li>historically the first VM lab is hard</li>
<li>this year too, even though we made a new lab to provide a gentler intro to VM</li>
</ul>
<p>Part 1 of pgtbl lab
Explain vm output in terms of fig 3-4</p>
<p>page table 0x0000000087f67000
..0: pte 0x0000000021fd8c01 pa 0x0000000087f63000 fl 0x0000000000000001
.. ..0: pte 0x0000000021fd8801 pa 0x0000000087f62000 fl 0x0000000000000001
.. .. ..0: pte 0x0000000021fd901f pa 0x0000000087f64000 fl 0x000000000000001f
.. .. ..1: pte 0x0000000021fd840f pa 0x0000000087f61000 fl 0x000000000000000f
.. .. ..2: pte 0x0000000021fd801f pa 0x0000000087f60000 fl 0x000000000000001f
..255: pte 0x0000000021fd9801 pa 0x0000000087f66000 fl 0x0000000000000001
.. ..511: pte 0x0000000021fd9401 pa 0x0000000087f65000 fl 0x0000000000000001
.. .. ..510: pte 0x0000000021fdd807 pa 0x0000000087f76000 fl 0x0000000000000007
.. .. ..511: pte 0x0000000020001c0b pa 0x0000000080007000 fl 0x000000000000000b</p>
<pre><code>what is entry 0, 1, and 2?
what is 510 and 511?
- 511: trampoline
- 510: trapframe
why are the protection bits as they are?
- 510: RWV
- 511: XV
- 1: no U
are the physical addresses contiguous?
</code></pre>
<p>Part 2 of pgtbl lab
Add a kernel page table to each process in prep for Part 3</p>
<ul>
<li>exact copy of <em>the</em> kernel_pagetable</li>
</ul>
<p>How hard can this be?  hard! some reasons:</p>
<ul>
<li>xv6 code specialized to one kernel page table
no kvmcreate_page_table()</li>
<li>kvminit() isn&rsquo;t the full story
also mappings in procinit(), and virtio_disk.c</li>
<li>cleanup must be done care
don&rsquo;t free kernel stacks</li>
<li>easy to make a small error
even small errors are time consuming</li>
</ul>
<p>Two possible approaches to part II</p>
<ol>
<li>generalize kvminit()</li>
</ol>
<pre><code>create a new per-process kernel page table
</code></pre>
<ol start="2">
<li>share kernel_pagetable</li>
</ol>
<pre><code>make the per-process kernel page table share much with kernel_pagetable
- my solutions takes approach 2; other staff members too approach 1
- i took approach 2 mostly out of &quot;laziness&quot;
  don't have to think too hard what is in the kernel_pagetable
  didn't want to write much code
  - not sure it is shorter, though
  approach 2 has some benefits I didn't realize
  - avoided certain class of bugs (e.g., kernel stacks)
</code></pre>
<p>Implementation approach:
small incremental baby steps
keep existing code working
allows comparing old and new easily
allows rolling back easily</p>
<p>Approach 2</p>
<ul>
<li>kvmcreate()
copy entries 1..512
add a few devices that live in 0
<ul>
<li>anything below 1G (i.e., all devices)</li>
</ul>
</li>
<li>kvmfree()
only entry 0 is worth considering
just need to free intermediate pages (see 3-level pic)
a bit ugly
where to call kvmfree()
<ul>
<li>exit()?</li>
<li>freeproc()?</li>
</ul>
</li>
<li>scheduler()</li>
<li>usertrapret()</li>
</ul>
<p>Part 3 of pgtbl lab
map user pgtbl of process into bottom of process&rsquo;s kernel page table</p>
<ul>
<li>draw figure
why? convenient for kernel programmers</li>
<li>can replace copyin with copy_new()
copyin_new is just a memmove(), avoid the walkaddr()&rsquo;s</li>
<li>hardware can do the walks for us</li>
</ul>
<p>mapping user page tables into kernel page table</p>
<ul>
<li>kvmmapuser()
copies upte into kpte, adjust permissions</li>
</ul>
<p>Using kvmmapuser():</p>
<ul>
<li>userinit()</li>
<li>exec()
no need to replace kernel page table</li>
<li>fork()</li>
<li>sbrk()</li>
</ul>
<p>memmove()</p>
<ul>
<li>why the checks before the memmove()?</li>
<li>what does each case cover</li>
</ul>
<p>Syscall lab
systems calls look like functions calls
BUT they are not function calls</p>
<ul>
<li>U/K boundary transition
user/usys.pl</li>
<li>generates stubs for stubs
kernel/syscall.c</li>
<li>demultiplexes system calls
trace</li>
<li>proc.h</li>
<li>fork()
sysinfo</li>
<li>copyout()</li>
</ul>
<p>Util lab
primes</p>
<ul>
<li>close fd&rsquo;s to terminate correctly
xargs</li>
<li>setting up argv</li>
</ul>
<p>=== Questions ===</p>
<p>HW</p>
<p>===</p>
<p>In the page table lab, the kernel&rsquo;s hardware address translator won&rsquo;t
allow kernel to dereference user pages. More specifically, if the page
table entry has &ldquo;PTE_U&rdquo; bit set, which means user can access it, then
kernel won&rsquo;t be able to access it through the hardware address
translator unless we set &ldquo;PTE_U&rdquo; to false in the per-process kernel
page table. Is there a specific reason for this?</p>
<p>===</p>
<p>Why is the kernel not allowed to read memory mapped with the PTE_U
flag? To prevent malicious memory from being read?</p>
<p>===</p>
<p>In the last lecture, it was mentioned that even the kernel in
supervisor mode could not directly edit anything and everything in the
memory. The kernel accesses memory through the kernel page table, and
thus is limited. However, couldn&rsquo;t the kernel just set the satp
register to 0, and then there is no MMU translation, the CPU directly
accesses physical addresses. Could that situation not arise? That
certainly the case before page tables are set up and paging is
enabled.</p>
<p>===</p>
<p>A minor question: why the specific order of the trapframe in proc.h
(t0..t2, then s0, s1, a0..a7, s2..s11)?</p>
<p>===</p>
<p>PGTBL LAB</p>
<p>I&rsquo;m confused why the kernel can directly dereference the pointer in
part 3 of pagetable because we have now mapped the user&rsquo;s virtual
address into the user&rsquo;s kernel pagetable. Since it is still a virtual
address, doesn&rsquo;t it need to just walk the user&rsquo;s kernel page table? Or
is it because the user code now enters the kernel, and the kernel&rsquo;s
pagetable directly maps virtual addresses to physical addressses?
However, in my implementation, it seems to be that the kernel still
maps the same virtual addresses to the same physical addresses as the
user&rsquo;s page table, , which is not a direct mapping.</p>
<p>===</p>
<p>In the pgtbl lab, during Part 3 (copyin), I ran into an interesting
bug while changing a process&rsquo;s user mappings. In fork(), I was calling
my helper function to copy the user mappings from the process&rsquo;s user
page table to its kernel page table. When I tried to copy the parent
process&rsquo;s user page table, running &ldquo;usertests&rdquo; in the xv6 kernel just
caused it to return and none of the tests were run. However, copying
the child&rsquo;s user page table worked. Shouldn&rsquo;t either instruction be
ok, since the child&rsquo;s user page table was just copied over from the
parent?</p>
<p>===</p>
<p>For the page tables lab, what was the correct way to copy and change
the process&rsquo;s kernel page table the same way in fork(), exec(), and
sbrk()? I tried to copy over a range of entries from the process&rsquo;s
page table into the process&rsquo;s kernel page table directly, but my code
was panicking when trying to use mappages() after my change to the 3
functions.</p>
<p>===</p>
<p>If xv6 was written with the modifications from the pgtbl lab, we would
not need to worry about switching the pagetables in the trampline
code, right? Would there even be a need for the trampoline code to be
mapped in the user pages? My understanding was that that code can be
mapped in the per-process kernel pgtbls and be used from there during
the trap handling. I was also curious about why when a PTE has the
PTE_U bit is set, code in supervisor mode cannot access that page
table. It is confusing to me because I thought that the kernel has the
whole memory mapped and it can modify any virtual address even if some
user data lives there. In the last lab, we could even know the exact
va that the user pgtbl has for each of the pa that it uses and I think
maybe be able to corrupt user&rsquo;s data.</p>
<p>===</p>
<p>Is there a more efficient way to free each process&rsquo;s kernel pagetable?
I basically copied the freewalk function and removed the panic for
leaves.  Although this seemed fast enough for the tests, it still
seemed a little slow.  When I tried to optimize it by reducing
recursion depth, I ran into troubles.  Overall, this seems like a
computationally intensive task, especially if all physical memory is
mapped in the kernel pagetable for all processes. I was a little
worried about breaking something, but could I have stopped mapping all
physical memory?</p>
<p>===</p>
<p>Do operating systems using hierarchical pagetables ever set up the pagetable
pages so that the lower parts of the hierachy are (atleast in part) shared?</p>
<p>===</p>
<p>For the pagetable lab, I was trying to implement
copyin/copyinstr. However, I got stuck in an infinite loop with the
scheduler because the scheduler seemed to have no process that needs
to be run. I am curious as to what could happen to the pagetable so
that the OS would stop a process from running (especially the main
process). What part of the code does the operating system set the
state of a process to not running if the pagetable is broken?</p>
<p>===</p>
<p>I don&rsquo;t understand why when I moved</p>
<p>w_satp(MAKE_SATP(kernel_pagetable));
sfence_vma();</p>
<p>outside of</p>
<p>if(found == 0) {
intr_on();
asm volatile(&ldquo;wfi&rdquo;);
}</p>
<p>in scheduler that everything in part 2 of the page table lab
worked. Because before then, it worked to a certain degree, where
sometimes it&rsquo;d pass and sometimes it&rsquo;d fail.</p>
<p>===</p>
<p>In the pagetable lab, is there a significant impact on performance
from copying to per-process kernel page tables so frequently? If so,
how does this balance out with the improvements that come from being
able to directly de-reference user address in kernel space?</p>
<p>===</p>
<p>How are pipes implemented in xv6, and how would the changes to the
page tables implemented in the pgtbl lab effect this implementation?
Do the per-process page tables hinder each process&rsquo; ability to
communicate with each other?</p>
<p>===</p>
<ol>
<li>
<p>Why did uvmfree/freewalk originally panic at a leaf, and why did we need to
change that.</p>
</li>
<li>
<p>Why does the inclusion of the user PTE_U bit not allow the kernel to access
the PTE?</p>
</li>
</ol>
<p>===</p>
<p>The lab mentioned that &ldquo;the goal of this section and the next is to
allow the kernel to directly dereference user pointers.&rdquo; However, I
didn&rsquo;t understand how this adds functionality to the kernel, or why
this is an important function for the kernel to be able to do.</p>
<p>===</p>
<p>For the page table lab, I had some questions on access rights. If the
user bit is set, does that mean in user mode both read/write/execute
options can be performed, or can only read/write/execute be done in
kernel mode?</p>
<p>Also, are there pages in the kernel page table accessible in user mode?</p>
<p>===</p>
<p>In the pgtbl lab, we added kernel pagetables to each process in order
to simplify reading userspace pointers. Was there any reason we
couldn&rsquo;t do the same for copying data out to userspace? I think you&rsquo;d
have to be a little careful in exec(), since copyout is used there
while setting up the process, but apart from that?</p>
<p>Also, one of the challenge exercises for that lab is to remove the
PLIC limit.  How would you do that&ndash;set up a new pagetable for PLIC
access, and switch to that when trying to access PLIC registers?</p>
<p>===</p>
<p>I was talking to some friends who solved the pagetable part 3 by using
a modified uvmcopy but they needed to limit the pages they were
copying to pass the runtime limit. What&rsquo;s taking so long in that
function? Does the walking make the copy function less optimized for
the job?</p>
<p>===</p>
<p>Question: About the page table lab, when I was debugging my code, I
realized for reparent test, I sometimes pass it but I sometimes
fail. I fixed this issue by realizing I need to switch back to
kernel_pagetable in the scheduler after exiting the process&rsquo;s kernal
pagetable. I wonder why such mistakes would cause reparent to behave
non-deterministaclly? Was there some sort of race condition?</p>
<p>===</p>
<p>In our &ldquo;copy user page table to kernel page table&rdquo; functions in the
pagetable lab, why was it necessary to panic when a pagetable entry
didn&rsquo;t exist or was not valid for a given virtual address? Why
couldn&rsquo;t we have just skipped that virtual address? More broadly, how
could we assume that all of the user page table values that we were
copying over were present and valid?</p>
<p>===</p>
<p>It really messes with my head that you have to define a C function for
allocating memory (kalloc). This is one of the first things xv6 does
in main.c, directly after which it creates the kernel page table
(using a call to kalloc). Given the way kalloc works, is the kernel
page table always going to be at the &ldquo;end&rdquo; address in the kernel&rsquo;s
virtual memory space since its the first piece of memory to be
allocated? And do you have to be careful about using memory prior to
calling kinit in main.c?</p>
<p>===</p>
<p>This question is regarding the pgtbl lab. I had some confusion about
the exact motivation for the lab, specifically creating a separate
kernel page table for each process. I wasn&rsquo;t sure what the lab meant
by &ldquo;directly dereferencing the user address&rdquo;. From my understanding,
what the kernel currently does to translate the virtual address of the
user process is to &ldquo;walk&rdquo; down the user pagetable.</p>
<p>So if you essentially combine the kernel page table and user page
tables, wouldn&rsquo;t you still &ldquo;walk&rdquo; down the new per-process kernel page
table to get the physical address? I don&rsquo;t understand how this changes
anything since the two approaches differ only in which page table the
kernel is walking down.</p>
<p>===</p>
<p>For question 1 in the page table lab, was page 1 the guard page? This
made sense to me since it has the user flag off so it would cause
errors if the user tried to access it. However I believe the textbook
said that the guard page will have its valid bit off in which case it
would not show up in vmprint.</p>
<p>====</p>
<p>Why does the initial page table ( as printed in vmprint ) have indices
0 and 255?I deduced that these pages should eventually point towards
the initial user program data ( text, guard page and stack ) and the
trampoline/trapframe respectively. However, the trampoline should be
at the very top of the virtual address space, so it should have the
highest possible virtual address. Therefore, shouldn&rsquo;t the root page
table contain pages 0 and 511 rather than 0 and 255?</p>
<p>====</p>
<p>VM IN GENERAL</p>
<p>====</p>
<p>How was copyin with per process kernel pagetables exploited, as
mentioned in the pgtbl lab?</p>
<p>===</p>
<p>This is less of a question, but I&rsquo;d love to hear more about how Xv6 compares to
various other operating systems that we might use in our day-to-day lives.</p>
<p>I don&rsquo;t have specific questions, but for example:</p>
<ul>
<li>
<p>How does Linux set up its page tables? The lab mentioned this may have
changed with Spectre/Meltdown, but what do they do now?</p>
</li>
<li>
<p>Do we know how pages/traps are handled in Windows or macOS, or what tradeoffs
were made in the design decisions there? I read somewhere that Windows XP
source code leaked - did we learn anything interesting from that, or does
Microsoft just use standard techniques?</p>
</li>
<li>
<p>Does x86-64 have instructions that significantly simplify or combine or
increase performance of particular parts of the pagetable or traps chain of
code in interesting ways?</p>
</li>
<li>
<p>How active is the development of OS techniques like syscalls, pagetables,
etc.? Are they mostly considered a &ldquo;solved&rdquo; problem by modern operating
systems and only really experimented on in research?</p>
</li>
</ul>
<p>===</p>
<p>SYSCALL LAB</p>
<p>===</p>
<p>Could you possibly walk through the roles of the different places we
had to update when we added a new system call? (e.g. user/user.h,
user/usys.pl, kernel/syscall.h, and a few others)</p>
<p>I&rsquo;m mostly wondering (1) in what order these are visited when the code
is compiled and (2) why there isn&rsquo;t a more centralized way to do this?
For example, in kernel/syscall.c, why do we need to manually edit both
the extern list and the syscalls array beneath it?</p>
<p>===</p>
<p>UTIL LAB</p>
<p>===</p>
<p>One of the challenges for the first lab was to add history/tab
completion. However, one thing that gave me some trouble was being
able to parse single keystrokes (namely the arrow keys). Is there a
way to read a single character (not having to press enter)?</p>


  </div>

  <footer class="post-footer">
    <ul class="post-tags">
      <li><a href="https://kennems.github.io/tags/mit6.s081/">MIT6.S081</a></li>
    </ul>
        
    
    <ul id="categories">
      
        <li><a href="https://kennems.github.io/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F">Êìç‰ΩúÁ≥ªÁªü</a> </li>
      
    </ul>
    
    
<nav class="paginav">
  <a class="prev" href="https://kennems.github.io/posts/tech/%E5%91%A8%E8%B5%9B240915/">
    <span class="title">¬´ ‰∏ä‰∏ÄÈ°µ</span>
    <br>
    <span>LeetCodeÂë®Ëµõ415(250915)</span>
  </a>
  <a class="next" href="https://kennems.github.io/posts/tech/mit6.s0816-system-call-entryexit/">
    <span class="title">‰∏ã‰∏ÄÈ°µ ¬ª</span>
    <br>
    <span>MIT6.S081(6)-System Call Entry/Exit</span>
  </a>
</nav>

  </footer>
</article>
    </main>
    
<footer class="footer">
        <span>&copy; 2025 <a href="https://kennems.github.io/">Kennem&#39;s Blog</a></span> ¬∑ 

    <span>
        Powered by
        <a href="https://gohugo.io/" rel="noopener noreferrer" target="_blank">Hugo</a> &
        <a href="https://github.com/adityatelange/hugo-PaperMod/" rel="noopener" target="_blank">PaperMod</a>
    </span>
</footer>
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)" class="top-link" id="top-link" accesskey="g">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
        <path d="M12 6H0l6-6z" />
    </svg>
</a>

<script>
    let menu = document.getElementById('menu')
    if (menu) {
        menu.scrollLeft = localStorage.getItem("menu-scroll-position");
        menu.onscroll = function () {
            localStorage.setItem("menu-scroll-position", menu.scrollLeft);
        }
    }

    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.pushState(null, null, `#${id}`);
            }
        });
    });

</script>
<script>
    var mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };

</script>
<script>
    document.getElementById("theme-toggle").addEventListener("click", () => {
        if (document.body.className.includes("dark")) {
            document.body.classList.remove('dark');
            localStorage.setItem("pref-theme", 'light');
        } else {
            document.body.classList.add('dark');
            localStorage.setItem("pref-theme", 'dark');
        }
    })

</script>
<script>
    document.querySelectorAll('pre > code').forEach((codeblock) => {
        const container = codeblock.parentNode.parentNode;

        const copybutton = document.createElement('button');
        copybutton.classList.add('copy-code');
        copybutton.innerHTML = 'Â§çÂà∂';

        function copyingDone() {
            copybutton.innerHTML = 'Â∑≤Â§çÂà∂ÔºÅ';
            setTimeout(() => {
                copybutton.innerHTML = 'Â§çÂà∂';
            }, 2000);
        }

        copybutton.addEventListener('click', (cb) => {
            if ('clipboard' in navigator) {
                navigator.clipboard.writeText(codeblock.textContent);
                copyingDone();
                return;
            }

            const range = document.createRange();
            range.selectNodeContents(codeblock);
            const selection = window.getSelection();
            selection.removeAllRanges();
            selection.addRange(range);
            try {
                document.execCommand('copy');
                copyingDone();
            } catch (e) { };
            selection.removeRange(range);
        });

        if (container.classList.contains("highlight")) {
            container.appendChild(copybutton);
        } else if (container.parentNode.firstChild == container) {
            
        } else if (codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName == "TABLE") {
            
            codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(copybutton);
        } else {
            
            codeblock.parentNode.appendChild(copybutton);
        }
    });
</script>
<footer class="footer">
    <script async src="https://busuanzi.sukap.cn/busuanzi.pure.mini.js"></script>
    <span id="busuanzi_container">
        <link rel="stylesheet" href="//maxcdn.bootstrapcdn.com/font-awesome/4.3.0/css/font-awesome.min.css">
        Visitors: <span id="busuanzi_value_page_uv"></span>
        Views: <span id="busuanzi_value_page_pv"></span>

        
    </span>
</footer>



</body>

</html>
