<!DOCTYPE html>
<html lang="zh" dir="auto">

<head><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="index, follow">

<meta name="msvalidate.01" content="DF5FE493CC759E62BFE073BEA8EFD472" />
<title>20250329LeetCode双周赛 &amp; 20250330LeetCode周赛 | Kennem&#39;s Blog</title>
<meta name="keywords" content="LeetCode周赛">
<meta name="description" content="20250329LeetCode双周赛 &amp; 20250330LeetCode周赛">
<meta name="author" content="ShowGuan">
<link rel="canonical" href="https://kennems.github.io/posts/tech/20250329leetcode%E5%8F%8C%E5%91%A8%E8%B5%9B--20250330leetcode%E5%91%A8%E8%B5%9B/">
<link crossorigin="anonymous" href="/assets/css/stylesheet.1a7bc7e6d01b82c8ca2b2e53cfcf7e33d2fd9058f6b28245f94da0d91447c6a0.css" integrity="sha256-GnvH5tAbgsjKKy5Tz89&#43;M9L9kFj2soJF&#43;U2g2RRHxqA=" rel="preload stylesheet" as="style">
<link rel="icon" href="https://kennems.github.io/img/sun.png">
<link rel="icon" type="image/png" sizes="16x16" href="https://kennems.github.io/img/sun.png">
<link rel="icon" type="image/png" sizes="32x32" href="https://kennems.github.io/img/sun.png">
<link rel="apple-touch-icon" href="https://kennems.github.io/img/sun.png">
<link rel="mask-icon" href="https://kennems.github.io/img/sun.png">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<link rel="alternate" hreflang="zh" href="https://kennems.github.io/posts/tech/20250329leetcode%E5%8F%8C%E5%91%A8%E8%B5%9B--20250330leetcode%E5%91%A8%E8%B5%9B/">
<noscript>
    <style>
        #theme-toggle,
        .top-link {
            display: none;
        }

    </style>
    <style>
        @media (prefers-color-scheme: dark) {
            :root {
                --theme: rgb(29, 30, 32);
                --entry: rgb(46, 46, 51);
                --primary: rgb(218, 218, 219);
                --secondary: rgb(155, 156, 157);
                --tertiary: rgb(65, 66, 68);
                --content: rgb(196, 196, 197);
                --code-block-bg: rgb(46, 46, 51);
                --code-bg: rgb(55, 56, 62);
                --border: rgb(51, 51, 51);
            }

            .list {
                background: var(--theme);
            }

            .list:not(.dark)::-webkit-scrollbar-track {
                background: 0 0;
            }

            .list:not(.dark)::-webkit-scrollbar-thumb {
                border-color: var(--theme);
            }
        }

    </style>
</noscript>

<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.2/dist/katex.min.css" integrity="sha384-MlJdn/WNKDGXveldHDdyRP1R4CTHr3FeuDNfhsLPYrq2t0UBkUdK2jyTnXPEK1NQ" crossorigin="anonymous">

<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.2/dist/katex.min.js" integrity="sha384-VQ8d8WVFw0yHhCk5E8I86oOhv48xLpnDZx5T9GogA/Y84DcCKWXDmSDfn13bzFZY" crossorigin="anonymous"></script>

<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.2/dist/contrib/auto-render.min.js" integrity="sha384-+XBljXPPiv+OzfbB3cVmLHf4hdUFHlWNZN5spNQ7rmHTXpd7WvJum6fIACpNNfIR" crossorigin="anonymous"
    onload="renderMathInElement(document.body);"></script>

<script>
document.addEventListener("DOMContentLoaded", function() {
    renderMathInElement(document.body, {
        delimiters: [
            {left: "$$", right: "$$", display: true},
            {left: "$", right: "$", display: false}
        ]
    });
});
</script>



<link rel="stylesheet" href="https://fonts.cdnfonts.com/css/code-new-roman">
<link rel="preconnect" href="https://fonts.googleapis.com">
<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>


  

<meta property="og:url" content="https://kennems.github.io/posts/tech/20250329leetcode%E5%8F%8C%E5%91%A8%E8%B5%9B--20250330leetcode%E5%91%A8%E8%B5%9B/">
  <meta property="og:site_name" content="Kennem&#39;s Blog">
  <meta property="og:title" content="20250329LeetCode双周赛 & 20250330LeetCode周赛">
  <meta property="og:description" content="20250329LeetCode双周赛 &amp; 20250330LeetCode周赛">
  <meta property="og:locale" content="zh">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2025-03-30T15:37:01+08:00">
    <meta property="article:modified_time" content="2025-03-30T15:37:01+08:00">
    <meta property="article:tag" content="LeetCode周赛">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="20250329LeetCode双周赛 &amp; 20250330LeetCode周赛">
<meta name="twitter:description" content="20250329LeetCode双周赛 &amp; 20250330LeetCode周赛">


<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BreadcrumbList",
  "itemListElement": [
    {
      "@type": "ListItem",
      "position":  1 ,
      "name": "📚文章",
      "item": "https://kennems.github.io/posts/"
    }, 
    {
      "@type": "ListItem",
      "position":  2 ,
      "name": "💻技术",
      "item": "https://kennems.github.io/posts/tech/"
    }, 
    {
      "@type": "ListItem",
      "position":  3 ,
      "name": "20250329LeetCode双周赛 \u0026 20250330LeetCode周赛",
      "item": "https://kennems.github.io/posts/tech/20250329leetcode%E5%8F%8C%E5%91%A8%E8%B5%9B--20250330leetcode%E5%91%A8%E8%B5%9B/"
    }
  ]
}
</script>
<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "20250329LeetCode双周赛 \u0026 20250330LeetCode周赛",
  "name": "20250329LeetCode双周赛 \u0026 20250330LeetCode周赛",
  "description": "20250329LeetCode双周赛 \u0026 20250330LeetCode周赛",
  "keywords": [
    "LeetCode周赛"
  ],
  "articleBody": "20250329LeetCode双周赛 \u0026 20250330LeetCode周赛 T3 - 3500. 将数组分割为子数组的最小代价 1. 题目大意 给定两个等长的整数数组 nums 和 cost，以及一个整数 k。可以将 nums 分割为若干个连续的子数组，每个子数组的代价计算方式如下：\n子数组的代价 =\n$\\left( \\sum \\text{nums}[0:r] + k \\times i \\right) \\times \\sum \\text{cost}[l:r]$\n其中：\ni 代表当前子数组的顺序，从 1 开始递增。 目标是找到一种划分方式，使所有子数组的总代价最小。 2. 实现思路 该问题可以通过 动态规划 进行求解，使用 dp[i] 表示将前 i 个元素进行划分所能得到的最小代价。\n(1) 预处理前缀和 为了快速计算 nums 的累加和 cost 的累加和，我们构建两个前缀和数组：\npre[i] 表示 nums[0:i] 的前缀和 pc[i] 表示 cost[0:i] 的前缀和 (2) 动态规划转移方程 设 dp[i] 表示 nums 数组前 i 个元素的最小总代价。对于 j 到 i 形成一个子数组：\n$dp[i] = \\min_{j=1}^{i} \\left( dp[j-1] + (\\text{pre}[i] + k \\times \\text{(当前子数组编号)}) \\times (\\text{pc}[i] - \\text{pc}[j-1]) \\right)$\n其中：\ndp[j-1] 是 nums[0:j-1] 的最小总代价。 pre[i] - pre[j-1] 是 nums[j:i] 这一段的数值和。 pc[i] - pc[j-1] 是 cost[j:i] 这一段的代价和。 (3) 复杂度分析 由于 dp[i] 的状态转移涉及 O(n) 的子问题计算，因此总体复杂度为 O(n^2)，可以接受。 最终代码 from typing import List class Solution: def minimumCost(self, nums: List[int], cost: List[int], k: int) -\u003e int: n = len(nums) # 计算前缀和 pre = [0] * (n + 1) pc = [0] * (n + 1) for i in range(1, n + 1): pre[i] = pre[i - 1] + nums[i - 1] pc[i] = pc[i - 1] + cost[i - 1] # 初始化 DP 数组 dp = [float('inf')] * (n + 1) dp[0] = 0 # 没有元素时的总代价为 0 # 计算最优划分 for i in range(1, n + 1): for j in range(1, i + 1): subarray_cost = (pre[i] + k * (j)) * (pc[i] - pc[j - 1]) dp[i] = min(dp[i], dp[j - 1] + subarray_cost) return dp[n] T4 - 3501. 操作后最大活跃区段数 II 1. 题目大意 问题描述： 给定一个长度为 n 的二进制字符串 s，其中字符 ‘1’ 表示一个活跃区间，字符 ‘0’ 表示一个非活跃区间。你可以进行一次操作来最大化 s 中活跃区间的数量。 在这一次操作中，你可以分两步进行： 第一步： 将一个被 ‘0’ 包围的连续 ‘1’ 区间转换为全 ‘0’。 第二步： 将一个被 ‘1’ 包围的连续 ‘0’ 区间转换为全 ‘1’。 此外，还给定了一个二维数组 queries，其中每个查询 queries[i] = [li, ri] 表示子串 s[li…ri]。 对于每个查询，需要先将该子串两端分别虚拟添加一个 ‘1’（形成 t = “1” + s[li…ri] + “1”），然后在这个子串上进行上述操作，求出操作后 s 中可能获得的最大活跃区间数。 注意： 各个查询互不影响。 2. 实现思路 预处理： 利用前缀和数组快速统计任意区间内 ‘1’ 的个数，以便计算操作前已有的活跃区段数量。 区段划分与分类： 遍历字符串 s，将其分为连续相同字符的区段，并根据相邻字符判断该区段是否符合操作条件。 对于连续的 ‘1’ 区段： 如果其左右两侧都是 ‘0’（即被 ‘0’ 包围），则该区段可以考虑转换成全 ‘0’，视作一个成本区段（操作时需要付出“代价”）。 对于连续的 ‘0’ 区段： 如果其左右两侧都是 ‘1’（即被 ‘1’ 包围），则该区段可以考虑转换成全 ‘1’，视作一个增益区段（操作后可增加活跃区间数）。 同时，还需要考虑位于字符串边界处的特殊情况（比如子串的左边或右边恰好紧邻一个 ‘1’）。 线段树辅助查询： 为了高效回答多个查询，构建两棵线段树： STMin（最小值线段树）： 用于存储并查询成本区段（记录转换一个 ‘1’ 区段所需的“成本”），以便在查询区间内快速获得最小成本。 STMax（最大值线段树）： 用于存储并查询增益区段（记录转换一个 ‘0’ 区段后能够增加的活跃区段数），从而在查询区间内获得最大的增益值。 查询处理： 将所有查询按右边界排序，并按右边界遍历字符串，同时同步更新线段树中对应区段的信息。 对于每个查询 [l, r]： 根据预处理的前缀和数组计算出子串中原有的 ‘1’ 数量。 使用 STMin 和 STMax 查询区间内的成本和增益信息；同时处理边界处的特殊增益情况。 结合原有的 ‘1’ 数量和操作后可能获得的净增益（增益可能需要扣除相应成本），得到该查询下最大活跃区段数。 返回结果： 将所有查询的结果存入数组并返回。 import math from typing import List class STMin: def __init__(self, n): self.n = n self.t = [math.inf] * (4 * n) def _upd(self, nd, s, e, i, v): if s == e: if s == i: self.t[nd] = min(self.t[nd], v) return m = (s + e) // 2 if s \u003c= i \u003c= m: self._upd(2 * nd, s, m, i, v) else: self._upd(2 * nd + 1, m + 1, e, i, v) self.t[nd] = min(self.t[2 * nd], self.t[2 * nd + 1]) def update(self, i, v): if 0 \u003c= i \u003c self.n: self._upd(1, 0, self.n - 1, i, v) def _qry(self, nd, s, e, l, r): if r \u003c s or e \u003c l: return math.inf if l \u003c= s and e \u003c= r: return self.t[nd] m = (s + e) // 2 return min(self._qry(2 * nd, s, m, l, r), self._qry(2 * nd + 1, m + 1, e, l, r)) def query(self, l, r): return self._qry(1, 0, self.n - 1, max(l, 0), min(r, self.n - 1)) class STMax: def __init__(self, n): self.n = n self.t = [0] * (4 * n) def _upd(self, nd, s, e, i, v): if s == e: if s == i: self.t[nd] = max(self.t[nd], v) return m = (s + e) // 2 if s \u003c= i \u003c= m: self._upd(2 * nd, s, m, i, v) else: self._upd(2 * nd + 1, m + 1, e, i, v) self.t[nd] = max(self.t[2 * nd], self.t[2 * nd + 1]) def update(self, i, v): if 0 \u003c= i \u003c self.n: self._upd(1, 0, self.n - 1, i, v) def _qry(self, nd, s, e, l, r): if r \u003c s or e \u003c l: return 0 if l \u003c= s and e \u003c= r: return self.t[nd] m = (s + e) // 2 return max(self._qry(2 * nd, s, m, l, r), self._qry(2 * nd + 1, m + 1, e, l, r)) def query(self, l, r): return self._qry(1, 0, self.n - 1, max(l, 0), min(r, self.n - 1)) class Solution: def maxActiveSectionsAfterTrade(self, s: str, qs: List[List[int]]) -\u003e List[int]: n = len(s) if n == 0: return [0] * len(qs) # 前缀和预处理 pref = [0] * (n + 1) for i in range(n): pref[i + 1] = pref[i] + (1 if s[i] == '1' else 0) # 结果存储 res = [0] * len(qs) # 查询处理 for idx, (l, r) in enumerate(qs): ones = pref[r + 1] - pref[l] res[idx] = ones + 1 if ones \u003e 0 else 0 return res T3 - 100614. 子字符串连接后的最长回文串 II 1. 题目大意 给定两个字符串 s 和 t，可以从 s 中选择一个子串（可以为空）以及从 t 中选择一个子串（可以为空），然后将它们按顺序连接，得到一个新的字符串。要求返回可以构造出的最长回文串的长度。\n2. 实现思路 该问题的核心是找到 s 和 t 之间最长的回文子串，并通过连接 s 的子串和 t 的子串最大化回文长度。\n具体步骤\n反转 t：由于 t 连接 s 之后要形成回文，所以先对 t 进行反转，记为 t_rev。 预处理 s 和 t_rev：将字符转换为 ASCII 码，方便后续计算。 计算 dp[i][j]： dp[i][j] 记录 s[i:] 和 t_rev[j:] 之间最长的公共前缀长度。 dp[i][j] = dp[i + 1][j + 1] + 1，若 s[i] == t_rev[j]。 计算最长回文子串长度： 使用中心扩展法 calc(x) 计算 s 和 t_rev 各自的最长回文子串数组 ws 和 wt，其中 ws[i] 表示以 s[i] 开始的最长回文子串长度。 计算 max(ws) 和 max(wt)，得到 s 或 t_rev 各自的最长回文子串长度。 合并 s 和 t_rev 的回文部分： 遍历 s 和 t_rev 的所有匹配点 (i, j)，找到 dp[i][j] 最大值，计算可能的最长回文串长度 dp[i][j] * 2 + max(ws[i + dp[i][j]], wt[j + dp[i][j]])。 维护 res 记录最大长度。 时间复杂度分析\n计算 dp 表：O(n × m) 计算 ws 和 wt：O(n + m) 遍历 s 和 t 的所有匹配点：O(n × m) 总复杂度：O(n × m)，适用于 n, m ≤ 1000 的情况。 fmax = lambda x, y: x if x \u003e y else y class Solution: def longestPalindrome(self, s: str, t: str) -\u003e int: t = t[::-1] s = [ord(c) for c in s] t = [ord(c) for c in t] print(s, t) n = len(s) m = len(t) dp = [[0] * (m + 1) for _ in range(n + 1)] for i in range(n - 1, -1, -1): for j in range(m - 1, -1, -1): if s[i] == t[j]: dp[i][j] = dp[i + 1][j + 1] + 1 def calc(x): k = len(x) res = [0] * (k + 1) for i in range(k): l = r = i res[l] = fmax(res[l], 1) while l \u003e 0 and r + 1 \u003c k and x[l - 1] == x[r + 1]: l -= 1 r += 1 res[l] = fmax(res[l], r - l + 1) for i in range(1, k): if x[i - 1] == x[i]: l = i - 1 r = i res[l] = fmax(res[l], 2) while l \u003e 0 and r + 1 \u003c k and x[l - 1] == x[r + 1]: l -= 1 r += 1 res[l] = fmax(res[l], r - l + 1) return res ws = calc(s) wt = calc(t) res = fmax(max(ws), max(wt)) for i in range(n): for j in range(m): res = fmax(res, dp[i][j] * 2 + fmax(ws[i + dp[i][j]], wt[j + dp[i][j]])) return res T4 - 100537. 使 K 个子数组内元素相等的最少操作数 1. 题目大意 给定一个整数数组 nums 和两个整数 x 和 k，你可以对 nums 中的任意元素执行加 1 或减 1 操作。目标是至少包含 k 个长度恰好为 x 的不重叠子数组，每个子数组中的所有元素相等，求所需的最少操作数。\n2. 实现思路 本题的核心是：\n滑动窗口 + 二分查找 + 树状数组（Fenwick Tree） 来高效计算构造一个 x 长度的子数组的最优操作数。 动态规划 解决 最少 k 个 x 长度子数组 的最优选取。 步骤 Step 1: 计算所有长度为 x 的子数组的最优操作数 排序 + 中位数贪心策略： 选取 nums[i:i+x]，令其中所有元素变为中位数最优。 采用 树状数组 (Fenwick Tree) 维护 窗口的数值和个数，快速求解变成中位数的最小代价。 滑动窗口更新代价 设 stl 为窗口中元素的有序集合 (SortedList)，快速查询中位数。 维护两个树状数组： fen_cnt[i] 记录值 nums[i] 的出现次数 fen_sum[i] 记录值 nums[i] 的总和 移动窗口时，删除 nums[i-x]，插入 nums[i]，并高效更新操作数。 Step 2: 动态规划 dp[i] dp[i] 记录前 i 个元素能构造 k 个子数组的最小操作数。 递推公式：$dp[j + x] = \\min(dp[j + x], dp[j] + \\text{当前窗口操作数})$ 通过 ndp 数组优化转移，确保 O(n*k) 复杂度。 3. 时间复杂度分析 预处理子数组 O(n log n) SortedList 插入/删除 O(log x) Fenwick Tree 查询/更新 O(log x) 遍历 n 个窗口 O(n log x) 动态规划 O(n * k) k 轮遍历 O(n) 总复杂度：\n$O(n \\log x + n k)$\n对于 n ≤ 10^5，k ≤ 15，可以接受。\n4. 代码分析 inf = 10 ** 18 fmin = lambda x, y: x if x \u003c y else y class FenwickTree: def __init__(self, n): self.n = n self.bit = [0] * n def sum(self, r): res = 0 while r \u003e= 0: res += self.bit[r] r = (r \u0026 (r + 1)) - 1 return res def rsum(self, l, r): return self.sum(r) - self.sum(l - 1) def add(self, idx, delta): while idx \u003c self.n: self.bit[idx] += delta idx = idx | (idx + 1) from sortedcontainers import SortedList class Solution: def minOperations(self, nums: List[int], x: int, k: int) -\u003e int: n = len(nums) vs = sorted(set(nums)) d = {v: i for i, v in enumerate(vs)} k = len(d) stl = SortedList(nums[:x]) fen_cnt = FenwickTree(k) fen_sum = FenwickTree(k) total = 0 for i in range(x): total += nums[i] fen_cnt.add(d[nums[i]], 1) fen_sum.add(d[nums[i]], nums[i]) def calc(): mid = stl[len(stl) // 2] p = d[mid] c1 = fen_cnt.sum(p) s1 = fen_sum.sum(p) c2 = x - c1 s2 = total - s1 return c1 * mid - s1 + s2 - c2 * mid ans = [calc()] for i in range(x, n): stl.remove(nums[i - x]) stl.add(nums[i]) fen_cnt.add(d[nums[i - x]], -1) fen_sum.add(d[nums[i - x]], -nums[i - x]) fen_cnt.add(d[nums[i]], 1) fen_sum.add(d[nums[i]], nums[i]) total -= nums[i - x] total += nums[i] ans.append(calc()) dp = [0] * (n + 1) ndp = [inf] * (n + 1) for i in range(k): for j in range(n + 1): if j \u003e= len(ans): break if dp[j] \u003c inf: ndp[j + x] = fmin(ndp[j + x], dp[j] + ans[j]) for j in range(1, n + 1): ndp[j] = fmin(ndp[j], ndp[j - 1]) for j in range(n + 1): dp[j] = ndp[j] ndp[j] = inf return dp[n] ",
  "wordCount" : "3612",
  "inLanguage": "zh",
  "datePublished": "2025-03-30T15:37:01+08:00",
  "dateModified": "2025-03-30T15:37:01+08:00",
  "author":{
    "@type": "Person",
    "name": "ShowGuan"
  },
  "mainEntityOfPage": {
    "@type": "WebPage",
    "@id": "https://kennems.github.io/posts/tech/20250329leetcode%E5%8F%8C%E5%91%A8%E8%B5%9B--20250330leetcode%E5%91%A8%E8%B5%9B/"
  },
  "publisher": {
    "@type": "Organization",
    "name": "Kennem's Blog",
    "logo": {
      "@type": "ImageObject",
      "url": "https://kennems.github.io/img/sun.png"
    }
  }
}
</script>
<script src="https://cdn.jsdelivr.net/npm/jquery@3.5.1/dist/jquery.min.js"></script>
<link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.css" />
<script src="https://cdn.jsdelivr.net/gh/fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.js"></script>




</head>

<body class="" id="top">
<script>
    if (localStorage.getItem("pref-theme") === "dark") {
        document.body.classList.add('dark');
    } else if (localStorage.getItem("pref-theme") === "light") {
        document.body.classList.remove('dark')
    } else if (window.matchMedia('(prefers-color-scheme: dark)').matches) {
        document.body.classList.add('dark');
    }

</script>

<header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="https://kennems.github.io/" accesskey="h" title="Kennem&#39;s Blog (Alt + H)">
                <img src="https://kennems.github.io/img/sun.png" alt="" aria-label="logo"
                    height="35">Kennem&#39;s Blog</a>
            <div class="logo-switches">
                <button id="theme-toggle" accesskey="t" title="(Alt + T)">
                    <svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
                    </svg>
                    <svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <circle cx="12" cy="12" r="5"></circle>
                        <line x1="12" y1="1" x2="12" y2="3"></line>
                        <line x1="12" y1="21" x2="12" y2="23"></line>
                        <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                        <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                        <line x1="1" y1="12" x2="3" y2="12"></line>
                        <line x1="21" y1="12" x2="23" y2="12"></line>
                        <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                        <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
                    </svg>
                </button>
            </div>
        </div>
        <ul id="menu">
            <li>
                <a href="https://kennems.github.io/" title="🏠主页">
                    <span>🏠主页</span>
                </a>
            </li>
            <li>
                <a href="https://kennems.github.io/search" title="🔍搜索 (Alt &#43; /)" accesskey=/>
                    <span>🔍搜索</span>
                </a>
            </li>
            <li>
                <a href="https://kennems.github.io/posts" title="📚文章">
                    <span>📚文章</span>
                </a>
            </li>
            <li>
                <a href="https://kennems.github.io/archives" title="⏱时间轴">
                    <span>⏱时间轴</span>
                </a>
            </li>
            <li>
                <a href="https://kennems.github.io/tags" title="🔖标签">
                    <span>🔖标签</span>
                </a>
            </li>
            <li>
                <a href="https://kennems.github.io/categories" title="🗂️分类">
                    <span>🗂️分类</span>
                </a>
            </li>
            <li>
                <a href="https://kennems.github.io/about" title="🙋🏻‍♂️关于">
                    <span>🙋🏻‍♂️关于</span>
                </a>
            </li>
        </ul>
    </nav>
</header>
<main class="main">

<article class="post-single">
  <header class="post-header">
    <div class="breadcrumbs"><a href="https://kennems.github.io/">主页</a>&nbsp;»&nbsp;<a href="https://kennems.github.io/posts/">📚文章</a>&nbsp;»&nbsp;<a href="https://kennems.github.io/posts/tech/">💻技术</a></div>
    <h1 class="post-title entry-hint-parent">
      20250329LeetCode双周赛 &amp; 20250330LeetCode周赛
    </h1>
    <div class="post-description">
      20250329LeetCode双周赛 &amp; 20250330LeetCode周赛
    </div>
    <div class="post-meta"><span title='2025-03-30 15:37:01 +0800 CST'>2025-03-30</span>&nbsp;·&nbsp;8 分钟&nbsp;·&nbsp;3612 字&nbsp;·&nbsp;updated:&nbsp;2025-03-30&nbsp;·&nbsp;ShowGuan

</div>
    
     <div class="post-password">
        
    </div>
  </header> <aside id="toc-container" class="toc-container wide">
    <div class="toc">
        <details  open>
            <summary accesskey="c" title="(Alt + C)">
                <span class="details">目录</span>
            </summary>

            <div class="inner"><ul>
                    <li>
                        <a href="#20250329leetcode%e5%8f%8c%e5%91%a8%e8%b5%9b--20250330leetcode%e5%91%a8%e8%b5%9b" aria-label="20250329LeetCode双周赛 &amp; 20250330LeetCode周赛">20250329LeetCode双周赛 &amp; 20250330LeetCode周赛</a><ul>
                            
                    <li>
                        <a href="#t3---3500-%e5%b0%86%e6%95%b0%e7%bb%84%e5%88%86%e5%89%b2%e4%b8%ba%e5%ad%90%e6%95%b0%e7%bb%84%e7%9a%84%e6%9c%80%e5%b0%8f%e4%bb%a3%e4%bb%b7httpsleetcodecncontestbiweekly-contest-153problemsminimum-cost-to-divide-array-into-subarrays" aria-label="T3 - 3500. 将数组分割为子数组的最小代价"><a href="https://leetcode.cn/contest/biweekly-contest-153/problems/minimum-cost-to-divide-array-into-subarrays/">T3 - 3500. 将数组分割为子数组的最小代价</a></a><ul>
                            
                    <li>
                        <a href="#1-%e9%a2%98%e7%9b%ae%e5%a4%a7%e6%84%8f" aria-label="1. 题目大意">1. 题目大意</a></li>
                    <li>
                        <a href="#2-%e5%ae%9e%e7%8e%b0%e6%80%9d%e8%b7%af" aria-label="2. 实现思路">2. 实现思路</a><ul>
                            
                    <li>
                        <a href="#1-%e9%a2%84%e5%a4%84%e7%90%86%e5%89%8d%e7%bc%80%e5%92%8c" aria-label="(1) 预处理前缀和"><strong>(1) 预处理前缀和</strong></a></li>
                    <li>
                        <a href="#2-%e5%8a%a8%e6%80%81%e8%a7%84%e5%88%92%e8%bd%ac%e7%a7%bb%e6%96%b9%e7%a8%8b" aria-label="(2) 动态规划转移方程"><strong>(2) 动态规划转移方程</strong></a></li>
                    <li>
                        <a href="#3-%e5%a4%8d%e6%9d%82%e5%ba%a6%e5%88%86%e6%9e%90" aria-label="(3) 复杂度分析"><strong>(3) 复杂度分析</strong></a></li></ul>
                    </li>
                    <li>
                        <a href="#%e6%9c%80%e7%bb%88%e4%bb%a3%e7%a0%81" aria-label="最终代码"><strong>最终代码</strong></a></li></ul>
                    </li>
                    <li>
                        <a href="#t4---3501-%e6%93%8d%e4%bd%9c%e5%90%8e%e6%9c%80%e5%a4%a7%e6%b4%bb%e8%b7%83%e5%8c%ba%e6%ae%b5%e6%95%b0-iihttpsleetcodecncontestbiweekly-contest-153problemsmaximize-active-section-with-trade-ii" aria-label="T4 - 3501. 操作后最大活跃区段数 II"><a href="https://leetcode.cn/contest/biweekly-contest-153/problems/maximize-active-section-with-trade-ii/">T4 - 3501. 操作后最大活跃区段数 II</a></a><ul>
                            
                    <li>
                        <a href="#1-%e9%a2%98%e7%9b%ae%e5%a4%a7%e6%84%8f-1" aria-label="1. 题目大意">1. 题目大意</a></li>
                    <li>
                        <a href="#2-%e5%ae%9e%e7%8e%b0%e6%80%9d%e8%b7%af-1" aria-label="2. 实现思路">2. 实现思路</a></li></ul>
                    </li>
                    <li>
                        <a href="#t3---100614-%e5%ad%90%e5%ad%97%e7%ac%a6%e4%b8%b2%e8%bf%9e%e6%8e%a5%e5%90%8e%e7%9a%84%e6%9c%80%e9%95%bf%e5%9b%9e%e6%96%87%e4%b8%b2-iihttpsleetcodecncontestweekly-contest-443problemslongest-palindrome-after-substring-concatenation-ii" aria-label="T3 - 100614. 子字符串连接后的最长回文串 II"><a href="https://leetcode.cn/contest/weekly-contest-443/problems/longest-palindrome-after-substring-concatenation-ii/">T3 - 100614. 子字符串连接后的最长回文串 II</a></a><ul>
                            
                    <li>
                        <a href="#1-%e9%a2%98%e7%9b%ae%e5%a4%a7%e6%84%8f-2" aria-label="1. 题目大意">1. 题目大意</a></li>
                    <li>
                        <a href="#2-%e5%ae%9e%e7%8e%b0%e6%80%9d%e8%b7%af-2" aria-label="2. 实现思路">2. <strong>实现思路</strong></a></li></ul>
                    </li>
                    <li>
                        <a href="#t4---100537-%e4%bd%bf-k-%e4%b8%aa%e5%ad%90%e6%95%b0%e7%bb%84%e5%86%85%e5%85%83%e7%b4%a0%e7%9b%b8%e7%ad%89%e7%9a%84%e6%9c%80%e5%b0%91%e6%93%8d%e4%bd%9c%e6%95%b0httpsleetcodecncontestweekly-contest-443problemsminimum-operations-to-make-elements-within-k-subarrays-equal" aria-label="T4 - 100537. 使 K 个子数组内元素相等的最少操作数"><a href="https://leetcode.cn/contest/weekly-contest-443/problems/minimum-operations-to-make-elements-within-k-subarrays-equal/">T4 - 100537. 使 K 个子数组内元素相等的最少操作数</a></a><ul>
                            
                    <li>
                        <a href="#1-%e9%a2%98%e7%9b%ae%e5%a4%a7%e6%84%8f-3" aria-label="1. 题目大意"><strong>1. 题目大意</strong></a></li>
                    <li>
                        <a href="#2-%e5%ae%9e%e7%8e%b0%e6%80%9d%e8%b7%af-3" aria-label="2. 实现思路"><strong>2. 实现思路</strong></a><ul>
                            
                    <li>
                        <a href="#%e6%ad%a5%e9%aa%a4" aria-label="步骤"><strong>步骤</strong></a><ul>
                            
                    <li>
                        <a href="#step-1-%e8%ae%a1%e7%ae%97%e6%89%80%e6%9c%89%e9%95%bf%e5%ba%a6%e4%b8%ba-x-%e7%9a%84%e5%ad%90%e6%95%b0%e7%bb%84%e7%9a%84%e6%9c%80%e4%bc%98%e6%93%8d%e4%bd%9c%e6%95%b0" aria-label="Step 1: 计算所有长度为 x 的子数组的最优操作数"><strong>Step 1: 计算所有长度为 <code>x</code> 的子数组的最优操作数</strong></a></li>
                    <li>
                        <a href="#step-2-%e5%8a%a8%e6%80%81%e8%a7%84%e5%88%92-dpi" aria-label="Step 2: 动态规划 dp[i]"><strong>Step 2: 动态规划 <code>dp[i]</code></strong></a></li></ul>
                    </li></ul>
                    </li>
                    <li>
                        <a href="#3-%e6%97%b6%e9%97%b4%e5%a4%8d%e6%9d%82%e5%ba%a6%e5%88%86%e6%9e%90" aria-label="3. 时间复杂度分析"><strong>3. 时间复杂度分析</strong></a></li>
                    <li>
                        <a href="#4-%e4%bb%a3%e7%a0%81%e5%88%86%e6%9e%90" aria-label="4. 代码分析"><strong>4. 代码分析</strong></a>
                    </li>
                </ul>
                </li>
                </ul>
                </li>
                </ul>
            </div>
        </details>
    </div>
</aside>
<script>
    let activeElement;
    let elements;
    window.addEventListener('DOMContentLoaded', function (event) {
        checkTocPosition();

        elements = document.querySelectorAll('h1[id],h2[id],h3[id],h4[id],h5[id],h6[id]');
         
         activeElement = elements[0];
         const id = encodeURI(activeElement.getAttribute('id')).toLowerCase();
         document.querySelector(`.inner ul li a[href="#${id}"]`).classList.add('active');
     }, false);

    window.addEventListener('resize', function(event) {
        checkTocPosition();
    }, false);

    window.addEventListener('scroll', () => {
        
        activeElement = Array.from(elements).find((element) => {
            if ((getOffsetTop(element) - window.pageYOffset) > 0 && 
                (getOffsetTop(element) - window.pageYOffset) < window.innerHeight/2) {
                return element;
            }
        }) || activeElement

        elements.forEach(element => {
             const id = encodeURI(element.getAttribute('id')).toLowerCase();
             if (element === activeElement){
                 document.querySelector(`.inner ul li a[href="#${id}"]`).classList.add('active');
             } else {
                 document.querySelector(`.inner ul li a[href="#${id}"]`).classList.remove('active');
             }
         })
     }, false);

    const main = parseInt(getComputedStyle(document.body).getPropertyValue('--article-width'), 10);
    const toc = parseInt(getComputedStyle(document.body).getPropertyValue('--toc-width'), 10);
    const gap = parseInt(getComputedStyle(document.body).getPropertyValue('--gap'), 10);

    function checkTocPosition() {
        const width = document.body.scrollWidth;

        if (width - main - (toc * 2) - (gap * 4) > 0) {
            document.getElementById("toc-container").classList.add("wide");
        } else {
            document.getElementById("toc-container").classList.remove("wide");
        }
    }

    function getOffsetTop(element) {
        if (!element.getClientRects().length) {
            return 0;
        }
        let rect = element.getBoundingClientRect();
        let win = element.ownerDocument.defaultView;
        return rect.top + win.pageYOffset;   
    }
</script>

  <div class="post-content"><h1 id="20250329leetcode双周赛--20250330leetcode周赛">20250329LeetCode双周赛 &amp; 20250330LeetCode周赛<a hidden class="anchor" aria-hidden="true" href="#20250329leetcode双周赛--20250330leetcode周赛">#</a></h1>
<h2 id="t3---3500-将数组分割为子数组的最小代价httpsleetcodecncontestbiweekly-contest-153problemsminimum-cost-to-divide-array-into-subarrays"><a href="https://leetcode.cn/contest/biweekly-contest-153/problems/minimum-cost-to-divide-array-into-subarrays/">T3 - 3500. 将数组分割为子数组的最小代价</a><a hidden class="anchor" aria-hidden="true" href="#t3---3500-将数组分割为子数组的最小代价httpsleetcodecncontestbiweekly-contest-153problemsminimum-cost-to-divide-array-into-subarrays">#</a></h2>
<h3 id="1-题目大意">1. 题目大意<a hidden class="anchor" aria-hidden="true" href="#1-题目大意">#</a></h3>
<p>给定两个等长的整数数组 <code>nums</code> 和 <code>cost</code>，以及一个整数 <code>k</code>。可以将 <code>nums</code> 分割为若干个连续的子数组，每个子数组的代价计算方式如下：</p>
<p><strong>子数组的代价 =</strong></p>
<p>$\left( \sum \text{nums}[0:r] + k \times i \right) \times \sum \text{cost}[l:r]$</p>
<p>其中：</p>
<ul>
<li><code>i</code> 代表当前子数组的顺序，从 <code>1</code> 开始递增。</li>
<li>目标是找到一种划分方式，使所有子数组的总代价最小。</li>
</ul>
<hr>
<h3 id="2-实现思路">2. 实现思路<a hidden class="anchor" aria-hidden="true" href="#2-实现思路">#</a></h3>
<p>该问题可以通过 <strong>动态规划</strong> 进行求解，使用 <code>dp[i]</code> 表示将前 <code>i</code> 个元素进行划分所能得到的最小代价。</p>
<h4 id="1-预处理前缀和"><strong>(1) 预处理前缀和</strong><a hidden class="anchor" aria-hidden="true" href="#1-预处理前缀和">#</a></h4>
<p>为了快速计算 <code>nums</code> 的累加和 <code>cost</code> 的累加和，我们构建两个前缀和数组：</p>
<ul>
<li><code>pre[i]</code> 表示 <code>nums[0:i]</code> 的前缀和</li>
<li><code>pc[i]</code> 表示 <code>cost[0:i]</code> 的前缀和</li>
</ul>
<h4 id="2-动态规划转移方程"><strong>(2) 动态规划转移方程</strong><a hidden class="anchor" aria-hidden="true" href="#2-动态规划转移方程">#</a></h4>
<p>设 <code>dp[i]</code> 表示 <code>nums</code> 数组前 <code>i</code> 个元素的最小总代价。对于 <code>j</code> 到 <code>i</code> 形成一个子数组：</p>
<p>$dp[i] = \min_{j=1}^{i} \left( dp[j-1] + (\text{pre}[i] + k \times \text{(当前子数组编号)}) \times (\text{pc}[i] - \text{pc}[j-1]) \right)$</p>
<p>其中：</p>
<ul>
<li><code>dp[j-1]</code> 是 <code>nums[0:j-1]</code> 的最小总代价。</li>
<li><code>pre[i] - pre[j-1]</code> 是 <code>nums[j:i]</code> 这一段的数值和。</li>
<li><code>pc[i] - pc[j-1]</code> 是 <code>cost[j:i]</code> 这一段的代价和。</li>
</ul>
<h4 id="3-复杂度分析"><strong>(3) 复杂度分析</strong><a hidden class="anchor" aria-hidden="true" href="#3-复杂度分析">#</a></h4>
<ul>
<li>由于 <code>dp[i]</code> 的状态转移涉及 <code>O(n)</code> 的子问题计算，因此总体复杂度为 <code>O(n^2)</code>，可以接受。</li>
</ul>
<hr>
<h3 id="最终代码"><strong>最终代码</strong><a hidden class="anchor" aria-hidden="true" href="#最终代码">#</a></h3>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span><span style="color:#f92672">from</span> typing <span style="color:#f92672">import</span> List
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Solution</span>:
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">def</span> <span style="color:#a6e22e">minimumCost</span>(self, nums: List[int], cost: List[int], k: int) <span style="color:#f92672">-&gt;</span> int:
</span></span><span style="display:flex;"><span>        n <span style="color:#f92672">=</span> len(nums)
</span></span><span style="display:flex;"><span>        
</span></span><span style="display:flex;"><span>        <span style="color:#75715e"># 计算前缀和</span>
</span></span><span style="display:flex;"><span>        pre <span style="color:#f92672">=</span> [<span style="color:#ae81ff">0</span>] <span style="color:#f92672">*</span> (n <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>)
</span></span><span style="display:flex;"><span>        pc <span style="color:#f92672">=</span> [<span style="color:#ae81ff">0</span>] <span style="color:#f92672">*</span> (n <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>)
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">for</span> i <span style="color:#f92672">in</span> range(<span style="color:#ae81ff">1</span>, n <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>):
</span></span><span style="display:flex;"><span>            pre[i] <span style="color:#f92672">=</span> pre[i <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>] <span style="color:#f92672">+</span> nums[i <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>]
</span></span><span style="display:flex;"><span>            pc[i] <span style="color:#f92672">=</span> pc[i <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>] <span style="color:#f92672">+</span> cost[i <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>]
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#75715e"># 初始化 DP 数组</span>
</span></span><span style="display:flex;"><span>        dp <span style="color:#f92672">=</span> [float(<span style="color:#e6db74">&#39;inf&#39;</span>)] <span style="color:#f92672">*</span> (n <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>)
</span></span><span style="display:flex;"><span>        dp[<span style="color:#ae81ff">0</span>] <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>  <span style="color:#75715e"># 没有元素时的总代价为 0</span>
</span></span><span style="display:flex;"><span>        
</span></span><span style="display:flex;"><span>        <span style="color:#75715e"># 计算最优划分</span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">for</span> i <span style="color:#f92672">in</span> range(<span style="color:#ae81ff">1</span>, n <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>):
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">for</span> j <span style="color:#f92672">in</span> range(<span style="color:#ae81ff">1</span>, i <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>):
</span></span><span style="display:flex;"><span>                subarray_cost <span style="color:#f92672">=</span> (pre[i] <span style="color:#f92672">+</span> k <span style="color:#f92672">*</span> (j)) <span style="color:#f92672">*</span> (pc[i] <span style="color:#f92672">-</span> pc[j <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>])
</span></span><span style="display:flex;"><span>                dp[i] <span style="color:#f92672">=</span> min(dp[i], dp[j <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>] <span style="color:#f92672">+</span> subarray_cost)
</span></span><span style="display:flex;"><span>        
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> dp[n]
</span></span></code></pre></div><h2 id="t4---3501-操作后最大活跃区段数-iihttpsleetcodecncontestbiweekly-contest-153problemsmaximize-active-section-with-trade-ii"><a href="https://leetcode.cn/contest/biweekly-contest-153/problems/maximize-active-section-with-trade-ii/">T4 - 3501. 操作后最大活跃区段数 II</a><a hidden class="anchor" aria-hidden="true" href="#t4---3501-操作后最大活跃区段数-iihttpsleetcodecncontestbiweekly-contest-153problemsmaximize-active-section-with-trade-ii">#</a></h2>
<h3 id="1-题目大意-1">1. 题目大意<a hidden class="anchor" aria-hidden="true" href="#1-题目大意-1">#</a></h3>
<ul>
<li><strong>问题描述：</strong>
给定一个长度为 n 的二进制字符串 s，其中字符 &lsquo;1&rsquo; 表示一个活跃区间，字符 &lsquo;0&rsquo; 表示一个非活跃区间。你可以进行一次操作来最大化 s 中活跃区间的数量。
在这一次操作中，你可以分两步进行：
<ol>
<li><strong>第一步：</strong> 将一个被 &lsquo;0&rsquo; 包围的连续 &lsquo;1&rsquo; 区间转换为全 &lsquo;0&rsquo;。</li>
<li><strong>第二步：</strong> 将一个被 &lsquo;1&rsquo; 包围的连续 &lsquo;0&rsquo; 区间转换为全 &lsquo;1&rsquo;。
此外，还给定了一个二维数组 queries，其中每个查询 queries[i] = [li, ri] 表示子串 s[li&hellip;ri]。
对于每个查询，需要先将该子串两端分别虚拟添加一个 &lsquo;1&rsquo;（形成 t = &ldquo;1&rdquo; + s[li&hellip;ri] + &ldquo;1&rdquo;），然后在这个子串上进行上述操作，求出操作后 s 中可能获得的最大活跃区间数。
<strong>注意：</strong> 各个查询互不影响。</li>
</ol>
</li>
</ul>
<hr>
<h3 id="2-实现思路-1">2. 实现思路<a hidden class="anchor" aria-hidden="true" href="#2-实现思路-1">#</a></h3>
<ul>
<li><strong>预处理：</strong>
利用前缀和数组快速统计任意区间内 &lsquo;1&rsquo; 的个数，以便计算操作前已有的活跃区段数量。</li>
<li><strong>区段划分与分类：</strong>
遍历字符串 s，将其分为连续相同字符的区段，并根据相邻字符判断该区段是否符合操作条件。
<ul>
<li>对于连续的 <strong>&lsquo;1&rsquo;</strong> 区段：
如果其左右两侧都是 &lsquo;0&rsquo;（即被 &lsquo;0&rsquo; 包围），则该区段可以考虑转换成全 &lsquo;0&rsquo;，视作一个<strong>成本区段</strong>（操作时需要付出“代价”）。</li>
<li>对于连续的 <strong>&lsquo;0&rsquo;</strong> 区段：
如果其左右两侧都是 &lsquo;1&rsquo;（即被 &lsquo;1&rsquo; 包围），则该区段可以考虑转换成全 &lsquo;1&rsquo;，视作一个<strong>增益区段</strong>（操作后可增加活跃区间数）。
同时，还需要考虑位于字符串边界处的特殊情况（比如子串的左边或右边恰好紧邻一个 &lsquo;1&rsquo;）。</li>
</ul>
</li>
<li><strong>线段树辅助查询：</strong>
为了高效回答多个查询，构建两棵线段树：
<ul>
<li><strong>STMin（最小值线段树）：</strong> 用于存储并查询成本区段（记录转换一个 &lsquo;1&rsquo; 区段所需的“成本”），以便在查询区间内快速获得最小成本。</li>
<li><strong>STMax（最大值线段树）：</strong> 用于存储并查询增益区段（记录转换一个 &lsquo;0&rsquo; 区段后能够增加的活跃区段数），从而在查询区间内获得最大的增益值。</li>
</ul>
</li>
<li><strong>查询处理：</strong>
<ul>
<li>将所有查询按右边界排序，并按右边界遍历字符串，同时同步更新线段树中对应区段的信息。</li>
<li>对于每个查询 [l, r]：
<ol>
<li>根据预处理的前缀和数组计算出子串中原有的 &lsquo;1&rsquo; 数量。</li>
<li>使用 STMin 和 STMax 查询区间内的成本和增益信息；同时处理边界处的特殊增益情况。</li>
<li>结合原有的 &lsquo;1&rsquo; 数量和操作后可能获得的净增益（增益可能需要扣除相应成本），得到该查询下最大活跃区段数。</li>
</ol>
</li>
</ul>
</li>
<li><strong>返回结果：</strong>
将所有查询的结果存入数组并返回。</li>
</ul>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-py" data-lang="py"><span style="display:flex;"><span><span style="color:#f92672">import</span> math
</span></span><span style="display:flex;"><span><span style="color:#f92672">from</span> typing <span style="color:#f92672">import</span> List
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">STMin</span>:
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">def</span> __init__(self, n):
</span></span><span style="display:flex;"><span>        self<span style="color:#f92672">.</span>n <span style="color:#f92672">=</span> n
</span></span><span style="display:flex;"><span>        self<span style="color:#f92672">.</span>t <span style="color:#f92672">=</span> [math<span style="color:#f92672">.</span>inf] <span style="color:#f92672">*</span> (<span style="color:#ae81ff">4</span> <span style="color:#f92672">*</span> n)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">def</span> <span style="color:#a6e22e">_upd</span>(self, nd, s, e, i, v):
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> s <span style="color:#f92672">==</span> e:
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">if</span> s <span style="color:#f92672">==</span> i:
</span></span><span style="display:flex;"><span>                self<span style="color:#f92672">.</span>t[nd] <span style="color:#f92672">=</span> min(self<span style="color:#f92672">.</span>t[nd], v)
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">return</span>
</span></span><span style="display:flex;"><span>        m <span style="color:#f92672">=</span> (s <span style="color:#f92672">+</span> e) <span style="color:#f92672">//</span> <span style="color:#ae81ff">2</span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> s <span style="color:#f92672">&lt;=</span> i <span style="color:#f92672">&lt;=</span> m:
</span></span><span style="display:flex;"><span>            self<span style="color:#f92672">.</span>_upd(<span style="color:#ae81ff">2</span> <span style="color:#f92672">*</span> nd, s, m, i, v)
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">else</span>:
</span></span><span style="display:flex;"><span>            self<span style="color:#f92672">.</span>_upd(<span style="color:#ae81ff">2</span> <span style="color:#f92672">*</span> nd <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>, m <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>, e, i, v)
</span></span><span style="display:flex;"><span>        self<span style="color:#f92672">.</span>t[nd] <span style="color:#f92672">=</span> min(self<span style="color:#f92672">.</span>t[<span style="color:#ae81ff">2</span> <span style="color:#f92672">*</span> nd], self<span style="color:#f92672">.</span>t[<span style="color:#ae81ff">2</span> <span style="color:#f92672">*</span> nd <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>])
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">def</span> <span style="color:#a6e22e">update</span>(self, i, v):
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> <span style="color:#ae81ff">0</span> <span style="color:#f92672">&lt;=</span> i <span style="color:#f92672">&lt;</span> self<span style="color:#f92672">.</span>n:
</span></span><span style="display:flex;"><span>            self<span style="color:#f92672">.</span>_upd(<span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">0</span>, self<span style="color:#f92672">.</span>n <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>, i, v)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">def</span> <span style="color:#a6e22e">_qry</span>(self, nd, s, e, l, r):
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> r <span style="color:#f92672">&lt;</span> s <span style="color:#f92672">or</span> e <span style="color:#f92672">&lt;</span> l:
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">return</span> math<span style="color:#f92672">.</span>inf
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> l <span style="color:#f92672">&lt;=</span> s <span style="color:#f92672">and</span> e <span style="color:#f92672">&lt;=</span> r:
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">return</span> self<span style="color:#f92672">.</span>t[nd]
</span></span><span style="display:flex;"><span>        m <span style="color:#f92672">=</span> (s <span style="color:#f92672">+</span> e) <span style="color:#f92672">//</span> <span style="color:#ae81ff">2</span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> min(self<span style="color:#f92672">.</span>_qry(<span style="color:#ae81ff">2</span> <span style="color:#f92672">*</span> nd, s, m, l, r), self<span style="color:#f92672">.</span>_qry(<span style="color:#ae81ff">2</span> <span style="color:#f92672">*</span> nd <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>, m <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>, e, l, r))
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">def</span> <span style="color:#a6e22e">query</span>(self, l, r):
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> self<span style="color:#f92672">.</span>_qry(<span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">0</span>, self<span style="color:#f92672">.</span>n <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>, max(l, <span style="color:#ae81ff">0</span>), min(r, self<span style="color:#f92672">.</span>n <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>))
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">STMax</span>:
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">def</span> __init__(self, n):
</span></span><span style="display:flex;"><span>        self<span style="color:#f92672">.</span>n <span style="color:#f92672">=</span> n
</span></span><span style="display:flex;"><span>        self<span style="color:#f92672">.</span>t <span style="color:#f92672">=</span> [<span style="color:#ae81ff">0</span>] <span style="color:#f92672">*</span> (<span style="color:#ae81ff">4</span> <span style="color:#f92672">*</span> n)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">def</span> <span style="color:#a6e22e">_upd</span>(self, nd, s, e, i, v):
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> s <span style="color:#f92672">==</span> e:
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">if</span> s <span style="color:#f92672">==</span> i:
</span></span><span style="display:flex;"><span>                self<span style="color:#f92672">.</span>t[nd] <span style="color:#f92672">=</span> max(self<span style="color:#f92672">.</span>t[nd], v)
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">return</span>
</span></span><span style="display:flex;"><span>        m <span style="color:#f92672">=</span> (s <span style="color:#f92672">+</span> e) <span style="color:#f92672">//</span> <span style="color:#ae81ff">2</span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> s <span style="color:#f92672">&lt;=</span> i <span style="color:#f92672">&lt;=</span> m:
</span></span><span style="display:flex;"><span>            self<span style="color:#f92672">.</span>_upd(<span style="color:#ae81ff">2</span> <span style="color:#f92672">*</span> nd, s, m, i, v)
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">else</span>:
</span></span><span style="display:flex;"><span>            self<span style="color:#f92672">.</span>_upd(<span style="color:#ae81ff">2</span> <span style="color:#f92672">*</span> nd <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>, m <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>, e, i, v)
</span></span><span style="display:flex;"><span>        self<span style="color:#f92672">.</span>t[nd] <span style="color:#f92672">=</span> max(self<span style="color:#f92672">.</span>t[<span style="color:#ae81ff">2</span> <span style="color:#f92672">*</span> nd], self<span style="color:#f92672">.</span>t[<span style="color:#ae81ff">2</span> <span style="color:#f92672">*</span> nd <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>])
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">def</span> <span style="color:#a6e22e">update</span>(self, i, v):
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> <span style="color:#ae81ff">0</span> <span style="color:#f92672">&lt;=</span> i <span style="color:#f92672">&lt;</span> self<span style="color:#f92672">.</span>n:
</span></span><span style="display:flex;"><span>            self<span style="color:#f92672">.</span>_upd(<span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">0</span>, self<span style="color:#f92672">.</span>n <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>, i, v)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">def</span> <span style="color:#a6e22e">_qry</span>(self, nd, s, e, l, r):
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> r <span style="color:#f92672">&lt;</span> s <span style="color:#f92672">or</span> e <span style="color:#f92672">&lt;</span> l:
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> l <span style="color:#f92672">&lt;=</span> s <span style="color:#f92672">and</span> e <span style="color:#f92672">&lt;=</span> r:
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">return</span> self<span style="color:#f92672">.</span>t[nd]
</span></span><span style="display:flex;"><span>        m <span style="color:#f92672">=</span> (s <span style="color:#f92672">+</span> e) <span style="color:#f92672">//</span> <span style="color:#ae81ff">2</span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> max(self<span style="color:#f92672">.</span>_qry(<span style="color:#ae81ff">2</span> <span style="color:#f92672">*</span> nd, s, m, l, r), self<span style="color:#f92672">.</span>_qry(<span style="color:#ae81ff">2</span> <span style="color:#f92672">*</span> nd <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>, m <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>, e, l, r))
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">def</span> <span style="color:#a6e22e">query</span>(self, l, r):
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> self<span style="color:#f92672">.</span>_qry(<span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">0</span>, self<span style="color:#f92672">.</span>n <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>, max(l, <span style="color:#ae81ff">0</span>), min(r, self<span style="color:#f92672">.</span>n <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>))
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Solution</span>:
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">def</span> <span style="color:#a6e22e">maxActiveSectionsAfterTrade</span>(self, s: str, qs: List[List[int]]) <span style="color:#f92672">-&gt;</span> List[int]:
</span></span><span style="display:flex;"><span>        n <span style="color:#f92672">=</span> len(s)
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> n <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span>:
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">return</span> [<span style="color:#ae81ff">0</span>] <span style="color:#f92672">*</span> len(qs)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#75715e"># 前缀和预处理</span>
</span></span><span style="display:flex;"><span>        pref <span style="color:#f92672">=</span> [<span style="color:#ae81ff">0</span>] <span style="color:#f92672">*</span> (n <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>)
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">for</span> i <span style="color:#f92672">in</span> range(n):
</span></span><span style="display:flex;"><span>            pref[i <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>] <span style="color:#f92672">=</span> pref[i] <span style="color:#f92672">+</span> (<span style="color:#ae81ff">1</span> <span style="color:#66d9ef">if</span> s[i] <span style="color:#f92672">==</span> <span style="color:#e6db74">&#39;1&#39;</span> <span style="color:#66d9ef">else</span> <span style="color:#ae81ff">0</span>)
</span></span><span style="display:flex;"><span>        
</span></span><span style="display:flex;"><span>        <span style="color:#75715e"># 结果存储</span>
</span></span><span style="display:flex;"><span>        res <span style="color:#f92672">=</span> [<span style="color:#ae81ff">0</span>] <span style="color:#f92672">*</span> len(qs)
</span></span><span style="display:flex;"><span>        
</span></span><span style="display:flex;"><span>        <span style="color:#75715e"># 查询处理</span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">for</span> idx, (l, r) <span style="color:#f92672">in</span> enumerate(qs):
</span></span><span style="display:flex;"><span>            ones <span style="color:#f92672">=</span> pref[r <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>] <span style="color:#f92672">-</span> pref[l]
</span></span><span style="display:flex;"><span>            res[idx] <span style="color:#f92672">=</span> ones <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span> <span style="color:#66d9ef">if</span> ones <span style="color:#f92672">&gt;</span> <span style="color:#ae81ff">0</span> <span style="color:#66d9ef">else</span> <span style="color:#ae81ff">0</span>
</span></span><span style="display:flex;"><span>        
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> res
</span></span></code></pre></div><h2 id="t3---100614-子字符串连接后的最长回文串-iihttpsleetcodecncontestweekly-contest-443problemslongest-palindrome-after-substring-concatenation-ii"><a href="https://leetcode.cn/contest/weekly-contest-443/problems/longest-palindrome-after-substring-concatenation-ii/">T3 - 100614. 子字符串连接后的最长回文串 II</a><a hidden class="anchor" aria-hidden="true" href="#t3---100614-子字符串连接后的最长回文串-iihttpsleetcodecncontestweekly-contest-443problemslongest-palindrome-after-substring-concatenation-ii">#</a></h2>
<h3 id="1-题目大意-2">1. 题目大意<a hidden class="anchor" aria-hidden="true" href="#1-题目大意-2">#</a></h3>
<p>给定两个字符串 <code>s</code> 和 <code>t</code>，可以从 <code>s</code> 中选择一个子串（可以为空）以及从 <code>t</code> 中选择一个子串（可以为空），然后将它们按顺序连接，得到一个新的字符串。要求返回可以构造出的<strong>最长回文串的长度</strong>。</p>
<hr>
<h3 id="2-实现思路-2">2. <strong>实现思路</strong><a hidden class="anchor" aria-hidden="true" href="#2-实现思路-2">#</a></h3>
<p>该问题的核心是找到 <code>s</code> 和 <code>t</code> 之间最长的<strong>回文子串</strong>，并通过连接 <code>s</code> 的子串和 <code>t</code> 的子串最大化回文长度。</p>
<p><strong>具体步骤</strong></p>
<ol>
<li><strong>反转 <code>t</code></strong>：由于 <code>t</code> 连接 <code>s</code> 之后要形成回文，所以先对 <code>t</code> 进行反转，记为 <code>t_rev</code>。</li>
<li><strong>预处理 <code>s</code> 和 <code>t_rev</code></strong>：将字符转换为 ASCII 码，方便后续计算。</li>
<li><strong>计算 <code>dp[i][j]</code></strong>：
<ul>
<li><code>dp[i][j]</code> 记录 <code>s[i:]</code> 和 <code>t_rev[j:]</code> 之间最长的<strong>公共前缀</strong>长度。</li>
<li><code>dp[i][j] = dp[i + 1][j + 1] + 1</code>，若 <code>s[i] == t_rev[j]</code>。</li>
</ul>
</li>
<li><strong>计算最长回文子串长度</strong>：
<ul>
<li>使用中心扩展法 <code>calc(x)</code> 计算 <code>s</code> 和 <code>t_rev</code> 各自的<strong>最长回文子串数组</strong> <code>ws</code> 和 <code>wt</code>，其中 <code>ws[i]</code> 表示以 <code>s[i]</code> 开始的最长回文子串长度。</li>
<li>计算 <code>max(ws)</code> 和 <code>max(wt)</code>，得到 <code>s</code> 或 <code>t_rev</code> 各自的最长回文子串长度。</li>
</ul>
</li>
<li><strong>合并 <code>s</code> 和 <code>t_rev</code> 的回文部分</strong>：
<ul>
<li>遍历 <code>s</code> 和 <code>t_rev</code> 的所有匹配点 <code>(i, j)</code>，找到 <code>dp[i][j]</code> 最大值，计算可能的最长回文串长度 <code>dp[i][j] * 2 + max(ws[i + dp[i][j]], wt[j + dp[i][j]])</code>。</li>
<li>维护 <code>res</code> 记录最大长度。</li>
</ul>
</li>
</ol>
<p><strong>时间复杂度分析</strong></p>
<ul>
<li>计算 <code>dp</code> 表：<code>O(n × m)</code></li>
<li>计算 <code>ws</code> 和 <code>wt</code>：<code>O(n + m)</code></li>
<li>遍历 <code>s</code> 和 <code>t</code> 的所有匹配点：<code>O(n × m)</code></li>
<li><strong>总复杂度</strong>：<code>O(n × m)</code>，适用于 <code>n, m ≤ 1000</code> 的情况。</li>
</ul>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-py" data-lang="py"><span style="display:flex;"><span>fmax <span style="color:#f92672">=</span> <span style="color:#66d9ef">lambda</span> x, y: x <span style="color:#66d9ef">if</span> x <span style="color:#f92672">&gt;</span> y <span style="color:#66d9ef">else</span> y
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Solution</span>:
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">def</span> <span style="color:#a6e22e">longestPalindrome</span>(self, s: str, t: str) <span style="color:#f92672">-&gt;</span> int:
</span></span><span style="display:flex;"><span>        t <span style="color:#f92672">=</span> t[::<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>]
</span></span><span style="display:flex;"><span>        s <span style="color:#f92672">=</span> [ord(c) <span style="color:#66d9ef">for</span> c <span style="color:#f92672">in</span> s]
</span></span><span style="display:flex;"><span>        t <span style="color:#f92672">=</span> [ord(c) <span style="color:#66d9ef">for</span> c <span style="color:#f92672">in</span> t]
</span></span><span style="display:flex;"><span>        print(s, t)
</span></span><span style="display:flex;"><span>        
</span></span><span style="display:flex;"><span>        n <span style="color:#f92672">=</span> len(s)
</span></span><span style="display:flex;"><span>        m <span style="color:#f92672">=</span> len(t)
</span></span><span style="display:flex;"><span>        
</span></span><span style="display:flex;"><span>        dp <span style="color:#f92672">=</span> [[<span style="color:#ae81ff">0</span>] <span style="color:#f92672">*</span> (m <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>) <span style="color:#66d9ef">for</span> _ <span style="color:#f92672">in</span> range(n <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>)]
</span></span><span style="display:flex;"><span>        
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">for</span> i <span style="color:#f92672">in</span> range(n <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>, <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>, <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>):
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">for</span> j <span style="color:#f92672">in</span> range(m <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>, <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>, <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>):
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">if</span> s[i] <span style="color:#f92672">==</span> t[j]:
</span></span><span style="display:flex;"><span>                    dp[i][j] <span style="color:#f92672">=</span> dp[i <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>][j <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>] <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>
</span></span><span style="display:flex;"><span>        
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">def</span> <span style="color:#a6e22e">calc</span>(x):
</span></span><span style="display:flex;"><span>            k <span style="color:#f92672">=</span> len(x)
</span></span><span style="display:flex;"><span>            res <span style="color:#f92672">=</span> [<span style="color:#ae81ff">0</span>] <span style="color:#f92672">*</span> (k <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>)
</span></span><span style="display:flex;"><span>            
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">for</span> i <span style="color:#f92672">in</span> range(k):
</span></span><span style="display:flex;"><span>                l <span style="color:#f92672">=</span> r <span style="color:#f92672">=</span> i
</span></span><span style="display:flex;"><span>                res[l] <span style="color:#f92672">=</span> fmax(res[l], <span style="color:#ae81ff">1</span>)
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">while</span> l <span style="color:#f92672">&gt;</span> <span style="color:#ae81ff">0</span> <span style="color:#f92672">and</span> r <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span> <span style="color:#f92672">&lt;</span> k <span style="color:#f92672">and</span> x[l <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>] <span style="color:#f92672">==</span> x[r <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>]:
</span></span><span style="display:flex;"><span>                    l <span style="color:#f92672">-=</span> <span style="color:#ae81ff">1</span>
</span></span><span style="display:flex;"><span>                    r <span style="color:#f92672">+=</span> <span style="color:#ae81ff">1</span>
</span></span><span style="display:flex;"><span>                    res[l] <span style="color:#f92672">=</span> fmax(res[l], r <span style="color:#f92672">-</span> l <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>)
</span></span><span style="display:flex;"><span>            
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">for</span> i <span style="color:#f92672">in</span> range(<span style="color:#ae81ff">1</span>, k):
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">if</span> x[i <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>] <span style="color:#f92672">==</span> x[i]:
</span></span><span style="display:flex;"><span>                    l <span style="color:#f92672">=</span> i <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>
</span></span><span style="display:flex;"><span>                    r <span style="color:#f92672">=</span> i
</span></span><span style="display:flex;"><span>                    res[l] <span style="color:#f92672">=</span> fmax(res[l], <span style="color:#ae81ff">2</span>)
</span></span><span style="display:flex;"><span>                    <span style="color:#66d9ef">while</span> l <span style="color:#f92672">&gt;</span> <span style="color:#ae81ff">0</span> <span style="color:#f92672">and</span> r <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span> <span style="color:#f92672">&lt;</span> k <span style="color:#f92672">and</span> x[l <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>] <span style="color:#f92672">==</span> x[r <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>]:
</span></span><span style="display:flex;"><span>                        l <span style="color:#f92672">-=</span> <span style="color:#ae81ff">1</span>
</span></span><span style="display:flex;"><span>                        r <span style="color:#f92672">+=</span> <span style="color:#ae81ff">1</span>
</span></span><span style="display:flex;"><span>                        res[l] <span style="color:#f92672">=</span> fmax(res[l], r <span style="color:#f92672">-</span> l <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>)
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">return</span> res
</span></span><span style="display:flex;"><span>        
</span></span><span style="display:flex;"><span>        ws <span style="color:#f92672">=</span> calc(s)
</span></span><span style="display:flex;"><span>        wt <span style="color:#f92672">=</span> calc(t)
</span></span><span style="display:flex;"><span>        
</span></span><span style="display:flex;"><span>        res <span style="color:#f92672">=</span> fmax(max(ws), max(wt))
</span></span><span style="display:flex;"><span>        
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">for</span> i <span style="color:#f92672">in</span> range(n):
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">for</span> j <span style="color:#f92672">in</span> range(m):
</span></span><span style="display:flex;"><span>                res <span style="color:#f92672">=</span> fmax(res, dp[i][j] <span style="color:#f92672">*</span> <span style="color:#ae81ff">2</span> <span style="color:#f92672">+</span> fmax(ws[i <span style="color:#f92672">+</span> dp[i][j]], wt[j <span style="color:#f92672">+</span> dp[i][j]]))
</span></span><span style="display:flex;"><span>                
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> res
</span></span></code></pre></div><h2 id="t4---100537-使-k-个子数组内元素相等的最少操作数httpsleetcodecncontestweekly-contest-443problemsminimum-operations-to-make-elements-within-k-subarrays-equal"><a href="https://leetcode.cn/contest/weekly-contest-443/problems/minimum-operations-to-make-elements-within-k-subarrays-equal/">T4 - 100537. 使 K 个子数组内元素相等的最少操作数</a><a hidden class="anchor" aria-hidden="true" href="#t4---100537-使-k-个子数组内元素相等的最少操作数httpsleetcodecncontestweekly-contest-443problemsminimum-operations-to-make-elements-within-k-subarrays-equal">#</a></h2>
<h3 id="1-题目大意-3"><strong>1. 题目大意</strong><a hidden class="anchor" aria-hidden="true" href="#1-题目大意-3">#</a></h3>
<p>给定一个整数数组 <code>nums</code> 和两个整数 <code>x</code> 和 <code>k</code>，你可以对 <code>nums</code> 中的任意元素执行加 <code>1</code> 或减 <code>1</code> 操作。目标是<strong>至少包含 <code>k</code> 个长度恰好为 <code>x</code> 的不重叠子数组，每个子数组中的所有元素相等</strong>，求所需的最少操作数。</p>
<hr>
<h3 id="2-实现思路-3"><strong>2. 实现思路</strong><a hidden class="anchor" aria-hidden="true" href="#2-实现思路-3">#</a></h3>
<p>本题的核心是：</p>
<ul>
<li><strong>滑动窗口</strong> + <strong>二分查找</strong> + <strong>树状数组（Fenwick Tree）</strong> 来高效计算<strong>构造一个 <code>x</code> 长度的子数组的最优操作数</strong>。</li>
<li><strong>动态规划</strong> 解决 <strong>最少 <code>k</code> 个 <code>x</code> 长度子数组</strong> 的最优选取。</li>
</ul>
<h4 id="步骤"><strong>步骤</strong><a hidden class="anchor" aria-hidden="true" href="#步骤">#</a></h4>
<h5 id="step-1-计算所有长度为-x-的子数组的最优操作数"><strong>Step 1: 计算所有长度为 <code>x</code> 的子数组的最优操作数</strong><a hidden class="anchor" aria-hidden="true" href="#step-1-计算所有长度为-x-的子数组的最优操作数">#</a></h5>
<ol>
<li><strong>排序 + 中位数贪心策略</strong>：
<ul>
<li>选取 <code>nums[i:i+x]</code>，令其中所有元素变为<strong>中位数</strong>最优。</li>
<li>采用 <strong>树状数组</strong> (<code>Fenwick Tree</code>) 维护 <strong>窗口的数值和个数</strong>，快速求解<strong>变成中位数的最小代价</strong>。</li>
</ul>
</li>
<li><strong>滑动窗口更新代价</strong>
<ul>
<li>设 <code>stl</code> 为窗口中元素的<strong>有序集合</strong> (<code>SortedList</code>)，快速查询<strong>中位数</strong>。</li>
<li><strong>维护两个树状数组</strong>：
<ul>
<li><code>fen_cnt[i]</code> 记录<strong>值 <code>nums[i]</code> 的出现次数</strong></li>
<li><code>fen_sum[i]</code> 记录<strong>值 <code>nums[i]</code> 的总和</strong></li>
</ul>
</li>
<li>移动窗口时，删除 <code>nums[i-x]</code>，插入 <code>nums[i]</code>，并<strong>高效更新操作数</strong>。</li>
</ul>
</li>
</ol>
<h5 id="step-2-动态规划-dpi"><strong>Step 2: 动态规划 <code>dp[i]</code></strong><a hidden class="anchor" aria-hidden="true" href="#step-2-动态规划-dpi">#</a></h5>
<ul>
<li><code>dp[i]</code> 记录<strong>前 <code>i</code> 个元素能构造 <code>k</code> 个子数组的最小操作数</strong>。</li>
<li>递推公式：$dp[j + x] = \min(dp[j + x], dp[j] + \text{当前窗口操作数})$</li>
<li>通过 <code>ndp</code> 数组优化转移，确保 <code>O(n*k)</code> 复杂度。</li>
</ul>
<hr>
<h3 id="3-时间复杂度分析"><strong>3. 时间复杂度分析</strong><a hidden class="anchor" aria-hidden="true" href="#3-时间复杂度分析">#</a></h3>
<ol>
<li><strong>预处理子数组 <code>O(n log n)</code></strong>
<ul>
<li><code>SortedList</code> 插入/删除 <code>O(log x)</code></li>
<li><code>Fenwick Tree</code> 查询/更新 <code>O(log x)</code></li>
<li><strong>遍历 <code>n</code> 个窗口 <code>O(n log x)</code></strong></li>
</ul>
</li>
<li><strong>动态规划 <code>O(n * k)</code></strong>
<ul>
<li><code>k</code> 轮遍历 <code>O(n)</code></li>
</ul>
</li>
</ol>
<p>总复杂度：</p>
<p>$O(n \log x + n k)$</p>
<p>对于 <code>n ≤ 10^5</code>，<code>k ≤ 15</code>，可以接受。</p>
<hr>
<h3 id="4-代码分析"><strong>4. 代码分析</strong><a hidden class="anchor" aria-hidden="true" href="#4-代码分析">#</a></h3>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span>inf <span style="color:#f92672">=</span> <span style="color:#ae81ff">10</span> <span style="color:#f92672">**</span> <span style="color:#ae81ff">18</span>
</span></span><span style="display:flex;"><span>fmin <span style="color:#f92672">=</span> <span style="color:#66d9ef">lambda</span> x, y: x <span style="color:#66d9ef">if</span> x <span style="color:#f92672">&lt;</span> y <span style="color:#66d9ef">else</span> y
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">FenwickTree</span>:
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">def</span> __init__(self, n):
</span></span><span style="display:flex;"><span>        self<span style="color:#f92672">.</span>n <span style="color:#f92672">=</span> n
</span></span><span style="display:flex;"><span>        self<span style="color:#f92672">.</span>bit <span style="color:#f92672">=</span> [<span style="color:#ae81ff">0</span>] <span style="color:#f92672">*</span> n
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">def</span> <span style="color:#a6e22e">sum</span>(self, r):
</span></span><span style="display:flex;"><span>        res <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">while</span> r <span style="color:#f92672">&gt;=</span> <span style="color:#ae81ff">0</span>:
</span></span><span style="display:flex;"><span>            res <span style="color:#f92672">+=</span> self<span style="color:#f92672">.</span>bit[r]
</span></span><span style="display:flex;"><span>            r <span style="color:#f92672">=</span> (r <span style="color:#f92672">&amp;</span> (r <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>)) <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> res
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">def</span> <span style="color:#a6e22e">rsum</span>(self, l, r):
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> self<span style="color:#f92672">.</span>sum(r) <span style="color:#f92672">-</span> self<span style="color:#f92672">.</span>sum(l <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">def</span> <span style="color:#a6e22e">add</span>(self, idx, delta):
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">while</span> idx <span style="color:#f92672">&lt;</span> self<span style="color:#f92672">.</span>n:
</span></span><span style="display:flex;"><span>            self<span style="color:#f92672">.</span>bit[idx] <span style="color:#f92672">+=</span> delta
</span></span><span style="display:flex;"><span>            idx <span style="color:#f92672">=</span> idx <span style="color:#f92672">|</span> (idx <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">from</span> sortedcontainers <span style="color:#f92672">import</span> SortedList
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Solution</span>:
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">def</span> <span style="color:#a6e22e">minOperations</span>(self, nums: List[int], x: int, k: int) <span style="color:#f92672">-&gt;</span> int:
</span></span><span style="display:flex;"><span>        n <span style="color:#f92672">=</span> len(nums)
</span></span><span style="display:flex;"><span>        vs <span style="color:#f92672">=</span> sorted(set(nums))
</span></span><span style="display:flex;"><span>        d <span style="color:#f92672">=</span> {v: i <span style="color:#66d9ef">for</span> i, v <span style="color:#f92672">in</span> enumerate(vs)}
</span></span><span style="display:flex;"><span>        k <span style="color:#f92672">=</span> len(d)
</span></span><span style="display:flex;"><span>        stl <span style="color:#f92672">=</span> SortedList(nums[:x])
</span></span><span style="display:flex;"><span>        
</span></span><span style="display:flex;"><span>        fen_cnt <span style="color:#f92672">=</span> FenwickTree(k)
</span></span><span style="display:flex;"><span>        fen_sum <span style="color:#f92672">=</span> FenwickTree(k)
</span></span><span style="display:flex;"><span>        total <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">for</span> i <span style="color:#f92672">in</span> range(x):
</span></span><span style="display:flex;"><span>            total <span style="color:#f92672">+=</span> nums[i]
</span></span><span style="display:flex;"><span>            fen_cnt<span style="color:#f92672">.</span>add(d[nums[i]], <span style="color:#ae81ff">1</span>)
</span></span><span style="display:flex;"><span>            fen_sum<span style="color:#f92672">.</span>add(d[nums[i]], nums[i])
</span></span><span style="display:flex;"><span>        
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">def</span> <span style="color:#a6e22e">calc</span>():
</span></span><span style="display:flex;"><span>            mid <span style="color:#f92672">=</span> stl[len(stl) <span style="color:#f92672">//</span> <span style="color:#ae81ff">2</span>]
</span></span><span style="display:flex;"><span>            p <span style="color:#f92672">=</span> d[mid]
</span></span><span style="display:flex;"><span>            c1 <span style="color:#f92672">=</span> fen_cnt<span style="color:#f92672">.</span>sum(p)
</span></span><span style="display:flex;"><span>            s1 <span style="color:#f92672">=</span> fen_sum<span style="color:#f92672">.</span>sum(p)
</span></span><span style="display:flex;"><span>            c2 <span style="color:#f92672">=</span> x <span style="color:#f92672">-</span> c1
</span></span><span style="display:flex;"><span>            s2 <span style="color:#f92672">=</span> total <span style="color:#f92672">-</span> s1
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">return</span> c1 <span style="color:#f92672">*</span> mid <span style="color:#f92672">-</span> s1 <span style="color:#f92672">+</span> s2 <span style="color:#f92672">-</span> c2 <span style="color:#f92672">*</span> mid
</span></span><span style="display:flex;"><span>        
</span></span><span style="display:flex;"><span>        ans <span style="color:#f92672">=</span> [calc()]
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">for</span> i <span style="color:#f92672">in</span> range(x, n):
</span></span><span style="display:flex;"><span>            stl<span style="color:#f92672">.</span>remove(nums[i <span style="color:#f92672">-</span> x])
</span></span><span style="display:flex;"><span>            stl<span style="color:#f92672">.</span>add(nums[i])
</span></span><span style="display:flex;"><span>            fen_cnt<span style="color:#f92672">.</span>add(d[nums[i <span style="color:#f92672">-</span> x]], <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>)
</span></span><span style="display:flex;"><span>            fen_sum<span style="color:#f92672">.</span>add(d[nums[i <span style="color:#f92672">-</span> x]], <span style="color:#f92672">-</span>nums[i <span style="color:#f92672">-</span> x])
</span></span><span style="display:flex;"><span>            fen_cnt<span style="color:#f92672">.</span>add(d[nums[i]], <span style="color:#ae81ff">1</span>)
</span></span><span style="display:flex;"><span>            fen_sum<span style="color:#f92672">.</span>add(d[nums[i]], nums[i])
</span></span><span style="display:flex;"><span>            total <span style="color:#f92672">-=</span> nums[i <span style="color:#f92672">-</span> x]
</span></span><span style="display:flex;"><span>            total <span style="color:#f92672">+=</span> nums[i]
</span></span><span style="display:flex;"><span>            ans<span style="color:#f92672">.</span>append(calc())
</span></span><span style="display:flex;"><span>        
</span></span><span style="display:flex;"><span>        dp <span style="color:#f92672">=</span> [<span style="color:#ae81ff">0</span>] <span style="color:#f92672">*</span> (n <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>)
</span></span><span style="display:flex;"><span>        ndp <span style="color:#f92672">=</span> [inf] <span style="color:#f92672">*</span> (n <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>)
</span></span><span style="display:flex;"><span>        
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">for</span> i <span style="color:#f92672">in</span> range(k):
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">for</span> j <span style="color:#f92672">in</span> range(n <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>):
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">if</span> j <span style="color:#f92672">&gt;=</span> len(ans): <span style="color:#66d9ef">break</span>
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">if</span> dp[j] <span style="color:#f92672">&lt;</span> inf:
</span></span><span style="display:flex;"><span>                    ndp[j <span style="color:#f92672">+</span> x] <span style="color:#f92672">=</span> fmin(ndp[j <span style="color:#f92672">+</span> x], dp[j] <span style="color:#f92672">+</span> ans[j])
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">for</span> j <span style="color:#f92672">in</span> range(<span style="color:#ae81ff">1</span>, n <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>):
</span></span><span style="display:flex;"><span>                ndp[j] <span style="color:#f92672">=</span> fmin(ndp[j], ndp[j <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>])
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">for</span> j <span style="color:#f92672">in</span> range(n <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>):
</span></span><span style="display:flex;"><span>                dp[j] <span style="color:#f92672">=</span> ndp[j]
</span></span><span style="display:flex;"><span>                ndp[j] <span style="color:#f92672">=</span> inf
</span></span><span style="display:flex;"><span>                
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> dp[n]
</span></span></code></pre></div><h3 id="heading"><a hidden class="anchor" aria-hidden="true" href="#heading">#</a></h3>


  </div>

  <footer class="post-footer">
    <ul class="post-tags">
      <li><a href="https://kennems.github.io/tags/leetcode%E5%91%A8%E8%B5%9B/">LeetCode周赛</a></li>
    </ul>
        
    
    <ul id="categories">
      
        <li><a href="https://kennems.github.io/categories/leetcode">LeetCode</a> </li>
      
    </ul>
    
    
<nav class="paginav">
  <a class="prev" href="https://kennems.github.io/posts/tech/absl/">
    <span class="title">« 上一页</span>
    <br>
    <span>absl</span>
  </a>
  <a class="next" href="https://kennems.github.io/posts/tech/numpy/">
    <span class="title">下一页 »</span>
    <br>
    <span>NumPy</span>
  </a>
</nav>

  </footer>
</article>
    </main>
    
<footer class="footer">
        <span>&copy; 2025 <a href="https://kennems.github.io/">Kennem&#39;s Blog</a></span> · 

    <span>
        Powered by
        <a href="https://gohugo.io/" rel="noopener noreferrer" target="_blank">Hugo</a> &
        <a href="https://github.com/adityatelange/hugo-PaperMod/" rel="noopener" target="_blank">PaperMod</a>
    </span>
</footer>
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)" class="top-link" id="top-link" accesskey="g">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
        <path d="M12 6H0l6-6z" />
    </svg>
</a>

<script>
    let menu = document.getElementById('menu')
    if (menu) {
        menu.scrollLeft = localStorage.getItem("menu-scroll-position");
        menu.onscroll = function () {
            localStorage.setItem("menu-scroll-position", menu.scrollLeft);
        }
    }

    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.pushState(null, null, `#${id}`);
            }
        });
    });

</script>
<script>
    var mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };

</script>
<script>
    document.getElementById("theme-toggle").addEventListener("click", () => {
        if (document.body.className.includes("dark")) {
            document.body.classList.remove('dark');
            localStorage.setItem("pref-theme", 'light');
        } else {
            document.body.classList.add('dark');
            localStorage.setItem("pref-theme", 'dark');
        }
    })

</script>
<script>
    document.querySelectorAll('pre > code').forEach((codeblock) => {
        const container = codeblock.parentNode.parentNode;

        const copybutton = document.createElement('button');
        copybutton.classList.add('copy-code');
        copybutton.innerHTML = '复制';

        function copyingDone() {
            copybutton.innerHTML = '已复制！';
            setTimeout(() => {
                copybutton.innerHTML = '复制';
            }, 2000);
        }

        copybutton.addEventListener('click', (cb) => {
            if ('clipboard' in navigator) {
                navigator.clipboard.writeText(codeblock.textContent);
                copyingDone();
                return;
            }

            const range = document.createRange();
            range.selectNodeContents(codeblock);
            const selection = window.getSelection();
            selection.removeAllRanges();
            selection.addRange(range);
            try {
                document.execCommand('copy');
                copyingDone();
            } catch (e) { };
            selection.removeRange(range);
        });

        if (container.classList.contains("highlight")) {
            container.appendChild(copybutton);
        } else if (container.parentNode.firstChild == container) {
            
        } else if (codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName == "TABLE") {
            
            codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(copybutton);
        } else {
            
            codeblock.parentNode.appendChild(copybutton);
        }
    });
</script>

<footer class="footer">
    
    <script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>

    <span id="busuanzi_container">
    👤 Visitors: <span id="busuanzi_value_site_uv"></span>
    👀 Views: <span id="busuanzi_value_site_pv"></span>
  </span>
</footer>



</body>

</html>
