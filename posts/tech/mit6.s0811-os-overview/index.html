<!DOCTYPE html>
<html lang="zh" dir="auto">

<head><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="index, follow">

<meta name="msvalidate.01" content="DF5FE493CC759E62BFE073BEA8EFD472" />
<title>MIT6.S081(1)-O/S overview | Kennem&#39;s Blog</title>
<meta name="keywords" content="MIT6.S081">
<meta name="description" content="MIT6.S081(1)">
<meta name="author" content="ShowGuan">
<link rel="canonical" href="https://kennems.github.io/posts/tech/mit6.s0811-os-overview/">
<link crossorigin="anonymous" href="/assets/css/stylesheet.6fdd1949bc615fbdbd83115b51397fd1d48449cdd9f5e872a98212bb78d466ea.css" integrity="sha256-b90ZSbxhX729gxFbUTl/0dSESc3Z9ehyqYISu3jUZuo=" rel="preload stylesheet" as="style">
<link rel="icon" href="https://kennems.github.io/img/sun.png">
<link rel="icon" type="image/png" sizes="16x16" href="https://kennems.github.io/img/sun.png">
<link rel="icon" type="image/png" sizes="32x32" href="https://kennems.github.io/img/sun.png">
<link rel="apple-touch-icon" href="https://kennems.github.io/img/sun.png">
<link rel="mask-icon" href="https://kennems.github.io/img/sun.png">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<link rel="alternate" hreflang="zh" href="https://kennems.github.io/posts/tech/mit6.s0811-os-overview/">
<noscript>
    <style>
        #theme-toggle,
        .top-link {
            display: none;
        }

    </style>
    <style>
        @media (prefers-color-scheme: dark) {
            :root {
                --theme: rgb(29, 30, 32);
                --entry: rgb(46, 46, 51);
                --primary: rgb(218, 218, 219);
                --secondary: rgb(155, 156, 157);
                --tertiary: rgb(65, 66, 68);
                --content: rgb(196, 196, 197);
                --code-block-bg: rgb(46, 46, 51);
                --code-bg: rgb(55, 56, 62);
                --border: rgb(51, 51, 51);
            }

            .list {
                background: var(--theme);
            }

            .list:not(.dark)::-webkit-scrollbar-track {
                background: 0 0;
            }

            .list:not(.dark)::-webkit-scrollbar-thumb {
                border-color: var(--theme);
            }
        }

    </style>
</noscript>

<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.2/dist/katex.min.css" integrity="sha384-MlJdn/WNKDGXveldHDdyRP1R4CTHr3FeuDNfhsLPYrq2t0UBkUdK2jyTnXPEK1NQ" crossorigin="anonymous">

<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.2/dist/katex.min.js" integrity="sha384-VQ8d8WVFw0yHhCk5E8I86oOhv48xLpnDZx5T9GogA/Y84DcCKWXDmSDfn13bzFZY" crossorigin="anonymous"></script>

<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.2/dist/contrib/auto-render.min.js" integrity="sha384-+XBljXPPiv+OzfbB3cVmLHf4hdUFHlWNZN5spNQ7rmHTXpd7WvJum6fIACpNNfIR" crossorigin="anonymous"
    onload="renderMathInElement(document.body);"></script>


<script>
document.addEventListener("DOMContentLoaded", function() {
    renderMathInElement(document.body, {
        delimiters: [
            {left: "$$", right: "$$", display: true},
            {left: "$", right: "$", display: false}
        ]
    });
});
</script>


<link href="https://fonts.cdnfonts.com/css/code-new-roman" rel="stylesheet">
                
  

<meta property="og:url" content="https://kennems.github.io/posts/tech/mit6.s0811-os-overview/">
  <meta property="og:site_name" content="Kennem&#39;s Blog">
  <meta property="og:title" content="MIT6.S081(1)-O/S overview">
  <meta property="og:description" content="MIT6.S081(1)">
  <meta property="og:locale" content="zh">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2024-08-31T22:30:13+08:00">
    <meta property="article:modified_time" content="2024-08-31T22:20:13+08:00">
    <meta property="article:tag" content="MIT6.S081">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="MIT6.S081(1)-O/S overview">
<meta name="twitter:description" content="MIT6.S081(1)">


<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BreadcrumbList",
  "itemListElement": [
    {
      "@type": "ListItem",
      "position":  1 ,
      "name": "📚文章",
      "item": "https://kennems.github.io/posts/"
    }, 
    {
      "@type": "ListItem",
      "position":  2 ,
      "name": "💻技术",
      "item": "https://kennems.github.io/posts/tech/"
    }, 
    {
      "@type": "ListItem",
      "position":  3 ,
      "name": "MIT6.S081(1)-O/S overview",
      "item": "https://kennems.github.io/posts/tech/mit6.s0811-os-overview/"
    }
  ]
}
</script>
<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "MIT6.S081(1)-O/S overview",
  "name": "MIT6.S081(1)-O\/S overview",
  "description": "MIT6.S081(1)",
  "keywords": [
    "MIT6.S081"
  ],
  "articleBody": "MIT6.S081(1)-O/S overview Class Page Overview 6.S081 goals Understand operating system (O/S) design and implementation Hands-on experience extending a small O/S Hands-on experience writing systems software What is the purpose of an O/S? Abstract the hardware for convenience and portability Multiplex the hardware among many applications Isolate applications in order to contain bugs Allow sharing among cooperating applications Control sharing for security Don’t get in the way of high performance Support a wide range of applications Organization: layered picture user applications: vi, gcc, DB, \u0026c kernel services h/w: CPU, RAM, disk, net, \u0026c we care a lot about the interfaces and internal kernel structure What services does an O/S kernel typically provide? process (a running program) memory allocation file contents file names, directories access control (security) many others: users, IPC（Inter-Process Communication）, network, time, terminals What’s the application / kernel interface? “System calls”\nExamples, in C, from UNIX (e.g. Linux, macOS, FreeBSD):\nfd = open(\"out\", 1); write(fd, \"hello\\n\", 6); pid = fork(); These look like function calls but they aren’t\nSystem Calls 函数名 功能描述 int fork() 创建一个进程，返回子进程的 PID。 int exit(int status) 终止当前进程，status 返回给 wait()，不返回。 int wait(int *status) 等待子进程退出，退出状态存入 *status，返回子进程的 PID。 int kill(int pid) 终止进程 PID。返回 0 或 -1（表示错误）。 int getpid() 返回当前进程的 PID。 int sleep(int n) 暂停 n 个时钟周期。 int exec(char *file, char *argv[]) 加载并执行文件 file，传入参数 argv[]，仅在发生错误时返回。 char *sbrk(int n) 增加 n 字节的进程内存，返回新内存的起始地址。 int open(char *file, int flags) 打开文件，flags 指示读/写模式，返回文件描述符。 int write(int fd, char *buf, int n) 从 buf 中向文件描述符 fd 写入 n 字节，返回写入的字节数。 int read(int fd, char *buf, int n) 从文件描述符 fd 中读取 n 字节到 buf，返回读取的字节数或 0（文件结束）。 int close(int fd) 关闭文件描述符 fd。 int dup(int fd) 返回一个新的文件描述符，指向与 fd 相同的文件。 int pipe(int p[]) 创建一个管道，将读/写文件描述符放入 p[0] 和 p[1]。 int chdir(char *dir) 更改当前目录为 dir。 int mkdir(char *dir) 创建一个新目录 dir。 int mknod(char *file, int, int) 创建一个设备文件。 int fstat(int fd, struct stat *st) 将关于打开文件的信息放入 *st。 int stat(char *file, struct stat *st) 将关于文件 file 的信息放入 *st。 int link(char *file1, char *file2) 为文件 file1 创建另一个名称 file2。 int unlink(char *file) 删除文件 file。 Why is O/S design + implementation hard and interesting? unforgiving environment: quirky h/w, hard to debug\nmany design tensions:\nefficient vs abstract / portable / general-purpose powerful vs simple interfaces flexible vs secure features interact: fd = open(); fork()\nuses are varied: laptops, smart-phones, cloud, virtual machines, embedded\nevolving hardware: NVRAM, multi-core, fast networks\nYou’ll be glad you took this course if you…\ncare about what goes on under the hood like infrastructure need to track down bugs or security problems care about high performance Class structure Online course information: https://pdos.csail.mit.edu/6.S081/2020 – schedule, assignments, labs Piazza – announcements, discussion, lab help\nLectures\nO/S ideas case study of xv6, a small O/S, via code and xv6 book lab background O/S papers submit a question about each reading, before lecture. Labs: The point: hands-on experience Mostly one week each. Three kinds: Systems programming (due next week…) O/S primitives, e.g. thread switching. O/S kernel extensions to xv6, e.g. network. Use piazza to ask/answer lab questions. Discussion is great, but please do not look at others’ solutions!\nGrading: 70% labs, based on tests (the same tests you run). 20% lab check-off meetings: we’ll ask you about randomly-selected labs. 10% home-work and class/piazza discussion. No exams, no quizzes. Note that most of the grade is from labs. Start them early!\nIntroduction to UNIX system calls I’ll show some examples, and run them on xv6. xv6 has similar structure to UNIX systems such as Linux. but much simpler – you’ll be able to digest all of xv6 accompanying book explains how xv6 works, and why Why UNIX? open source, well documented, clean design, widely used studying xv6 will help if you ever need to look inside Linux xv6 has two roles in 6.S081: example of core functions: virtual memory, multi-core, interrupts, \u0026c starting point for most of the labs xv6 runs on RISC-V, as in current 6.004 you’ll run xv6 under the qemu machine emulator\nExample: copy.c, copy input to output read bytes from input, write them to the output\n$ copy copy.c is written in C Kernighan and Ritchie (K\u0026R) book is good for learning C you can find these example programs via the schedule on the web site\ncopy.c // copy.c: 复制输入到输出 #include \"kernel/types.h\" // 包含系统调用相关的类型定义 #include \"user/user.h\" // 包含用户态函数的声明（如 read, write, exit） int main() { char buf[64]; // 定义一个缓冲区，用于存储读取的数据 // 无限循环，直到读取到文件结束标志或出现错误 while(1){ // 从标准输入（文件描述符 0）中读取数据到 buf 中 int n = read(0, buf, sizeof(buf)); // 如果读取到的数据量小于等于 0，则表示输入结束或发生了错误 if(n \u003c= 0) break; // 退出循环 // 将读取的数据写入标准输出（文件描述符 1） write(1, buf, n); } // 正常退出程序 exit(0); } read() and write() are system calls first read()/write() argument is a \"file descriptor\" (fd) passed to kernel to tell it which “open file” to read/write must previously have been opened\nan FD connects to a file/device/socket/\u0026c a process can open many files, have many FDs\nUNIX convention: fd 0 is “standard input”, 1 is “standard output”\nsecond read() argument is a pointer to some memory into which to read\nthird argument is the maximum number of bytes to read read() may read less, but not more return value: number of bytes actually read, or -1 for error\nnote: copy.c does not care about the format of the data UNIX I/O is 8-bit bytes interpretation is application-specific, e.g. database records, C source, \u0026c\nWhere do file descriptors come from? example: open.c, create a file\n$ open $ cat output.txt open() creates a file, returns a file descriptor (or -1 for error) FD is a small integer FD indexes into a per-process table maintained by kernel [user/kernel diagram] different processes have different FD name-spaces i.e. FD 1 often means different things to different processes these examples ignore errors – don’t be this sloppy! Figure 1.2 in the xv6 book lists system call arguments/return or look at UNIX man pages, e.g. “man 2 open”\nWhat happens when a program calls a system call like open()? looks like a function call, but it’s actually a special instruction hardware saves some user registers hardware increases privilege level hardware jumps to a known “entry point” in the kernel now running C code in the kernel kernel calls system call implementation open() looks up name in file system it might wait for the disk it updates kernel data structures (cache, FD table) restore user registers reduce privilege level jump back to calling point in the program, which resumes we’ll see more detail later in the course\nI’ve been typing to UNIX’s command-line interface, the shell. the shell prints the “$” prompts. the shell lets you run UNIX command-line utilities useful for system management, messing with files, development, scripting\n$ ls $ ls \u003e out $ grep x \u003c out UNIX supports other styles of interaction too window systems, GUIs, servers, routers, \u0026c. but time-sharing via the shell was the original focus of UNIX. we can exercise many system calls via the shell.\nexample: fork.c, create a new process\n​\tthe shell creates a new process for each command you type, e.g. for\n$ echo hello the fork() system call creates a new process\n$ fork the kernel makes a copy of the calling process instructions, data, registers, file descriptors, current directory “parent” and “child” processes only difference: fork() returns a pid in parent, 0 in child a pid (process ID) is an integer, kernel gives each process a different pid thus: fork.c’s “fork() returned” executes in both processes the “if(pid == 0)” allows code to distinguish ok, fork lets us create a new process how can we run a program in that process?\nexample: exec.c, replace calling process with an executable file how does the shell run a program, e.g.\n$ echo a b c a program is stored in a file: instructions and initial memory created by the compiler and linker so there’s a file called echo, containing instructions\n$ exec exec() replaces current process with an executable file discards instruction and data memory loads instructions and memory from the file preserves file descriptors exec(filename, argument-array) argument-array holds command-line arguments; exec passes to main() cat user/echo.c echo.c shows how a program looks at its command-line arguments\nexample: forkexec.c, fork() a new process, exec() a program\n$ forkexec forkexec.c contains a common UNIX idiom: fork() : a child process exec() : a command in the child parent wait()s for child to finish the shell does fork/exec/wait for every command you type after wait(), the shell prints the next prompt to run in the background – \u0026 – the shell skips the wait() exit(status) -\u003e wait(\u0026status) status convention: 0 = success, 1 = command encountered an error note: the fork() copies, but exec() discards the copied memory this may seem wasteful you’ll transparently eliminate the copy in the “copy-on-write” lab\nfork 和 exec 的区别 fork 用于创建新进程，父子进程并发执行。\nexec 用于在现有进程中加载并运行新程序。\nfork 系统调用 功能：fork 用于创建一个新进程，称为子进程。子进程是通过复制当前进程（父进程）的地址空间创建的，因此子进程和父进程几乎完全相同，拥有相同的代码、数据和打开的文件描述符。 执行结果： 父进程调用 fork 后，返回值是子进程的 PID。 子进程从 fork 返回时，返回值是 0。 特点： 子进程是父进程的几乎精确副本，包括文件描述符、变量、代码段等，但其 PID（进程 ID）不同。 并发执行：fork 之后，父进程和子进程可以并发执行各自的代码。 多次返回：fork 会返回两次，一次在父进程中，一次在子进程中。 exec 系统调用 功能：exec 用于替换当前进程的代码和数据段，加载一个新程序并执行该程序。当 exec 被调用时，当前进程的所有内容（如代码、数据、堆栈）都被新程序替换，但进程的 PID 不变。 执行结果： exec 不返回，除非调用失败。成功调用 exec 后，旧的程序代码完全被新程序替换。 文件描述符不会被关闭（除非设置了 close-on-exec 标志）。 特点： exec 只会改变进程的执行代码，不会创建新的进程。 新程序继承了调用进程的 PID 和文件描述符，但原有的内存数据、堆栈、代码等都会被新程序替换掉。 example: redirect.c, redirect the output of a command what does the shell do for this?\n$ echo hello \u003e out answer: fork, change FD 1 in child, exec echo\n$ redirect $ cat output.txt note: open() always chooses lowest unused FD; 1 due to close(1). fork, FDs, and exec interact nicely to implement I/O redirection separate fork-then-exec give child a chance to change FDs before exec FDs provide indirection commands just use FDs 0 and 1, don’t have to know where they go exec preserves the FDs that sh set up thus: only sh has to know about I/O redirection, not each program\nIt’s worth asking “why” about design decisions: Why these I/O and process abstractions? Why not something else? Why provide a file system? Why not let programs use the disk their own way? Why FDs? Why not pass a filename to write()? Why are files streams of bytes, not disk blocks or formatted records? Why not combine fork() and exec()? The UNIX design works well, but we will see other designs!\nexample: pipe1.c, communicate through a pipe how does the shell implement\n$ ls | grep x $ pipe1 an FD can refer to a “pipe”, as well as a file the pipe() system call creates two FDs read from the first FD write to the second FD the kernel maintains a buffer for each pipe [u/k diagram] write() appends to the buffer read() waits until there is data\nexample: pipe2.c, communicate between processes pipes combine well with fork() to implement ls | grep x shell creates a pipe, then forks (twice), then connects ls’s FD 1 to pipe’s write FD, and grep’s FD 0 to the pipe [diagram]\n$ pipe2 -- a simplified version pipes are a separate abstraction, but combine well w/ fork()\nexample: list.c, list files in a directory how does ls get a list of the files in a directory? you can open a directory and read it -\u003e file names “.” is a pseudo-name for a process’s current directory see ls.c for more details\nSummary We’ve looked at UNIX’s I/O, file system, and process abstractions. The interfaces are simple – just integers and I/O buffers. The abstractions combine well, e.g. for I/O redirection. You’ll use these system calls in the first lab, due next week.\nCode Pipes int pipeFd[2]; // 管道文件描述符数组，pipeFd[0]为读取端，pipeFd[1]为写入端 char *arguments[2]; // 存储传递给exec的参数 int main() { // 设置要执行的命令和参数 arguments[0] = \"wc\"; // 将 \"wc\" 命令作为参数传递给exec，用于统计输入的行、单词和字符数 arguments[1] = 0; // 以NULL表示参数结束 // 创建管道 pipe(pipeFd); // pipeFd[0]用于读取，pipeFd[1]用于写入 // 创建子进程 if(fork() == 0) { // 子进程代码，fork()返回0表示当前是子进程 close(0); // 关闭标准输入（文件描述符0） dup(pipeFd[0]); // 将管道的读取端复制到文件描述符0，使标准输入重定向到管道的读取端 close(pipeFd[0]); // 关闭管道的读取端，已重定向到标准输入，不再需要 close(pipeFd[1]); // 关闭管道的写入端，子进程不负责写入数据 exec(\"/bin/wc\", arguments); // 执行wc命令，读取标准输入（从管道中读取），计算行、单词和字符数 } else { // 父进程代码 close(pipeFd[0]); // 关闭管道的读取端，父进程不负责读取数据 // 向管道写入数据 write(pipeFd[1], \"hello world\\n\", 12); // 将 \"hello world\\n\" 写入管道，供子进程读取 close(pipeFd[1]); // 关闭管道的写入端，表示数据写入完成 } return 0; } cat.c #include \"kernel/types.h\" // 包含系统调用相关的类型定义 #include \"kernel/stat.h\" // 包含文件状态相关的定义 #include \"user/user.h\" // 包含用户态函数的声明（如 read, write, open, close, fprintf, exit） char buf[512]; // 定义一个缓冲区，用于存储读取的数据 // 函数：cat // 参数：int fd - 文件描述符 // 功能：从文件描述符 fd 中读取数据，并将其写入标准输出（文件描述符 1） void cat(int fd) { int n; // 从文件描述符 fd 中读取数据到 buf 中，读取的字节数存储在 n 中 while((n = read(fd, buf, sizeof(buf))) \u003e 0) { // 将读取的数据写入标准输出 if (write(1, buf, n) != n) { // 如果写入的字节数不等于读取的字节数，报告写入错误 fprintf(2, \"cat: write error\\n\"); exit(1); } } // 如果读取过程中出现错误，报告读取错误并退出 if(n \u003c 0){ fprintf(2, \"cat: read error\\n\"); exit(1); } } // 主函数 int main(int argc, char *argv[]) { int fd, i; // 如果没有提供文件参数，默认读取标准输入（文件描述符 0） if(argc \u003c= 1){ cat(0); exit(0); } // 遍历命令行参数中的文件名 for(i = 1; i \u003c argc; i++){ // 打开文件，获取文件描述符 if((fd = open(argv[i], 0)) \u003c 0){ // 如果文件无法打开，报告错误并退出 fprintf(2, \"cat: cannot open %s\\n\", argv[i]); exit(1); } // 调用 cat 函数，将文件内容输出到标准输出 cat(fd); // 关闭文件描述符 close(fd); } // 正常退出 exit(0); } echo.c #include \"kernel/types.h\" // 包含系统调用相关的类型定义 #include \"kernel/stat.h\" // 包含文件状态相关的定义 #include \"user/user.h\" // 包含用户态函数的声明（如 write, exit, strlen） int main(int argc, char *argv[]) { int i; // 遍历命令行参数，从第一个参数（argv[1]）开始 for(i = 1; i \u003c argc; i++){ // 将当前参数 argv[i] 写入标准输出（文件描述符 1） write(1, argv[i], strlen(argv[i])); // 如果不是最后一个参数，在其后写入一个空格 if(i + 1 \u003c argc){ write(1, \" \", 1); } else { // 如果是最后一个参数，在其后写入一个换行符 write(1, \"\\n\", 1); } } // 正常退出程序 exit(0); } forktest.c // 测试 fork 是否能在进程表满时优雅地失败。 // 这个程序是一个小的可执行文件，用于填充进程表以测试 fork 的行为。 #include \"kernel/types.h\" // 包含系统调用相关的类型定义 #include \"kernel/stat.h\" // 包含文件状态相关的定义 #include \"user/user.h\" // 包含用户态函数的声明（如 write, exit, fork, wait, strlen） #define N 1000 // 定义测试的 fork 最大次数 // 函数：print // 参数：const char *s - 要输出的字符串 // 功能：将字符串 s 写入标准输出（文件描述符 1） void print(const char *s) { write(1, s, strlen(s)); // 使用 write 系统调用将字符串写入标准输出 } // 函数：forktest // 功能：测试 fork 系统调用的行为，特别是在进程表满时 void forktest(void) { int n, pid; // 输出开始测试的信息 print(\"fork test\\n\"); // 循环尝试创建 N 个子进程 for(n = 0; n \u003c N; n++){ pid = fork(); // 创建一个子进程 if(pid \u003c 0) break; // 如果 fork 失败，退出循环 if(pid == 0) exit(0); // 子进程退出 } // 如果成功创建了 N 个子进程，表示 fork 行为异常 if(n == N){ print(\"fork claimed to work N times!\\n\"); exit(1); } // 等待所有子进程结束 for(; n \u003e 0; n--){ if(wait(0) \u003c 0){ // 等待子进程结束 print(\"wait stopped early\\n\"); exit(1); // 如果 wait 失败，报告错误并退出 } } // 如果 wait 没有返回 -1，表示还有多余的子进程 if(wait(0) != -1){ print(\"wait got too many\\n\"); exit(1); } // 输出测试成功的信息 print(\"fork test OK\\n\"); } // 主函数 int main(void) { forktest(); // 执行 fork 测试 exit(0); // 正常退出程序 } stressfs.c // Demonstrate that moving the \"acquire\" in iderw after the loop that // appends to the idequeue results in a race. // For this to work, you should also add a spin within iderw's // idequeue traversal loop. Adding the following demonstrated a panic // after about 5 runs of stressfs in QEMU on a 2.1GHz CPU: // for (i = 0; i \u003c 40000; i++) // asm volatile(\"\"); #include \"kernel/types.h\" #include \"kernel/stat.h\" #include \"user/user.h\" #include \"kernel/fs.h\" #include \"kernel/fcntl.h\" int main(int argc, char *argv[]) { int fd, i; char path[] = \"stressfs0\"; char data[512]; printf(\"stressfs starting\\n\"); memset(data, 'a', sizeof(data)); for(i = 0; i \u003c 4; i++) if(fork() \u003e 0) break; printf(\"write %d\\n\", i); path[8] += i; fd = open(path, O_CREATE | O_RDWR); for(i = 0; i \u003c 20; i++) // printf(fd, \"%d\\n\", i); write(fd, data, sizeof(data)); close(fd); printf(\"read\\n\"); fd = open(path, O_RDONLY); for (i = 0; i \u003c 20; i++) read(fd, data, sizeof(data)); close(fd); wait(0); exit(0); } Lab - Util sleep (easy) #include \"kernel/types.h\" #include \"kernel/stat.h\" #include \"user/user.h\" int main(int argc, char *argv[]) { if(argc != 2){ fprintf(2, \"Usage: sleep [the times of ticks]...\\n\"); exit(1); } int times = atoi(argv[1]); sleep(times); exit(0); } pingpong (easy) #include \"kernel/types.h\" #include \"kernel/stat.h\" #include \"user/user.h\" int main(int argc, char *argv[]) { if (argc \u003e 1) { fprintf(2, \"Usage: pingpong (without any parameters)\\n\"); exit(1); } int pipe_fd[2]; if (pipe(pipe_fd) \u003c 0) { fprintf(2, \"pipe error\\n\"); exit(1); } int pid = fork(); if (pid \u003e 0) { // 父进程关闭管道的写端 close(pipe_fd[1]); // 父进程等待子进程的信号 char buf[1]; read(pipe_fd[0], buf, 1); pid = wait((int *)0); printf(\"%d: received pong\\n\", getpid()); // 父进程关闭管道的读端 close(pipe_fd[0]); } else if (pid == 0) { // 子进程关闭管道的读端 close(pipe_fd[0]); printf(\"%d: received ping\\n\", getpid()); // 子进程通过管道向父进程发送信号 write(pipe_fd[1], \"x\", 1); // 子进程关闭管道的写端 close(pipe_fd[1]); exit(0); } else { printf(\"fork error\\n\"); exit(1); } exit(0); } primes (moderate)/(hard) #include \"kernel/types.h\" #include \"kernel/stat.h\" #include \"user/user.h\" void sieve(int p_left) { int p_right[2]; int prime; // 从左侧管道读取第一个数字 if (read(p_left, \u0026prime, sizeof(int)) == 0) { close(p_left); exit(0); } // 输出该素数 printf(\"prime %d\\n\", prime); // 创建一个新的管道 if (pipe(p_right) \u003c 0) { fprintf(2, \"pipe error\\n\"); exit(1); } if (fork() == 0) { // 子进程递归处理 close(p_right[1]); sieve(p_right[0]); } else { // 父进程继续读取并筛选 close(p_right[0]); int num; while (read(p_left, \u0026num, sizeof(int)) != 0) { if (num % prime != 0) { write(p_right[1], \u0026num, sizeof(int)); } } // 关闭管道，等待子进程结束 close(p_left); close(p_right[1]); wait(0); exit(0); } } int main(int argc, char *argv[]) { int p[2]; if (pipe(p) \u003c 0) { fprintf(2, \"pipe error\\n\"); exit(1); } if (fork() == 0) { close(p[1]); sieve(p[0]); } else { close(p[0]); // 将 2 到 35 的数字写入管道 for (int i = 2; i \u003c= 35; i++) { write(p[1], \u0026i, sizeof(int)); } close(p[1]); wait(0); exit(0); } return 0; } find (moderate) #include \"kernel/types.h\" #include \"kernel/stat.h\" #include \"user/user.h\" #include \"kernel/fs.h\" #include \"kernel/fcntl.h\" #define MAXBUF 512 // 定义缓冲区大小 /** * find - 递归查找目录树中与指定文件名匹配的文件。 * @path: 要搜索的目录路径。 * @filename: 要查找的文件名。 * * 该函数通过递归遍历目录树，打印出与指定文件名匹配的文件的路径。 * 它会忽略特殊目录项 `.` 和 `..` 以避免递归回到当前或父目录。 */ void find(char *path, char *filename) { char buf[512], *p; int fd; struct dirent de; struct stat st; // 打开指定的目录路径 if ((fd = open(path, 0)) \u003c 0) { fprintf(2, \"find: cannot open %s\\n\", path); return; } // 获取文件状态（例如确定是文件还是目录） if (fstat(fd, \u0026st) \u003c 0) { fprintf(2, \"find: cannot stat %s\\n\", path); close(fd); return; } // 判断文件类型，处理不同的情况 switch (st.type) { case T_FILE: // 如果是普通文件 // 检查文件名是否与目标文件名匹配 if (strcmp(path + strlen(path) - strlen(filename), filename) == 0) { // 如果匹配，打印文件路径 printf(\"%s\\n\", path); // 注意这里每个匹配的文件都应该在新行打印 } break; case T_DIR: // 如果是目录 // 检查路径长度是否超出缓冲区大小 if (strlen(path) + 1 + DIRSIZ + 1 \u003e sizeof(buf)) { printf(\"find: path too long\\n\"); break; } // 将当前路径复制到缓冲区中 strcpy(buf, path); p = buf + strlen(buf); *p++ = '/'; // 读取目录中的每个目录项 while (read(fd, \u0026de, sizeof(de)) == sizeof(de)) { if (de.inum == 0) continue; // 跳过无效的目录项 // 将目录项名称复制到路径缓冲区 memmove(p, de.name, DIRSIZ); p[DIRSIZ] = 0; // 忽略特殊目录项 `.` 和 `..` if (strcmp(de.name, \".\") == 0 || strcmp(de.name, \"..\") == 0) continue; // 递归调用 find 函数处理子目录或文件 find(buf, filename); } break; } // 关闭文件描述符以释放资源 close(fd); } /** * main - 程序的入口点，解析命令行参数并调用 find 函数。 * @argc: 参数个数。 * @argv: 参数值数组。 * * 该函数验证参数的正确性，并调用 find 函数开始递归查找。 */ int main(int argc, char *argv[]) { // 检查命令行参数是否正确 if (argc \u003c 3) { // 如果参数不足，打印使用说明并退出 fprintf(2, \"Usage: find \\n\"); exit(1); } // 调用 find 函数，开始查找文件 find(argv[1], argv[2]); exit(0); } xargs (moderate) #include \"kernel/types.h\" #include \"kernel/stat.h\" #include \"user/user.h\" #define MAXARG 32 // 最大参数数量 #define MAXBUF 1024 // 最大输入缓冲区大小 // 从标准输入读取一行 int read_line(char *buf, int size) { int i = 0; // 当前字符索引 char c; // 存储读取的字符 // 从标准输入逐字符读取，直到遇到换行符或缓冲区已满 while (i \u003c size - 1) { if (read(0, \u0026c, 1) != 1) { return i; // 到达输入结束或发生错误 } if (c == '\\n') { break; // 遇到换行符，停止读取 } buf[i++] = c; // 将读取的字符存入缓冲区 } buf[i] = '\\0'; // 在字符串末尾添加 null 终止符 return i; } int main(int argc, char *argv[]) { if (argc \u003c 2) { fprintf(2, \"Usage: xargs command [initial-args]\\n\"); // 如果没有提供命令参数，输出用法提示 exit(1); // 退出程序 } char buf[MAXBUF]; // 用于存储输入行的缓冲区 // 从标准输入读取每一行 while (read_line(buf, sizeof(buf)) \u003e 0) { // 创建命令行参数数组 char *cmd_argv[MAXARG + 2]; // +2: 一个存放命令名，一个存放拼接后的参数 cmd_argv[0] = argv[1]; // 命令名称 int i; // 复制用户提供的初始参数（如果有） for (i = 1; i \u003c argc - 1 \u0026\u0026 i \u003c MAXARG; i++) { cmd_argv[i] = argv[i + 1]; } // 将读取的行作为最后一个参数 cmd_argv[i++] = buf; cmd_argv[i] = 0; // 参数列表以 null 终止 int pid = fork(); // 创建子进程 if (pid \u003c 0) { fprintf(2, \"xargs: fork failed\\n\"); // 如果创建子进程失败，输出错误信息 exit(1); // 退出程序 } else if (pid == 0) { exec(cmd_argv[0], cmd_argv); // 执行命令 fprintf(2, \"xargs: exec failed\\n\"); // 如果执行命令失败，输出错误信息 exit(1); // 退出子进程 } else { // 父进程中 wait(0); // 等待子进程完成 } } exit(0); // 正常退出程序 } ",
  "wordCount" : "5897",
  "inLanguage": "zh",
  "datePublished": "2024-08-31T22:30:13+08:00",
  "dateModified": "2024-08-31T22:20:13+08:00",
  "author":{
    "@type": "Person",
    "name": "ShowGuan"
  },
  "mainEntityOfPage": {
    "@type": "WebPage",
    "@id": "https://kennems.github.io/posts/tech/mit6.s0811-os-overview/"
  },
  "publisher": {
    "@type": "Organization",
    "name": "Kennem's Blog",
    "logo": {
      "@type": "ImageObject",
      "url": "https://kennems.github.io/img/sun.png"
    }
  }
}
</script>
<script src="https://cdn.jsdelivr.net/npm/jquery@3.5.1/dist/jquery.min.js"></script>
<link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.css" />
<script src="https://cdn.jsdelivr.net/gh/fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.js"></script>




</head>

<body class="" id="top">
<script>
    if (localStorage.getItem("pref-theme") === "dark") {
        document.body.classList.add('dark');
    } else if (localStorage.getItem("pref-theme") === "light") {
        document.body.classList.remove('dark')
    } else if (window.matchMedia('(prefers-color-scheme: dark)').matches) {
        document.body.classList.add('dark');
    }

</script>

<header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="https://kennems.github.io/" accesskey="h" title="Kennem&#39;s Blog (Alt + H)">
                <img src="https://kennems.github.io/img/sun.png" alt="" aria-label="logo"
                    height="35">Kennem&#39;s Blog</a>
            <div class="logo-switches">
                <button id="theme-toggle" accesskey="t" title="(Alt + T)">
                    <svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
                    </svg>
                    <svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <circle cx="12" cy="12" r="5"></circle>
                        <line x1="12" y1="1" x2="12" y2="3"></line>
                        <line x1="12" y1="21" x2="12" y2="23"></line>
                        <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                        <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                        <line x1="1" y1="12" x2="3" y2="12"></line>
                        <line x1="21" y1="12" x2="23" y2="12"></line>
                        <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                        <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
                    </svg>
                </button>
            </div>
        </div>
        <ul id="menu">
            <li>
                <a href="https://kennems.github.io/" title="🏠主页">
                    <span>🏠主页</span>
                </a>
            </li>
            <li>
                <a href="https://kennems.github.io/search" title="🔍搜索 (Alt &#43; /)" accesskey=/>
                    <span>🔍搜索</span>
                </a>
            </li>
            <li>
                <a href="https://kennems.github.io/posts" title="📚文章">
                    <span>📚文章</span>
                </a>
            </li>
            <li>
                <a href="https://kennems.github.io/archives" title="⏱时间轴">
                    <span>⏱时间轴</span>
                </a>
            </li>
            <li>
                <a href="https://kennems.github.io/tags" title="🔖标签">
                    <span>🔖标签</span>
                </a>
            </li>
            <li>
                <a href="https://kennems.github.io/categories" title="🗂️分类">
                    <span>🗂️分类</span>
                </a>
            </li>
            <li>
                <a href="https://kennems.github.io/about" title="🙋🏻‍♂️关于">
                    <span>🙋🏻‍♂️关于</span>
                </a>
            </li>
        </ul>
    </nav>
</header>
<main class="main">

<article class="post-single">
  <header class="post-header">
    <div class="breadcrumbs"><a href="https://kennems.github.io/">主页</a>&nbsp;»&nbsp;<a href="https://kennems.github.io/posts/">📚文章</a>&nbsp;»&nbsp;<a href="https://kennems.github.io/posts/tech/">💻技术</a></div>
    <h1 class="post-title entry-hint-parent">
      MIT6.S081(1)-O/S overview
    </h1>
    <div class="post-description">
      MIT6.S081(1)
    </div>
    <div class="post-meta"><span title='2024-08-31 22:30:13 +0800 CST'>2024-08-31</span>&nbsp;·&nbsp;12 分钟&nbsp;·&nbsp;5897 字&nbsp;·&nbsp;updated:&nbsp;2024-08-31&nbsp;·&nbsp;ShowGuan

</div>
    
     <div class="post-password">
        
    </div>
  </header> <aside id="toc-container" class="toc-container wide">
    <div class="toc">
        <details  open>
            <summary accesskey="c" title="(Alt + C)">
                <span class="details">目录</span>
            </summary>

            <div class="inner"><ul>
                    <li>
                        <a href="#mit6s0811-os-overview" aria-label="MIT6.S081(1)-O/S overview">MIT6.S081(1)-O/S overview</a><ul>
                            
                    <li>
                        <a href="#class-pagehttpspdoscsailmitedu6s0812020schedulehtml" aria-label="Class Page"><a href="https://pdos.csail.mit.edu/6.S081/2020/schedule.html">Class Page</a></a></li>
                    <li>
                        <a href="#overview" aria-label="Overview">Overview</a><ul>
                            
                    <li>
                        <a href="#6s081-goals" aria-label="6.S081 goals">6.S081 goals</a></li>
                    <li>
                        <a href="#what-is-the-purpose-of-an-os" aria-label="What is the purpose of an O/S?">What is the purpose of an O/S?</a></li>
                    <li>
                        <a href="#organization-layered-picture" aria-label="Organization: layered picture">Organization: layered picture</a></li>
                    <li>
                        <a href="#what-services-does-an-os-kernel-typically-provide" aria-label="What services does an O/S kernel typically provide?">What services does an O/S kernel typically provide?</a></li>
                    <li>
                        <a href="#whats-the-application--kernel-interface" aria-label="What&rsquo;s the application / kernel interface?">What&rsquo;s the application / kernel interface?</a></li>
                    <li>
                        <a href="#system-calls" aria-label="System Calls">System Calls</a></li>
                    <li>
                        <a href="#why-is-os-design--implementation-hard-and-interesting" aria-label="Why is O/S design &#43; implementation hard and interesting?">Why is O/S design + implementation hard and interesting?</a></li></ul>
                    </li>
                    <li>
                        <a href="#class-structure" aria-label="Class structure">Class structure</a></li>
                    <li>
                        <a href="#introduction-to-unix-system-calls" aria-label="Introduction to UNIX system calls">Introduction to UNIX system calls</a></li>
                    <li>
                        <a href="#why-unix" aria-label="Why UNIX?">Why UNIX?</a><ul>
                            
                    <li>
                        <a href="#example-copyc-copy-input-to-output" aria-label="Example: copy.c, copy input to output">Example: copy.c, copy input to output</a><ul>
                            
                    <li>
                        <a href="#copyc" aria-label="copy.c">copy.c</a></li></ul>
                    </li>
                    <li>
                        <a href="#where-do-file-descriptors-come-from" aria-label="Where do file descriptors come from?">Where do file descriptors come from?</a><ul>
                            
                    <li>
                        <a href="#what-happens-when-a-program-calls-a-system-call-like-open" aria-label="What happens when a program calls a system call like open()?">What happens when a program calls a system call like open()?</a></li></ul>
                    </li>
                    <li>
                        <a href="#fork-%e5%92%8c-exec-%e7%9a%84%e5%8c%ba%e5%88%ab" aria-label="fork 和 exec 的区别"><code>fork</code> 和 <code>exec</code> 的区别</a><ul>
                            
                    <li>
                        <a href="#fork-%e7%b3%bb%e7%bb%9f%e8%b0%83%e7%94%a8" aria-label="fork 系统调用"><strong><code>fork</code> 系统调用</strong></a></li>
                    <li>
                        <a href="#exec-%e7%b3%bb%e7%bb%9f%e8%b0%83%e7%94%a8" aria-label="exec 系统调用"><strong><code>exec</code> 系统调用</strong></a></li></ul>
                    </li>
                    <li>
                        <a href="#its-worth-asking-why-about-design-decisions" aria-label="It&rsquo;s worth asking &ldquo;why&rdquo; about design decisions:">It&rsquo;s worth asking &ldquo;why&rdquo; about design decisions:</a></li>
                    <li>
                        <a href="#summary" aria-label="Summary">Summary</a></li></ul>
                    </li>
                    <li>
                        <a href="#code" aria-label="Code">Code</a><ul>
                            
                    <li>
                        <a href="#pipes" aria-label="Pipes">Pipes</a></li>
                    <li>
                        <a href="#catc" aria-label="cat.c">cat.c</a></li>
                    <li>
                        <a href="#echoc" aria-label="echo.c">echo.c</a></li>
                    <li>
                        <a href="#forktestc" aria-label="forktest.c">forktest.c</a></li>
                    <li>
                        <a href="#stressfsc" aria-label="stressfs.c">stressfs.c</a></li></ul>
                    </li>
                    <li>
                        <a href="#lab---utilhttpspdoscsailmitedu6s0812020labsutilhtml" aria-label="Lab - Util"><a href="https://pdos.csail.mit.edu/6.S081/2020/labs/util.html">Lab - Util</a></a><ul>
                            
                    <li>
                        <a href="#sleep-easyhttpspdoscsailmitedu6s0812020labsguidancehtml" aria-label="sleep (easy)">sleep (<a href="https://pdos.csail.mit.edu/6.S081/2020/labs/guidance.html">easy</a>)</a></li>
                    <li>
                        <a href="#pingpong-easyhttpspdoscsailmitedu6s0812020labsguidancehtml" aria-label="pingpong (easy)">pingpong (<a href="https://pdos.csail.mit.edu/6.S081/2020/labs/guidance.html">easy</a>)</a></li>
                    <li>
                        <a href="#primes-moderatehttpspdoscsailmitedu6s0812020labsguidancehtmlhardhttpspdoscsailmitedu6s0812020labsguidancehtml" aria-label="primes (moderate)/(hard)">primes (<a href="https://pdos.csail.mit.edu/6.S081/2020/labs/guidance.html">moderate</a>)/(<a href="https://pdos.csail.mit.edu/6.S081/2020/labs/guidance.html">hard</a>)</a></li>
                    <li>
                        <a href="#find-moderatehttpspdoscsailmitedu6s0812020labsguidancehtml" aria-label="find (moderate)">find (<a href="https://pdos.csail.mit.edu/6.S081/2020/labs/guidance.html">moderate</a>)</a></li>
                    <li>
                        <a href="#xargs-moderatehttpspdoscsailmitedu6s0812020labsguidancehtml" aria-label="xargs (moderate)">xargs (<a href="https://pdos.csail.mit.edu/6.S081/2020/labs/guidance.html">moderate</a>)</a>
                    </li>
                </ul>
                </li>
                </ul>
                </li>
                </ul>
            </div>
        </details>
    </div>
</aside>
<script>
    let activeElement;
    let elements;
    window.addEventListener('DOMContentLoaded', function (event) {
        checkTocPosition();

        elements = document.querySelectorAll('h1[id],h2[id],h3[id],h4[id],h5[id],h6[id]');
         
         activeElement = elements[0];
         const id = encodeURI(activeElement.getAttribute('id')).toLowerCase();
         document.querySelector(`.inner ul li a[href="#${id}"]`).classList.add('active');
     }, false);

    window.addEventListener('resize', function(event) {
        checkTocPosition();
    }, false);

    window.addEventListener('scroll', () => {
        
        activeElement = Array.from(elements).find((element) => {
            if ((getOffsetTop(element) - window.pageYOffset) > 0 && 
                (getOffsetTop(element) - window.pageYOffset) < window.innerHeight/2) {
                return element;
            }
        }) || activeElement

        elements.forEach(element => {
             const id = encodeURI(element.getAttribute('id')).toLowerCase();
             if (element === activeElement){
                 document.querySelector(`.inner ul li a[href="#${id}"]`).classList.add('active');
             } else {
                 document.querySelector(`.inner ul li a[href="#${id}"]`).classList.remove('active');
             }
         })
     }, false);

    const main = parseInt(getComputedStyle(document.body).getPropertyValue('--article-width'), 10);
    const toc = parseInt(getComputedStyle(document.body).getPropertyValue('--toc-width'), 10);
    const gap = parseInt(getComputedStyle(document.body).getPropertyValue('--gap'), 10);

    function checkTocPosition() {
        const width = document.body.scrollWidth;

        if (width - main - (toc * 2) - (gap * 4) > 0) {
            document.getElementById("toc-container").classList.add("wide");
        } else {
            document.getElementById("toc-container").classList.remove("wide");
        }
    }

    function getOffsetTop(element) {
        if (!element.getClientRects().length) {
            return 0;
        }
        let rect = element.getBoundingClientRect();
        let win = element.ownerDocument.defaultView;
        return rect.top + win.pageYOffset;   
    }
</script>

  <div class="post-content"><h1 id="mit6s0811-os-overview">MIT6.S081(1)-O/S overview<a hidden class="anchor" aria-hidden="true" href="#mit6s0811-os-overview">#</a></h1>
<h2 id="class-pagehttpspdoscsailmitedu6s0812020schedulehtml"><a href="https://pdos.csail.mit.edu/6.S081/2020/schedule.html">Class Page</a><a hidden class="anchor" aria-hidden="true" href="#class-pagehttpspdoscsailmitedu6s0812020schedulehtml">#</a></h2>
<h2 id="overview">Overview<a hidden class="anchor" aria-hidden="true" href="#overview">#</a></h2>
<h3 id="6s081-goals">6.S081 goals<a hidden class="anchor" aria-hidden="true" href="#6s081-goals">#</a></h3>
<ul>
<li>Understand operating system (O/S) design and implementation</li>
<li>Hands-on experience extending a small O/S</li>
<li>Hands-on experience writing systems software</li>
</ul>
<h3 id="what-is-the-purpose-of-an-os">What is the purpose of an O/S?<a hidden class="anchor" aria-hidden="true" href="#what-is-the-purpose-of-an-os">#</a></h3>
<ul>
<li><strong>Abstract the hardware</strong> for convenience and portability</li>
<li><strong>Multiplex</strong> the hardware among many applications</li>
<li><strong>Isolate</strong> applications in order to contain bugs</li>
<li>Allow <strong>sharing</strong> among cooperating applications</li>
<li>Control sharing for <strong>security</strong></li>
<li>Don&rsquo;t get in the way of high <strong>performance</strong></li>
<li>Support a wide <strong>range of applications</strong></li>
</ul>
<h3 id="organization-layered-picture">Organization: layered picture<a hidden class="anchor" aria-hidden="true" href="#organization-layered-picture">#</a></h3>
<ul>
<li>user applications: <code>vi</code>, <code>gcc</code>, <code>DB</code>, &amp;c</li>
<li>kernel services</li>
<li>h/w: <code>CPU</code>, <code>RAM</code>, <code>disk</code>, <code>net</code>, &amp;c</li>
</ul>
<ul>
<li>we care a lot about the interfaces and internal kernel structure</li>
</ul>
<p>
<img alt="image-20240830172602324" loading="lazy" src="https://raw.githubusercontent.com/Kennems/blog-image/main/image-20240830172602324.png">

    <div class="post-img-view">
        <a data-fancybox="gallery" href="https://raw.githubusercontent.com/Kennems/blog-image/main/image-20240830172602324.png">
            <img src="https://raw.githubusercontent.com/Kennems/blog-image/main/image-20240830172602324.png" alt="image-20240830172602324"  />
        </a>
    </div>
</p>
<h3 id="what-services-does-an-os-kernel-typically-provide">What services does an O/S kernel typically provide?<a hidden class="anchor" aria-hidden="true" href="#what-services-does-an-os-kernel-typically-provide">#</a></h3>
<ul>
<li>process (a running program)</li>
<li>memory allocation</li>
<li>file contents</li>
<li>file names, directories</li>
<li>access control (security)</li>
<li>many others: users, IPC（Inter-Process Communication）, network, time, terminals</li>
</ul>
<h3 id="whats-the-application--kernel-interface">What&rsquo;s the application / kernel interface?<a hidden class="anchor" aria-hidden="true" href="#whats-the-application--kernel-interface">#</a></h3>
<ul>
<li>
<p><strong>&ldquo;System calls&rdquo;</strong></p>
</li>
<li>
<p>Examples, in C, from UNIX (e.g. Linux, macOS, FreeBSD):</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span>fd <span style="color:#f92672">=</span> <span style="color:#a6e22e">open</span>(<span style="color:#e6db74">&#34;out&#34;</span>, <span style="color:#ae81ff">1</span>);
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">write</span>(fd, <span style="color:#e6db74">&#34;hello</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>, <span style="color:#ae81ff">6</span>);
</span></span><span style="display:flex;"><span>pid <span style="color:#f92672">=</span> <span style="color:#a6e22e">fork</span>();
</span></span></code></pre></div></li>
<li>
<p>These look like function calls but they aren&rsquo;t</p>
</li>
</ul>
<h3 id="system-calls">System Calls<a hidden class="anchor" aria-hidden="true" href="#system-calls">#</a></h3>
<table>
<thead>
<tr>
<th>函数名</th>
<th>功能描述</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>int fork()</code></td>
<td>创建一个进程，返回子进程的 PID。</td>
</tr>
<tr>
<td><code>int exit(int status)</code></td>
<td>终止当前进程，<code>status</code> 返回给 <code>wait()</code>，不返回。</td>
</tr>
<tr>
<td><code>int wait(int *status)</code></td>
<td>等待子进程退出，退出状态存入 <code>*status</code>，返回子进程的 PID。</td>
</tr>
<tr>
<td><code>int kill(int pid)</code></td>
<td>终止进程 PID。返回 0 或 -1（表示错误）。</td>
</tr>
<tr>
<td><code>int getpid()</code></td>
<td>返回当前进程的 PID。</td>
</tr>
<tr>
<td><code>int sleep(int n)</code></td>
<td>暂停 <code>n</code> 个时钟周期。</td>
</tr>
<tr>
<td><code>int exec(char *file, char *argv[])</code></td>
<td>加载并执行文件 <code>file</code>，传入参数 <code>argv[]</code>，仅在发生错误时返回。</td>
</tr>
<tr>
<td><code>char *sbrk(int n)</code></td>
<td>增加 <code>n</code> 字节的进程内存，返回新内存的起始地址。</td>
</tr>
<tr>
<td><code>int open(char *file, int flags)</code></td>
<td>打开文件，<code>flags</code> 指示读/写模式，返回文件描述符。</td>
</tr>
<tr>
<td><code>int write(int fd, char *buf, int n)</code></td>
<td>从 <code>buf</code> 中向文件描述符 <code>fd</code> 写入 <code>n</code> 字节，返回写入的字节数。</td>
</tr>
<tr>
<td><code>int read(int fd, char *buf, int n)</code></td>
<td>从文件描述符 <code>fd</code> 中读取 <code>n</code> 字节到 <code>buf</code>，返回读取的字节数或 0（文件结束）。</td>
</tr>
<tr>
<td><code>int close(int fd)</code></td>
<td>关闭文件描述符 <code>fd</code>。</td>
</tr>
<tr>
<td><code>int dup(int fd)</code></td>
<td>返回一个新的文件描述符，指向与 <code>fd</code> 相同的文件。</td>
</tr>
<tr>
<td><code>int pipe(int p[])</code></td>
<td>创建一个管道，将读/写文件描述符放入 <code>p[0]</code> 和 <code>p[1]</code>。</td>
</tr>
<tr>
<td><code>int chdir(char *dir)</code></td>
<td>更改当前目录为 <code>dir</code>。</td>
</tr>
<tr>
<td><code>int mkdir(char *dir)</code></td>
<td>创建一个新目录 <code>dir</code>。</td>
</tr>
<tr>
<td><code>int mknod(char *file, int, int)</code></td>
<td>创建一个设备文件。</td>
</tr>
<tr>
<td><code>int fstat(int fd, struct stat *st)</code></td>
<td>将关于打开文件的信息放入 <code>*st</code>。</td>
</tr>
<tr>
<td><code>int stat(char *file, struct stat *st)</code></td>
<td>将关于文件 <code>file</code> 的信息放入 <code>*st</code>。</td>
</tr>
<tr>
<td><code>int link(char *file1, char *file2)</code></td>
<td>为文件 <code>file1</code> 创建另一个名称 <code>file2</code>。</td>
</tr>
<tr>
<td><code>int unlink(char *file)</code></td>
<td>删除文件 <code>file</code>。</td>
</tr>
</tbody>
</table>
<h3 id="why-is-os-design--implementation-hard-and-interesting">Why is O/S design + implementation hard and interesting?<a hidden class="anchor" aria-hidden="true" href="#why-is-os-design--implementation-hard-and-interesting">#</a></h3>
<ul>
<li>
<p>unforgiving environment: quirky h/w, hard to debug</p>
</li>
<li>
<p>many design tensions:</p>
<ul>
<li>efficient vs abstract / portable / general-purpose</li>
<li>powerful vs simple interfaces</li>
<li>flexible vs secure</li>
</ul>
</li>
<li>
<p>features interact: <code>fd = open(); fork()</code></p>
</li>
<li>
<p>uses are varied: laptops, smart-phones, cloud, virtual machines, embedded</p>
</li>
<li>
<p>evolving hardware: NVRAM, multi-core, fast networks</p>
</li>
<li>
<p>You&rsquo;ll be glad you took this course if you&hellip;</p>
<ul>
<li>care about what goes on under the hood</li>
<li>like infrastructure</li>
<li>need to track down bugs or security problems</li>
<li>care about high performance</li>
</ul>
</li>
</ul>
<h2 id="class-structure">Class structure<a hidden class="anchor" aria-hidden="true" href="#class-structure">#</a></h2>
<ul>
<li>
<p>Online course information:
<a href="https://pdos.csail.mit.edu/6.S081/2020">https://pdos.csail.mit.edu/6.S081/2020</a> &ndash; schedule, assignments, labs
Piazza &ndash; announcements, discussion, lab help</p>
</li>
<li>
<p>Lectures</p>
<ul>
<li>O/S ideas</li>
<li>case study of xv6, a small O/S, via code and xv6 book</li>
<li>lab background</li>
<li>O/S papers</li>
<li>submit a question about each reading, before lecture.</li>
</ul>
</li>
<li>
<p>Labs:
The point: hands-on experience
Mostly one week each.
Three kinds:
Systems programming (due next week&hellip;)
O/S primitives, e.g. thread switching.
O/S kernel extensions to xv6, e.g. network.
Use piazza to ask/answer lab questions.
Discussion is great, but please do not look at others&rsquo; solutions!</p>
</li>
<li>
<p>Grading:
70% labs, based on tests (the same tests you run).
20% lab check-off meetings: we&rsquo;ll ask you about randomly-selected labs.
10% home-work and class/piazza discussion.
No exams, no quizzes.
Note that most of the grade is from labs. Start them early!</p>
</li>
</ul>
<h2 id="introduction-to-unix-system-calls">Introduction to UNIX system calls<a hidden class="anchor" aria-hidden="true" href="#introduction-to-unix-system-calls">#</a></h2>
<ul>
<li>I&rsquo;ll show some examples, and run them on xv6.
xv6 has similar structure to UNIX systems such as Linux.
but much simpler &ndash; you&rsquo;ll be able to digest all of xv6
accompanying book explains how xv6 works, and why</li>
</ul>
<h2 id="why-unix">Why UNIX?<a hidden class="anchor" aria-hidden="true" href="#why-unix">#</a></h2>
<p>open source, well documented, clean design, widely used
studying xv6 will help if you ever need to look inside Linux
xv6 has two roles in 6.S081:
example of core functions: virtual memory, multi-core, interrupts, &amp;c
starting point for most of the labs
xv6 runs on RISC-V, as in current 6.004
you&rsquo;ll run xv6 under the qemu machine emulator</p>
<h3 id="example-copyc-copy-input-to-output">Example: copy.c, copy input to output<a hidden class="anchor" aria-hidden="true" href="#example-copyc-copy-input-to-output">#</a></h3>
<p>read bytes from input, write them to the output</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-shell" data-lang="shell"><span style="display:flex;"><span>$ copy
</span></span></code></pre></div><p><code>copy.c</code> is written in C
Kernighan and Ritchie (K&amp;R) book is good for learning C
you can find these example programs via the schedule on the web site</p>
<h4 id="copyc">copy.c<a hidden class="anchor" aria-hidden="true" href="#copyc">#</a></h4>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#75715e">// copy.c: 复制输入到输出
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&#34;kernel/types.h&#34;   // 包含系统调用相关的类型定义</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&#34;user/user.h&#34;      // 包含用户态函数的声明（如 read, write, exit）</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span>
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">main</span>()
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">char</span> buf[<span style="color:#ae81ff">64</span>];  <span style="color:#75715e">// 定义一个缓冲区，用于存储读取的数据
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span>  <span style="color:#75715e">// 无限循环，直到读取到文件结束标志或出现错误
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  <span style="color:#66d9ef">while</span>(<span style="color:#ae81ff">1</span>){
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// 从标准输入（文件描述符 0）中读取数据到 buf 中
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">int</span> n <span style="color:#f92672">=</span> <span style="color:#a6e22e">read</span>(<span style="color:#ae81ff">0</span>, buf, <span style="color:#66d9ef">sizeof</span>(buf));
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// 如果读取到的数据量小于等于 0，则表示输入结束或发生了错误
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">if</span>(n <span style="color:#f92672">&lt;=</span> <span style="color:#ae81ff">0</span>)
</span></span><span style="display:flex;"><span>      <span style="color:#66d9ef">break</span>;  <span style="color:#75715e">// 退出循环
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// 将读取的数据写入标准输出（文件描述符 1）
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#a6e22e">write</span>(<span style="color:#ae81ff">1</span>, buf, n);
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#75715e">// 正常退出程序
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  <span style="color:#a6e22e">exit</span>(<span style="color:#ae81ff">0</span>);
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p><code>read()</code> and <code>write()</code> are system calls
<strong>first</strong> <code>read()/write()</code> argument is a <code>&quot;file descriptor&quot;</code> <code>(fd)</code>
passed to kernel to tell it which &ldquo;open file&rdquo; to read/write
must previously have been opened</p>
<p>an FD connects to a <code>file</code>/<code>device</code>/<code>socket</code>/&amp;c
a process can open many files, have many FDs</p>
<p><strong>UNIX convention</strong>: fd 0 is &ldquo;standard input&rdquo;, 1 is &ldquo;standard output&rdquo;</p>
<p><strong>second</strong> read() argument is a pointer to some memory into which to read</p>
<p><strong>third</strong> argument is the maximum number of bytes to read
read() may read less, but not more
return value: number of bytes actually read, or -1 for error</p>
<p><strong>note</strong>: <code>copy.c</code> does not care about the format of the data
UNIX I/O is 8-bit bytes
interpretation is application-specific, e.g. database records, C source, &amp;c</p>
<h3 id="where-do-file-descriptors-come-from">Where do file descriptors come from?<a hidden class="anchor" aria-hidden="true" href="#where-do-file-descriptors-come-from">#</a></h3>
<ul>
<li>
<p>example: open.c, create a file</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-sh" data-lang="sh"><span style="display:flex;"><span>$ open
</span></span></code></pre></div><div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-sh" data-lang="sh"><span style="display:flex;"><span>$ cat output.txt
</span></span></code></pre></div></li>
</ul>
<p><code>	open()</code> creates a file, returns a file descriptor (or -1 for error)
<strong>FD is a small integer</strong>
FD indexes into a per-process table maintained by kernel
[user/kernel diagram]
different processes have different FD name-spaces
i.e. FD 1 often means different things to different processes
these examples ignore errors &ndash; don&rsquo;t be this sloppy!
Figure 1.2 in the xv6 book lists system call arguments/return
or look at UNIX man pages, e.g. &ldquo;man 2 open&rdquo;</p>
<h4 id="what-happens-when-a-program-calls-a-system-call-like-open">What happens when a program calls a system call like open()?<a hidden class="anchor" aria-hidden="true" href="#what-happens-when-a-program-calls-a-system-call-like-open">#</a></h4>
<p>looks like a function call, but it&rsquo;s actually a <strong>special instruction</strong>
hardware saves some user registers
hardware increases privilege level
hardware jumps to a known &ldquo;entry point&rdquo; in the kernel
now running C code in the kernel
kernel calls system call implementation
<code>open()</code> looks up name in file system
it might wait for the disk
it updates kernel data structures (cache, FD table)
restore user registers
reduce privilege level
jump back to calling point in the program, which resumes
we&rsquo;ll see more detail later in the course</p>
<ul>
<li>
<p>I&rsquo;ve been typing to UNIX&rsquo;s command-line interface, the shell.
the shell prints the &ldquo;$&rdquo; prompts.
the shell lets you run UNIX command-line utilities
useful for system management, messing with files, development, scripting</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-sh" data-lang="sh"><span style="display:flex;"><span>$ ls
</span></span></code></pre></div><div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-sh" data-lang="sh"><span style="display:flex;"><span>$ ls &gt; out
</span></span></code></pre></div><div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-sh" data-lang="sh"><span style="display:flex;"><span>$ grep x &lt; out
</span></span></code></pre></div><p>UNIX supports other styles of interaction too
<code>window systems</code>, <code>GUIs</code>, <code>servers</code>, <code>routers</code>, &amp;c.
but time-sharing via the shell was the original focus of UNIX.
we can exercise many system calls via the shell.</p>
</li>
<li>
<p>example: <code>fork.c</code>, create a new process</p>
</li>
</ul>
<p>​	the shell creates a new process for each command you type, e.g. for</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-sh" data-lang="sh"><span style="display:flex;"><span>$ echo hello
</span></span></code></pre></div><p>the <code>fork()</code> system call creates a new process</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-sh" data-lang="sh"><span style="display:flex;"><span>$ fork
</span></span></code></pre></div><p>the kernel makes a copy of the calling process
instructions, data, registers, file descriptors, current directory
&ldquo;parent&rdquo; and &ldquo;child&rdquo; processes
only difference: <code>fork()</code> returns a pid in parent, 0 in child
a pid (process ID) is an integer, kernel gives each process a different pid
thus:
<code>fork.c</code>&rsquo;s &ldquo;fork() returned&rdquo; executes in <em>both</em> processes
the &ldquo;if(pid == 0)&rdquo; allows code to distinguish
ok, fork lets us create a new process
how can we run a program in that process?</p>
<ul>
<li>
<p>example: <code>exec.c</code>, replace calling process with an executable file
how does the shell run a program, e.g.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-sh" data-lang="sh"><span style="display:flex;"><span>$ echo a b c
</span></span></code></pre></div><p>a program is stored in a file: instructions and initial memory
created by the compiler and linker
so there&rsquo;s a file called echo, containing instructions</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-sh" data-lang="sh"><span style="display:flex;"><span>$ exec
</span></span></code></pre></div><p><code>exec()</code> replaces current process with an executable file
discards instruction and data memory
loads instructions and memory from the file
preserves file descriptors
<code>exec(filename, argument-array)</code>
argument-array holds command-line arguments; exec passes to main()
cat user/echo.c
echo.c shows how a program looks at its command-line arguments</p>
</li>
<li>
<p>example: forkexec.c, <code>fork()</code> a new process, exec() a program</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-sh" data-lang="sh"><span style="display:flex;"><span>$ forkexec
</span></span></code></pre></div><p>forkexec.c contains a common UNIX idiom:
<code>fork()</code> :  a child process
<code>exec()</code>  : a command in the child
parent wait()s for child to finish
the shell does fork/exec/wait for every command you type
after <code>wait()</code>, the shell prints the next prompt
to run in the background &ndash; &amp; &ndash; the shell skips the <code>wait()</code>
<code>exit(status)</code> <code>-&gt;</code> <code>wait(&amp;status)</code>
status convention: 0 = success, 1 = command encountered an error
note: the <code>fork()</code> copies, but <code>exec()</code> discards the copied memory
this may seem wasteful
you&rsquo;ll transparently eliminate the copy in the &ldquo;copy-on-write&rdquo; lab</p>
</li>
</ul>
<h3 id="fork-和-exec-的区别"><code>fork</code> 和 <code>exec</code> 的区别<a hidden class="anchor" aria-hidden="true" href="#fork-和-exec-的区别">#</a></h3>
<p><strong><code>fork</code></strong> 用于创建新进程，父子进程并发执行。</p>
<p><strong><code>exec</code></strong> 用于在现有进程中加载并运行新程序。</p>
<h4 id="fork-系统调用"><strong><code>fork</code> 系统调用</strong><a hidden class="anchor" aria-hidden="true" href="#fork-系统调用">#</a></h4>
<ul>
<li><strong>功能</strong>：<code>fork</code> 用于创建一个新进程，称为子进程。子进程是通过复制当前进程（父进程）的地址空间创建的，因此子进程和父进程几乎完全相同，拥有相同的代码、数据和打开的文件描述符。</li>
<li>执行结果：
<ul>
<li>父进程调用 <code>fork</code> 后，返回值是子进程的 PID。</li>
<li>子进程从 <code>fork</code> 返回时，返回值是 0。</li>
</ul>
</li>
<li>特点：
<ul>
<li>子进程是父进程的几乎精确副本，包括文件描述符、变量、代码段等，但其 PID（进程 ID）不同。</li>
<li><strong>并发执行</strong>：<code>fork</code> 之后，父进程和子进程可以并发执行各自的代码。</li>
<li><strong>多次返回</strong>：<code>fork</code> 会返回两次，一次在父进程中，一次在子进程中。</li>
</ul>
</li>
</ul>
<h4 id="exec-系统调用"><strong><code>exec</code> 系统调用</strong><a hidden class="anchor" aria-hidden="true" href="#exec-系统调用">#</a></h4>
<ul>
<li><strong>功能</strong>：<code>exec</code> 用于替换当前进程的代码和数据段，加载一个新程序并执行该程序。当 <code>exec</code> 被调用时，当前进程的所有内容（如代码、数据、堆栈）都被新程序替换，但进程的 PID 不变。</li>
<li>执行结果：
<ul>
<li><code>exec</code> 不返回，除非调用失败。成功调用 <code>exec</code> 后，旧的程序代码完全被新程序替换。</li>
<li>文件描述符不会被关闭（除非设置了 <code>close-on-exec</code> 标志）。</li>
</ul>
</li>
<li>特点：
<ul>
<li><code>exec</code> 只会改变进程的执行代码，不会创建新的进程。</li>
<li>新程序继承了调用进程的 PID 和文件描述符，但原有的内存数据、堆栈、代码等都会被新程序替换掉。</li>
</ul>
</li>
</ul>
<ul>
<li>
<p>example: <code>redirect.c</code>, redirect the output of a command
what does the shell do for this?</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-sh" data-lang="sh"><span style="display:flex;"><span>$ echo hello &gt; out
</span></span></code></pre></div><p>answer: fork, change FD 1 in child, exec echo</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-sh" data-lang="sh"><span style="display:flex;"><span>$ redirect
</span></span></code></pre></div><div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-sh" data-lang="sh"><span style="display:flex;"><span>$ cat output.txt
</span></span></code></pre></div><p><strong>note</strong>: <code>open()</code> always chooses lowest unused FD; 1 due to <code>close(1)</code>.
fork, FDs, and exec interact nicely to implement I/O redirection
separate fork-then-exec give child a chance to change FDs before exec
FDs provide indirection
commands just use FDs 0 and 1, don&rsquo;t have to know where they go
exec preserves the FDs that sh set up
thus: only sh has to know about I/O redirection, not each program</p>
</li>
</ul>
<h3 id="its-worth-asking-why-about-design-decisions">It&rsquo;s worth asking &ldquo;why&rdquo; about design decisions:<a hidden class="anchor" aria-hidden="true" href="#its-worth-asking-why-about-design-decisions">#</a></h3>
<p>Why these I/O and process abstractions? Why not something else?
Why provide a file system? Why not let programs use the disk their own way?
Why FDs? Why not pass a filename to write()?
Why are files streams of bytes, not disk blocks or formatted records?
Why not combine fork() and exec()?
The UNIX design works well, but we will see other designs!</p>
<ul>
<li>
<p>example: pipe1.c, communicate through a pipe
how does the shell implement</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-sh" data-lang="sh"><span style="display:flex;"><span>$ ls | grep x
</span></span></code></pre></div><div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-sh" data-lang="sh"><span style="display:flex;"><span>$ pipe1
</span></span></code></pre></div><p>an FD can refer to a &ldquo;pipe&rdquo;, as well as a file
the pipe() system call creates two FDs
read from the first FD
write to the second FD
the kernel maintains a buffer for each pipe
[u/k diagram]
<code>write()</code> appends to the buffer
<code>read()</code> waits until there is data</p>
</li>
<li>
<p>example: pipe2.c, communicate between processes
pipes combine well with fork() to implement ls | grep x
shell creates a pipe,
then forks (twice),
then connects ls&rsquo;s FD 1 to pipe&rsquo;s write FD,
and grep&rsquo;s FD 0 to the pipe
[diagram]</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-sh" data-lang="sh"><span style="display:flex;"><span>$ pipe2 -- a simplified version 
</span></span></code></pre></div><p>pipes are a separate abstraction, but combine well w/ fork()</p>
</li>
<li>
<p>example: list.c, list files in a directory
how does ls get a list of the files in a directory?
you can open a directory and read it -&gt; file names
&ldquo;.&rdquo; is a pseudo-name for a process&rsquo;s current directory
see ls.c for more details</p>
</li>
</ul>
<h3 id="summary">Summary<a hidden class="anchor" aria-hidden="true" href="#summary">#</a></h3>
<ul>
<li>We&rsquo;ve looked at UNIX&rsquo;s I/O, file system, and process abstractions.</li>
<li>The interfaces are simple &ndash; just integers and I/O buffers.</li>
<li>The abstractions combine well, e.g. for I/O redirection.</li>
</ul>
<p>You&rsquo;ll use these system calls in the first lab, due next week.</p>
<h2 id="code">Code<a hidden class="anchor" aria-hidden="true" href="#code">#</a></h2>
<h3 id="pipes">Pipes<a hidden class="anchor" aria-hidden="true" href="#pipes">#</a></h3>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#66d9ef">int</span> pipeFd[<span style="color:#ae81ff">2</span>];    <span style="color:#75715e">// 管道文件描述符数组，pipeFd[0]为读取端，pipeFd[1]为写入端
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">char</span> <span style="color:#f92672">*</span>arguments[<span style="color:#ae81ff">2</span>];  <span style="color:#75715e">// 存储传递给exec的参数
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>() {
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// 设置要执行的命令和参数
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    arguments[<span style="color:#ae81ff">0</span>] <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;wc&#34;</span>;   <span style="color:#75715e">// 将 &#34;wc&#34; 命令作为参数传递给exec，用于统计输入的行、单词和字符数
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    arguments[<span style="color:#ae81ff">1</span>] <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;      <span style="color:#75715e">// 以NULL表示参数结束
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// 创建管道
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#a6e22e">pipe</span>(pipeFd);          <span style="color:#75715e">// pipeFd[0]用于读取，pipeFd[1]用于写入
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// 创建子进程
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">if</span>(<span style="color:#a6e22e">fork</span>() <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span>) {      <span style="color:#75715e">// 子进程代码，fork()返回0表示当前是子进程
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#a6e22e">close</span>(<span style="color:#ae81ff">0</span>);          <span style="color:#75715e">// 关闭标准输入（文件描述符0）
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#a6e22e">dup</span>(pipeFd[<span style="color:#ae81ff">0</span>]);    <span style="color:#75715e">// 将管道的读取端复制到文件描述符0，使标准输入重定向到管道的读取端
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#a6e22e">close</span>(pipeFd[<span style="color:#ae81ff">0</span>]);  <span style="color:#75715e">// 关闭管道的读取端，已重定向到标准输入，不再需要
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#a6e22e">close</span>(pipeFd[<span style="color:#ae81ff">1</span>]);  <span style="color:#75715e">// 关闭管道的写入端，子进程不负责写入数据
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#a6e22e">exec</span>(<span style="color:#e6db74">&#34;/bin/wc&#34;</span>, arguments);  <span style="color:#75715e">// 执行wc命令，读取标准输入（从管道中读取），计算行、单词和字符数
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    } <span style="color:#66d9ef">else</span> {               <span style="color:#75715e">// 父进程代码
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#a6e22e">close</span>(pipeFd[<span style="color:#ae81ff">0</span>]);  <span style="color:#75715e">// 关闭管道的读取端，父进程不负责读取数据
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#75715e">// 向管道写入数据
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#a6e22e">write</span>(pipeFd[<span style="color:#ae81ff">1</span>], <span style="color:#e6db74">&#34;hello world</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>, <span style="color:#ae81ff">12</span>);  <span style="color:#75715e">// 将 &#34;hello world\n&#34; 写入管道，供子进程读取
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#a6e22e">close</span>(pipeFd[<span style="color:#ae81ff">1</span>]);  <span style="color:#75715e">// 关闭管道的写入端，表示数据写入完成
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h3 id="catc">cat.c<a hidden class="anchor" aria-hidden="true" href="#catc">#</a></h3>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&#34;kernel/types.h&#34;   // 包含系统调用相关的类型定义</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&#34;kernel/stat.h&#34;    // 包含文件状态相关的定义</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&#34;user/user.h&#34;      // 包含用户态函数的声明（如 read, write, open, close, fprintf, exit）</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">char</span> buf[<span style="color:#ae81ff">512</span>];  <span style="color:#75715e">// 定义一个缓冲区，用于存储读取的数据
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 函数：cat
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">// 参数：int fd - 文件描述符
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">// 功能：从文件描述符 fd 中读取数据，并将其写入标准输出（文件描述符 1）
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">void</span>
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">cat</span>(<span style="color:#66d9ef">int</span> fd)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">int</span> n;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#75715e">// 从文件描述符 fd 中读取数据到 buf 中，读取的字节数存储在 n 中
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  <span style="color:#66d9ef">while</span>((n <span style="color:#f92672">=</span> <span style="color:#a6e22e">read</span>(fd, buf, <span style="color:#66d9ef">sizeof</span>(buf))) <span style="color:#f92672">&gt;</span> <span style="color:#ae81ff">0</span>) {
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// 将读取的数据写入标准输出
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">if</span> (<span style="color:#a6e22e">write</span>(<span style="color:#ae81ff">1</span>, buf, n) <span style="color:#f92672">!=</span> n) {
</span></span><span style="display:flex;"><span>      <span style="color:#75715e">// 如果写入的字节数不等于读取的字节数，报告写入错误
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>      <span style="color:#a6e22e">fprintf</span>(<span style="color:#ae81ff">2</span>, <span style="color:#e6db74">&#34;cat: write error</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>);
</span></span><span style="display:flex;"><span>      <span style="color:#a6e22e">exit</span>(<span style="color:#ae81ff">1</span>);
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>  
</span></span><span style="display:flex;"><span>  <span style="color:#75715e">// 如果读取过程中出现错误，报告读取错误并退出
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  <span style="color:#66d9ef">if</span>(n <span style="color:#f92672">&lt;</span> <span style="color:#ae81ff">0</span>){
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">fprintf</span>(<span style="color:#ae81ff">2</span>, <span style="color:#e6db74">&#34;cat: read error</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>);
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">exit</span>(<span style="color:#ae81ff">1</span>);
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 主函数
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">int</span>
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">main</span>(<span style="color:#66d9ef">int</span> argc, <span style="color:#66d9ef">char</span> <span style="color:#f92672">*</span>argv[])
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">int</span> fd, i;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#75715e">// 如果没有提供文件参数，默认读取标准输入（文件描述符 0）
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  <span style="color:#66d9ef">if</span>(argc <span style="color:#f92672">&lt;=</span> <span style="color:#ae81ff">1</span>){
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">cat</span>(<span style="color:#ae81ff">0</span>);
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">exit</span>(<span style="color:#ae81ff">0</span>);
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#75715e">// 遍历命令行参数中的文件名
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  <span style="color:#66d9ef">for</span>(i <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>; i <span style="color:#f92672">&lt;</span> argc; i<span style="color:#f92672">++</span>){
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// 打开文件，获取文件描述符
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">if</span>((fd <span style="color:#f92672">=</span> <span style="color:#a6e22e">open</span>(argv[i], <span style="color:#ae81ff">0</span>)) <span style="color:#f92672">&lt;</span> <span style="color:#ae81ff">0</span>){
</span></span><span style="display:flex;"><span>      <span style="color:#75715e">// 如果文件无法打开，报告错误并退出
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>      <span style="color:#a6e22e">fprintf</span>(<span style="color:#ae81ff">2</span>, <span style="color:#e6db74">&#34;cat: cannot open %s</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>, argv[i]);
</span></span><span style="display:flex;"><span>      <span style="color:#a6e22e">exit</span>(<span style="color:#ae81ff">1</span>);
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// 调用 cat 函数，将文件内容输出到标准输出
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#a6e22e">cat</span>(fd);
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// 关闭文件描述符
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#a6e22e">close</span>(fd);
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>  
</span></span><span style="display:flex;"><span>  <span style="color:#75715e">// 正常退出
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  <span style="color:#a6e22e">exit</span>(<span style="color:#ae81ff">0</span>);
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h3 id="echoc">echo.c<a hidden class="anchor" aria-hidden="true" href="#echoc">#</a></h3>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&#34;kernel/types.h&#34;   // 包含系统调用相关的类型定义</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&#34;kernel/stat.h&#34;    // 包含文件状态相关的定义</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&#34;user/user.h&#34;      // 包含用户态函数的声明（如 write, exit, strlen）</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span>
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">main</span>(<span style="color:#66d9ef">int</span> argc, <span style="color:#66d9ef">char</span> <span style="color:#f92672">*</span>argv[])
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">int</span> i;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#75715e">// 遍历命令行参数，从第一个参数（argv[1]）开始
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  <span style="color:#66d9ef">for</span>(i <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>; i <span style="color:#f92672">&lt;</span> argc; i<span style="color:#f92672">++</span>){
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// 将当前参数 argv[i] 写入标准输出（文件描述符 1）
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#a6e22e">write</span>(<span style="color:#ae81ff">1</span>, argv[i], <span style="color:#a6e22e">strlen</span>(argv[i]));
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// 如果不是最后一个参数，在其后写入一个空格
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">if</span>(i <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span> <span style="color:#f92672">&lt;</span> argc){
</span></span><span style="display:flex;"><span>      <span style="color:#a6e22e">write</span>(<span style="color:#ae81ff">1</span>, <span style="color:#e6db74">&#34; &#34;</span>, <span style="color:#ae81ff">1</span>);
</span></span><span style="display:flex;"><span>    } <span style="color:#66d9ef">else</span> {
</span></span><span style="display:flex;"><span>      <span style="color:#75715e">// 如果是最后一个参数，在其后写入一个换行符
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>      <span style="color:#a6e22e">write</span>(<span style="color:#ae81ff">1</span>, <span style="color:#e6db74">&#34;</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>, <span style="color:#ae81ff">1</span>);
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>  
</span></span><span style="display:flex;"><span>  <span style="color:#75715e">// 正常退出程序
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  <span style="color:#a6e22e">exit</span>(<span style="color:#ae81ff">0</span>);
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h3 id="forktestc">forktest.c<a hidden class="anchor" aria-hidden="true" href="#forktestc">#</a></h3>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#75715e">// 测试 fork 是否能在进程表满时优雅地失败。
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">// 这个程序是一个小的可执行文件，用于填充进程表以测试 fork 的行为。
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&#34;kernel/types.h&#34;   // 包含系统调用相关的类型定义</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&#34;kernel/stat.h&#34;    // 包含文件状态相关的定义</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&#34;user/user.h&#34;      // 包含用户态函数的声明（如 write, exit, fork, wait, strlen）</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">#define N  1000  </span><span style="color:#75715e">// 定义测试的 fork 最大次数
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 函数：print
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">// 参数：const char *s - 要输出的字符串
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">// 功能：将字符串 s 写入标准输出（文件描述符 1）
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">void</span>
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">print</span>(<span style="color:#66d9ef">const</span> <span style="color:#66d9ef">char</span> <span style="color:#f92672">*</span>s)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">write</span>(<span style="color:#ae81ff">1</span>, s, <span style="color:#a6e22e">strlen</span>(s));  <span style="color:#75715e">// 使用 write 系统调用将字符串写入标准输出
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 函数：forktest
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">// 功能：测试 fork 系统调用的行为，特别是在进程表满时
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">void</span>
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">forktest</span>(<span style="color:#66d9ef">void</span>)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">int</span> n, pid;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#75715e">// 输出开始测试的信息
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  <span style="color:#a6e22e">print</span>(<span style="color:#e6db74">&#34;fork test</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#75715e">// 循环尝试创建 N 个子进程
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  <span style="color:#66d9ef">for</span>(n <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; n <span style="color:#f92672">&lt;</span> N; n<span style="color:#f92672">++</span>){
</span></span><span style="display:flex;"><span>    pid <span style="color:#f92672">=</span> <span style="color:#a6e22e">fork</span>();  <span style="color:#75715e">// 创建一个子进程
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">if</span>(pid <span style="color:#f92672">&lt;</span> <span style="color:#ae81ff">0</span>)
</span></span><span style="display:flex;"><span>      <span style="color:#66d9ef">break</span>;  <span style="color:#75715e">// 如果 fork 失败，退出循环
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">if</span>(pid <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span>)
</span></span><span style="display:flex;"><span>      <span style="color:#a6e22e">exit</span>(<span style="color:#ae81ff">0</span>);  <span style="color:#75715e">// 子进程退出
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#75715e">// 如果成功创建了 N 个子进程，表示 fork 行为异常
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  <span style="color:#66d9ef">if</span>(n <span style="color:#f92672">==</span> N){
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">print</span>(<span style="color:#e6db74">&#34;fork claimed to work N times!</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>);
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">exit</span>(<span style="color:#ae81ff">1</span>);
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#75715e">// 等待所有子进程结束
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  <span style="color:#66d9ef">for</span>(; n <span style="color:#f92672">&gt;</span> <span style="color:#ae81ff">0</span>; n<span style="color:#f92672">--</span>){
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span>(<span style="color:#a6e22e">wait</span>(<span style="color:#ae81ff">0</span>) <span style="color:#f92672">&lt;</span> <span style="color:#ae81ff">0</span>){  <span style="color:#75715e">// 等待子进程结束
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>      <span style="color:#a6e22e">print</span>(<span style="color:#e6db74">&#34;wait stopped early</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>);
</span></span><span style="display:flex;"><span>      <span style="color:#a6e22e">exit</span>(<span style="color:#ae81ff">1</span>);  <span style="color:#75715e">// 如果 wait 失败，报告错误并退出
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    }
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#75715e">// 如果 wait 没有返回 -1，表示还有多余的子进程
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  <span style="color:#66d9ef">if</span>(<span style="color:#a6e22e">wait</span>(<span style="color:#ae81ff">0</span>) <span style="color:#f92672">!=</span> <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>){
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">print</span>(<span style="color:#e6db74">&#34;wait got too many</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>);
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">exit</span>(<span style="color:#ae81ff">1</span>);
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#75715e">// 输出测试成功的信息
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  <span style="color:#a6e22e">print</span>(<span style="color:#e6db74">&#34;fork test OK</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>);
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 主函数
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">int</span>
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">main</span>(<span style="color:#66d9ef">void</span>)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">forktest</span>();  <span style="color:#75715e">// 执行 fork 测试
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  <span style="color:#a6e22e">exit</span>(<span style="color:#ae81ff">0</span>);     <span style="color:#75715e">// 正常退出程序
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>}
</span></span></code></pre></div><h3 id="stressfsc">stressfs.c<a hidden class="anchor" aria-hidden="true" href="#stressfsc">#</a></h3>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#75715e">// Demonstrate that moving the &#34;acquire&#34; in iderw after the loop that
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">// appends to the idequeue results in a race.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// For this to work, you should also add a spin within iderw&#39;s
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">// idequeue traversal loop.  Adding the following demonstrated a panic
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">// after about 5 runs of stressfs in QEMU on a 2.1GHz CPU:
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">//    for (i = 0; i &lt; 40000; i++)
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">//      asm volatile(&#34;&#34;);
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&#34;kernel/types.h&#34;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&#34;kernel/stat.h&#34;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&#34;user/user.h&#34;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&#34;kernel/fs.h&#34;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&#34;kernel/fcntl.h&#34;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span>
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">main</span>(<span style="color:#66d9ef">int</span> argc, <span style="color:#66d9ef">char</span> <span style="color:#f92672">*</span>argv[])
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">int</span> fd, i;
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">char</span> path[] <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;stressfs0&#34;</span>;
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">char</span> data[<span style="color:#ae81ff">512</span>];
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">printf</span>(<span style="color:#e6db74">&#34;stressfs starting</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>);
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">memset</span>(data, <span style="color:#e6db74">&#39;a&#39;</span>, <span style="color:#66d9ef">sizeof</span>(data));
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">for</span>(i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; i <span style="color:#f92672">&lt;</span> <span style="color:#ae81ff">4</span>; i<span style="color:#f92672">++</span>)
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span>(<span style="color:#a6e22e">fork</span>() <span style="color:#f92672">&gt;</span> <span style="color:#ae81ff">0</span>)
</span></span><span style="display:flex;"><span>      <span style="color:#66d9ef">break</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">printf</span>(<span style="color:#e6db74">&#34;write %d</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>, i);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  path[<span style="color:#ae81ff">8</span>] <span style="color:#f92672">+=</span> i;
</span></span><span style="display:flex;"><span>  fd <span style="color:#f92672">=</span> <span style="color:#a6e22e">open</span>(path, O_CREATE <span style="color:#f92672">|</span> O_RDWR);
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">for</span>(i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; i <span style="color:#f92672">&lt;</span> <span style="color:#ae81ff">20</span>; i<span style="color:#f92672">++</span>)
</span></span><span style="display:flex;"><span><span style="color:#75715e">//    printf(fd, &#34;%d\n&#34;, i);
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#a6e22e">write</span>(fd, data, <span style="color:#66d9ef">sizeof</span>(data));
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">close</span>(fd);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">printf</span>(<span style="color:#e6db74">&#34;read</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  fd <span style="color:#f92672">=</span> <span style="color:#a6e22e">open</span>(path, O_RDONLY);
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">for</span> (i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; i <span style="color:#f92672">&lt;</span> <span style="color:#ae81ff">20</span>; i<span style="color:#f92672">++</span>)
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">read</span>(fd, data, <span style="color:#66d9ef">sizeof</span>(data));
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">close</span>(fd);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">wait</span>(<span style="color:#ae81ff">0</span>);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">exit</span>(<span style="color:#ae81ff">0</span>);
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h2 id="lab---utilhttpspdoscsailmitedu6s0812020labsutilhtml"><a href="https://pdos.csail.mit.edu/6.S081/2020/labs/util.html">Lab - Util</a><a hidden class="anchor" aria-hidden="true" href="#lab---utilhttpspdoscsailmitedu6s0812020labsutilhtml">#</a></h2>
<h3 id="sleep-easyhttpspdoscsailmitedu6s0812020labsguidancehtml">sleep (<a href="https://pdos.csail.mit.edu/6.S081/2020/labs/guidance.html">easy</a>)<a hidden class="anchor" aria-hidden="true" href="#sleep-easyhttpspdoscsailmitedu6s0812020labsguidancehtml">#</a></h3>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&#34;kernel/types.h&#34;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&#34;kernel/stat.h&#34;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&#34;user/user.h&#34;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span>
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">main</span>(<span style="color:#66d9ef">int</span> argc, <span style="color:#66d9ef">char</span> <span style="color:#f92672">*</span>argv[])
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">if</span>(argc <span style="color:#f92672">!=</span> <span style="color:#ae81ff">2</span>){
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">fprintf</span>(<span style="color:#ae81ff">2</span>, <span style="color:#e6db74">&#34;Usage: sleep [the times of ticks]...</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>);
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">exit</span>(<span style="color:#ae81ff">1</span>);
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">int</span> times <span style="color:#f92672">=</span> <span style="color:#a6e22e">atoi</span>(argv[<span style="color:#ae81ff">1</span>]);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">sleep</span>(times);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">exit</span>(<span style="color:#ae81ff">0</span>);
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h3 id="pingpong-easyhttpspdoscsailmitedu6s0812020labsguidancehtml">pingpong (<a href="https://pdos.csail.mit.edu/6.S081/2020/labs/guidance.html">easy</a>)<a hidden class="anchor" aria-hidden="true" href="#pingpong-easyhttpspdoscsailmitedu6s0812020labsguidancehtml">#</a></h3>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&#34;kernel/types.h&#34;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&#34;kernel/stat.h&#34;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&#34;user/user.h&#34;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>(<span style="color:#66d9ef">int</span> argc, <span style="color:#66d9ef">char</span> <span style="color:#f92672">*</span>argv[])
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> (argc <span style="color:#f92672">&gt;</span> <span style="color:#ae81ff">1</span>)
</span></span><span style="display:flex;"><span>    {
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">fprintf</span>(<span style="color:#ae81ff">2</span>, <span style="color:#e6db74">&#34;Usage: pingpong (without any parameters)</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>);
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">exit</span>(<span style="color:#ae81ff">1</span>);
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> pipe_fd[<span style="color:#ae81ff">2</span>];
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> (<span style="color:#a6e22e">pipe</span>(pipe_fd) <span style="color:#f92672">&lt;</span> <span style="color:#ae81ff">0</span>)
</span></span><span style="display:flex;"><span>    {
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">fprintf</span>(<span style="color:#ae81ff">2</span>, <span style="color:#e6db74">&#34;pipe error</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>);
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">exit</span>(<span style="color:#ae81ff">1</span>);
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> pid <span style="color:#f92672">=</span> <span style="color:#a6e22e">fork</span>();
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> (pid <span style="color:#f92672">&gt;</span> <span style="color:#ae81ff">0</span>)
</span></span><span style="display:flex;"><span>    {
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// 父进程关闭管道的写端
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#a6e22e">close</span>(pipe_fd[<span style="color:#ae81ff">1</span>]);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// 父进程等待子进程的信号
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#66d9ef">char</span> buf[<span style="color:#ae81ff">1</span>];
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">read</span>(pipe_fd[<span style="color:#ae81ff">0</span>], buf, <span style="color:#ae81ff">1</span>);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        pid <span style="color:#f92672">=</span> <span style="color:#a6e22e">wait</span>((<span style="color:#66d9ef">int</span> <span style="color:#f92672">*</span>)<span style="color:#ae81ff">0</span>);
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">printf</span>(<span style="color:#e6db74">&#34;%d: received pong</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>, <span style="color:#a6e22e">getpid</span>());
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// 父进程关闭管道的读端
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#a6e22e">close</span>(pipe_fd[<span style="color:#ae81ff">0</span>]);
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">else</span> <span style="color:#66d9ef">if</span> (pid <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span>)
</span></span><span style="display:flex;"><span>    {
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// 子进程关闭管道的读端
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#a6e22e">close</span>(pipe_fd[<span style="color:#ae81ff">0</span>]);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">printf</span>(<span style="color:#e6db74">&#34;%d: received ping</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>, <span style="color:#a6e22e">getpid</span>());
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// 子进程通过管道向父进程发送信号
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#a6e22e">write</span>(pipe_fd[<span style="color:#ae81ff">1</span>], <span style="color:#e6db74">&#34;x&#34;</span>, <span style="color:#ae81ff">1</span>);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// 子进程关闭管道的写端
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#a6e22e">close</span>(pipe_fd[<span style="color:#ae81ff">1</span>]);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">exit</span>(<span style="color:#ae81ff">0</span>);
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">else</span>
</span></span><span style="display:flex;"><span>    {
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">printf</span>(<span style="color:#e6db74">&#34;fork error</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>);
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">exit</span>(<span style="color:#ae81ff">1</span>);
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">exit</span>(<span style="color:#ae81ff">0</span>);
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h3 id="primes-moderatehttpspdoscsailmitedu6s0812020labsguidancehtmlhardhttpspdoscsailmitedu6s0812020labsguidancehtml">primes (<a href="https://pdos.csail.mit.edu/6.S081/2020/labs/guidance.html">moderate</a>)/(<a href="https://pdos.csail.mit.edu/6.S081/2020/labs/guidance.html">hard</a>)<a hidden class="anchor" aria-hidden="true" href="#primes-moderatehttpspdoscsailmitedu6s0812020labsguidancehtmlhardhttpspdoscsailmitedu6s0812020labsguidancehtml">#</a></h3>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&#34;kernel/types.h&#34;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&#34;kernel/stat.h&#34;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&#34;user/user.h&#34;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">sieve</span>(<span style="color:#66d9ef">int</span> p_left) {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> p_right[<span style="color:#ae81ff">2</span>];
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> prime;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// 从左侧管道读取第一个数字
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">if</span> (<span style="color:#a6e22e">read</span>(p_left, <span style="color:#f92672">&amp;</span>prime, <span style="color:#66d9ef">sizeof</span>(<span style="color:#66d9ef">int</span>)) <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span>) {
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">close</span>(p_left);
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">exit</span>(<span style="color:#ae81ff">0</span>);
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// 输出该素数
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#a6e22e">printf</span>(<span style="color:#e6db74">&#34;prime %d</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>, prime);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// 创建一个新的管道
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">if</span> (<span style="color:#a6e22e">pipe</span>(p_right) <span style="color:#f92672">&lt;</span> <span style="color:#ae81ff">0</span>) {
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">fprintf</span>(<span style="color:#ae81ff">2</span>, <span style="color:#e6db74">&#34;pipe error</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>);
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">exit</span>(<span style="color:#ae81ff">1</span>);
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> (<span style="color:#a6e22e">fork</span>() <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span>) {
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// 子进程递归处理
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#a6e22e">close</span>(p_right[<span style="color:#ae81ff">1</span>]);
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">sieve</span>(p_right[<span style="color:#ae81ff">0</span>]);
</span></span><span style="display:flex;"><span>    } <span style="color:#66d9ef">else</span> {
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// 父进程继续读取并筛选
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#a6e22e">close</span>(p_right[<span style="color:#ae81ff">0</span>]);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">int</span> num;
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">while</span> (<span style="color:#a6e22e">read</span>(p_left, <span style="color:#f92672">&amp;</span>num, <span style="color:#66d9ef">sizeof</span>(<span style="color:#66d9ef">int</span>)) <span style="color:#f92672">!=</span> <span style="color:#ae81ff">0</span>) {
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">if</span> (num <span style="color:#f92672">%</span> prime <span style="color:#f92672">!=</span> <span style="color:#ae81ff">0</span>) {
</span></span><span style="display:flex;"><span>                <span style="color:#a6e22e">write</span>(p_right[<span style="color:#ae81ff">1</span>], <span style="color:#f92672">&amp;</span>num, <span style="color:#66d9ef">sizeof</span>(<span style="color:#66d9ef">int</span>));
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// 关闭管道，等待子进程结束
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#a6e22e">close</span>(p_left);
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">close</span>(p_right[<span style="color:#ae81ff">1</span>]);
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">wait</span>(<span style="color:#ae81ff">0</span>);
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">exit</span>(<span style="color:#ae81ff">0</span>);
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>(<span style="color:#66d9ef">int</span> argc, <span style="color:#66d9ef">char</span> <span style="color:#f92672">*</span>argv[]) {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> p[<span style="color:#ae81ff">2</span>];
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> (<span style="color:#a6e22e">pipe</span>(p) <span style="color:#f92672">&lt;</span> <span style="color:#ae81ff">0</span>) {
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">fprintf</span>(<span style="color:#ae81ff">2</span>, <span style="color:#e6db74">&#34;pipe error</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>);
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">exit</span>(<span style="color:#ae81ff">1</span>);
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> (<span style="color:#a6e22e">fork</span>() <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span>) {
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">close</span>(p[<span style="color:#ae81ff">1</span>]);
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">sieve</span>(p[<span style="color:#ae81ff">0</span>]);
</span></span><span style="display:flex;"><span>    } <span style="color:#66d9ef">else</span> {
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">close</span>(p[<span style="color:#ae81ff">0</span>]);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// 将 2 到 35 的数字写入管道
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">2</span>; i <span style="color:#f92672">&lt;=</span> <span style="color:#ae81ff">35</span>; i<span style="color:#f92672">++</span>) {
</span></span><span style="display:flex;"><span>            <span style="color:#a6e22e">write</span>(p[<span style="color:#ae81ff">1</span>], <span style="color:#f92672">&amp;</span>i, <span style="color:#66d9ef">sizeof</span>(<span style="color:#66d9ef">int</span>));
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">close</span>(p[<span style="color:#ae81ff">1</span>]);
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">wait</span>(<span style="color:#ae81ff">0</span>);
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">exit</span>(<span style="color:#ae81ff">0</span>);
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h3 id="find-moderatehttpspdoscsailmitedu6s0812020labsguidancehtml">find (<a href="https://pdos.csail.mit.edu/6.S081/2020/labs/guidance.html">moderate</a>)<a hidden class="anchor" aria-hidden="true" href="#find-moderatehttpspdoscsailmitedu6s0812020labsguidancehtml">#</a></h3>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&#34;kernel/types.h&#34;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&#34;kernel/stat.h&#34;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&#34;user/user.h&#34;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&#34;kernel/fs.h&#34;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&#34;kernel/fcntl.h&#34;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">#define MAXBUF 512  </span><span style="color:#75715e">// 定义缓冲区大小
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">/**
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"> * find - 递归查找目录树中与指定文件名匹配的文件。
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"> * @path: 要搜索的目录路径。
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"> * @filename: 要查找的文件名。
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"> *
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"> * 该函数通过递归遍历目录树，打印出与指定文件名匹配的文件的路径。
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"> * 它会忽略特殊目录项 `.` 和 `..` 以避免递归回到当前或父目录。
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"> */</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">find</span>(<span style="color:#66d9ef">char</span> <span style="color:#f92672">*</span>path, <span style="color:#66d9ef">char</span> <span style="color:#f92672">*</span>filename) {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">char</span> buf[<span style="color:#ae81ff">512</span>], <span style="color:#f92672">*</span>p;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> fd;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">struct</span> dirent de;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">struct</span> stat st;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// 打开指定的目录路径
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">if</span> ((fd <span style="color:#f92672">=</span> <span style="color:#a6e22e">open</span>(path, <span style="color:#ae81ff">0</span>)) <span style="color:#f92672">&lt;</span> <span style="color:#ae81ff">0</span>) {
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">fprintf</span>(<span style="color:#ae81ff">2</span>, <span style="color:#e6db74">&#34;find: cannot open %s</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>, path);
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span>;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// 获取文件状态（例如确定是文件还是目录）
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">if</span> (<span style="color:#a6e22e">fstat</span>(fd, <span style="color:#f92672">&amp;</span>st) <span style="color:#f92672">&lt;</span> <span style="color:#ae81ff">0</span>) {
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">fprintf</span>(<span style="color:#ae81ff">2</span>, <span style="color:#e6db74">&#34;find: cannot stat %s</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>, path);
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">close</span>(fd);
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span>;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// 判断文件类型，处理不同的情况
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">switch</span> (st.type) {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">case</span> T_FILE:  <span style="color:#75715e">// 如果是普通文件
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#75715e">// 检查文件名是否与目标文件名匹配
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#66d9ef">if</span> (<span style="color:#a6e22e">strcmp</span>(path <span style="color:#f92672">+</span> <span style="color:#a6e22e">strlen</span>(path) <span style="color:#f92672">-</span> <span style="color:#a6e22e">strlen</span>(filename), filename) <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span>) {
</span></span><span style="display:flex;"><span>            <span style="color:#75715e">// 如果匹配，打印文件路径
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>            <span style="color:#a6e22e">printf</span>(<span style="color:#e6db74">&#34;%s</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>, path);  <span style="color:#75715e">// 注意这里每个匹配的文件都应该在新行打印
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        }
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">break</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">case</span> T_DIR:  <span style="color:#75715e">// 如果是目录
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#75715e">// 检查路径长度是否超出缓冲区大小
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#66d9ef">if</span> (<span style="color:#a6e22e">strlen</span>(path) <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span> <span style="color:#f92672">+</span> DIRSIZ <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span> <span style="color:#f92672">&gt;</span> <span style="color:#66d9ef">sizeof</span>(buf)) {
</span></span><span style="display:flex;"><span>            <span style="color:#a6e22e">printf</span>(<span style="color:#e6db74">&#34;find: path too long</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>);
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">break</span>;
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// 将当前路径复制到缓冲区中
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#a6e22e">strcpy</span>(buf, path);
</span></span><span style="display:flex;"><span>        p <span style="color:#f92672">=</span> buf <span style="color:#f92672">+</span> <span style="color:#a6e22e">strlen</span>(buf);
</span></span><span style="display:flex;"><span>        <span style="color:#f92672">*</span>p<span style="color:#f92672">++</span> <span style="color:#f92672">=</span> <span style="color:#e6db74">&#39;/&#39;</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// 读取目录中的每个目录项
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#66d9ef">while</span> (<span style="color:#a6e22e">read</span>(fd, <span style="color:#f92672">&amp;</span>de, <span style="color:#66d9ef">sizeof</span>(de)) <span style="color:#f92672">==</span> <span style="color:#66d9ef">sizeof</span>(de)) {
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">if</span> (de.inum <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span>)
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">continue</span>;  <span style="color:#75715e">// 跳过无效的目录项
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>            <span style="color:#75715e">// 将目录项名称复制到路径缓冲区
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>            <span style="color:#a6e22e">memmove</span>(p, de.name, DIRSIZ);
</span></span><span style="display:flex;"><span>            p[DIRSIZ] <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>            <span style="color:#75715e">// 忽略特殊目录项 `.` 和 `..`
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>            <span style="color:#66d9ef">if</span> (<span style="color:#a6e22e">strcmp</span>(de.name, <span style="color:#e6db74">&#34;.&#34;</span>) <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span> <span style="color:#f92672">||</span> <span style="color:#a6e22e">strcmp</span>(de.name, <span style="color:#e6db74">&#34;..&#34;</span>) <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span>)
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">continue</span>;
</span></span><span style="display:flex;"><span>            <span style="color:#75715e">// 递归调用 find 函数处理子目录或文件
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>            <span style="color:#a6e22e">find</span>(buf, filename);
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">break</span>;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// 关闭文件描述符以释放资源
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#a6e22e">close</span>(fd);
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">/**
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"> * main - 程序的入口点，解析命令行参数并调用 find 函数。
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"> * @argc: 参数个数。
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"> * @argv: 参数值数组。
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"> *
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"> * 该函数验证参数的正确性，并调用 find 函数开始递归查找。
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"> */</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>(<span style="color:#66d9ef">int</span> argc, <span style="color:#66d9ef">char</span> <span style="color:#f92672">*</span>argv[]) {
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// 检查命令行参数是否正确
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">if</span> (argc <span style="color:#f92672">&lt;</span> <span style="color:#ae81ff">3</span>) {
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// 如果参数不足，打印使用说明并退出
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#a6e22e">fprintf</span>(<span style="color:#ae81ff">2</span>, <span style="color:#e6db74">&#34;Usage: find &lt;directory&gt; &lt;filename&gt;</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>);
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">exit</span>(<span style="color:#ae81ff">1</span>);
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// 调用 find 函数，开始查找文件
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#a6e22e">find</span>(argv[<span style="color:#ae81ff">1</span>], argv[<span style="color:#ae81ff">2</span>]);
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">exit</span>(<span style="color:#ae81ff">0</span>);
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h3 id="xargs-moderatehttpspdoscsailmitedu6s0812020labsguidancehtml">xargs (<a href="https://pdos.csail.mit.edu/6.S081/2020/labs/guidance.html">moderate</a>)<a hidden class="anchor" aria-hidden="true" href="#xargs-moderatehttpspdoscsailmitedu6s0812020labsguidancehtml">#</a></h3>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&#34;kernel/types.h&#34;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&#34;kernel/stat.h&#34;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&#34;user/user.h&#34;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">#define MAXARG 32   </span><span style="color:#75715e">// 最大参数数量
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#75715e">#define MAXBUF 1024 </span><span style="color:#75715e">// 最大输入缓冲区大小
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 从标准输入读取一行
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">read_line</span>(<span style="color:#66d9ef">char</span> <span style="color:#f92672">*</span>buf, <span style="color:#66d9ef">int</span> size)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; <span style="color:#75715e">// 当前字符索引
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">char</span> c;    <span style="color:#75715e">// 存储读取的字符
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// 从标准输入逐字符读取，直到遇到换行符或缓冲区已满
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">while</span> (i <span style="color:#f92672">&lt;</span> size <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>)
</span></span><span style="display:flex;"><span>    {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> (<span style="color:#a6e22e">read</span>(<span style="color:#ae81ff">0</span>, <span style="color:#f92672">&amp;</span>c, <span style="color:#ae81ff">1</span>) <span style="color:#f92672">!=</span> <span style="color:#ae81ff">1</span>)
</span></span><span style="display:flex;"><span>        {
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">return</span> i; <span style="color:#75715e">// 到达输入结束或发生错误
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        }
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> (c <span style="color:#f92672">==</span> <span style="color:#e6db74">&#39;\n&#39;</span>)
</span></span><span style="display:flex;"><span>        {
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">break</span>; <span style="color:#75715e">// 遇到换行符，停止读取
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        }
</span></span><span style="display:flex;"><span>        buf[i<span style="color:#f92672">++</span>] <span style="color:#f92672">=</span> c; <span style="color:#75715e">// 将读取的字符存入缓冲区
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    }
</span></span><span style="display:flex;"><span>    buf[i] <span style="color:#f92672">=</span> <span style="color:#e6db74">&#39;\0&#39;</span>; <span style="color:#75715e">// 在字符串末尾添加 null 终止符
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">return</span> i;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>(<span style="color:#66d9ef">int</span> argc, <span style="color:#66d9ef">char</span> <span style="color:#f92672">*</span>argv[])
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> (argc <span style="color:#f92672">&lt;</span> <span style="color:#ae81ff">2</span>)
</span></span><span style="display:flex;"><span>    {
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">fprintf</span>(<span style="color:#ae81ff">2</span>, <span style="color:#e6db74">&#34;Usage: xargs command [initial-args]</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>); <span style="color:#75715e">// 如果没有提供命令参数，输出用法提示
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#a6e22e">exit</span>(<span style="color:#ae81ff">1</span>);                                             <span style="color:#75715e">// 退出程序
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">char</span> buf[MAXBUF]; <span style="color:#75715e">// 用于存储输入行的缓冲区
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// 从标准输入读取每一行
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">while</span> (<span style="color:#a6e22e">read_line</span>(buf, <span style="color:#66d9ef">sizeof</span>(buf)) <span style="color:#f92672">&gt;</span> <span style="color:#ae81ff">0</span>)
</span></span><span style="display:flex;"><span>    {
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// 创建命令行参数数组
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#66d9ef">char</span> <span style="color:#f92672">*</span>cmd_argv[MAXARG <span style="color:#f92672">+</span> <span style="color:#ae81ff">2</span>]; <span style="color:#75715e">// +2: 一个存放命令名，一个存放拼接后的参数
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        cmd_argv[<span style="color:#ae81ff">0</span>] <span style="color:#f92672">=</span> argv[<span style="color:#ae81ff">1</span>];      <span style="color:#75715e">// 命令名称
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">int</span> i;
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// 复制用户提供的初始参数（如果有）
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#66d9ef">for</span> (i <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>; i <span style="color:#f92672">&lt;</span> argc <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span> <span style="color:#f92672">&amp;&amp;</span> i <span style="color:#f92672">&lt;</span> MAXARG; i<span style="color:#f92672">++</span>)
</span></span><span style="display:flex;"><span>        {
</span></span><span style="display:flex;"><span>            cmd_argv[i] <span style="color:#f92672">=</span> argv[i <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>];
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// 将读取的行作为最后一个参数
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        cmd_argv[i<span style="color:#f92672">++</span>] <span style="color:#f92672">=</span> buf;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        cmd_argv[i] <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; <span style="color:#75715e">// 参数列表以 null 终止
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">int</span> pid <span style="color:#f92672">=</span> <span style="color:#a6e22e">fork</span>(); <span style="color:#75715e">// 创建子进程
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#66d9ef">if</span> (pid <span style="color:#f92672">&lt;</span> <span style="color:#ae81ff">0</span>)
</span></span><span style="display:flex;"><span>        {
</span></span><span style="display:flex;"><span>            <span style="color:#a6e22e">fprintf</span>(<span style="color:#ae81ff">2</span>, <span style="color:#e6db74">&#34;xargs: fork failed</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>); <span style="color:#75715e">// 如果创建子进程失败，输出错误信息
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>            <span style="color:#a6e22e">exit</span>(<span style="color:#ae81ff">1</span>);                            <span style="color:#75715e">// 退出程序
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        }
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">else</span> <span style="color:#66d9ef">if</span> (pid <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span>)
</span></span><span style="display:flex;"><span>        {
</span></span><span style="display:flex;"><span>            <span style="color:#a6e22e">exec</span>(cmd_argv[<span style="color:#ae81ff">0</span>], cmd_argv);        <span style="color:#75715e">// 执行命令
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>            <span style="color:#a6e22e">fprintf</span>(<span style="color:#ae81ff">2</span>, <span style="color:#e6db74">&#34;xargs: exec failed</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>); <span style="color:#75715e">// 如果执行命令失败，输出错误信息
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>            <span style="color:#a6e22e">exit</span>(<span style="color:#ae81ff">1</span>);                            <span style="color:#75715e">// 退出子进程
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        }
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">else</span>
</span></span><span style="display:flex;"><span>        {
</span></span><span style="display:flex;"><span>            <span style="color:#75715e">// 父进程中
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>            <span style="color:#a6e22e">wait</span>(<span style="color:#ae81ff">0</span>); <span style="color:#75715e">// 等待子进程完成
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">exit</span>(<span style="color:#ae81ff">0</span>); <span style="color:#75715e">// 正常退出程序
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>}
</span></span></code></pre></div>

  </div>

  <footer class="post-footer">
    <ul class="post-tags">
      <li><a href="https://kennems.github.io/tags/mit6.s081/">MIT6.S081</a></li>
    </ul>
        
    
    <ul id="categories">
      
        <li><a href="https://kennems.github.io/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F">操作系统</a> </li>
      
    </ul>
    
    
<nav class="paginav">
  <a class="prev" href="https://kennems.github.io/posts/read/%E8%82%A1%E7%A5%A8/">
    <span class="title">« 上一页</span>
    <br>
    <span>股票</span>
  </a>
  <a class="next" href="https://kennems.github.io/posts/tech/mit6.s0813-os-organization/">
    <span class="title">下一页 »</span>
    <br>
    <span>MIT6.S081(3)-OS organization</span>
  </a>
</nav>

  </footer>
</article>
    </main>
    
<footer class="footer">
        <span>&copy; 2025 <a href="https://kennems.github.io/">Kennem&#39;s Blog</a></span> · 

    <span>
        Powered by
        <a href="https://gohugo.io/" rel="noopener noreferrer" target="_blank">Hugo</a> &
        <a href="https://github.com/adityatelange/hugo-PaperMod/" rel="noopener" target="_blank">PaperMod</a>
    </span>
</footer>
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)" class="top-link" id="top-link" accesskey="g">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
        <path d="M12 6H0l6-6z" />
    </svg>
</a>

<script>
    let menu = document.getElementById('menu')
    if (menu) {
        menu.scrollLeft = localStorage.getItem("menu-scroll-position");
        menu.onscroll = function () {
            localStorage.setItem("menu-scroll-position", menu.scrollLeft);
        }
    }

    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.pushState(null, null, `#${id}`);
            }
        });
    });

</script>
<script>
    var mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };

</script>
<script>
    document.getElementById("theme-toggle").addEventListener("click", () => {
        if (document.body.className.includes("dark")) {
            document.body.classList.remove('dark');
            localStorage.setItem("pref-theme", 'light');
        } else {
            document.body.classList.add('dark');
            localStorage.setItem("pref-theme", 'dark');
        }
    })

</script>
<script>
    document.querySelectorAll('pre > code').forEach((codeblock) => {
        const container = codeblock.parentNode.parentNode;

        const copybutton = document.createElement('button');
        copybutton.classList.add('copy-code');
        copybutton.innerHTML = '复制';

        function copyingDone() {
            copybutton.innerHTML = '已复制！';
            setTimeout(() => {
                copybutton.innerHTML = '复制';
            }, 2000);
        }

        copybutton.addEventListener('click', (cb) => {
            if ('clipboard' in navigator) {
                navigator.clipboard.writeText(codeblock.textContent);
                copyingDone();
                return;
            }

            const range = document.createRange();
            range.selectNodeContents(codeblock);
            const selection = window.getSelection();
            selection.removeAllRanges();
            selection.addRange(range);
            try {
                document.execCommand('copy');
                copyingDone();
            } catch (e) { };
            selection.removeRange(range);
        });

        if (container.classList.contains("highlight")) {
            container.appendChild(copybutton);
        } else if (container.parentNode.firstChild == container) {
            
        } else if (codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName == "TABLE") {
            
            codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(copybutton);
        } else {
            
            codeblock.parentNode.appendChild(copybutton);
        }
    });
</script>
<footer class="footer">
    <script async src="https://busuanzi.sukap.cn/busuanzi.pure.mini.js"></script>
    <span id="busuanzi_container">
        <link rel="stylesheet" href="//maxcdn.bootstrapcdn.com/font-awesome/4.3.0/css/font-awesome.min.css">
        Visitors: <span id="busuanzi_value_page_uv"></span>
        Views: <span id="busuanzi_value_page_pv"></span>

        
    </span>
</footer>



</body>

</html>
