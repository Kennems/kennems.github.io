<!DOCTYPE html>
<html lang="zh" dir="auto">

<head><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="index, follow">

<meta name="msvalidate.01" content="DF5FE493CC759E62BFE073BEA8EFD472" />
<title>MIT6.S081(11)- Thread switching | Kennem&#39;s Blog</title>
<meta name="keywords" content="MIT6.S081">
<meta name="description" content="MIT6.S081(11)- Thread switching">
<meta name="author" content="ShowGuan">
<link rel="canonical" href="https://kennems.github.io/posts/tech/mit6.s08111--thread-switching/">
<link crossorigin="anonymous" href="/assets/css/stylesheet.7045628b25fd3fad918f2f9c49167d0b138d1b1fb53e698f76bfb9c755495fef.css" integrity="sha256-cEViiyX9P62Rjy&#43;cSRZ9CxONGx&#43;1PmmPdr&#43;5x1VJX&#43;8=" rel="preload stylesheet" as="style">
<link rel="icon" href="https://kennems.github.io/img/sun.png">
<link rel="icon" type="image/png" sizes="16x16" href="https://kennems.github.io/img/sun.png">
<link rel="icon" type="image/png" sizes="32x32" href="https://kennems.github.io/img/sun.png">
<link rel="apple-touch-icon" href="https://kennems.github.io/img/sun.png">
<link rel="mask-icon" href="https://kennems.github.io/img/sun.png">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<link rel="alternate" hreflang="zh" href="https://kennems.github.io/posts/tech/mit6.s08111--thread-switching/">
<noscript>
    <style>
        #theme-toggle,
        .top-link {
            display: none;
        }

    </style>
    <style>
        @media (prefers-color-scheme: dark) {
            :root {
                --theme: rgb(29, 30, 32);
                --entry: rgb(46, 46, 51);
                --primary: rgb(218, 218, 219);
                --secondary: rgb(155, 156, 157);
                --tertiary: rgb(65, 66, 68);
                --content: rgb(196, 196, 197);
                --code-block-bg: rgb(46, 46, 51);
                --code-bg: rgb(55, 56, 62);
                --border: rgb(51, 51, 51);
            }

            .list {
                background: var(--theme);
            }

            .list:not(.dark)::-webkit-scrollbar-track {
                background: 0 0;
            }

            .list:not(.dark)::-webkit-scrollbar-thumb {
                border-color: var(--theme);
            }
        }

    </style>
</noscript>

<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.2/dist/katex.min.css" integrity="sha384-MlJdn/WNKDGXveldHDdyRP1R4CTHr3FeuDNfhsLPYrq2t0UBkUdK2jyTnXPEK1NQ" crossorigin="anonymous">

<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.2/dist/katex.min.js" integrity="sha384-VQ8d8WVFw0yHhCk5E8I86oOhv48xLpnDZx5T9GogA/Y84DcCKWXDmSDfn13bzFZY" crossorigin="anonymous"></script>

<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.2/dist/contrib/auto-render.min.js" integrity="sha384-+XBljXPPiv+OzfbB3cVmLHf4hdUFHlWNZN5spNQ7rmHTXpd7WvJum6fIACpNNfIR" crossorigin="anonymous"
    onload="renderMathInElement(document.body);"></script>


<script>
document.addEventListener("DOMContentLoaded", function() {
    renderMathInElement(document.body, {
        delimiters: [
            {left: "$$", right: "$$", display: true},
            {left: "$", right: "$", display: false}
        ]
    });
});
</script>


<link rel="stylesheet" href="https://fonts.cdnfonts.com/css/code-new-roman">
<link rel="preconnect" href="https://fonts.googleapis.com">
<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  

<meta property="og:url" content="https://kennems.github.io/posts/tech/mit6.s08111--thread-switching/">
  <meta property="og:site_name" content="Kennem&#39;s Blog">
  <meta property="og:title" content="MIT6.S081(11)- Thread switching">
  <meta property="og:description" content="MIT6.S081(11)- Thread switching">
  <meta property="og:locale" content="zh">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2024-09-21T19:30:13+08:00">
    <meta property="article:modified_time" content="2024-09-21T19:20:13+08:00">
    <meta property="article:tag" content="MIT6.S081">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="MIT6.S081(11)- Thread switching">
<meta name="twitter:description" content="MIT6.S081(11)- Thread switching">


<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BreadcrumbList",
  "itemListElement": [
    {
      "@type": "ListItem",
      "position":  1 ,
      "name": "ğŸ“šæ–‡ç« ",
      "item": "https://kennems.github.io/posts/"
    }, 
    {
      "@type": "ListItem",
      "position":  2 ,
      "name": "ğŸ’»æŠ€æœ¯",
      "item": "https://kennems.github.io/posts/tech/"
    }, 
    {
      "@type": "ListItem",
      "position":  3 ,
      "name": "MIT6.S081(11)- Thread switching",
      "item": "https://kennems.github.io/posts/tech/mit6.s08111--thread-switching/"
    }
  ]
}
</script>
<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "MIT6.S081(11)- Thread switching",
  "name": "MIT6.S081(11)- Thread switching",
  "description": "MIT6.S081(11)- Thread switching",
  "keywords": [
    "MIT6.S081"
  ],
  "articleBody": "MIT6.S081(11)- Thread switching Topic: more â€œunder the hoodâ€ with xv6 Previously: system calls, interrupts, page tables, locks Today: process/thread switching\nWhy support multiple tasks? Time-sharing: many users and/or many running programs. program structure: prime number sieve. parallel speedup on multi-core hardware.\nThreads are an abstraction to simplify programming when there are many tasks. thread = an independent serial execution â€“ registers, pc, stack the threading system interleaves the execution of multiple threads\nTwo main strategies: â€‹ multiple CPUs, each CPU runs a different thread â€‹ each CPU â€œswitchesâ€ between threads, runs one at a time\nthreads can share memory, or not xv6 kernel threads: they share kernel memory (thus locks) xv6 user processes: one thread per process, so no sharing linux: supports multiple threads sharing a user processâ€™s memory\nthere are other techniques for interleaving multiple tasks look up event-driven programming, or state machines threads are not the most efficient, but they are usually the most convenient\nThread design challenges How to interleave many threads on a few CPUs?\nHow to make interleaving transparent?\nâ€œschedulingâ€ = the process of choosing which thread to run next\nWhat to save while a thread isnâ€™t running?\nHow to cope with compute-bound threads?\nHow to cope with compute-bound threads?\neach CPU has timer hardware, which interrupts periodically kernel uses timer interrupts to grab control from looping threads kernel saves thread state, switches, eventually resumes, restores that saved state for transparency\nRUNNING vs RUNNABLE\nthis is â€œpre-emptiveâ€ scheduling â€“ a forced yield of unaware code as opposed to cooperative scheduling, in which code yields voluntarily\nWhat to do with a thread that isnâ€™t running? We need to set aside its state: registers, stack, memory though no need to worry about memory, it wonâ€™t go anywhere so implementation provides each thread with a stack and register save area need to track status of each thread RUNNING vs RUNNABLE vs SLEEPING\nin xv6:\n[simple diagram: processes, user stack, trapframe, kernel stack]\neach process has two threads, one user, one kernel a process is either executing its user thread, or in a system call or interrupt in its kernel thread kernel threads share kernel memory / data structures thus the kernel is a parallel program weâ€™ll use â€œprocessâ€ and â€œkernel threadâ€ and â€œthreadâ€ as synonyms\noverview of thread switching in xv6 (the point: switch among threads to interleave many threads on each CPU)\n[diagram: P1, TF1, STACK1, swtch(), CTX1; CTXs, swtch(), STACKs, scheduler(), \u0026c]\nTF = trapframe = saved user registers\rCTX = context = saved RISC-V registers getting from one process to another involves multiple transitions:\nâ€‹ user -\u003e kernel; saves user registers in trapframe â€‹ kernel thread -\u003e scheduler thread; saves kernel thread registers in context â€‹ scheduler thread -\u003e kernel thread; restores kernel thread registers from ctx â€‹ kernel -\u003e user; restores user registers from trapframe â€œcontext switchâ€ â€“ the switch from one thread to another\nscheduler threads Thereâ€™s one per core; each has a stack and a struct context kernel threads (processes) always switch to the current coreâ€™s scheduler thread which switches to another kernel thread, if one is RUNNABLE there are never direct kernel thread to kernel thread switches the reason: the schedulerâ€™s separate stack simplifies cases like switching away from an exiting process the scheduler thread keeps scanning the process table until it finds a RUNNABLE thread (there may not be one!) if there is not RUNNABLE thread, the scheduler is â€œidleâ€\nnote: each core is either running its scheduler thread, or some other thread a given core runs only one thread at a time each thread is either running on exactly one core, or its registers are saved in its context if a thread isnâ€™t running, its saved context refers to a call to swtch()\nstruct proc in proc.h p-\u003etrapframe holds saved user threadâ€™s registers p-\u003econtext holds saved kernel threadâ€™s registers p-\u003ekstack points to the threadâ€™s kernel stack p-\u003estate is RUNNING, RUNNABLE, SLEEPING, \u0026c p-\u003elock protects p-\u003estate (and other thingsâ€¦)\nCode pre-emptive switch demonstration user/spin.c â€“ two CPU-bound processes my qemu has only one CPU letâ€™s watch xv6 switch between them\nmake qemu-gdb gdb (gdb) c show user/spin.c spin you can see that they alternate, despite running continuously. xv6 is switching its one CPU between the two processes. how does the switching work?\nIâ€™m going to cause a break-point at the timer interrupt.\n(gdb) b trap.c:207 (gdb) c (gdb) finish (gdb) where weâ€™re in usertrap(), handling a device interrupt from the timer (timerinit() in kernel/start.c configures the RISC-V timer hardware).\nwhat was running when the timer interrupt happened?\n(gdb) print p-\u003ename (gdb) print p-\u003epid (gdb) print/x *(p-\u003etrapframe) (gdb) print/x p-\u003etrapframe-\u003eepc letâ€™s look for the saved epc in user/spin.asm timer interrupted user code in the increment loop, no surprise\n(gdb) step ... into yield() in proc.c (gdb) next (gdb) print p-\u003estate change p-\u003estate from RUNNING to RUNNABLE -\u003e give up CPU but want to run again. note: yield() acquires p-\u003elock since modifying p-\u003estate and to prevent another CPU from running this RUNNABLE thread!\n(gdb) next 2 (gdb) step (into sched()) sched() makes some sanity checks, then calls swtch()\n(gdb) next 7 this is the context switch from a processâ€™s kernel thread to the scheduler thread swtch will save the current RISC-V registers in first argument (p-\u003econtext) and restore previously-saved registers from 2nd argument (c-\u003econtext) letâ€™s see what register values swtch() will restore\n(gdb) print/x cpus[0].context where is cpus[0].context.ra? i.e. where will swtch() return to? kernel.asm says itâ€™s in the scheduler() function in proc.c\n(gdb) tbreak swtch (gdb) c weâ€™re in kernel/swtch.S a0 is the first argument, p-\u003econtext a1 is the second argument, cpus[0].context swtch() saves current registers in xx(a0) (p-\u003econtext) swtch() then restores registers from xx(a1) (cpus[0].context) then swtch returns\nQ: swtch() neither saves nor restores $pc (program counter)! so how does it know where to start executing in the target thread?\nQ: why does swtch() save only 14 registers (ra, sp, s0..s11)? the RISC-V has 32 registers â€“ what about the other 18? zero, gp, tp t0-t6, a0-a7 note weâ€™re talking about kernel thread registers all 32 user register have already been saved in the trapframe\nregisters at start of swtch:\n(gdb) print $pc -- swtch (gdb) print $ra -- sched (gdb) print $sp registers at end of swtch:\n(gdb) stepi 28 -- until ret (gdb) print $pc -- swtch (gdb) print $ra -- scheduler (gdb) print $sp -- stack0+??? -- entry.S set this up at boot (gdb) where (gdb) stepi weâ€™re in scheduler() now, in the â€œscheduler threadâ€, on the schedulerâ€™s stack\nscheduler() just returned from a call to swtch() it made that call a while ago, to switch to our processâ€™s kernel thread that previous call saved scheduler()â€™s registers our processesâ€™s call to swtch() restored scheduler()â€™s saved registers p here refers to the interrupted process\n(gdb) print p-\u003ename (gdb) print p-\u003epid (gdb) print p-\u003estate remember yield() acquired the processâ€™s lock now scheduler releases it the scheduler() code looks like an ordinary acquire/release pair but in fact scheduler acquires, yield releases then yield acquires, scheduler releases unusual: the lock is released by a different thread than acquired it!\nQ: why hold p-\u003elock across swtch()? yield() acquires scheduler() releases could we release p-\u003elock just before calling swtch()?\np-\u003elock protects a few things: makes these steps atomic:\np-\u003estate=RUNNABLE save registers in p-\u003econtext stop using pâ€™s kernel stack â€‹ so other CPUâ€™s scheduler wonâ€™t start running p until all steps complete\nmakes these steps atomic and uninterruptable:\np-\u003estate=RUNNING move registers from context to RISC-V registers â€‹ so an interrupt wonâ€™t yield() and save not-yet-initialized\nâ€‹ RISC-V registers in context.\nscheduler()â€™s loop looks at all processes, finds one thatâ€™s RUNNABLE keeps looping until it finds something â€“ may be idle for a while in this demo, will find the other spin process letâ€™s fast-forward to when scheduler() finds a RUNNABLE process\n(gdb) tbreak proc.c:474 (gdb) c scheduler() locked the new process, then set state to RUNNING now another CPUsâ€™ scheduler wonâ€™t run it\nitâ€™s the other â€œspinâ€ process:\n(gdb) print p-\u003ename (gdb) print p-\u003epid (gdb) print p-\u003estate letâ€™s see where the new thread will start executing after swtch() by looking at $ra (return address) in its context\n(gdb) print/x p-\u003econtext (gdb) x/4i p-\u003econtext-\u003era new thread will return into sched()\nlook at kernel/swtch.S (again)\n(gdb) tbreak swtch (gdb) c (gdb) stepi 28 -- now just about to execute swtch()'s ret (gdb) print $ra (gdb) where now weâ€™re in a timer interrupt in the other spin process in the past it was interrupted, called yield() / sched() / swtch() but now it will resume, and return to user space\nnote: only swtch() writes contexts (except for initialization) only sched() and scheduler() call swtch() so for a kernel thread, context.ra always points into sched() and for a scheduler thread, context.ra always points into scheduler()\nnote: sched() calls swtch() â€“ then swtch() returns to sched() but itâ€™s typically a different thread returning\nsched() and scheduler() are â€œco-routinesâ€ each knows what it is swtch()ing to each knows where swtch() return is coming from e.g. yield() and scheduler() cooperate about p-\u003elock and p-\u003estate different from ordinary thread switching, where neither party typically knows which thread comes before/after\nQ: what is the â€œscheduling policyâ€?\ni.e. how does xv6 decide what to run next if multiple threads are RUNNABLE? is it a good policy?\nQ: is there pre-emptive scheduling of kernel threads?\nyes â€“ timer interrupt and yield() can occur while in kernel. yield() called by kerneltrap() in kernel/trap.c where to save registers of interrupted kernel code? not in p-\u003etrapframe, since already has user registers. not in p-\u003econtext, since weâ€™re about to call yield() and swtch() kernelvec.S pushes them on the kernel stack (since already in kernel). is pre-emption in the kernel useful? not critical in xv6. valuable if some system calls have lots of compute. or if we need a strict notion of thread priority.\nQ: why does scheduler() briefly enable interrupts, with intr_on()?\nThere may be no RUNNABLE threads They may all be waiting for I/O, e.g. disk or console Enable interrupts so device has a chance to signal completion and thus wake up a thread Otherwise, system will freeze\nQ: why does sched() forbid locks from being held when yielding the CPU?\n(other than p-\u003elock) i.e. sched() checks that noff == 1 suppose process P1 holding lock L1, yields CPU process P2 runs, tries acquire(L1) P2â€™s acquire spins with interrupts turned off so timer interrupts wonâ€™t occur so P2 wonâ€™t yield the CPU so P1 canâ€™t execute so P1 wonâ€™t release L1, ever\nQ: can we get rid of the separate per-cpu scheduler thread?\ncould sched() directly swtch() to a new thread? so that sched() looks for next process to run? that would be faster â€“ avoids one of the swtch() calls yes â€“ but: scheduling loop would run on a threadâ€™s kernel stack what if that thread is exiting? what if another cpu wants to run the thread? what if there are fewer threads than CPUs â€“ i.e. too few stacks? can be dealt with â€“ give it a try!\nSummary xv6 provides a convenient thread model for kernel code pre-emptive via timer interrupts transparent via switching registers and stack multi-core requires careful handling of stacks, locks next lecture: mechanisms for threads to wait for each other\nLab: Multithreading Uthread: switching between threads (moderate) è®¾è®¡å¹¶å®ç°ç”¨æˆ·çº§çº¿ç¨‹ç³»ç»Ÿçš„ä¸Šä¸‹æ–‡åˆ‡æ¢æœºåˆ¶ã€‚xv6ç³»ç»Ÿä¸­æä¾›äº†ä¸¤ä¸ªæ–‡ä»¶ï¼šuthread.c å’Œ uthread_switch.Sï¼Œä»¥åŠä¸€ä¸ªç”¨äºæ„å»º uthread ç¨‹åºçš„Makefileè§„åˆ™ã€‚uthread.c åŒ…å«äº†ä¸€ä¸ªåŸºæœ¬çš„ç”¨æˆ·çº§çº¿ç¨‹åŒ…ä»¥åŠä¸‰ä¸ªæµ‹è¯•çº¿ç¨‹çš„ä»£ç ï¼Œä½†ç¼ºå°‘åˆ›å»ºçº¿ç¨‹å’Œçº¿ç¨‹åˆ‡æ¢çš„éƒ¨åˆ†ä»£ç ã€‚\nä»»åŠ¡è¦æ±‚åŒ…æ‹¬ï¼š\nå®ç°çº¿ç¨‹åˆ›å»ºå’Œä¸Šä¸‹æ–‡åˆ‡æ¢çš„ä»£ç ã€‚ åœ¨çº¿ç¨‹ç¬¬ä¸€æ¬¡è¿è¡Œæ—¶ï¼Œç¡®ä¿æ‰§è¡Œåˆ›å»ºæ—¶ä¼ é€’çš„å‡½æ•°ï¼Œå¹¶ä½¿ç”¨è¯¥çº¿ç¨‹çš„æ ˆã€‚ å®ç° thread_switch æ¥ä¿å­˜å½“å‰çº¿ç¨‹çš„å¯„å­˜å™¨ï¼Œå¹¶æ¢å¤ä¸‹ä¸€ä¸ªçº¿ç¨‹çš„å¯„å­˜å™¨ï¼Œä»¥ç»§ç»­å…¶æ‰§è¡Œã€‚ 1.æ·»åŠ utcontextç»“æ„ä½“\n2.æ·»åŠ utcontextå­—æ®µ\nthread_createä¸­ä¿å­˜raå’Œsp 4.è¡¥å…¨uthread_switch.Sï¼Œ å®Œå…¨å‚ç…§swtch.S\n5.è°ƒç”¨thread_switchï¼Œè°ƒç”¨ thread_switch åˆ‡æ¢ä¸Šä¸‹æ–‡ï¼Œä¼ é€’å½“å‰çº¿ç¨‹å’Œä¸‹ä¸€ä¸ªçº¿ç¨‹çš„ä¸Šä¸‹æ–‡ï¼Œ æ³¨æ„è¿™é‡Œä¸Šä¸‹æ–‡åˆ‡æ¢éœ€è¦åœ¨æœ€åå®ç°ï¼Œå› ä¸ºè¿™ä¼šå½±å“next_thread, æ‰€ä»¥ä¸€å®šè¦åœ¨æ›´æ–°current_threadä¹‹åè°ƒç”¨thread_switchã€‚\nUsing threads (moderate) ç›®æ ‡ï¼šå®ç°çº¿ç¨‹å¹¶è¡Œç¼–ç¨‹ï¼Œä½¿ç”¨pthreadåº“åœ¨å¤šçº¿ç¨‹ç¯å¢ƒä¸‹æ“ä½œå“ˆå¸Œè¡¨ï¼Œå¹¶ç¡®ä¿å…¶çº¿ç¨‹å®‰å…¨ã€‚\nä»»åŠ¡ç¯å¢ƒï¼šåœ¨æ”¯æŒå¤šæ ¸çš„çœŸå®Linuxæˆ–MacOSè®¡ç®—æœºä¸Šå®Œæˆï¼Œä¸ä½¿ç”¨xv6æˆ–qemuã€‚\nåˆå§‹é—®é¢˜ï¼šæä¾›çš„å“ˆå¸Œè¡¨ä»…åœ¨å•çº¿ç¨‹æƒ…å†µä¸‹æ­£ç¡®ï¼Œå¤šçº¿ç¨‹ç¯å¢ƒä¸‹ä¼šæœ‰ç¼ºå¤±é”®çš„é—®é¢˜ã€‚\næ­¥éª¤ï¼š\nä½¿ç”¨pthreadåº“å¯¹å“ˆå¸Œè¡¨è¿›è¡Œå¹¶å‘æ“ä½œã€‚ è¿è¡Œæµ‹è¯•ph 1å’Œph 2ï¼Œè§‚å¯Ÿä¸åŒçº¿ç¨‹ä¸‹çš„æ’å…¥å’Œè·å–æ€§èƒ½ã€‚ åˆ†æç¼ºå¤±é”®å‡ºç°çš„åŸå› ï¼Œæäº¤è§£é‡Šï¼ˆsequence of eventsï¼‰ã€‚ è§£å†³æ–¹æ¡ˆï¼šåœ¨put()å’Œget()å‡½æ•°ä¸­æ·»åŠ é”æœºåˆ¶ï¼Œç¡®ä¿å¤šçº¿ç¨‹æ“ä½œæ—¶æ²¡æœ‰é”®ä¸¢å¤±ã€‚\nä½¿ç”¨pthread_mutex_tç›¸å…³å‡½æ•°å®ç°åŠ é”å’Œè§£é”ã€‚ ä¿®æ”¹ä»£ç ï¼Œé€šè¿‡æµ‹è¯•ph_safeï¼Œç¡®ä¿ä¸¤çº¿ç¨‹ä¸‹æ— é”®ä¸¢å¤±ã€‚ è¿›ä¸€æ­¥ä¼˜åŒ–ï¼šå°è¯•åœ¨æŸäº›æƒ…å†µä¸‹å…è®¸å¹¶è¡Œæ’å…¥æ“ä½œï¼Œä¾‹å¦‚ä½¿ç”¨æ¯ä¸ªå“ˆå¸Œæ¡¶ï¼ˆbucketï¼‰ä¸€ä¸ªé”ï¼Œä»¥æé«˜æ€§èƒ½ã€‚\nä¿®æ”¹ä»£ç ï¼Œä½¿å…¶é€šè¿‡ph_safeå’Œph_fastæµ‹è¯•ï¼Œè¦æ±‚åŒçº¿ç¨‹è‡³å°‘è¾¾åˆ°å•çº¿ç¨‹1.25å€çš„æ’å…¥é€Ÿåº¦ã€‚ 1.å®šä¹‰é”ï¼Œ å®šä¹‰å…¨å±€é”å¯ä»¥ä¿è¯å¤šçº¿ç¨‹æƒ…å†µä¸‹ä¸ä¼šä¸¢å¤±key, ä¸ºæ¯ä¸€ä¸ªæ¡¶åŠ é”å¯ä»¥åœ¨ä¿è¯ä¸ä¸¢å¤±keyçš„æƒ…å†µä¸‹ä¿è¯æ€§èƒ½\n2.åˆå§‹åŒ–é”\n3.åœ¨put()å’Œget()ä¸­åŠ é”ä»¥åŠè§£é”\nBarrier(moderate) å®ç°ä¸€ä¸ªçº¿ç¨‹å±éšœï¼ˆbarrierï¼‰ï¼Œå³æ‰€æœ‰çº¿ç¨‹åœ¨åŒä¸€ç‚¹ç­‰å¾…ï¼Œç›´åˆ°æ‰€æœ‰çº¿ç¨‹éƒ½åˆ°è¾¾è¯¥ç‚¹åå†ç»§ç»­ã€‚éœ€è¦ä½¿ç”¨ pthread çš„æ¡ä»¶å˜é‡ (pthread_cond_wait å’Œ pthread_cond_broadcast) æ¥åè°ƒçº¿ç¨‹ã€‚ä»»åŠ¡æ˜¯åœ¨ barrier.c ä¸­ä¿®å¤å·²å­˜åœ¨çš„é—®é¢˜ï¼Œç¡®ä¿æ‰€æœ‰çº¿ç¨‹åœ¨è°ƒç”¨ barrier() æ—¶éƒ½è¢«é˜»å¡ï¼Œç›´åˆ°å…¨éƒ¨çº¿ç¨‹åˆ°è¾¾ã€‚\nå…³é”®è¦æ±‚ï¼š\nä½¿ç”¨æ¡ä»¶å˜é‡å®ç°çº¿ç¨‹åŒæ­¥ã€‚ å¤„ç†å¤šæ¬¡å¾ªç¯ä¸­çš„å±éšœè°ƒç”¨ï¼Œæ¯æ¬¡å±éšœéƒ½ä»£è¡¨ä¸€ä¸ªâ€œå›åˆâ€ã€‚ é¿å…ä¸€ä¸ªçº¿ç¨‹å¿«é€Ÿç¦»å¼€å±éšœå¹¶å½±å“å…¶ä»–çº¿ç¨‹ã€‚ ç¡®ä¿è§£å†³æ–­è¨€é”™è¯¯å¹¶é€šè¿‡æµ‹è¯•ã€‚ åœ¨æ¯ä¸€ä¸ªthreadä¸­è°ƒç”¨barrierï¼Œ è®°å½•æ‰€æœ‰åˆ°è¾¾çš„threadæ•°é‡ï¼Œ å¦‚æœæ•°é‡ç­‰äºè®¾ç½®çš„çº¿ç¨‹æ•°ï¼Œåˆ™å¼€å§‹ä¸‹ä¸€roundï¼Œå¦åˆ™å°†æ­¤çº¿ç¨‹æ‰§è¡Œæ­¤æ“ä½œ ï¼š\npthread_cond_wait(\u0026bstate.barrier_cond, \u0026bstate.barrier_mutex); // Release mutex and wait ä¿è¯è¯¥çº¿ç¨‹å¤„äºç­‰å¾…çŠ¶æ€ï¼Œç­‰å¾…æ‰€æœ‰çº¿ç¨‹éƒ½å®Œæˆæ­¤roundã€‚\n",
  "wordCount" : "3091",
  "inLanguage": "zh",
  "datePublished": "2024-09-21T19:30:13+08:00",
  "dateModified": "2024-09-21T19:20:13+08:00",
  "author":{
    "@type": "Person",
    "name": "ShowGuan"
  },
  "mainEntityOfPage": {
    "@type": "WebPage",
    "@id": "https://kennems.github.io/posts/tech/mit6.s08111--thread-switching/"
  },
  "publisher": {
    "@type": "Organization",
    "name": "Kennem's Blog",
    "logo": {
      "@type": "ImageObject",
      "url": "https://kennems.github.io/img/sun.png"
    }
  }
}
</script>
<script src="https://cdn.jsdelivr.net/npm/jquery@3.5.1/dist/jquery.min.js"></script>
<link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.css" />
<script src="https://cdn.jsdelivr.net/gh/fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.js"></script>




</head>

<body class="" id="top">
<script>
    if (localStorage.getItem("pref-theme") === "dark") {
        document.body.classList.add('dark');
    } else if (localStorage.getItem("pref-theme") === "light") {
        document.body.classList.remove('dark')
    } else if (window.matchMedia('(prefers-color-scheme: dark)').matches) {
        document.body.classList.add('dark');
    }

</script>

<header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="https://kennems.github.io/" accesskey="h" title="Kennem&#39;s Blog (Alt + H)">
                <img src="https://kennems.github.io/img/sun.png" alt="" aria-label="logo"
                    height="35">Kennem&#39;s Blog</a>
            <div class="logo-switches">
                <button id="theme-toggle" accesskey="t" title="(Alt + T)">
                    <svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
                    </svg>
                    <svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <circle cx="12" cy="12" r="5"></circle>
                        <line x1="12" y1="1" x2="12" y2="3"></line>
                        <line x1="12" y1="21" x2="12" y2="23"></line>
                        <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                        <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                        <line x1="1" y1="12" x2="3" y2="12"></line>
                        <line x1="21" y1="12" x2="23" y2="12"></line>
                        <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                        <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
                    </svg>
                </button>
            </div>
        </div>
        <ul id="menu">
            <li>
                <a href="https://kennems.github.io/" title="ğŸ ä¸»é¡µ">
                    <span>ğŸ ä¸»é¡µ</span>
                </a>
            </li>
            <li>
                <a href="https://kennems.github.io/search" title="ğŸ”æœç´¢ (Alt &#43; /)" accesskey=/>
                    <span>ğŸ”æœç´¢</span>
                </a>
            </li>
            <li>
                <a href="https://kennems.github.io/posts" title="ğŸ“šæ–‡ç« ">
                    <span>ğŸ“šæ–‡ç« </span>
                </a>
            </li>
            <li>
                <a href="https://kennems.github.io/archives" title="â±æ—¶é—´è½´">
                    <span>â±æ—¶é—´è½´</span>
                </a>
            </li>
            <li>
                <a href="https://kennems.github.io/tags" title="ğŸ”–æ ‡ç­¾">
                    <span>ğŸ”–æ ‡ç­¾</span>
                </a>
            </li>
            <li>
                <a href="https://kennems.github.io/categories" title="ğŸ—‚ï¸åˆ†ç±»">
                    <span>ğŸ—‚ï¸åˆ†ç±»</span>
                </a>
            </li>
            <li>
                <a href="https://kennems.github.io/about" title="ğŸ™‹ğŸ»â€â™‚ï¸å…³äº">
                    <span>ğŸ™‹ğŸ»â€â™‚ï¸å…³äº</span>
                </a>
            </li>
        </ul>
    </nav>
</header>
<main class="main">

<article class="post-single">
  <header class="post-header">
    <div class="breadcrumbs"><a href="https://kennems.github.io/">ä¸»é¡µ</a>&nbsp;Â»&nbsp;<a href="https://kennems.github.io/posts/">ğŸ“šæ–‡ç« </a>&nbsp;Â»&nbsp;<a href="https://kennems.github.io/posts/tech/">ğŸ’»æŠ€æœ¯</a></div>
    <h1 class="post-title entry-hint-parent">
      MIT6.S081(11)- Thread switching
    </h1>
    <div class="post-description">
      MIT6.S081(11)- Thread switching
    </div>
    <div class="post-meta"><span title='2024-09-21 19:30:13 +0800 CST'>2024-09-21</span>&nbsp;Â·&nbsp;7 åˆ†é’Ÿ&nbsp;Â·&nbsp;3091 å­—&nbsp;Â·&nbsp;updated:&nbsp;2024-09-21&nbsp;Â·&nbsp;ShowGuan

</div>
    
     <div class="post-password">
        
    </div>
  </header> <aside id="toc-container" class="toc-container wide">
    <div class="toc">
        <details  open>
            <summary accesskey="c" title="(Alt + C)">
                <span class="details">ç›®å½•</span>
            </summary>

            <div class="inner"><ul>
                    <li>
                        <a href="#mit6s08111--thread-switching" aria-label="MIT6.S081(11)- Thread switching">MIT6.S081(11)- Thread switching</a><ul>
                            
                    <li>
                        <a href="#why-support-multiple-tasks" aria-label="Why support multiple tasks?">Why support multiple tasks?</a><ul>
                            
                    <li>
                        <a href="#two-main-strategies" aria-label="Two main strategies:">Two main strategies:</a></li></ul>
                    </li>
                    <li>
                        <a href="#thread-design-challenges" aria-label="Thread design challenges">Thread design challenges</a><ul>
                            
                    <li>
                        <a href="#what-to-do-with-a-thread-that-isnt-running" aria-label="What to do with a thread that isn&rsquo;t running?">What to do with a thread that isn&rsquo;t running?</a></li></ul>
                    </li>
                    <li>
                        <a href="#overview-of-thread-switching-in-xv6" aria-label="overview of thread switching in xv6">overview of thread switching in xv6</a></li>
                    <li>
                        <a href="#scheduler-threads" aria-label="scheduler threads">scheduler threads</a></li>
                    <li>
                        <a href="#code" aria-label="Code">Code</a></li>
                    <li>
                        <a href="#summary" aria-label="Summary">Summary</a></li>
                    <li>
                        <a href="#lab-multithreadinghttpspdoscsailmitedu6s0812020labsthreadhtml" aria-label="Lab: Multithreading"><a href="https://pdos.csail.mit.edu/6.S081/2020/labs/thread.html">Lab: Multithreading</a></a></li>
                    <li>
                        <a href="#uthread-switching-between-threads-moderatehttpspdoscsailmitedu6s0812020labsguidancehtml" aria-label="Uthread: switching between threads (moderate)">Uthread: switching between threads (<a href="https://pdos.csail.mit.edu/6.S081/2020/labs/guidance.html">moderate</a>)</a></li>
                    <li>
                        <a href="#using-threads-moderatehttpspdoscsailmitedu6s0812020labsguidancehtml" aria-label="Using threads (moderate)">Using threads (<a href="https://pdos.csail.mit.edu/6.S081/2020/labs/guidance.html">moderate</a>)</a></li>
                    <li>
                        <a href="#barriermoderatehttpspdoscsailmitedu6s0812020labsguidancehtml" aria-label="Barrier(moderate)">Barrier(<a href="https://pdos.csail.mit.edu/6.S081/2020/labs/guidance.html">moderate</a>)</a>
                    </li>
                </ul>
                </li>
                </ul>
            </div>
        </details>
    </div>
</aside>
<script>
    let activeElement;
    let elements;
    window.addEventListener('DOMContentLoaded', function (event) {
        checkTocPosition();

        elements = document.querySelectorAll('h1[id],h2[id],h3[id],h4[id],h5[id],h6[id]');
         
         activeElement = elements[0];
         const id = encodeURI(activeElement.getAttribute('id')).toLowerCase();
         document.querySelector(`.inner ul li a[href="#${id}"]`).classList.add('active');
     }, false);

    window.addEventListener('resize', function(event) {
        checkTocPosition();
    }, false);

    window.addEventListener('scroll', () => {
        
        activeElement = Array.from(elements).find((element) => {
            if ((getOffsetTop(element) - window.pageYOffset) > 0 && 
                (getOffsetTop(element) - window.pageYOffset) < window.innerHeight/2) {
                return element;
            }
        }) || activeElement

        elements.forEach(element => {
             const id = encodeURI(element.getAttribute('id')).toLowerCase();
             if (element === activeElement){
                 document.querySelector(`.inner ul li a[href="#${id}"]`).classList.add('active');
             } else {
                 document.querySelector(`.inner ul li a[href="#${id}"]`).classList.remove('active');
             }
         })
     }, false);

    const main = parseInt(getComputedStyle(document.body).getPropertyValue('--article-width'), 10);
    const toc = parseInt(getComputedStyle(document.body).getPropertyValue('--toc-width'), 10);
    const gap = parseInt(getComputedStyle(document.body).getPropertyValue('--gap'), 10);

    function checkTocPosition() {
        const width = document.body.scrollWidth;

        if (width - main - (toc * 2) - (gap * 4) > 0) {
            document.getElementById("toc-container").classList.add("wide");
        } else {
            document.getElementById("toc-container").classList.remove("wide");
        }
    }

    function getOffsetTop(element) {
        if (!element.getClientRects().length) {
            return 0;
        }
        let rect = element.getBoundingClientRect();
        let win = element.ownerDocument.defaultView;
        return rect.top + win.pageYOffset;   
    }
</script>

  <div class="post-content"><h1 id="mit6s08111--thread-switching">MIT6.S081(11)- Thread switching<a hidden class="anchor" aria-hidden="true" href="#mit6s08111--thread-switching">#</a></h1>
<p><strong>Topic</strong>: more &ldquo;under the hood&rdquo; with xv6
Previously: system calls, interrupts, page tables, locks
Today: process/thread switching</p>
<h2 id="why-support-multiple-tasks">Why support multiple tasks?<a hidden class="anchor" aria-hidden="true" href="#why-support-multiple-tasks">#</a></h2>
<p><strong>Time-sharing</strong>: many users and/or many running programs.
<strong>program structure</strong>: prime number sieve.
parallel speedup on multi-core hardware.</p>
<p>Threads are an abstraction to simplify programming when there are many tasks.
thread = an independent serial execution &ndash; registers, pc, stack
the threading system interleaves the execution of multiple threads</p>
<h3 id="two-main-strategies">Two main strategies:<a hidden class="anchor" aria-hidden="true" href="#two-main-strategies">#</a></h3>
<p>â€‹    multiple CPUs, each CPU runs a different thread
â€‹    each CPU &ldquo;switches&rdquo; between threads, runs one at a time</p>
<p>threads can share memory, or not
<strong>xv6 kernel threads</strong>: they share kernel memory (thus locks)
<strong>xv6 user processes</strong>: one thread per process, so no sharing
<strong>linux</strong>: supports multiple threads sharing a user process&rsquo;s memory</p>
<p>there are other techniques for interleaving multiple tasks
look up <code>event-driven programming</code>, or <code>state machines</code>
threads are not the most efficient, but they are usually the most convenient</p>
<h2 id="thread-design-challenges">Thread design challenges<a hidden class="anchor" aria-hidden="true" href="#thread-design-challenges">#</a></h2>
<ul>
<li>
<p>How to interleave many threads on a few CPUs?</p>
</li>
<li>
<p>How to make interleaving transparent?</p>
</li>
</ul>
<p><strong>&ldquo;scheduling&rdquo;</strong> = the process of choosing which thread to run next</p>
<ul>
<li>
<p>What to save while a thread isn&rsquo;t running?</p>
</li>
<li>
<p>How to cope with compute-bound threads?</p>
</li>
<li>
<p>How to cope with compute-bound threads?</p>
<p>each CPU has timer hardware, which interrupts periodically
kernel uses <strong>timer interrupts</strong> to grab control from looping threads
kernel saves thread state, switches, eventually resumes,
restores that saved state for transparency</p>
<p><strong>RUNNING</strong> vs <strong>RUNNABLE</strong></p>
<p>this is &ldquo;<strong>pre-emptive</strong>&rdquo; scheduling &ndash; a forced yield of unaware code
as opposed to <strong>cooperative scheduling</strong>, in which code yields voluntarily</p>
</li>
</ul>
<h3 id="what-to-do-with-a-thread-that-isnt-running">What to do with a thread that isn&rsquo;t running?<a hidden class="anchor" aria-hidden="true" href="#what-to-do-with-a-thread-that-isnt-running">#</a></h3>
<p>We need to set aside its state: registers, stack, memory
though no need to worry about memory, it won&rsquo;t go anywhere
so implementation provides each thread with a stack and register save area
need to track status of each thread
<strong>RUNNING</strong> vs <strong>RUNNABLE</strong> vs <strong>SLEEPING</strong></p>
<p>in xv6:</p>
<p>






    <div class="post-img-view">
        <a data-fancybox="gallery" href="https://raw.githubusercontent.com/Kennems/blog-image/main/image-20240921160329664.png">
            <img src="https://raw.githubusercontent.com/Kennems/blog-image/main/image-20240921160329664.png" alt="image-20240921160329664"  />
        </a>
    </div>
</p>
<p>[simple diagram: processes, user stack, trapframe, kernel stack]</p>
<p>each process has two threads, one user, one kernel
a process is <em>either</em> executing its user thread,
<em>or</em> in a system call or interrupt in its kernel thread
kernel threads share kernel memory / data structures
thus the kernel is a parallel program
we&rsquo;ll use &ldquo;process&rdquo; and &ldquo;kernel thread&rdquo; and &ldquo;thread&rdquo; as <strong>synonyms</strong></p>
<h2 id="overview-of-thread-switching-in-xv6">overview of thread switching in xv6<a hidden class="anchor" aria-hidden="true" href="#overview-of-thread-switching-in-xv6">#</a></h2>
<p>(the point: switch among threads to interleave many threads on each CPU)</p>
<p>






    <div class="post-img-view">
        <a data-fancybox="gallery" href="https://raw.githubusercontent.com/Kennems/blog-image/main/image-20240921161823595.png">
            <img src="https://raw.githubusercontent.com/Kennems/blog-image/main/image-20240921161823595.png" alt="image-20240921161823595"  />
        </a>
    </div>
  [diagram: P1, TF1, STACK1, swtch(), CTX1;
CTXs, swtch(), STACKs, scheduler(), &amp;c]</p>
<pre tabindex="0"><code>  TF = trapframe = saved user registers
  CTX = context = saved RISC-V registers
</code></pre><p>getting from one process to another involves multiple transitions:</p>
<ul>
<li>â€‹    <code>user -&gt; kernel</code>; saves user registers in trapframe</li>
<li>â€‹    <code>kernel thread -&gt; scheduler thread</code>; saves kernel thread registers in context</li>
<li>â€‹    <code>scheduler thread -&gt; kernel thread</code>; restores kernel thread registers from ctx</li>
<li>â€‹    <code>kernel -&gt; user</code>; restores user registers from trapframe</li>
</ul>
<p>&ldquo;context switch&rdquo; &ndash; the switch from one thread to another</p>
<h2 id="scheduler-threads">scheduler threads<a hidden class="anchor" aria-hidden="true" href="#scheduler-threads">#</a></h2>
<p>There&rsquo;s one per core; each has a stack and a struct context
kernel threads (processes) always switch to the current core&rsquo;s scheduler thread
which switches to another kernel thread, if one is RUNNABLE
there are never direct kernel thread to kernel thread switches
the reason: the scheduler&rsquo;s separate stack simplifies
cases like switching away from an exiting process
the scheduler thread keeps scanning the process table until
it finds a RUNNABLE thread (there may not be one!)
if there is not RUNNABLE thread, the scheduler is &ldquo;idle&rdquo;</p>
<p>note:
each core is either running its scheduler thread, or some other thread
a given core runs only one thread at a time
each thread is either running on exactly one core, or its registers
are saved in its context
if a thread isn&rsquo;t running, its saved context refers to a call
to swtch()</p>
<p>struct proc in proc.h
p-&gt;trapframe holds saved user thread&rsquo;s registers
p-&gt;context holds saved kernel thread&rsquo;s registers
p-&gt;kstack points to the thread&rsquo;s kernel stack
p-&gt;state is RUNNING, RUNNABLE, SLEEPING, &amp;c
p-&gt;lock protects p-&gt;state (and other things&hellip;)</p>
<h2 id="code">Code<a hidden class="anchor" aria-hidden="true" href="#code">#</a></h2>
<p>pre-emptive switch demonstration
user/spin.c &ndash; two CPU-bound processes
my qemu has only one CPU
let&rsquo;s watch xv6 switch between them</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-sh" data-lang="sh"><span style="display:flex;"><span>make qemu-gdb
</span></span><span style="display:flex;"><span>gdb
</span></span><span style="display:flex;"><span><span style="color:#f92672">(</span>gdb<span style="color:#f92672">)</span> c
</span></span><span style="display:flex;"><span>show user/spin.c
</span></span><span style="display:flex;"><span>spin
</span></span></code></pre></div><p>you can see that they alternate, despite running continuously.
xv6 is switching its one CPU between the two processes.
how does the switching work?</p>
<p>I&rsquo;m going to cause a break-point at the timer interrupt.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-sh" data-lang="sh"><span style="display:flex;"><span><span style="color:#f92672">(</span>gdb<span style="color:#f92672">)</span> b trap.c:207
</span></span><span style="display:flex;"><span><span style="color:#f92672">(</span>gdb<span style="color:#f92672">)</span> c
</span></span><span style="display:flex;"><span><span style="color:#f92672">(</span>gdb<span style="color:#f92672">)</span> finish
</span></span><span style="display:flex;"><span><span style="color:#f92672">(</span>gdb<span style="color:#f92672">)</span> where
</span></span></code></pre></div><p>we&rsquo;re in <code>usertrap()</code>, handling a device interrupt from the timer
(<code>timerinit()</code> in <code>kernel/start.c</code> configures the RISC-V timer hardware).</p>
<p>what was running when the timer interrupt happened?</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-sh" data-lang="sh"><span style="display:flex;"><span><span style="color:#f92672">(</span>gdb<span style="color:#f92672">)</span> print p-&gt;name
</span></span><span style="display:flex;"><span><span style="color:#f92672">(</span>gdb<span style="color:#f92672">)</span> print p-&gt;pid
</span></span><span style="display:flex;"><span><span style="color:#f92672">(</span>gdb<span style="color:#f92672">)</span> print/x *<span style="color:#f92672">(</span>p-&gt;trapframe<span style="color:#f92672">)</span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">(</span>gdb<span style="color:#f92672">)</span> print/x p-&gt;trapframe-&gt;epc
</span></span></code></pre></div><p>let&rsquo;s look for the saved epc in user/spin.asm
timer interrupted user code in the increment loop, no surprise</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-sh" data-lang="sh"><span style="display:flex;"><span><span style="color:#f92672">(</span>gdb<span style="color:#f92672">)</span> step ... into yield<span style="color:#f92672">()</span> in proc.c
</span></span><span style="display:flex;"><span><span style="color:#f92672">(</span>gdb<span style="color:#f92672">)</span> next
</span></span><span style="display:flex;"><span><span style="color:#f92672">(</span>gdb<span style="color:#f92672">)</span> print p-&gt;state
</span></span></code></pre></div><p>change <code>p-&gt;state</code> from <code>RUNNING</code> to <code>RUNNABLE</code> <code>-&gt;</code> give up CPU but want to run again.
note: <code>yield()</code> acquires <code>p-&gt;lock</code>
since modifying <code>p-&gt;state</code>
and to prevent another CPU from running this <code>RUNNABLE</code> thread!</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-sh" data-lang="sh"><span style="display:flex;"><span><span style="color:#f92672">(</span>gdb<span style="color:#f92672">)</span> next <span style="color:#ae81ff">2</span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">(</span>gdb<span style="color:#f92672">)</span> step <span style="color:#f92672">(</span>into sched<span style="color:#f92672">())</span>
</span></span></code></pre></div><p><code>sched()</code> makes some sanity checks, then calls <code>swtch()</code></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-sh" data-lang="sh"><span style="display:flex;"><span><span style="color:#f92672">(</span>gdb<span style="color:#f92672">)</span> next <span style="color:#ae81ff">7</span>
</span></span></code></pre></div><p>this is the context switch from a process&rsquo;s kernel thread to the scheduler thread
<code>swtch</code> will save the current RISC-V registers in first argument (<code>p-&gt;context</code>)
and restore previously-saved registers from 2nd argument (<code>c-&gt;context</code>)
let&rsquo;s see what register values <code>swtch()</code> will restore</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-sh" data-lang="sh"><span style="display:flex;"><span><span style="color:#f92672">(</span>gdb<span style="color:#f92672">)</span> print/x cpus<span style="color:#f92672">[</span>0<span style="color:#f92672">]</span>.context
</span></span></code></pre></div><p>where is <code>cpus[0].context.ra</code>?
i.e. where will swtch() return to?
<code>kernel.asm</code> says it&rsquo;s in the <code>scheduler()</code> function in proc.c</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-sh" data-lang="sh"><span style="display:flex;"><span><span style="color:#f92672">(</span>gdb<span style="color:#f92672">)</span> tbreak swtch
</span></span><span style="display:flex;"><span><span style="color:#f92672">(</span>gdb<span style="color:#f92672">)</span> c
</span></span></code></pre></div><p>we&rsquo;re in kernel/swtch.S
a0 is the first argument, <code>p-&gt;context</code>
a1 is the second argument, <code>cpus[0].context</code>
<code>swtch()</code> saves current registers in xx(a0) (<code>p-&gt;context</code>)
<code>swtch()</code> then restores registers from xx(a1) (<code>cpus[0].context</code>)
then <code>swtch</code> returns</p>
<p>Q: swtch() neither saves nor restores $pc (program counter)!
so how does it know where to start executing in the target thread?</p>
<p>Q: why does swtch() save only 14 registers (ra, sp, s0..s11)?
the RISC-V has 32 registers &ndash; what about the other 18?
zero, gp, tp
t0-t6, a0-a7
note we&rsquo;re talking about kernel thread registers
all 32 user register have already been saved in the trapframe</p>
<p>registers at start of swtch:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-sh" data-lang="sh"><span style="display:flex;"><span><span style="color:#f92672">(</span>gdb<span style="color:#f92672">)</span> print $pc  -- swtch
</span></span><span style="display:flex;"><span><span style="color:#f92672">(</span>gdb<span style="color:#f92672">)</span> print $ra  -- sched
</span></span><span style="display:flex;"><span><span style="color:#f92672">(</span>gdb<span style="color:#f92672">)</span> print $sp
</span></span></code></pre></div><p>registers at end of swtch:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-sh" data-lang="sh"><span style="display:flex;"><span><span style="color:#f92672">(</span>gdb<span style="color:#f92672">)</span> stepi <span style="color:#ae81ff">28</span>   -- <span style="color:#66d9ef">until</span> ret
</span></span><span style="display:flex;"><span><span style="color:#f92672">(</span>gdb<span style="color:#f92672">)</span> print $pc  -- swtch
</span></span><span style="display:flex;"><span><span style="color:#f92672">(</span>gdb<span style="color:#f92672">)</span> print $ra  -- scheduler
</span></span><span style="display:flex;"><span><span style="color:#f92672">(</span>gdb<span style="color:#f92672">)</span> print $sp  -- stack0+??? -- entry.S set this up at boot
</span></span><span style="display:flex;"><span><span style="color:#f92672">(</span>gdb<span style="color:#f92672">)</span> where
</span></span><span style="display:flex;"><span><span style="color:#f92672">(</span>gdb<span style="color:#f92672">)</span> stepi
</span></span></code></pre></div><p>we&rsquo;re in <code>scheduler()</code> now, in the &ldquo;scheduler thread&rdquo;,
on the scheduler&rsquo;s stack</p>
<p><code>scheduler()</code> just returned from a call to <code>swtch()</code>
it made that call a while ago, to switch to our process&rsquo;s kernel thread
that previous call saved <code>scheduler()</code>&rsquo;s registers
our processes&rsquo;s call to <code>swtch()</code> restored scheduler()&rsquo;s saved registers
p here refers to the interrupted process</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-sh" data-lang="sh"><span style="display:flex;"><span><span style="color:#f92672">(</span>gdb<span style="color:#f92672">)</span> print p-&gt;name
</span></span><span style="display:flex;"><span><span style="color:#f92672">(</span>gdb<span style="color:#f92672">)</span> print p-&gt;pid
</span></span><span style="display:flex;"><span><span style="color:#f92672">(</span>gdb<span style="color:#f92672">)</span> print p-&gt;state
</span></span></code></pre></div><p>remember <code>yield()</code> acquired the process&rsquo;s lock
now scheduler releases it
the <code>scheduler()</code> code <em>looks</em> like an ordinary acquire/release pair
but in fact scheduler acquires, yield releases
then yield acquires, scheduler releases
unusual: the lock is released by a different thread than acquired it!</p>
<p>Q: why hold <code>p-&gt;lock</code> across <code>swtch()</code>?
<code>yield()</code> acquires
<code>scheduler()</code> releases
could we release p-&gt;lock just before calling <code>swtch()</code>?</p>
<p>p-&gt;lock protects a few things:
makes these steps atomic:</p>
<ul>
<li>p-&gt;state=RUNNABLE</li>
<li>save registers in p-&gt;context</li>
<li>stop using p&rsquo;s kernel stack</li>
</ul>
<p>â€‹        so other CPU&rsquo;s scheduler won&rsquo;t start running p until all steps complete</p>
<p>makes these steps atomic and uninterruptable:</p>
<ul>
<li>p-&gt;state=RUNNING</li>
<li>move registers from context to RISC-V registers</li>
</ul>
<p>â€‹        so an interrupt won&rsquo;t yield() and save not-yet-initialized</p>
<p>â€‹          RISC-V registers in context.</p>
<p>scheduler()&rsquo;s loop looks at all processes, finds one that&rsquo;s RUNNABLE
keeps looping until it finds something &ndash; may be idle for a while
in this demo, will find the other spin process
let&rsquo;s fast-forward to when scheduler() finds a RUNNABLE process</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-sh" data-lang="sh"><span style="display:flex;"><span><span style="color:#f92672">(</span>gdb<span style="color:#f92672">)</span> tbreak proc.c:474
</span></span><span style="display:flex;"><span><span style="color:#f92672">(</span>gdb<span style="color:#f92672">)</span> c
</span></span></code></pre></div><p>scheduler() locked the new process, then set state to RUNNING
now another CPUs&rsquo; scheduler won&rsquo;t run it</p>
<p>it&rsquo;s the other &ldquo;spin&rdquo; process:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-sh" data-lang="sh"><span style="display:flex;"><span><span style="color:#f92672">(</span>gdb<span style="color:#f92672">)</span> print p-&gt;name
</span></span><span style="display:flex;"><span><span style="color:#f92672">(</span>gdb<span style="color:#f92672">)</span> print p-&gt;pid
</span></span><span style="display:flex;"><span><span style="color:#f92672">(</span>gdb<span style="color:#f92672">)</span> print p-&gt;state
</span></span></code></pre></div><p>let&rsquo;s see where the new thread will start executing after swtch()
by looking at $ra (return address) in its context</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-sh" data-lang="sh"><span style="display:flex;"><span><span style="color:#f92672">(</span>gdb<span style="color:#f92672">)</span> print/x p-&gt;context
</span></span><span style="display:flex;"><span><span style="color:#f92672">(</span>gdb<span style="color:#f92672">)</span> x/4i p-&gt;context-&gt;ra
</span></span></code></pre></div><p>new thread will return into <code>sched()</code></p>
<p>look at kernel/swtch.S (again)</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-sh" data-lang="sh"><span style="display:flex;"><span><span style="color:#f92672">(</span>gdb<span style="color:#f92672">)</span> tbreak swtch
</span></span><span style="display:flex;"><span><span style="color:#f92672">(</span>gdb<span style="color:#f92672">)</span> c
</span></span><span style="display:flex;"><span><span style="color:#f92672">(</span>gdb<span style="color:#f92672">)</span> stepi <span style="color:#ae81ff">28</span> -- now just about to execute swtch<span style="color:#f92672">()</span><span style="color:#960050;background-color:#1e0010">&#39;</span>s ret
</span></span><span style="display:flex;"><span><span style="color:#f92672">(</span>gdb<span style="color:#f92672">)</span> print $ra
</span></span><span style="display:flex;"><span><span style="color:#f92672">(</span>gdb<span style="color:#f92672">)</span> where
</span></span></code></pre></div><p>now we&rsquo;re in a timer interrupt in the <em>other</em> spin process
in the past it was interrupted, called <code>yield()</code> / <code>sched()</code> / <code>swtch()</code>
but now it will resume, and return to user space</p>
<p>note: only swtch() writes contexts (except for initialization)
only sched() and <code>scheduler()</code> call <code>swtch()</code>
so for a kernel thread, context.ra always points into <code>sched()</code>
and for a scheduler thread, context.ra always points into scheduler()</p>
<p>note: <code>sched()</code> calls <code>swtch()</code> &ndash; then <code>swtch()</code> returns to <code>sched()</code>
but it&rsquo;s typically a <em>different</em> thread returning</p>
<p><code>sched()</code> and <code>scheduler()</code> are &ldquo;co-routines&rdquo;
each knows what it is swtch()ing to
each knows where swtch() return is coming from
e.g. <code>yield()</code> and scheduler() cooperate about p-&gt;lock and p-&gt;state
different from ordinary thread switching, where neither
party typically knows which thread comes before/after</p>
<p>Q: what is the &ldquo;scheduling policy&rdquo;?</p>
<p>i.e. how does xv6 decide what to run next if multiple threads are RUNNABLE?
is it a good policy?</p>
<p>Q: is there pre-emptive scheduling of kernel threads?</p>
<p>yes &ndash; timer interrupt and yield() can occur while in kernel.
<code>yield()</code> called by kerneltrap() in kernel/trap.c
where to save registers of interrupted kernel code?
not in p-&gt;trapframe, since already has user registers.
not in p-&gt;context, since we&rsquo;re about to call yield() and swtch()
kernelvec.S pushes them on the kernel stack (since already in kernel).
is pre-emption in the kernel useful?
not critical in xv6.
valuable if some system calls have lots of compute.
or if we need a strict notion of thread priority.</p>
<p>Q: why does <code>scheduler()</code> briefly enable interrupts, with intr_on()?</p>
<p>There may be no RUNNABLE threads
They may all be waiting for I/O, e.g. disk or console
Enable interrupts so device has a chance to signal completion
and thus wake up a thread
Otherwise, system will freeze</p>
<p>Q: why does <code>sched()</code> forbid locks from being held when yielding the CPU?</p>
<p>(other than p-&gt;lock)
i.e. sched() checks that noff == 1
suppose process P1 holding lock L1, yields CPU
process P2 runs, tries acquire(L1)
P2&rsquo;s acquire spins with interrupts turned off
so timer interrupts won&rsquo;t occur
so P2 won&rsquo;t yield the CPU
so P1 can&rsquo;t execute
so P1 won&rsquo;t release L1, ever</p>
<p>Q: can we get rid of the separate per-cpu scheduler thread?</p>
<p>could <code>sched()</code> directly <code>swtch()</code> to a new thread?
so that <code>sched()</code> looks for next process to run?
that would be faster &ndash; avoids one of the swtch() calls
yes &ndash; but:
scheduling loop would run on a thread&rsquo;s kernel stack
what if that thread is exiting?
what if another cpu wants to run the thread?
what if there are fewer threads than CPUs &ndash; i.e. too few stacks?
can be dealt with &ndash; give it a try!</p>
<h2 id="summary">Summary<a hidden class="anchor" aria-hidden="true" href="#summary">#</a></h2>
<p>xv6 provides a convenient thread model for kernel code
pre-emptive via timer interrupts
transparent via switching registers and stack
multi-core requires careful handling of stacks, locks
next lecture: mechanisms for threads to wait for each other</p>
<h2 id="lab-multithreadinghttpspdoscsailmitedu6s0812020labsthreadhtml"><a href="https://pdos.csail.mit.edu/6.S081/2020/labs/thread.html">Lab: Multithreading</a><a hidden class="anchor" aria-hidden="true" href="#lab-multithreadinghttpspdoscsailmitedu6s0812020labsthreadhtml">#</a></h2>
<h2 id="uthread-switching-between-threads-moderatehttpspdoscsailmitedu6s0812020labsguidancehtml">Uthread: switching between threads (<a href="https://pdos.csail.mit.edu/6.S081/2020/labs/guidance.html">moderate</a>)<a hidden class="anchor" aria-hidden="true" href="#uthread-switching-between-threads-moderatehttpspdoscsailmitedu6s0812020labsguidancehtml">#</a></h2>
<p>è®¾è®¡å¹¶å®ç°ç”¨æˆ·çº§çº¿ç¨‹ç³»ç»Ÿçš„ä¸Šä¸‹æ–‡åˆ‡æ¢æœºåˆ¶ã€‚xv6ç³»ç»Ÿä¸­æä¾›äº†ä¸¤ä¸ªæ–‡ä»¶ï¼š<code>uthread.c</code> å’Œ <code>uthread_switch.S</code>ï¼Œä»¥åŠä¸€ä¸ªç”¨äºæ„å»º <code>uthread</code> ç¨‹åºçš„Makefileè§„åˆ™ã€‚<code>uthread.c</code> åŒ…å«äº†ä¸€ä¸ªåŸºæœ¬çš„ç”¨æˆ·çº§çº¿ç¨‹åŒ…ä»¥åŠä¸‰ä¸ªæµ‹è¯•çº¿ç¨‹çš„ä»£ç ï¼Œä½†ç¼ºå°‘åˆ›å»ºçº¿ç¨‹å’Œçº¿ç¨‹åˆ‡æ¢çš„éƒ¨åˆ†ä»£ç ã€‚</p>
<p>ä»»åŠ¡è¦æ±‚åŒ…æ‹¬ï¼š</p>
<ol>
<li>å®ç°çº¿ç¨‹åˆ›å»ºå’Œä¸Šä¸‹æ–‡åˆ‡æ¢çš„ä»£ç ã€‚</li>
<li>åœ¨çº¿ç¨‹ç¬¬ä¸€æ¬¡è¿è¡Œæ—¶ï¼Œç¡®ä¿æ‰§è¡Œåˆ›å»ºæ—¶ä¼ é€’çš„å‡½æ•°ï¼Œå¹¶ä½¿ç”¨è¯¥çº¿ç¨‹çš„æ ˆã€‚</li>
<li>å®ç° <code>thread_switch</code> æ¥ä¿å­˜å½“å‰çº¿ç¨‹çš„å¯„å­˜å™¨ï¼Œå¹¶æ¢å¤ä¸‹ä¸€ä¸ªçº¿ç¨‹çš„å¯„å­˜å™¨ï¼Œä»¥ç»§ç»­å…¶æ‰§è¡Œã€‚</li>
</ol>
<p>1.æ·»åŠ <code>utcontext</code>ç»“æ„ä½“</p>
<p>






    <div class="post-img-view">
        <a data-fancybox="gallery" href="https://raw.githubusercontent.com/Kennems/blog-image/main/image-20240925205441472.png">
            <img src="https://raw.githubusercontent.com/Kennems/blog-image/main/image-20240925205441472.png" alt="image-20240925205441472"  />
        </a>
    </div>
</p>
<p>2.æ·»åŠ <code>utcontext</code>å­—æ®µ</p>
<p>






    <div class="post-img-view">
        <a data-fancybox="gallery" href="https://raw.githubusercontent.com/Kennems/blog-image/main/image-20240925210233049.png">
            <img src="https://raw.githubusercontent.com/Kennems/blog-image/main/image-20240925210233049.png" alt="image-20240925210233049"  />
        </a>
    </div>
</p>
<ol start="3">
<li><code>thread_create</code>ä¸­ä¿å­˜<code>ra</code>å’Œ<code>sp</code></li>
</ol>
<p>






    <div class="post-img-view">
        <a data-fancybox="gallery" href="https://raw.githubusercontent.com/Kennems/blog-image/main/image-20240925210357062.png">
            <img src="https://raw.githubusercontent.com/Kennems/blog-image/main/image-20240925210357062.png" alt="image-20240925210357062"  />
        </a>
    </div>
</p>
<p>4.è¡¥å…¨<code>uthread_switch.S</code>ï¼Œ å®Œå…¨å‚ç…§<code>swtch.S</code></p>
<p>






    <div class="post-img-view">
        <a data-fancybox="gallery" href="https://raw.githubusercontent.com/Kennems/blog-image/main/image-20240925210456230.png">
            <img src="https://raw.githubusercontent.com/Kennems/blog-image/main/image-20240925210456230.png" alt="image-20240925210456230"  />
        </a>
    </div>
</p>
<p>5.è°ƒç”¨<code>thread_switch</code>ï¼Œè°ƒç”¨ <code>thread_switch</code> åˆ‡æ¢ä¸Šä¸‹æ–‡ï¼Œä¼ é€’å½“å‰çº¿ç¨‹å’Œä¸‹ä¸€ä¸ªçº¿ç¨‹çš„ä¸Šä¸‹æ–‡ï¼Œ æ³¨æ„è¿™é‡Œä¸Šä¸‹æ–‡åˆ‡æ¢éœ€è¦åœ¨æœ€åå®ç°ï¼Œå› ä¸ºè¿™ä¼šå½±å“<code>next_thread</code>, æ‰€ä»¥ä¸€å®šè¦åœ¨æ›´æ–°<code>current_thread</code>ä¹‹åè°ƒç”¨<code>thread_switch</code>ã€‚</p>
<p>






    <div class="post-img-view">
        <a data-fancybox="gallery" href="https://raw.githubusercontent.com/Kennems/blog-image/main/image-20240925210332105.png">
            <img src="https://raw.githubusercontent.com/Kennems/blog-image/main/image-20240925210332105.png" alt="image-20240925210332105"  />
        </a>
    </div>
</p>
<h2 id="using-threads-moderatehttpspdoscsailmitedu6s0812020labsguidancehtml">Using threads (<a href="https://pdos.csail.mit.edu/6.S081/2020/labs/guidance.html">moderate</a>)<a hidden class="anchor" aria-hidden="true" href="#using-threads-moderatehttpspdoscsailmitedu6s0812020labsguidancehtml">#</a></h2>
<p><strong>ç›®æ ‡</strong>ï¼šå®ç°çº¿ç¨‹å¹¶è¡Œç¼–ç¨‹ï¼Œä½¿ç”¨<code>pthread</code>åº“åœ¨å¤šçº¿ç¨‹ç¯å¢ƒä¸‹æ“ä½œå“ˆå¸Œè¡¨ï¼Œå¹¶ç¡®ä¿å…¶çº¿ç¨‹å®‰å…¨ã€‚</p>
<p><strong>ä»»åŠ¡ç¯å¢ƒ</strong>ï¼šåœ¨æ”¯æŒå¤šæ ¸çš„çœŸå®Linuxæˆ–MacOSè®¡ç®—æœºä¸Šå®Œæˆï¼Œä¸ä½¿ç”¨xv6æˆ–qemuã€‚</p>
<p><strong>åˆå§‹é—®é¢˜</strong>ï¼šæä¾›çš„å“ˆå¸Œè¡¨ä»…åœ¨å•çº¿ç¨‹æƒ…å†µä¸‹æ­£ç¡®ï¼Œå¤šçº¿ç¨‹ç¯å¢ƒä¸‹ä¼šæœ‰ç¼ºå¤±é”®çš„é—®é¢˜ã€‚</p>
<p><strong>æ­¥éª¤</strong>ï¼š</p>
<ul>
<li>ä½¿ç”¨<code>pthread</code>åº“å¯¹å“ˆå¸Œè¡¨è¿›è¡Œå¹¶å‘æ“ä½œã€‚</li>
<li>è¿è¡Œæµ‹è¯•<code>ph 1</code>å’Œ<code>ph 2</code>ï¼Œè§‚å¯Ÿä¸åŒçº¿ç¨‹ä¸‹çš„æ’å…¥å’Œè·å–æ€§èƒ½ã€‚</li>
<li>åˆ†æç¼ºå¤±é”®å‡ºç°çš„åŸå› ï¼Œæäº¤è§£é‡Šï¼ˆsequence of eventsï¼‰ã€‚</li>
</ul>
<p><strong>è§£å†³æ–¹æ¡ˆ</strong>ï¼šåœ¨<code>put()</code>å’Œ<code>get()</code>å‡½æ•°ä¸­æ·»åŠ é”æœºåˆ¶ï¼Œç¡®ä¿å¤šçº¿ç¨‹æ“ä½œæ—¶æ²¡æœ‰é”®ä¸¢å¤±ã€‚</p>
<ul>
<li>ä½¿ç”¨<code>pthread_mutex_t</code>ç›¸å…³å‡½æ•°å®ç°åŠ é”å’Œè§£é”ã€‚</li>
<li>ä¿®æ”¹ä»£ç ï¼Œé€šè¿‡æµ‹è¯•<code>ph_safe</code>ï¼Œç¡®ä¿ä¸¤çº¿ç¨‹ä¸‹æ— é”®ä¸¢å¤±ã€‚</li>
</ul>
<p><strong>è¿›ä¸€æ­¥ä¼˜åŒ–</strong>ï¼šå°è¯•åœ¨æŸäº›æƒ…å†µä¸‹å…è®¸å¹¶è¡Œæ’å…¥æ“ä½œï¼Œä¾‹å¦‚ä½¿ç”¨æ¯ä¸ªå“ˆå¸Œæ¡¶ï¼ˆbucketï¼‰ä¸€ä¸ªé”ï¼Œä»¥æé«˜æ€§èƒ½ã€‚</p>
<ul>
<li>ä¿®æ”¹ä»£ç ï¼Œä½¿å…¶é€šè¿‡<code>ph_safe</code>å’Œ<code>ph_fast</code>æµ‹è¯•ï¼Œè¦æ±‚åŒçº¿ç¨‹è‡³å°‘è¾¾åˆ°å•çº¿ç¨‹1.25å€çš„æ’å…¥é€Ÿåº¦ã€‚</li>
</ul>
<p>1.å®šä¹‰é”ï¼Œ å®šä¹‰å…¨å±€é”å¯ä»¥ä¿è¯å¤šçº¿ç¨‹æƒ…å†µä¸‹ä¸ä¼šä¸¢å¤±<code>key</code>, ä¸ºæ¯ä¸€ä¸ªæ¡¶åŠ é”å¯ä»¥åœ¨ä¿è¯ä¸ä¸¢å¤±<code>key</code>çš„æƒ…å†µä¸‹ä¿è¯æ€§èƒ½</p>
<p>






    <div class="post-img-view">
        <a data-fancybox="gallery" href="https://raw.githubusercontent.com/Kennems/blog-image/main/image-20240925223047695.png">
            <img src="https://raw.githubusercontent.com/Kennems/blog-image/main/image-20240925223047695.png" alt="image-20240925223047695"  />
        </a>
    </div>
</p>
<p>2.åˆå§‹åŒ–é”</p>
<p>






    <div class="post-img-view">
        <a data-fancybox="gallery" href="https://raw.githubusercontent.com/Kennems/blog-image/main/image-20240925223411090.png">
            <img src="https://raw.githubusercontent.com/Kennems/blog-image/main/image-20240925223411090.png" alt="image-20240925223411090"  />
        </a>
    </div>
</p>
<p>3.åœ¨<code>put()</code>å’Œ<code>get()</code>ä¸­åŠ é”ä»¥åŠè§£é”</p>
<p>






    <div class="post-img-view">
        <a data-fancybox="gallery" href="https://raw.githubusercontent.com/Kennems/blog-image/main/image-20240925223241354.png">
            <img src="https://raw.githubusercontent.com/Kennems/blog-image/main/image-20240925223241354.png" alt="image-20240925223241354"  />
        </a>
    </div>
</p>
<p>






    <div class="post-img-view">
        <a data-fancybox="gallery" href="https://raw.githubusercontent.com/Kennems/blog-image/main/image-20240925223331339.png">
            <img src="https://raw.githubusercontent.com/Kennems/blog-image/main/image-20240925223331339.png" alt="image-20240925223331339"  />
        </a>
    </div>
</p>
<h2 id="barriermoderatehttpspdoscsailmitedu6s0812020labsguidancehtml">Barrier(<a href="https://pdos.csail.mit.edu/6.S081/2020/labs/guidance.html">moderate</a>)<a hidden class="anchor" aria-hidden="true" href="#barriermoderatehttpspdoscsailmitedu6s0812020labsguidancehtml">#</a></h2>
<p>å®ç°ä¸€ä¸ªçº¿ç¨‹å±éšœï¼ˆbarrierï¼‰ï¼Œå³æ‰€æœ‰çº¿ç¨‹åœ¨åŒä¸€ç‚¹ç­‰å¾…ï¼Œç›´åˆ°æ‰€æœ‰çº¿ç¨‹éƒ½åˆ°è¾¾è¯¥ç‚¹åå†ç»§ç»­ã€‚éœ€è¦ä½¿ç”¨ <code>pthread</code> çš„æ¡ä»¶å˜é‡ (<code>pthread_cond_wait</code> å’Œ <code>pthread_cond_broadcast</code>) æ¥åè°ƒçº¿ç¨‹ã€‚ä»»åŠ¡æ˜¯åœ¨ <code>barrier.c</code> ä¸­ä¿®å¤å·²å­˜åœ¨çš„é—®é¢˜ï¼Œç¡®ä¿æ‰€æœ‰çº¿ç¨‹åœ¨è°ƒç”¨ <code>barrier()</code> æ—¶éƒ½è¢«é˜»å¡ï¼Œç›´åˆ°å…¨éƒ¨çº¿ç¨‹åˆ°è¾¾ã€‚</p>
<p>å…³é”®è¦æ±‚ï¼š</p>
<ol>
<li>ä½¿ç”¨æ¡ä»¶å˜é‡å®ç°çº¿ç¨‹åŒæ­¥ã€‚</li>
<li>å¤„ç†å¤šæ¬¡å¾ªç¯ä¸­çš„å±éšœè°ƒç”¨ï¼Œæ¯æ¬¡å±éšœéƒ½ä»£è¡¨ä¸€ä¸ªâ€œå›åˆâ€ã€‚</li>
<li>é¿å…ä¸€ä¸ªçº¿ç¨‹å¿«é€Ÿç¦»å¼€å±éšœå¹¶å½±å“å…¶ä»–çº¿ç¨‹ã€‚</li>
<li>ç¡®ä¿è§£å†³æ–­è¨€é”™è¯¯å¹¶é€šè¿‡æµ‹è¯•ã€‚</li>
</ol>
<p>åœ¨æ¯ä¸€ä¸ªthreadä¸­è°ƒç”¨barrierï¼Œ è®°å½•æ‰€æœ‰åˆ°è¾¾çš„threadæ•°é‡ï¼Œ å¦‚æœæ•°é‡ç­‰äºè®¾ç½®çš„çº¿ç¨‹æ•°ï¼Œåˆ™å¼€å§‹ä¸‹ä¸€<code>round</code>ï¼Œå¦åˆ™å°†æ­¤çº¿ç¨‹æ‰§è¡Œæ­¤æ“ä½œ ï¼š</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cc" data-lang="cc"><span style="display:flex;"><span>pthread_cond_wait(<span style="color:#f92672">&amp;</span>bstate.barrier_cond, <span style="color:#f92672">&amp;</span>bstate.barrier_mutex); <span style="color:#75715e">// Release mutex and wait
</span></span></span></code></pre></div><p>ä¿è¯è¯¥çº¿ç¨‹å¤„äºç­‰å¾…çŠ¶æ€ï¼Œç­‰å¾…æ‰€æœ‰çº¿ç¨‹éƒ½å®Œæˆæ­¤<code>round</code>ã€‚</p>
<p>






    <div class="post-img-view">
        <a data-fancybox="gallery" href="https://raw.githubusercontent.com/Kennems/blog-image/main/image-20240926113217023.png">
            <img src="https://raw.githubusercontent.com/Kennems/blog-image/main/image-20240926113217023.png" alt="image-20240926113217023"  />
        </a>
    </div>
</p>


  </div>

  <footer class="post-footer">
    <ul class="post-tags">
      <li><a href="https://kennems.github.io/tags/mit6.s081/">MIT6.S081</a></li>
    </ul>
        
    
    <ul id="categories">
      
        <li><a href="https://kennems.github.io/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F">æ“ä½œç³»ç»Ÿ</a> </li>
      
    </ul>
    
    
<nav class="paginav">
  <a class="prev" href="https://kennems.github.io/posts/tech/%E5%91%A8%E8%B5%9B240924/">
    <span class="title">Â« ä¸Šä¸€é¡µ</span>
    <br>
    <span>LeetCodeå‘¨èµ›416(250922)</span>
  </a>
  <a class="next" href="https://kennems.github.io/posts/tech/mit6.s08110-locks/">
    <span class="title">ä¸‹ä¸€é¡µ Â»</span>
    <br>
    <span>MIT6.S081(10)-Locking</span>
  </a>
</nav>

  </footer>
</article>
    </main>
    
<footer class="footer">
        <span>&copy; 2025 <a href="https://kennems.github.io/">Kennem&#39;s Blog</a></span> Â· 

    <span>
        Powered by
        <a href="https://gohugo.io/" rel="noopener noreferrer" target="_blank">Hugo</a> &
        <a href="https://github.com/adityatelange/hugo-PaperMod/" rel="noopener" target="_blank">PaperMod</a>
    </span>
</footer>
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)" class="top-link" id="top-link" accesskey="g">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
        <path d="M12 6H0l6-6z" />
    </svg>
</a>

<script>
    let menu = document.getElementById('menu')
    if (menu) {
        menu.scrollLeft = localStorage.getItem("menu-scroll-position");
        menu.onscroll = function () {
            localStorage.setItem("menu-scroll-position", menu.scrollLeft);
        }
    }

    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.pushState(null, null, `#${id}`);
            }
        });
    });

</script>
<script>
    var mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };

</script>
<script>
    document.getElementById("theme-toggle").addEventListener("click", () => {
        if (document.body.className.includes("dark")) {
            document.body.classList.remove('dark');
            localStorage.setItem("pref-theme", 'light');
        } else {
            document.body.classList.add('dark');
            localStorage.setItem("pref-theme", 'dark');
        }
    })

</script>
<script>
    document.querySelectorAll('pre > code').forEach((codeblock) => {
        const container = codeblock.parentNode.parentNode;

        const copybutton = document.createElement('button');
        copybutton.classList.add('copy-code');
        copybutton.innerHTML = 'å¤åˆ¶';

        function copyingDone() {
            copybutton.innerHTML = 'å·²å¤åˆ¶ï¼';
            setTimeout(() => {
                copybutton.innerHTML = 'å¤åˆ¶';
            }, 2000);
        }

        copybutton.addEventListener('click', (cb) => {
            if ('clipboard' in navigator) {
                navigator.clipboard.writeText(codeblock.textContent);
                copyingDone();
                return;
            }

            const range = document.createRange();
            range.selectNodeContents(codeblock);
            const selection = window.getSelection();
            selection.removeAllRanges();
            selection.addRange(range);
            try {
                document.execCommand('copy');
                copyingDone();
            } catch (e) { };
            selection.removeRange(range);
        });

        if (container.classList.contains("highlight")) {
            container.appendChild(copybutton);
        } else if (container.parentNode.firstChild == container) {
            
        } else if (codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName == "TABLE") {
            
            codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(copybutton);
        } else {
            
            codeblock.parentNode.appendChild(copybutton);
        }
    });
</script>
<footer class="footer">
    <script async src="https://busuanzi.sukap.cn/busuanzi.pure.mini.js"></script>
    <span id="busuanzi_container">
        <link rel="stylesheet" href="//maxcdn.bootstrapcdn.com/font-awesome/4.3.0/css/font-awesome.min.css">
        Visitors: <span id="busuanzi_value_page_uv"></span>
        Views: <span id="busuanzi_value_page_pv"></span>

        
    </span>
</footer>



</body>

</html>
