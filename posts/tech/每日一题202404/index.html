<!DOCTYPE html>
<html lang="zh" dir="auto">

<head><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="index, follow">

<meta name="msvalidate.01" content="DF5FE493CC759E62BFE073BEA8EFD472" />
<title>LeetCode每日一题（202404） | Kennem&#39;s Blog</title>
<meta name="keywords" content="LeetCode笔记">
<meta name="description" content="每日一题（202404）">
<meta name="author" content="ShowGuan">
<link rel="canonical" href="https://kennems.github.io/posts/tech/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98202404/">
<link crossorigin="anonymous" href="/assets/css/stylesheet.1a7bc7e6d01b82c8ca2b2e53cfcf7e33d2fd9058f6b28245f94da0d91447c6a0.css" integrity="sha256-GnvH5tAbgsjKKy5Tz89&#43;M9L9kFj2soJF&#43;U2g2RRHxqA=" rel="preload stylesheet" as="style">
<link rel="icon" href="https://kennems.github.io/img/sun.png">
<link rel="icon" type="image/png" sizes="16x16" href="https://kennems.github.io/img/sun.png">
<link rel="icon" type="image/png" sizes="32x32" href="https://kennems.github.io/img/sun.png">
<link rel="apple-touch-icon" href="https://kennems.github.io/img/sun.png">
<link rel="mask-icon" href="https://kennems.github.io/img/sun.png">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<link rel="alternate" hreflang="zh" href="https://kennems.github.io/posts/tech/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98202404/">
<noscript>
    <style>
        #theme-toggle,
        .top-link {
            display: none;
        }

    </style>
    <style>
        @media (prefers-color-scheme: dark) {
            :root {
                --theme: rgb(29, 30, 32);
                --entry: rgb(46, 46, 51);
                --primary: rgb(218, 218, 219);
                --secondary: rgb(155, 156, 157);
                --tertiary: rgb(65, 66, 68);
                --content: rgb(196, 196, 197);
                --code-block-bg: rgb(46, 46, 51);
                --code-bg: rgb(55, 56, 62);
                --border: rgb(51, 51, 51);
            }

            .list {
                background: var(--theme);
            }

            .list:not(.dark)::-webkit-scrollbar-track {
                background: 0 0;
            }

            .list:not(.dark)::-webkit-scrollbar-thumb {
                border-color: var(--theme);
            }
        }

    </style>
</noscript>

<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.2/dist/katex.min.css" integrity="sha384-MlJdn/WNKDGXveldHDdyRP1R4CTHr3FeuDNfhsLPYrq2t0UBkUdK2jyTnXPEK1NQ" crossorigin="anonymous">

<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.2/dist/katex.min.js" integrity="sha384-VQ8d8WVFw0yHhCk5E8I86oOhv48xLpnDZx5T9GogA/Y84DcCKWXDmSDfn13bzFZY" crossorigin="anonymous"></script>

<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.2/dist/contrib/auto-render.min.js" integrity="sha384-+XBljXPPiv+OzfbB3cVmLHf4hdUFHlWNZN5spNQ7rmHTXpd7WvJum6fIACpNNfIR" crossorigin="anonymous"
    onload="renderMathInElement(document.body);"></script>

<script>
document.addEventListener("DOMContentLoaded", function() {
    renderMathInElement(document.body, {
        delimiters: [
            {left: "$$", right: "$$", display: true},
            {left: "$", right: "$", display: false}
        ]
    });
});
</script>



<link rel="stylesheet" href="https://fonts.cdnfonts.com/css/code-new-roman">
<link rel="preconnect" href="https://fonts.googleapis.com">
<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>


  

<meta property="og:url" content="https://kennems.github.io/posts/tech/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98202404/">
  <meta property="og:site_name" content="Kennem&#39;s Blog">
  <meta property="og:title" content="LeetCode每日一题（202404）">
  <meta property="og:description" content="每日一题（202404）">
  <meta property="og:locale" content="zh">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2024-04-17T15:37:01+08:00">
    <meta property="article:modified_time" content="2024-04-22T15:37:01+08:00">
    <meta property="article:tag" content="LeetCode笔记">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="LeetCode每日一题（202404）">
<meta name="twitter:description" content="每日一题（202404）">


<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BreadcrumbList",
  "itemListElement": [
    {
      "@type": "ListItem",
      "position":  1 ,
      "name": "📚文章",
      "item": "https://kennems.github.io/posts/"
    }, 
    {
      "@type": "ListItem",
      "position":  2 ,
      "name": "💻技术",
      "item": "https://kennems.github.io/posts/tech/"
    }, 
    {
      "@type": "ListItem",
      "position":  3 ,
      "name": "LeetCode每日一题（202404）",
      "item": "https://kennems.github.io/posts/tech/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98202404/"
    }
  ]
}
</script>
<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "LeetCode每日一题（202404）",
  "name": "LeetCode每日一题（202404）",
  "description": "每日一题（202404）",
  "keywords": [
    "LeetCode笔记"
  ],
  "articleBody": "每日一题（202404） 2009. 使数组连续的最少操作数 题意：给定一个可能有重复元素的数组，可以修改数组中值为任意其他值，问使数组连续的最小操作数。\n思路：由于只能改动元素，所以最后的元素个数不变，去重后，枚举每个值作为左端点，则右端点为nums[i]+n-1, 用双指针计算在区间内的元素个数即为可以保留的数字，其他数字修改元素值填满空隙即可。\nclass Solution: def minOperations(self, nums: List[int]) -\u003e int: n = len(nums) nums = sorted(set(nums)) j, ans = 0, 0 for i in range(len(nums)): right = nums[i]+ n-1 if len(nums)-1 - i + 1 \u003c= ans: break while j\u003clen(nums) and nums[j]\u003c=right: j+=1 ans = max(ans, j-i) return n-ans 1600. 王位继承顺序 题意：国王继承次序按嫡长子次序，实现ThroneInheritance(string kingName)初始化,void birth(string parentName, string childName) 出生，void death(string name)人死亡，string[] getInheritanceOrder() 返回 除去 死亡人员的当前继承顺序列表。\n思路：类似树形结构，国王先继承，之后是国王的长子，之后是长子的长子， 如果不存在则为国王的次子以此类推， 所以可以用defaultdict()存储每个的儿子情况，然后查询时，先将自己入结果列表，然后是第一个儿子…；并记录每个人的存活情况，排除掉已经死掉的人。\nclass ThroneInheritance: def __init__(self, kingName: str): self.son = defaultdict(list) self.die = set() self.king = kingName def birth(self, parentName: str, childName: str) -\u003e None: self.son[parentName].append(childName) def death(self, name: str) -\u003e None: self.die.add(name) def getInheritanceOrder(self) -\u003e List[str]: ret = [] def dfs(root): if root not in self.die: ret.append(root) for child in self.son[root]: dfs(child) dfs(self.king) return ret 1483. 树节点的第 K 个祖先 题意：给定n个点(0~n-1)每个点的父亲节点，快速查询每个节点的第k个祖宗节点。\n思路：LCA倍增原理，$ancestor[j][i] = ancestor[ ancestor[j][i-1] ][i-1]$ 节点j的第$2^i$个祖宗节点为节点第$2^{i-1}$个祖宗的第$2^{i-1}$个祖宗，即$2^{i-1}*2$个祖宗节点， 所以先预处理好每个节点的各个二进制位上的祖宗节点是谁，之后分解二进制位据可以得知任意第k个祖宗节点是谁。\nclass TreeAncestor: def __init__(self, n: int, parent: List[int]): self.level = 16 self.ancestor = [[-1]*self.level for _ in range(n)] for i in range(1, n): self.ancestor[i][0] = parent[i] for i in range(1, self.level): for j in range(1, n): if self.ancestor[j][i-1]!=-1: self.ancestor[j][i] = self.ancestor[ self.ancestor[j][i-1] ][i-1] def getKthAncestor(self, node: int, k: int) -\u003e int: while k: t = k\u0026-k k -= t t = t.bit_length()-1 node = self.ancestor[node][t] if node==-1: return -1 return node 面试题 08.12. 八皇后 题目大意：\n这道题目是经典的八皇后问题的扩展，需要设计一个算法来打印 N 皇后在 N × N 棋盘上的各种摆法，其中每个皇后都不在同一行、同一列，也不在任何对角线上。\n实现思路：\n回溯算法：\n使用回溯算法来尝试所有可能的皇后摆放方式。 从第一行开始，依次尝试每一列放置皇后，然后继续递归地尝试下一行的放置，直到所有行都放置完毕。 在递归过程中，通过检查每个位置的列、主对角线和副对角线是否已经存在皇后来确定是否可以放置皇后。 生成棋盘：\n当确定了一种合法的皇后摆放方式时，将其转换为棋盘的形式，并将其添加到结果列表中。 对于每行中皇后的位置，用 ‘Q’ 表示，其他位置用 ‘.’ 表示。 辅助函数：\nsolve: 递归函数，尝试在每行放置皇后。 generate: 将合法的皇后摆放方式转换为棋盘形式并添加到结果列表中。 剪枝优化：\n使用位运算来表示列、主对角线和副对角线的占用情况，可以快速判断某个位置是否可以放置皇后，从而提高效率。 在每次递归时，利用位运算进行剪枝，排除不可能的位置。 class Solution: def solveNQueens(self, n: int) -\u003e List[List[str]]: def generate(): board = [] for r in range(n): c = pos[r] row[c] = 'Q' board.append(\"\".join(row)) row[c] = '.' ret.append(board) def solve(row, column, diag1, diag2): if row==n: generate() else: avail = ( (1\u003c\u003cn)-1) \u0026 ( ~(column|diag1|diag2) ) while avail: colPos = avail\u0026(-avail) avail -= colPos colNum = bin(colPos-1).count(\"1\") pos[row]=colNum solve(row+1, column|colPos, (diag1|colPos)\u003c\u003c1, (diag2|colPos)\u003e\u003e1) pos = [0]*n ret = [] row = ['.']*n solve(0, 0, 0, 0) return ret 1702. 修改后的最大二进制字符串 题意：给定一个二进制字符串00-\u003e10, 10-\u003e01问任意次操作后能达到的最大二进制字符串。\n思路：构造，根据条件推过程，10-\u003e01可以看作后面的0浮到前面，所有的0聚到一起可以变成10串，所以最后至多只有一个0。根据构造来做，统计第一个0的位置和0的个数，最后构造出最后的0的位置；双指针来做：遇到0时找到后面第一个0的位置，将其浮到旁边，并换成10。\n构造：\nclass Solution: def maximumBinaryString(self, binary: str) -\u003e str: cnt = binary.count('0') if cnt\u003c=1: return binary n = len(binary) ans = ['1']*n index = binary.index('0') ans[index+cnt-1]='0' return ''.join(ans) 双指针：\nclass Solution: def maximumBinaryString(self, binary: str) -\u003e str: n = len(binary) s = list(binary) j = 0 for i in range(n): if s[i]=='0': while j\u003c=i or (j\u003cn and s[j]=='1'): j+=1 if j\u003cn: s[i], s[j], s[i+1] = '1', '1', '0' return ''.join(s) 24. 两两交换链表中的节点 题意：给定一个链表，分别两个一组交换相对位置。\n思路：链表交换next指针操作，prev-\u003eA-\u003eB-\u003eC变成prev-\u003eB-\u003eA-\u003eC，一共要变三条边。需要记录前面的点，后面的点。\nclass Solution: def swapPairs(self, head: Optional[ListNode]) -\u003e Optional[ListNode]: dummy = head prev = None while head and head.next: tmp = head.next.next #A-\u003eB 变成 B-\u003eA nxt = head.next #nxt是B, head是A nxt.next = head head.next = tmp if prev: prev.next = nxt prev = nxt.next #是头节点(即没有前面的点)的时候不需要这一步 if dummy==head: dummy = nxt prev = nxt.next head = tmp return dummy 25. K 个一组翻转链表 题意：每隔k个数字翻转链表。\n思路：链表交换指针操作。\n# Definition for singly-linked list. # class ListNode: # def __init__(self, val=0, next=None): # self.val = val # self.next = next class Solution: def reverseKGroup(self, head: Optional[ListNode], k: int) -\u003e Optional[ListNode]: def reverse(head, tail): # A-\u003eB-\u003eC 变成 C-\u003eB-\u003eA cur = tail.next dummy = head while cur != tail: nxt = dummy.next dummy.next = cur cur = dummy dummy = nxt return tail, head # 原来的tail和head位置没变，但中间点的指向关系变了 hair = ListNode(-1) # 伪头节点 hair.next = head pre = hair while head: tail = pre for i in range(k): # 走过k个点 tail = tail.next if not tail: return hair.next head, tail = reverse(head, tail) pre.next = head # pre-\u003eC pre = tail # pre变成尾节点 head = tail.next # 头节点变成当前尾节点的下个一个节点 return hair.next 1766. 互质树 题意：给定一棵树0~n-1共n个节点， 每个节点有一个值，返回每个节点的 最近的 与自己互质的(gcd(a,b)=1) 祖宗节点的编号。值的范围为[1,50] 思路：DFS， 遍历一遍树，维护一个祖宗节点的列表，判断当前节点与祖宗节点的互质关系。但朴素的将所有的祖宗节点都加入列表中，到深层的子节点时会遍历整个列表，会超时。由于值的范围最大为50，所以可以先预处理50范围以内的互质关系，对于每个节点，只需要判断祖宗节点里面有没有这些互质的数即可，但是需要的是最近的祖宗节点，所以还要添加一个深度信息，这样才能保证在相同值的祖宗节点中选择离自己最近的祖宗节点。 class Solution: def getCoprimes(self, nums: List[int], edges: List[List[int]]) -\u003e List[int]: n = len(nums) g = [[]*n for _ in range(n)] ret = [-1]*n store = [[] for _ in range(51)] mem = [(-1, -1)]*(51) for i in range(1, 51): for j in range(1, 51): if gcd(i, j)==1: store[i].append(j) for u, v in edges: g[u].append(v) g[v].append(u) def dfs(u, last, level): ret[u] = max(mem[i] for i in store[nums[u]])[1] tmp = mem[nums[u]] mem[nums[u]] = (level, u) for son in g[u]: if son==last: continue dfs(son, u, level+1) mem[nums[u]] = tmp dfs(0, -1, 0) return ret 924. 尽量减少恶意软件的传播 题目大意：给定一个由n个节点组成的网络，用n x n个邻接矩阵图graph表示。节点之间存在直接连接当且仅当graph[i][j] = 1。一些节点initial最初被恶意软件感染，如果两个节点直接连接且至少一个节点被感染，则两个节点都将被感染。移除一个节点后，返回使得整个网络中感染恶意软件的最终节点数最小的节点，若有多个节点满足条件，则返回索引最小的节点。\n实现思路：首先使用并查集将节点分组，然后计算每个分组的大小和其中感染节点的数量。遍历initial列表，找到使得其所在分组中只有一个感染节点且分组大小最大的节点，返回其索引。\nclass Solution: def minMalwareSpread(self, g: List[List[int]], initial: List[int]) -\u003e int: n, m = len(g), len(initial) f = [i for i in range(n)] size = [1 for _ in range(n)] # 连通块内的点数 num = [0 for _ in range(n)] # 连通块内的感染点数 for x in initial: num[x]=1 def find(x): if f[x] != x: f[x] = find(f[x]) return f[x] for i in range(n): for j in range(i+1, n): if g[i][j]: fi, fj = find(i), find(j) if fi!=fj: f[fi] = fj num[fj] += num[fi] size[fj] += size[fi] ma = -1 initial.sort() idx = initial[0] for x in initial: if num[find(x)]==1 and size[find(x)]\u003ema: ma = size[find(x)] idx = x return idx 928. 尽量减少恶意软件的传播 II 题目大意：给定一个由n个节点组成的网络，用n x n个邻接矩阵graph表示。节点之间存在直接连接当且仅当graph[i][j] = 1。一些节点initial最初被恶意软件感染，如果两个节点直接连接且至少一个节点被感染，则两个节点都将被感染。移除一个节点及其连接后，返回移除后能使整个网络中感染恶意软件的最终节点数最小的节点，若有多个节点满足条件，则返回索引最小的节点。\n实现思路：首先通过并查集将不在initial中的节点进行合并，然后计算每个initial节点的直接感染节点数。最后选择使得感染节点数最小且索引最小的initial节点返回。\nclass Solution: def minMalwareSpread(self, g: List[List[int]], initial: List[int]) -\u003e int: n = len(g) def find(x): if f[x] != x: f[x] = find(f[x]) return f[x] f = [i for i in range(n)] source = [[] for _ in range(n)] cnt = [0]*n init = [0]*n for i in initial: init[i] = 1 for i in range(n): if init[i]: continue for j in range(n): if init[j] or not g[i][j]: continue fi, fj = find(i), find(j) if fi!=fj: f[fi] = fj for x in initial: infected = [0]*n for j in range(n): if not g[x][j] or init[j] or infected[find(j)]: continue infected[find(j)] = 1 for j in range(n): if infected[j]: source[j].append(x) for i in range(n): if len(source[i])==1: root = source[i][0] for j in range(n): if find(i)==find(j): # 是一个连通块 cnt[root]+=1 idx = initial[0] for x in initial: if cnt[x]\u003ecnt[idx] or (cnt[x]==cnt[idx] and x\u003cidx): idx = x return idx 2007. 从双倍数组中还原原数组 题目大意：给定一个数组 changed，通过以下方式构造原始数组 original：将 changed 中的每个元素乘以2，并将结果随机打乱，然后返回原始数组 original。如果无法构造原始数组，则返回空数组。\n实现思路：首先判断数组 changed 的长度是否为偶数，如果不是偶数，则无法构造原始数组，直接返回空数组。接着使用一个字典记录数组 changed 中各个元素的出现次数。然后遍历数组 changed，对于每个元素 i，判断是否存在 i 的两倍的元素，若存在，则将 i 和其两倍的元素都从字典中减去一个，并将 i 加入结果数组中。最后判断结果数组的长度是否达到了原始数组的一半，如果达到了则返回结果数组的前一半，否则返回空数组。\nclass Solution: def findOriginalArray(self, changed: List[int]) -\u003e List[int]: n = len(changed) if n\u00261: return [] d = defaultdict(int) res = [] cnt = 0 changed.sort() for i in changed: d[i]+=1 for i in changed: if not d[i]: continue x = i*2 if i==x: # 0*2 = 0 d[x]-=1 if d[x]: d[x]-=1 # 匹配成功 cnt+=1 res.append(i) else: if d[x]: d[x]-=1 # 匹配成功 d[i]-=1 cnt+=1 res.append(i) if cnt\u003e=n//2: return res[:n//2] return [] 实现思路：首先使用 Counter 统计数组 changed 中各个元素的出现次数。然后将字典中键为 0 的元素（如果存在）弹出，因为原始数组中不可能有 0。接着判断字典中键为 0 的元素出现次数是否为偶数，如果不是偶数则无法构造原始数组，直接返回空数组。然后初始化一个由 0 组成的数组 ans，长度为 cnt_0 的一半。接下来遍历字典中的键值对，对于每个键 x，判断是否存在其一半的键值对，并将 x 加入结果数组 ans 中相应次数。最后返回结果数组 ans。\nclass Solution: def findOriginalArray(self, changed: List[int]) -\u003e List[int]: cnt = Counter(changed) cnt_0 = cnt.pop(0, 0) if cnt_0\u00261: return [] ans = [0]*(cnt_0//2) for x in cnt: if x%2==0 and cnt[x//2]: continue while x in cnt: if cnt[2*x]\u003ccnt[x]: return [] ans.extend([x]*(cnt[x])) if cnt[2*x]\u003ecnt[x]: cnt[2*x]-=cnt[x] x*=2 else: x*=4 return ans 1883. 准时抵达会议现场的最小跳过休息次数 题目大意：题目给出了一组道路的长度和行驶速度，以及剩余可用时间。要求计算在给定的时间内，最少跳过休息次数，以准时抵达会议现场。\n实现思路：动态规划。使用二维数组dp[i][j]表示到达第i条路，跳过j次休息的最小距离。初始化dp数组，然后遍历每一条路，在遍历的过程中更新dp数组。最后检查是否有方案可以在规定时间内到达会议现场，如果有，返回跳过休息的最小次数，否则返回-1。\nclass Solution: def minSkips(self, dist: List[int], speed: int, hoursBefore: int) -\u003e int: n = len(dist) if sum(dist) \u003e hoursBefore * speed: return -1 dp = [[inf] * (n + 1) for _ in range(n + 1)] dp[0][0] = 0 for i in range(1, n): for j in range(i+1): # 到第i条路，跳过次数为j的最小距离 # 不跳过第 i 条路 dp[i][j] = min(dp[i][j], (dp[i-1][j] + dist[i-1] + speed -1)//speed*speed) # 跳过第 i 条路 if j: dp[i][j] = min(dp[i][j], dp[i - 1][j -1] + dist[i-1]) for j in range(n): # 可以跳0~n-1次(最后一条边不用跳) if dp[n-1][j]+dist[-1] \u003c= hoursBefore * speed: return j return -1 39. 组合总和 题目大意 ：给定一个无重复元素的整数数组 candidates 和一个目标整数 target，找出 candidates 中可以使数字和为目标数 target 的所有不同组合，并以列表形式返回。可以无限制重复选择 candidates 中的同一个数字。\n实现思路 ：\n使用深度优先搜索（DFS）进行组合搜索。 定义一个辅助函数 dfs(i, s)，其中 i 表示当前遍历到的 candidates 数组的索引，s 表示当前已经选取的数字的和。 在 dfs 函数中，如果 s 大于等于 target 或者已经遍历到数组末尾，则进行以下判断： 如果 s 等于 target，则将当前的组合 ls 加入结果列表 ret 中。 如果 s 大于 target 或者已经遍历到数组末尾，则直接返回。 在 dfs 函数中，分别尝试两种情况： 不选择当前数字，继续向后搜索：dfs(i+1, s)。 选择当前数字，继续向后搜索：将当前数字加入组合 ls 中，更新 s，并递归调用 dfs(i, s+c[i])。 在递归调用之后，需要将当前选择的数字从组合 ls 中弹出，保证不影响后续搜索。 最终返回结果列表 ret。 class Solution: def combinationSum(self, c: List[int], t: int) -\u003e List[List[int]]: n = len(c) ret, ls = [], [] def dfs(i, s): if s\u003e=t or i==n: if s==t: ret.append(ls[:]) return dfs(i+1, s) ls.append(c[i]) dfs(i, s+c[i]) ls.pop() dfs(0, 0) return ret 216. 组合总和 III 题目大意：找出所有相加之和为n的k个数的组合，要求使用数字1到9，每个数字最多使用一次，返回所有可能的有效组合的列表。列表不能包含相同的组合两次，组合可以以任何顺序返回。\n实现思路：使用深度优先搜索（DFS）的方法，从1到9的数字中进行遍历，每次选择一个数字或不选择，直到满足条件为止。递归过程中，维护一个列表ls，记录当前已选数字的集合，如果当前集合的数字个数等于k且它们的和等于n，则将其加入结果列表ret中。\nclass Solution: def combinationSum3(self, k: int, n: int) -\u003e List[List[int]]: ret, ls = [], [] def dfs(i, s, cnt): if i==10 or s\u003e=n or cnt\u003e=k: if s==n and cnt==k: ret.append(ls[:]) return dfs(i+1, s, cnt) ls.append(i) dfs(i+1, s+i, cnt+1) ls.pop() dfs(1, 0, 0) return ret 377. 组合总和 Ⅳ 题目大意：给定一个由不同整数组成的数组nums和一个目标整数target，要求从nums中找出总和为target的元素组合的个数。\n实现思路：这是一个典型的动态规划问题。使用递归+记忆化搜索（Memoization）的方法来解决。定义dfs函数，参数为当前的和s，函数返回当前和s能够组成的组合数目。递归的终止条件是当前和s大于等于目标target，则返回1（如果s等于target，则表示找到一种组合）。否则，遍历数组nums中的每个数，对每个数进行递归调用dfs(s+i)，累加得到的组合数目。使用cache装饰器对dfs函数进行记忆化搜索，避免重复计算。最终返回dfs(0)，即从初始和为0开始的组合数目。\nclass Solution: def combinationSum4(self, nums: List[int], target: int) -\u003e int: @cache def dfs(s): if s\u003e=target: if s==target: return 1 return 0 cnt = 0 for i in nums: cnt += dfs(s+i) return cnt return dfs(0) ",
  "wordCount" : "5131",
  "inLanguage": "zh",
  "datePublished": "2024-04-17T15:37:01+08:00",
  "dateModified": "2024-04-22T15:37:01+08:00",
  "author":{
    "@type": "Person",
    "name": "ShowGuan"
  },
  "mainEntityOfPage": {
    "@type": "WebPage",
    "@id": "https://kennems.github.io/posts/tech/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98202404/"
  },
  "publisher": {
    "@type": "Organization",
    "name": "Kennem's Blog",
    "logo": {
      "@type": "ImageObject",
      "url": "https://kennems.github.io/img/sun.png"
    }
  }
}
</script>
<script src="https://cdn.jsdelivr.net/npm/jquery@3.5.1/dist/jquery.min.js"></script>
<link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.css" />
<script src="https://cdn.jsdelivr.net/gh/fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.js"></script>




</head>

<body class="" id="top">
<script>
    if (localStorage.getItem("pref-theme") === "dark") {
        document.body.classList.add('dark');
    } else if (localStorage.getItem("pref-theme") === "light") {
        document.body.classList.remove('dark')
    } else if (window.matchMedia('(prefers-color-scheme: dark)').matches) {
        document.body.classList.add('dark');
    }

</script>

<header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="https://kennems.github.io/" accesskey="h" title="Kennem&#39;s Blog (Alt + H)">
                <img src="https://kennems.github.io/img/sun.png" alt="" aria-label="logo"
                    height="35">Kennem&#39;s Blog</a>
            <div class="logo-switches">
                <button id="theme-toggle" accesskey="t" title="(Alt + T)">
                    <svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
                    </svg>
                    <svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <circle cx="12" cy="12" r="5"></circle>
                        <line x1="12" y1="1" x2="12" y2="3"></line>
                        <line x1="12" y1="21" x2="12" y2="23"></line>
                        <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                        <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                        <line x1="1" y1="12" x2="3" y2="12"></line>
                        <line x1="21" y1="12" x2="23" y2="12"></line>
                        <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                        <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
                    </svg>
                </button>
            </div>
        </div>
        <ul id="menu">
            <li>
                <a href="https://kennems.github.io/" title="🏠主页">
                    <span>🏠主页</span>
                </a>
            </li>
            <li>
                <a href="https://kennems.github.io/search" title="🔍搜索 (Alt &#43; /)" accesskey=/>
                    <span>🔍搜索</span>
                </a>
            </li>
            <li>
                <a href="https://kennems.github.io/posts" title="📚文章">
                    <span>📚文章</span>
                </a>
            </li>
            <li>
                <a href="https://kennems.github.io/archives" title="⏱时间轴">
                    <span>⏱时间轴</span>
                </a>
            </li>
            <li>
                <a href="https://kennems.github.io/tags" title="🔖标签">
                    <span>🔖标签</span>
                </a>
            </li>
            <li>
                <a href="https://kennems.github.io/categories" title="🗂️分类">
                    <span>🗂️分类</span>
                </a>
            </li>
            <li>
                <a href="https://kennems.github.io/about" title="🙋🏻‍♂️关于">
                    <span>🙋🏻‍♂️关于</span>
                </a>
            </li>
        </ul>
    </nav>
</header>
<main class="main">

<article class="post-single">
  <header class="post-header">
    <div class="breadcrumbs"><a href="https://kennems.github.io/">主页</a>&nbsp;»&nbsp;<a href="https://kennems.github.io/posts/">📚文章</a>&nbsp;»&nbsp;<a href="https://kennems.github.io/posts/tech/">💻技术</a></div>
    <h1 class="post-title entry-hint-parent">
      LeetCode每日一题（202404）
    </h1>
    <div class="post-description">
      每日一题（202404）
    </div>
    <div class="post-meta"><span title='2024-04-17 15:37:01 +0800 CST'>2024-04-17</span>&nbsp;·&nbsp;11 分钟&nbsp;·&nbsp;5131 字&nbsp;·&nbsp;updated:&nbsp;2024-04-22&nbsp;·&nbsp;ShowGuan

</div>
    
     <div class="post-password">
        
    </div>
  </header> <aside id="toc-container" class="toc-container wide">
    <div class="toc">
        <details  open>
            <summary accesskey="c" title="(Alt + C)">
                <span class="details">目录</span>
            </summary>

            <div class="inner"><ul>
                    <li>
                        <a href="#%e6%af%8f%e6%97%a5%e4%b8%80%e9%a2%98202404" aria-label="每日一题（202404）">每日一题（202404）</a><ul>
                            <ul>
                            
                    <li>
                        <a href="#2009-%e4%bd%bf%e6%95%b0%e7%bb%84%e8%bf%9e%e7%bb%ad%e7%9a%84%e6%9c%80%e5%b0%91%e6%93%8d%e4%bd%9c%e6%95%b0httpsleetcodecnproblemsminimum-number-of-operations-to-make-array-continuous" aria-label="2009. 使数组连续的最少操作数"><a href="https://leetcode.cn/problems/minimum-number-of-operations-to-make-array-continuous/">2009. 使数组连续的最少操作数</a></a></li>
                    <li>
                        <a href="#1600-%e7%8e%8b%e4%bd%8d%e7%bb%a7%e6%89%bf%e9%a1%ba%e5%ba%8fhttpsleetcodecnproblemsthrone-inheritance" aria-label="1600. 王位继承顺序"><a href="https://leetcode.cn/problems/throne-inheritance/">1600. 王位继承顺序</a></a></li>
                    <li>
                        <a href="#1483-%e6%a0%91%e8%8a%82%e7%82%b9%e7%9a%84%e7%ac%ac-k-%e4%b8%aa%e7%a5%96%e5%85%88httpsleetcodecnproblemskth-ancestor-of-a-tree-node" aria-label="1483. 树节点的第 K 个祖先"><a href="https://leetcode.cn/problems/kth-ancestor-of-a-tree-node/">1483. 树节点的第 K 个祖先</a></a></li>
                    <li>
                        <a href="#%e9%9d%a2%e8%af%95%e9%a2%98-0812-%e5%85%ab%e7%9a%87%e5%90%8ehttpsleetcodecnproblemseight-queens-lcci" aria-label="面试题 08.12. 八皇后"><a href="https://leetcode.cn/problems/eight-queens-lcci/">面试题 08.12. 八皇后</a></a></li>
                    <li>
                        <a href="#1702-%e4%bf%ae%e6%94%b9%e5%90%8e%e7%9a%84%e6%9c%80%e5%a4%a7%e4%ba%8c%e8%bf%9b%e5%88%b6%e5%ad%97%e7%ac%a6%e4%b8%b2httpsleetcodecnproblemsmaximum-binary-string-after-change" aria-label="1702. 修改后的最大二进制字符串"><a href="https://leetcode.cn/problems/maximum-binary-string-after-change/">1702. 修改后的最大二进制字符串</a></a></li>
                    <li>
                        <a href="#24-%e4%b8%a4%e4%b8%a4%e4%ba%a4%e6%8d%a2%e9%93%be%e8%a1%a8%e4%b8%ad%e7%9a%84%e8%8a%82%e7%82%b9httpsleetcodecnproblemsswap-nodes-in-pairs" aria-label="24. 两两交换链表中的节点"><a href="https://leetcode.cn/problems/swap-nodes-in-pairs/">24. 两两交换链表中的节点</a></a></li>
                    <li>
                        <a href="#25-k-%e4%b8%aa%e4%b8%80%e7%bb%84%e7%bf%bb%e8%bd%ac%e9%93%be%e8%a1%a8httpsleetcodecnproblemsreverse-nodes-in-k-group" aria-label="25. K 个一组翻转链表"><a href="https://leetcode.cn/problems/reverse-nodes-in-k-group/">25. K 个一组翻转链表</a></a></li>
                    <li>
                        <a href="#1766-%e4%ba%92%e8%b4%a8%e6%a0%91httpsleetcodecnproblemstree-of-coprimes" aria-label="1766. 互质树"><a href="https://leetcode.cn/problems/tree-of-coprimes/">1766. 互质树</a></a></li>
                    <li>
                        <a href="#924-%e5%b0%bd%e9%87%8f%e5%87%8f%e5%b0%91%e6%81%b6%e6%84%8f%e8%bd%af%e4%bb%b6%e7%9a%84%e4%bc%a0%e6%92%adhttpsleetcodecnproblemsminimize-malware-spread" aria-label="924. 尽量减少恶意软件的传播"><a href="https://leetcode.cn/problems/minimize-malware-spread/">924. 尽量减少恶意软件的传播</a></a></li>
                    <li>
                        <a href="#928-%e5%b0%bd%e9%87%8f%e5%87%8f%e5%b0%91%e6%81%b6%e6%84%8f%e8%bd%af%e4%bb%b6%e7%9a%84%e4%bc%a0%e6%92%ad-iihttpsleetcodecnproblemsminimize-malware-spread-ii" aria-label="928. 尽量减少恶意软件的传播 II"><a href="https://leetcode.cn/problems/minimize-malware-spread-ii/">928. 尽量减少恶意软件的传播 II</a></a></li>
                    <li>
                        <a href="#2007-%e4%bb%8e%e5%8f%8c%e5%80%8d%e6%95%b0%e7%bb%84%e4%b8%ad%e8%bf%98%e5%8e%9f%e5%8e%9f%e6%95%b0%e7%bb%84httpsleetcodecnproblemsfind-original-array-from-doubled-array" aria-label="2007. 从双倍数组中还原原数组"><a href="https://leetcode.cn/problems/find-original-array-from-doubled-array/">2007. 从双倍数组中还原原数组</a></a></li>
                    <li>
                        <a href="#1883-%e5%87%86%e6%97%b6%e6%8a%b5%e8%be%be%e4%bc%9a%e8%ae%ae%e7%8e%b0%e5%9c%ba%e7%9a%84%e6%9c%80%e5%b0%8f%e8%b7%b3%e8%bf%87%e4%bc%91%e6%81%af%e6%ac%a1%e6%95%b0httpsleetcodecnproblemsminimum-skips-to-arrive-at-meeting-on-time" aria-label="1883. 准时抵达会议现场的最小跳过休息次数"><a href="https://leetcode.cn/problems/minimum-skips-to-arrive-at-meeting-on-time/">1883. 准时抵达会议现场的最小跳过休息次数</a></a></li>
                    <li>
                        <a href="#39-%e7%bb%84%e5%90%88%e6%80%bb%e5%92%8chttpsleetcodecnproblemscombination-sum" aria-label="39. 组合总和"><a href="https://leetcode.cn/problems/combination-sum/">39. 组合总和</a></a></li>
                    <li>
                        <a href="#216-%e7%bb%84%e5%90%88%e6%80%bb%e5%92%8c-iiihttpsleetcodecnproblemscombination-sum-iii" aria-label="216. 组合总和 III"><a href="https://leetcode.cn/problems/combination-sum-iii/">216. 组合总和 III</a></a></li>
                    <li>
                        <a href="#377-%e7%bb%84%e5%90%88%e6%80%bb%e5%92%8c-httpsleetcodecnproblemscombination-sum-iv" aria-label="377. 组合总和 Ⅳ"><a href="https://leetcode.cn/problems/combination-sum-iv/">377. 组合总和 Ⅳ</a></a>
                    </li>
                </ul>
                </ul>
                </li>
                </ul>
            </div>
        </details>
    </div>
</aside>
<script>
    let activeElement;
    let elements;
    window.addEventListener('DOMContentLoaded', function (event) {
        checkTocPosition();

        elements = document.querySelectorAll('h1[id],h2[id],h3[id],h4[id],h5[id],h6[id]');
         
         activeElement = elements[0];
         const id = encodeURI(activeElement.getAttribute('id')).toLowerCase();
         document.querySelector(`.inner ul li a[href="#${id}"]`).classList.add('active');
     }, false);

    window.addEventListener('resize', function(event) {
        checkTocPosition();
    }, false);

    window.addEventListener('scroll', () => {
        
        activeElement = Array.from(elements).find((element) => {
            if ((getOffsetTop(element) - window.pageYOffset) > 0 && 
                (getOffsetTop(element) - window.pageYOffset) < window.innerHeight/2) {
                return element;
            }
        }) || activeElement

        elements.forEach(element => {
             const id = encodeURI(element.getAttribute('id')).toLowerCase();
             if (element === activeElement){
                 document.querySelector(`.inner ul li a[href="#${id}"]`).classList.add('active');
             } else {
                 document.querySelector(`.inner ul li a[href="#${id}"]`).classList.remove('active');
             }
         })
     }, false);

    const main = parseInt(getComputedStyle(document.body).getPropertyValue('--article-width'), 10);
    const toc = parseInt(getComputedStyle(document.body).getPropertyValue('--toc-width'), 10);
    const gap = parseInt(getComputedStyle(document.body).getPropertyValue('--gap'), 10);

    function checkTocPosition() {
        const width = document.body.scrollWidth;

        if (width - main - (toc * 2) - (gap * 4) > 0) {
            document.getElementById("toc-container").classList.add("wide");
        } else {
            document.getElementById("toc-container").classList.remove("wide");
        }
    }

    function getOffsetTop(element) {
        if (!element.getClientRects().length) {
            return 0;
        }
        let rect = element.getBoundingClientRect();
        let win = element.ownerDocument.defaultView;
        return rect.top + win.pageYOffset;   
    }
</script>

  <div class="post-content"><h1 id="每日一题202404">每日一题（202404）<a hidden class="anchor" aria-hidden="true" href="#每日一题202404">#</a></h1>
<h3 id="2009-使数组连续的最少操作数httpsleetcodecnproblemsminimum-number-of-operations-to-make-array-continuous"><a href="https://leetcode.cn/problems/minimum-number-of-operations-to-make-array-continuous/">2009. 使数组连续的最少操作数</a><a hidden class="anchor" aria-hidden="true" href="#2009-使数组连续的最少操作数httpsleetcodecnproblemsminimum-number-of-operations-to-make-array-continuous">#</a></h3>
<ul>
<li>
<p><strong>题意</strong>：给定一个可能有重复元素的数组，可以修改数组中值为任意其他值，问使数组连续的最小操作数。</p>
</li>
<li>
<p><strong>思路</strong>：由于只能改动元素，所以最后的元素个数不变，去重后，枚举每个值作为左端点，则右端点为<code>nums[i]+n-1</code>, 用双指针计算在区间内的元素个数即为可以保留的数字，其他数字修改元素值填满空隙即可。</p>
</li>
</ul>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-py" data-lang="py"><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Solution</span>:
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">def</span> <span style="color:#a6e22e">minOperations</span>(self, nums: List[int]) <span style="color:#f92672">-&gt;</span> int:
</span></span><span style="display:flex;"><span>        n <span style="color:#f92672">=</span> len(nums)
</span></span><span style="display:flex;"><span>        nums <span style="color:#f92672">=</span> sorted(set(nums))
</span></span><span style="display:flex;"><span>        j, ans <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>, <span style="color:#ae81ff">0</span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">for</span> i <span style="color:#f92672">in</span> range(len(nums)):
</span></span><span style="display:flex;"><span>            right <span style="color:#f92672">=</span> nums[i]<span style="color:#f92672">+</span> n<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">if</span> len(nums)<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span> <span style="color:#f92672">-</span> i <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span> <span style="color:#f92672">&lt;=</span> ans:
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">break</span>
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">while</span> j<span style="color:#f92672">&lt;</span>len(nums) <span style="color:#f92672">and</span> nums[j]<span style="color:#f92672">&lt;=</span>right:
</span></span><span style="display:flex;"><span>                j<span style="color:#f92672">+=</span><span style="color:#ae81ff">1</span>
</span></span><span style="display:flex;"><span>            ans <span style="color:#f92672">=</span> max(ans, j<span style="color:#f92672">-</span>i)
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> n<span style="color:#f92672">-</span>ans
</span></span></code></pre></div><h3 id="1600-王位继承顺序httpsleetcodecnproblemsthrone-inheritance"><a href="https://leetcode.cn/problems/throne-inheritance/">1600. 王位继承顺序</a><a hidden class="anchor" aria-hidden="true" href="#1600-王位继承顺序httpsleetcodecnproblemsthrone-inheritance">#</a></h3>
<ul>
<li>
<p><strong>题意</strong>：国王继承次序按嫡长子次序，实现<code>ThroneInheritance(string kingName)</code>初始化,<code>void birth(string parentName, string childName)</code> 出生，<code>void death(string name)</code>人死亡，<code>string[] getInheritanceOrder()</code> 返回 <strong>除去</strong> 死亡人员的当前继承顺序列表。</p>
</li>
<li>
<p><strong>思路</strong>：类似树形结构，国王先继承，之后是国王的长子，之后是长子的长子， 如果不存在则为国王的次子以此类推， 所以可以用<code>defaultdict()</code>存储每个的儿子情况，然后查询时，先将自己入结果列表，然后是第一个儿子&hellip;；并记录每个人的存活情况，排除掉已经死掉的人。</p>
</li>
</ul>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-py" data-lang="py"><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">ThroneInheritance</span>:
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">def</span> __init__(self, kingName: str):
</span></span><span style="display:flex;"><span>        self<span style="color:#f92672">.</span>son <span style="color:#f92672">=</span> defaultdict(list)
</span></span><span style="display:flex;"><span>        self<span style="color:#f92672">.</span>die <span style="color:#f92672">=</span> set()
</span></span><span style="display:flex;"><span>        self<span style="color:#f92672">.</span>king <span style="color:#f92672">=</span> kingName
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">def</span> <span style="color:#a6e22e">birth</span>(self, parentName: str, childName: str) <span style="color:#f92672">-&gt;</span> <span style="color:#66d9ef">None</span>:
</span></span><span style="display:flex;"><span>        self<span style="color:#f92672">.</span>son[parentName]<span style="color:#f92672">.</span>append(childName)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">def</span> <span style="color:#a6e22e">death</span>(self, name: str) <span style="color:#f92672">-&gt;</span> <span style="color:#66d9ef">None</span>:
</span></span><span style="display:flex;"><span>        self<span style="color:#f92672">.</span>die<span style="color:#f92672">.</span>add(name)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">def</span> <span style="color:#a6e22e">getInheritanceOrder</span>(self) <span style="color:#f92672">-&gt;</span> List[str]:
</span></span><span style="display:flex;"><span>        ret <span style="color:#f92672">=</span> []
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">def</span> <span style="color:#a6e22e">dfs</span>(root):
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">if</span> root <span style="color:#f92672">not</span> <span style="color:#f92672">in</span> self<span style="color:#f92672">.</span>die:
</span></span><span style="display:flex;"><span>                ret<span style="color:#f92672">.</span>append(root)
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">for</span> child <span style="color:#f92672">in</span> self<span style="color:#f92672">.</span>son[root]:
</span></span><span style="display:flex;"><span>                dfs(child)
</span></span><span style="display:flex;"><span>        dfs(self<span style="color:#f92672">.</span>king)
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> ret
</span></span></code></pre></div><h3 id="1483-树节点的第-k-个祖先httpsleetcodecnproblemskth-ancestor-of-a-tree-node"><a href="https://leetcode.cn/problems/kth-ancestor-of-a-tree-node/">1483. 树节点的第 K 个祖先</a><a hidden class="anchor" aria-hidden="true" href="#1483-树节点的第-k-个祖先httpsleetcodecnproblemskth-ancestor-of-a-tree-node">#</a></h3>
<ul>
<li>
<p><strong>题意</strong>：给定n个点(<code>0~n-1</code>)每个点的父亲节点，快速查询每个节点的第k个祖宗节点。</p>
</li>
<li>
<p><strong>思路</strong>：LCA倍增原理，$ancestor[j][i] = ancestor[ ancestor[j][i-1] ][i-1]$ 节点j的第$2^i$个祖宗节点为节点第$2^{i-1}$个祖宗的第$2^{i-1}$个祖宗，即$2^{i-1}*2$个祖宗节点， 所以先预处理好每个节点的各个二进制位上的祖宗节点是谁，之后分解二进制位据可以得知任意第k个祖宗节点是谁。</p>
</li>
</ul>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-py" data-lang="py"><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">TreeAncestor</span>:
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">def</span> __init__(self, n: int, parent: List[int]):
</span></span><span style="display:flex;"><span>        self<span style="color:#f92672">.</span>level <span style="color:#f92672">=</span> <span style="color:#ae81ff">16</span>
</span></span><span style="display:flex;"><span>        self<span style="color:#f92672">.</span>ancestor <span style="color:#f92672">=</span> [[<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>]<span style="color:#f92672">*</span>self<span style="color:#f92672">.</span>level <span style="color:#66d9ef">for</span> _ <span style="color:#f92672">in</span> range(n)]
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">for</span> i <span style="color:#f92672">in</span> range(<span style="color:#ae81ff">1</span>, n):
</span></span><span style="display:flex;"><span>            self<span style="color:#f92672">.</span>ancestor[i][<span style="color:#ae81ff">0</span>] <span style="color:#f92672">=</span> parent[i]
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">for</span> i <span style="color:#f92672">in</span> range(<span style="color:#ae81ff">1</span>, self<span style="color:#f92672">.</span>level):
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">for</span> j <span style="color:#f92672">in</span> range(<span style="color:#ae81ff">1</span>, n):
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">if</span> self<span style="color:#f92672">.</span>ancestor[j][i<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>]<span style="color:#f92672">!=-</span><span style="color:#ae81ff">1</span>:
</span></span><span style="display:flex;"><span>                    self<span style="color:#f92672">.</span>ancestor[j][i] <span style="color:#f92672">=</span> self<span style="color:#f92672">.</span>ancestor[ self<span style="color:#f92672">.</span>ancestor[j][i<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>] ][i<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>]
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">def</span> <span style="color:#a6e22e">getKthAncestor</span>(self, node: int, k: int) <span style="color:#f92672">-&gt;</span> int:
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">while</span> k:
</span></span><span style="display:flex;"><span>            t <span style="color:#f92672">=</span> k<span style="color:#f92672">&amp;-</span>k
</span></span><span style="display:flex;"><span>            k <span style="color:#f92672">-=</span> t
</span></span><span style="display:flex;"><span>            t <span style="color:#f92672">=</span> t<span style="color:#f92672">.</span>bit_length()<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>
</span></span><span style="display:flex;"><span>            node <span style="color:#f92672">=</span> self<span style="color:#f92672">.</span>ancestor[node][t]
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">if</span> node<span style="color:#f92672">==-</span><span style="color:#ae81ff">1</span>:
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">return</span> <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> node
</span></span></code></pre></div><h3 id="面试题-0812-八皇后httpsleetcodecnproblemseight-queens-lcci"><a href="https://leetcode.cn/problems/eight-queens-lcci/">面试题 08.12. 八皇后</a><a hidden class="anchor" aria-hidden="true" href="#面试题-0812-八皇后httpsleetcodecnproblemseight-queens-lcci">#</a></h3>
<p><strong>题目大意</strong>：</p>
<p>这道题目是经典的八皇后问题的扩展，需要设计一个算法来打印 N 皇后在 N × N 棋盘上的各种摆法，其中每个皇后都不在同一行、同一列，也不在任何对角线上。</p>
<p><strong>实现思路：</strong></p>
<ol>
<li>
<p><strong>回溯算法</strong>：</p>
<ul>
<li>使用回溯算法来尝试所有可能的皇后摆放方式。</li>
<li>从第一行开始，依次尝试每一列放置皇后，然后继续递归地尝试下一行的放置，直到所有行都放置完毕。</li>
<li>在递归过程中，通过检查每个位置的列、主对角线和副对角线是否已经存在皇后来确定是否可以放置皇后。</li>
</ul>
</li>
<li>
<p><strong>生成棋盘</strong>：</p>
<ul>
<li>当确定了一种合法的皇后摆放方式时，将其转换为棋盘的形式，并将其添加到结果列表中。</li>
<li>对于每行中皇后的位置，用 &lsquo;Q&rsquo; 表示，其他位置用 &lsquo;.&rsquo; 表示。</li>
</ul>
</li>
<li>
<p><strong>辅助函数</strong>：</p>
<ul>
<li><code>solve</code>: 递归函数，尝试在每行放置皇后。</li>
<li><code>generate</code>: 将合法的皇后摆放方式转换为棋盘形式并添加到结果列表中。</li>
</ul>
</li>
<li>
<p><strong>剪枝优化</strong>：</p>
<ul>
<li>使用位运算来表示列、主对角线和副对角线的占用情况，可以快速判断某个位置是否可以放置皇后，从而提高效率。</li>
<li>在每次递归时，利用位运算进行剪枝，排除不可能的位置。</li>
</ul>
</li>
</ol>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-py" data-lang="py"><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Solution</span>:
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">def</span> <span style="color:#a6e22e">solveNQueens</span>(self, n: int) <span style="color:#f92672">-&gt;</span> List[List[str]]:
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">def</span> <span style="color:#a6e22e">generate</span>():
</span></span><span style="display:flex;"><span>            board <span style="color:#f92672">=</span> []
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">for</span> r <span style="color:#f92672">in</span> range(n):
</span></span><span style="display:flex;"><span>                c <span style="color:#f92672">=</span> pos[r]
</span></span><span style="display:flex;"><span>                row[c] <span style="color:#f92672">=</span> <span style="color:#e6db74">&#39;Q&#39;</span>
</span></span><span style="display:flex;"><span>                board<span style="color:#f92672">.</span>append(<span style="color:#e6db74">&#34;&#34;</span><span style="color:#f92672">.</span>join(row))
</span></span><span style="display:flex;"><span>                row[c] <span style="color:#f92672">=</span> <span style="color:#e6db74">&#39;.&#39;</span>
</span></span><span style="display:flex;"><span>            ret<span style="color:#f92672">.</span>append(board)
</span></span><span style="display:flex;"><span>        
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">def</span> <span style="color:#a6e22e">solve</span>(row, column, diag1, diag2):
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">if</span> row<span style="color:#f92672">==</span>n:
</span></span><span style="display:flex;"><span>                generate()
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">else</span>:
</span></span><span style="display:flex;"><span>                avail <span style="color:#f92672">=</span> ( (<span style="color:#ae81ff">1</span><span style="color:#f92672">&lt;&lt;</span>n)<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>) <span style="color:#f92672">&amp;</span> ( <span style="color:#f92672">~</span>(column<span style="color:#f92672">|</span>diag1<span style="color:#f92672">|</span>diag2) )
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">while</span> avail:
</span></span><span style="display:flex;"><span>                    colPos <span style="color:#f92672">=</span> avail<span style="color:#f92672">&amp;</span>(<span style="color:#f92672">-</span>avail)
</span></span><span style="display:flex;"><span>                    avail <span style="color:#f92672">-=</span> colPos
</span></span><span style="display:flex;"><span>                    colNum <span style="color:#f92672">=</span> bin(colPos<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>)<span style="color:#f92672">.</span>count(<span style="color:#e6db74">&#34;1&#34;</span>)
</span></span><span style="display:flex;"><span>                    pos[row]<span style="color:#f92672">=</span>colNum
</span></span><span style="display:flex;"><span>                    solve(row<span style="color:#f92672">+</span><span style="color:#ae81ff">1</span>, column<span style="color:#f92672">|</span>colPos, (diag1<span style="color:#f92672">|</span>colPos)<span style="color:#f92672">&lt;&lt;</span><span style="color:#ae81ff">1</span>, (diag2<span style="color:#f92672">|</span>colPos)<span style="color:#f92672">&gt;&gt;</span><span style="color:#ae81ff">1</span>)
</span></span><span style="display:flex;"><span>        
</span></span><span style="display:flex;"><span>        pos <span style="color:#f92672">=</span> [<span style="color:#ae81ff">0</span>]<span style="color:#f92672">*</span>n 
</span></span><span style="display:flex;"><span>        ret <span style="color:#f92672">=</span> []
</span></span><span style="display:flex;"><span>        row <span style="color:#f92672">=</span> [<span style="color:#e6db74">&#39;.&#39;</span>]<span style="color:#f92672">*</span>n
</span></span><span style="display:flex;"><span>        solve(<span style="color:#ae81ff">0</span>, <span style="color:#ae81ff">0</span>, <span style="color:#ae81ff">0</span>, <span style="color:#ae81ff">0</span>)
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> ret
</span></span></code></pre></div><h3 id="1702-修改后的最大二进制字符串httpsleetcodecnproblemsmaximum-binary-string-after-change"><a href="https://leetcode.cn/problems/maximum-binary-string-after-change/">1702. 修改后的最大二进制字符串</a><a hidden class="anchor" aria-hidden="true" href="#1702-修改后的最大二进制字符串httpsleetcodecnproblemsmaximum-binary-string-after-change">#</a></h3>
<ul>
<li>
<p><strong>题意</strong>：给定一个二进制字符串<code>00-&gt;10, 10-&gt;01</code>问任意次操作后能达到的最大二进制字符串。</p>
</li>
<li>
<p><strong>思路</strong>：构造，根据条件推过程，<code>10-&gt;01</code>可以看作后面的0浮到前面，所有的0聚到一起可以变成<code>10</code>串，所以最后至多只有一个<code>0</code>。根据<strong>构造</strong>来做，统计第一个0的位置和0的个数，最后构造出最后的0的位置；<strong>双指针</strong>来做：遇到0时找到后面第一个0的位置，将其浮到旁边，并换成10。</p>
</li>
</ul>
<p><strong>构造</strong>：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-py" data-lang="py"><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Solution</span>:
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">def</span> <span style="color:#a6e22e">maximumBinaryString</span>(self, binary: str) <span style="color:#f92672">-&gt;</span> str:
</span></span><span style="display:flex;"><span>        cnt <span style="color:#f92672">=</span> binary<span style="color:#f92672">.</span>count(<span style="color:#e6db74">&#39;0&#39;</span>)
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> cnt<span style="color:#f92672">&lt;=</span><span style="color:#ae81ff">1</span>:
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">return</span> binary
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        n <span style="color:#f92672">=</span> len(binary)
</span></span><span style="display:flex;"><span>        ans <span style="color:#f92672">=</span> [<span style="color:#e6db74">&#39;1&#39;</span>]<span style="color:#f92672">*</span>n
</span></span><span style="display:flex;"><span>        index <span style="color:#f92672">=</span> binary<span style="color:#f92672">.</span>index(<span style="color:#e6db74">&#39;0&#39;</span>)
</span></span><span style="display:flex;"><span>        ans[index<span style="color:#f92672">+</span>cnt<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>]<span style="color:#f92672">=</span><span style="color:#e6db74">&#39;0&#39;</span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> <span style="color:#e6db74">&#39;&#39;</span><span style="color:#f92672">.</span>join(ans)
</span></span></code></pre></div><p><strong>双指针</strong>：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-py" data-lang="py"><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Solution</span>:
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">def</span> <span style="color:#a6e22e">maximumBinaryString</span>(self, binary: str) <span style="color:#f92672">-&gt;</span> str:
</span></span><span style="display:flex;"><span>        n <span style="color:#f92672">=</span> len(binary)
</span></span><span style="display:flex;"><span>        s <span style="color:#f92672">=</span> list(binary)
</span></span><span style="display:flex;"><span>        j <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">for</span> i <span style="color:#f92672">in</span> range(n):
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">if</span> s[i]<span style="color:#f92672">==</span><span style="color:#e6db74">&#39;0&#39;</span>:
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">while</span> j<span style="color:#f92672">&lt;=</span>i <span style="color:#f92672">or</span> (j<span style="color:#f92672">&lt;</span>n <span style="color:#f92672">and</span> s[j]<span style="color:#f92672">==</span><span style="color:#e6db74">&#39;1&#39;</span>):
</span></span><span style="display:flex;"><span>                    j<span style="color:#f92672">+=</span><span style="color:#ae81ff">1</span>
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">if</span> j<span style="color:#f92672">&lt;</span>n:
</span></span><span style="display:flex;"><span>                    s[i], s[j], s[i<span style="color:#f92672">+</span><span style="color:#ae81ff">1</span>] <span style="color:#f92672">=</span> <span style="color:#e6db74">&#39;1&#39;</span>, <span style="color:#e6db74">&#39;1&#39;</span>, <span style="color:#e6db74">&#39;0&#39;</span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> <span style="color:#e6db74">&#39;&#39;</span><span style="color:#f92672">.</span>join(s)
</span></span></code></pre></div><h3 id="24-两两交换链表中的节点httpsleetcodecnproblemsswap-nodes-in-pairs"><a href="https://leetcode.cn/problems/swap-nodes-in-pairs/">24. 两两交换链表中的节点</a><a hidden class="anchor" aria-hidden="true" href="#24-两两交换链表中的节点httpsleetcodecnproblemsswap-nodes-in-pairs">#</a></h3>
<ul>
<li>
<p><strong>题意</strong>：给定一个链表，分别两个一组交换相对位置。</p>
</li>
<li>
<p><strong>思路</strong>：链表交换next指针操作，<code>prev-&gt;A-&gt;B-&gt;C</code>变成<code>prev-&gt;B-&gt;A-&gt;C</code>，一共要变三条边。需要记录前面的点，后面的点。</p>
</li>
</ul>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-py" data-lang="py"><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Solution</span>:
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">def</span> <span style="color:#a6e22e">swapPairs</span>(self, head: Optional[ListNode]) <span style="color:#f92672">-&gt;</span> Optional[ListNode]:
</span></span><span style="display:flex;"><span>        dummy <span style="color:#f92672">=</span> head
</span></span><span style="display:flex;"><span>        prev <span style="color:#f92672">=</span> <span style="color:#66d9ef">None</span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">while</span> head <span style="color:#f92672">and</span> head<span style="color:#f92672">.</span>next:
</span></span><span style="display:flex;"><span>            tmp <span style="color:#f92672">=</span> head<span style="color:#f92672">.</span>next<span style="color:#f92672">.</span>next
</span></span><span style="display:flex;"><span>            <span style="color:#75715e">#A-&gt;B 变成 B-&gt;A</span>
</span></span><span style="display:flex;"><span>            nxt <span style="color:#f92672">=</span> head<span style="color:#f92672">.</span>next <span style="color:#75715e">#nxt是B, head是A</span>
</span></span><span style="display:flex;"><span>            
</span></span><span style="display:flex;"><span>            nxt<span style="color:#f92672">.</span>next <span style="color:#f92672">=</span> head 
</span></span><span style="display:flex;"><span>            head<span style="color:#f92672">.</span>next <span style="color:#f92672">=</span> tmp
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">if</span> prev:
</span></span><span style="display:flex;"><span>                prev<span style="color:#f92672">.</span>next <span style="color:#f92672">=</span> nxt
</span></span><span style="display:flex;"><span>                prev <span style="color:#f92672">=</span> nxt<span style="color:#f92672">.</span>next <span style="color:#75715e">#是头节点(即没有前面的点)的时候不需要这一步</span>
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">if</span> dummy<span style="color:#f92672">==</span>head:
</span></span><span style="display:flex;"><span>                dummy <span style="color:#f92672">=</span> nxt
</span></span><span style="display:flex;"><span>                prev <span style="color:#f92672">=</span> nxt<span style="color:#f92672">.</span>next
</span></span><span style="display:flex;"><span>            
</span></span><span style="display:flex;"><span>            head <span style="color:#f92672">=</span> tmp
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> dummy
</span></span></code></pre></div><h3 id="25-k-个一组翻转链表httpsleetcodecnproblemsreverse-nodes-in-k-group"><a href="https://leetcode.cn/problems/reverse-nodes-in-k-group/">25. K 个一组翻转链表</a><a hidden class="anchor" aria-hidden="true" href="#25-k-个一组翻转链表httpsleetcodecnproblemsreverse-nodes-in-k-group">#</a></h3>
<ul>
<li>
<p><strong>题意</strong>：每隔k个数字翻转链表。</p>
</li>
<li>
<p><strong>思路</strong>：链表交换指针操作。</p>
</li>
</ul>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-py" data-lang="py"><span style="display:flex;"><span><span style="color:#75715e"># Definition for singly-linked list.</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># class ListNode:</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">#     def __init__(self, val=0, next=None):</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">#         self.val = val</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">#         self.next = next</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Solution</span>:
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">def</span> <span style="color:#a6e22e">reverseKGroup</span>(self, head: Optional[ListNode], k: int) <span style="color:#f92672">-&gt;</span> Optional[ListNode]:
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">def</span> <span style="color:#a6e22e">reverse</span>(head, tail): <span style="color:#75715e"># A-&gt;B-&gt;C 变成 C-&gt;B-&gt;A</span>
</span></span><span style="display:flex;"><span>            cur <span style="color:#f92672">=</span> tail<span style="color:#f92672">.</span>next
</span></span><span style="display:flex;"><span>            dummy <span style="color:#f92672">=</span> head
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">while</span> cur <span style="color:#f92672">!=</span> tail:
</span></span><span style="display:flex;"><span>                nxt <span style="color:#f92672">=</span> dummy<span style="color:#f92672">.</span>next
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>                dummy<span style="color:#f92672">.</span>next <span style="color:#f92672">=</span> cur
</span></span><span style="display:flex;"><span>                cur <span style="color:#f92672">=</span> dummy
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>                dummy <span style="color:#f92672">=</span> nxt
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">return</span> tail, head <span style="color:#75715e"># 原来的tail和head位置没变，但中间点的指向关系变了</span>
</span></span><span style="display:flex;"><span>        hair <span style="color:#f92672">=</span> ListNode(<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>) <span style="color:#75715e"># 伪头节点</span>
</span></span><span style="display:flex;"><span>        hair<span style="color:#f92672">.</span>next <span style="color:#f92672">=</span> head
</span></span><span style="display:flex;"><span>        pre <span style="color:#f92672">=</span> hair
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">while</span> head:
</span></span><span style="display:flex;"><span>            tail <span style="color:#f92672">=</span> pre
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">for</span> i <span style="color:#f92672">in</span> range(k): <span style="color:#75715e"># 走过k个点</span>
</span></span><span style="display:flex;"><span>                tail <span style="color:#f92672">=</span> tail<span style="color:#f92672">.</span>next
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">if</span> <span style="color:#f92672">not</span> tail:
</span></span><span style="display:flex;"><span>                    <span style="color:#66d9ef">return</span> hair<span style="color:#f92672">.</span>next
</span></span><span style="display:flex;"><span>            head, tail <span style="color:#f92672">=</span> reverse(head, tail)
</span></span><span style="display:flex;"><span>            pre<span style="color:#f92672">.</span>next <span style="color:#f92672">=</span> head <span style="color:#75715e"># pre-&gt;C</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>            pre <span style="color:#f92672">=</span> tail <span style="color:#75715e"># pre变成尾节点</span>
</span></span><span style="display:flex;"><span>            head <span style="color:#f92672">=</span> tail<span style="color:#f92672">.</span>next <span style="color:#75715e"># 头节点变成当前尾节点的下个一个节点</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> hair<span style="color:#f92672">.</span>next
</span></span></code></pre></div><h3 id="1766-互质树httpsleetcodecnproblemstree-of-coprimes"><a href="https://leetcode.cn/problems/tree-of-coprimes/">1766. 互质树</a><a hidden class="anchor" aria-hidden="true" href="#1766-互质树httpsleetcodecnproblemstree-of-coprimes">#</a></h3>
<ul>
<li><strong>题意</strong>：给定一棵树<code>0~n-1</code>共n个节点， 每个节点有一个值，返回每个节点的 最近的 与自己互质的<code>(gcd(a,b)=1)</code> 祖宗节点的编号。值的范围为<code>[1,50]</code></li>
<li><strong>思路</strong>：<code>DFS</code>， 遍历一遍树，维护一个祖宗节点的列表，判断当前节点与祖宗节点的互质关系。但朴素的将所有的祖宗节点都加入列表中，到深层的子节点时会遍历整个列表，会超时。由于值的范围最大为<code>50</code>，所以可以先预处理<code>50</code>范围以内的互质关系，对于每个节点，只需要判断祖宗节点里面有没有这些互质的数即可，但是需要的是最近的祖宗节点，所以还要添加一个深度信息，这样才能保证在相同值的祖宗节点中选择离自己最近的祖宗节点。</li>
</ul>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-py" data-lang="py"><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Solution</span>:
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">def</span> <span style="color:#a6e22e">getCoprimes</span>(self, nums: List[int], edges: List[List[int]]) <span style="color:#f92672">-&gt;</span> List[int]:
</span></span><span style="display:flex;"><span>        n <span style="color:#f92672">=</span> len(nums)
</span></span><span style="display:flex;"><span>        g <span style="color:#f92672">=</span> [[]<span style="color:#f92672">*</span>n <span style="color:#66d9ef">for</span> _ <span style="color:#f92672">in</span> range(n)]
</span></span><span style="display:flex;"><span>        ret <span style="color:#f92672">=</span> [<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>]<span style="color:#f92672">*</span>n
</span></span><span style="display:flex;"><span>        store <span style="color:#f92672">=</span> [[] <span style="color:#66d9ef">for</span> _ <span style="color:#f92672">in</span> range(<span style="color:#ae81ff">51</span>)]
</span></span><span style="display:flex;"><span>        mem <span style="color:#f92672">=</span> [(<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>, <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>)]<span style="color:#f92672">*</span>(<span style="color:#ae81ff">51</span>) 
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">for</span> i <span style="color:#f92672">in</span> range(<span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">51</span>):
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">for</span> j <span style="color:#f92672">in</span> range(<span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">51</span>):
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">if</span> gcd(i, j)<span style="color:#f92672">==</span><span style="color:#ae81ff">1</span>:
</span></span><span style="display:flex;"><span>                    store[i]<span style="color:#f92672">.</span>append(j)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">for</span> u, v <span style="color:#f92672">in</span> edges:
</span></span><span style="display:flex;"><span>            g[u]<span style="color:#f92672">.</span>append(v)
</span></span><span style="display:flex;"><span>            g[v]<span style="color:#f92672">.</span>append(u)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">def</span> <span style="color:#a6e22e">dfs</span>(u, last, level):
</span></span><span style="display:flex;"><span>            ret[u] <span style="color:#f92672">=</span> max(mem[i] <span style="color:#66d9ef">for</span> i <span style="color:#f92672">in</span> store[nums[u]])[<span style="color:#ae81ff">1</span>]
</span></span><span style="display:flex;"><span>            tmp <span style="color:#f92672">=</span> mem[nums[u]]
</span></span><span style="display:flex;"><span>            mem[nums[u]] <span style="color:#f92672">=</span> (level, u)
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">for</span> son <span style="color:#f92672">in</span> g[u]:
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">if</span> son<span style="color:#f92672">==</span>last:
</span></span><span style="display:flex;"><span>                    <span style="color:#66d9ef">continue</span>
</span></span><span style="display:flex;"><span>                dfs(son, u, level<span style="color:#f92672">+</span><span style="color:#ae81ff">1</span>)
</span></span><span style="display:flex;"><span>            mem[nums[u]] <span style="color:#f92672">=</span> tmp
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        dfs(<span style="color:#ae81ff">0</span>, <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">0</span>)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> ret
</span></span></code></pre></div><h3 id="924-尽量减少恶意软件的传播httpsleetcodecnproblemsminimize-malware-spread"><a href="https://leetcode.cn/problems/minimize-malware-spread/">924. 尽量减少恶意软件的传播</a><a hidden class="anchor" aria-hidden="true" href="#924-尽量减少恶意软件的传播httpsleetcodecnproblemsminimize-malware-spread">#</a></h3>
<p><strong>题目大意</strong>：给定一个由n个节点组成的网络，用n x n个邻接矩阵图graph表示。节点之间存在直接连接当且仅当graph[i][j] = 1。一些节点initial最初被恶意软件感染，如果两个节点直接连接且至少一个节点被感染，则两个节点都将被感染。移除一个节点后，返回使得整个网络中感染恶意软件的最终节点数最小的节点，若有多个节点满足条件，则返回索引最小的节点。</p>
<p><strong>实现思路</strong>：首先使用并查集将节点分组，然后计算每个分组的大小和其中感染节点的数量。遍历initial列表，找到使得其所在分组中只有一个感染节点且分组大小最大的节点，返回其索引。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-py" data-lang="py"><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Solution</span>:
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">def</span> <span style="color:#a6e22e">minMalwareSpread</span>(self, g: List[List[int]], initial: List[int]) <span style="color:#f92672">-&gt;</span> int:
</span></span><span style="display:flex;"><span>        n, m <span style="color:#f92672">=</span> len(g), len(initial)
</span></span><span style="display:flex;"><span>        f <span style="color:#f92672">=</span> [i <span style="color:#66d9ef">for</span> i <span style="color:#f92672">in</span> range(n)]
</span></span><span style="display:flex;"><span>        size <span style="color:#f92672">=</span> [<span style="color:#ae81ff">1</span> <span style="color:#66d9ef">for</span> _ <span style="color:#f92672">in</span> range(n)] <span style="color:#75715e"># 连通块内的点数</span>
</span></span><span style="display:flex;"><span>        num <span style="color:#f92672">=</span> [<span style="color:#ae81ff">0</span> <span style="color:#66d9ef">for</span> _ <span style="color:#f92672">in</span> range(n)] <span style="color:#75715e"># 连通块内的感染点数</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">for</span> x <span style="color:#f92672">in</span> initial:
</span></span><span style="display:flex;"><span>            num[x]<span style="color:#f92672">=</span><span style="color:#ae81ff">1</span>
</span></span><span style="display:flex;"><span>        
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">def</span> <span style="color:#a6e22e">find</span>(x):
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">if</span> f[x] <span style="color:#f92672">!=</span> x:
</span></span><span style="display:flex;"><span>                f[x] <span style="color:#f92672">=</span> find(f[x])
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">return</span> f[x]
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">for</span> i <span style="color:#f92672">in</span> range(n):
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">for</span> j <span style="color:#f92672">in</span> range(i<span style="color:#f92672">+</span><span style="color:#ae81ff">1</span>, n):
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">if</span> g[i][j]:
</span></span><span style="display:flex;"><span>                    fi, fj <span style="color:#f92672">=</span> find(i), find(j)
</span></span><span style="display:flex;"><span>                    <span style="color:#66d9ef">if</span> fi<span style="color:#f92672">!=</span>fj:
</span></span><span style="display:flex;"><span>                        f[fi] <span style="color:#f92672">=</span> fj
</span></span><span style="display:flex;"><span>                        num[fj] <span style="color:#f92672">+=</span> num[fi]
</span></span><span style="display:flex;"><span>                        size[fj] <span style="color:#f92672">+=</span> size[fi]
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        ma <span style="color:#f92672">=</span> <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>
</span></span><span style="display:flex;"><span>        initial<span style="color:#f92672">.</span>sort()
</span></span><span style="display:flex;"><span>        idx <span style="color:#f92672">=</span> initial[<span style="color:#ae81ff">0</span>]
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">for</span> x <span style="color:#f92672">in</span> initial:
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">if</span> num[find(x)]<span style="color:#f92672">==</span><span style="color:#ae81ff">1</span> <span style="color:#f92672">and</span> size[find(x)]<span style="color:#f92672">&gt;</span>ma:
</span></span><span style="display:flex;"><span>                ma <span style="color:#f92672">=</span> size[find(x)]
</span></span><span style="display:flex;"><span>                idx <span style="color:#f92672">=</span> x
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> idx
</span></span></code></pre></div><h3 id="928-尽量减少恶意软件的传播-iihttpsleetcodecnproblemsminimize-malware-spread-ii"><a href="https://leetcode.cn/problems/minimize-malware-spread-ii/">928. 尽量减少恶意软件的传播 II</a><a hidden class="anchor" aria-hidden="true" href="#928-尽量减少恶意软件的传播-iihttpsleetcodecnproblemsminimize-malware-spread-ii">#</a></h3>
<ul>
<li>
<p><strong>题目大意</strong>：给定一个由n个节点组成的网络，用n x n个邻接矩阵graph表示。节点之间存在直接连接当且仅当graph[i][j] = 1。一些节点initial最初被恶意软件感染，如果两个节点直接连接且至少一个节点被感染，则两个节点都将被感染。移除一个节点及其连接后，返回移除后能使整个网络中感染恶意软件的最终节点数最小的节点，若有多个节点满足条件，则返回索引最小的节点。</p>
</li>
<li>
<p><strong>实现思路</strong>：首先通过并查集将不在initial中的节点进行合并，然后计算每个initial节点的直接感染节点数。最后选择使得感染节点数最小且索引最小的initial节点返回。</p>
</li>
</ul>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-py" data-lang="py"><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Solution</span>:
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">def</span> <span style="color:#a6e22e">minMalwareSpread</span>(self, g: List[List[int]], initial: List[int]) <span style="color:#f92672">-&gt;</span> int:
</span></span><span style="display:flex;"><span>        n <span style="color:#f92672">=</span> len(g)
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">def</span> <span style="color:#a6e22e">find</span>(x):
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">if</span> f[x] <span style="color:#f92672">!=</span> x:
</span></span><span style="display:flex;"><span>                f[x] <span style="color:#f92672">=</span> find(f[x])
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">return</span> f[x]
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        f <span style="color:#f92672">=</span> [i <span style="color:#66d9ef">for</span> i <span style="color:#f92672">in</span> range(n)]
</span></span><span style="display:flex;"><span>        source <span style="color:#f92672">=</span> [[] <span style="color:#66d9ef">for</span> _ <span style="color:#f92672">in</span> range(n)]
</span></span><span style="display:flex;"><span>        cnt <span style="color:#f92672">=</span> [<span style="color:#ae81ff">0</span>]<span style="color:#f92672">*</span>n
</span></span><span style="display:flex;"><span>        init <span style="color:#f92672">=</span> [<span style="color:#ae81ff">0</span>]<span style="color:#f92672">*</span>n
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">for</span> i <span style="color:#f92672">in</span> initial:
</span></span><span style="display:flex;"><span>            init[i] <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">for</span> i <span style="color:#f92672">in</span> range(n):
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">if</span> init[i]:
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">continue</span>
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">for</span> j <span style="color:#f92672">in</span> range(n):
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">if</span> init[j] <span style="color:#f92672">or</span> <span style="color:#f92672">not</span> g[i][j]:
</span></span><span style="display:flex;"><span>                    <span style="color:#66d9ef">continue</span>
</span></span><span style="display:flex;"><span>                fi, fj <span style="color:#f92672">=</span> find(i), find(j)
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">if</span> fi<span style="color:#f92672">!=</span>fj:
</span></span><span style="display:flex;"><span>                    f[fi] <span style="color:#f92672">=</span> fj
</span></span><span style="display:flex;"><span>        
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">for</span> x <span style="color:#f92672">in</span> initial:
</span></span><span style="display:flex;"><span>            infected <span style="color:#f92672">=</span> [<span style="color:#ae81ff">0</span>]<span style="color:#f92672">*</span>n 
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">for</span> j <span style="color:#f92672">in</span> range(n):
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">if</span> <span style="color:#f92672">not</span> g[x][j] <span style="color:#f92672">or</span> init[j] <span style="color:#f92672">or</span> infected[find(j)]:
</span></span><span style="display:flex;"><span>                    <span style="color:#66d9ef">continue</span>
</span></span><span style="display:flex;"><span>                infected[find(j)] <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">for</span> j <span style="color:#f92672">in</span> range(n):
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">if</span> infected[j]:
</span></span><span style="display:flex;"><span>                    source[j]<span style="color:#f92672">.</span>append(x)
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">for</span> i <span style="color:#f92672">in</span> range(n):
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">if</span> len(source[i])<span style="color:#f92672">==</span><span style="color:#ae81ff">1</span>:
</span></span><span style="display:flex;"><span>                root <span style="color:#f92672">=</span> source[i][<span style="color:#ae81ff">0</span>]
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">for</span> j <span style="color:#f92672">in</span> range(n):
</span></span><span style="display:flex;"><span>                    <span style="color:#66d9ef">if</span> find(i)<span style="color:#f92672">==</span>find(j): <span style="color:#75715e"># 是一个连通块</span>
</span></span><span style="display:flex;"><span>                        cnt[root]<span style="color:#f92672">+=</span><span style="color:#ae81ff">1</span>
</span></span><span style="display:flex;"><span>        idx <span style="color:#f92672">=</span> initial[<span style="color:#ae81ff">0</span>]
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">for</span> x <span style="color:#f92672">in</span> initial:
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">if</span> cnt[x]<span style="color:#f92672">&gt;</span>cnt[idx] <span style="color:#f92672">or</span> (cnt[x]<span style="color:#f92672">==</span>cnt[idx] <span style="color:#f92672">and</span> x<span style="color:#f92672">&lt;</span>idx):
</span></span><span style="display:flex;"><span>                idx <span style="color:#f92672">=</span> x
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> idx
</span></span></code></pre></div><h3 id="2007-从双倍数组中还原原数组httpsleetcodecnproblemsfind-original-array-from-doubled-array"><a href="https://leetcode.cn/problems/find-original-array-from-doubled-array/">2007. 从双倍数组中还原原数组</a><a hidden class="anchor" aria-hidden="true" href="#2007-从双倍数组中还原原数组httpsleetcodecnproblemsfind-original-array-from-doubled-array">#</a></h3>
<p><strong>题目大意</strong>：给定一个数组 <code>changed</code>，通过以下方式构造原始数组 <code>original</code>：将 <code>changed</code> 中的每个元素乘以2，并将结果随机打乱，然后返回原始数组 <code>original</code>。如果无法构造原始数组，则返回空数组。</p>
<p><strong>实现思路</strong>：首先判断数组 <code>changed</code> 的长度是否为偶数，如果不是偶数，则无法构造原始数组，直接返回空数组。接着使用一个字典记录数组 <code>changed</code> 中各个元素的出现次数。然后遍历数组 <code>changed</code>，对于每个元素 i，判断是否存在 i 的两倍的元素，若存在，则将 i 和其两倍的元素都从字典中减去一个，并将 i 加入结果数组中。最后判断结果数组的长度是否达到了原始数组的一半，如果达到了则返回结果数组的前一半，否则返回空数组。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-py" data-lang="py"><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Solution</span>:
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">def</span> <span style="color:#a6e22e">findOriginalArray</span>(self, changed: List[int]) <span style="color:#f92672">-&gt;</span> List[int]:
</span></span><span style="display:flex;"><span>        n <span style="color:#f92672">=</span> len(changed)
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> n<span style="color:#f92672">&amp;</span><span style="color:#ae81ff">1</span>:
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">return</span> []
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        d <span style="color:#f92672">=</span> defaultdict(int)
</span></span><span style="display:flex;"><span>        res <span style="color:#f92672">=</span> []
</span></span><span style="display:flex;"><span>        cnt <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>
</span></span><span style="display:flex;"><span>        changed<span style="color:#f92672">.</span>sort()
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">for</span> i <span style="color:#f92672">in</span> changed:
</span></span><span style="display:flex;"><span>            d[i]<span style="color:#f92672">+=</span><span style="color:#ae81ff">1</span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">for</span> i <span style="color:#f92672">in</span> changed:
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">if</span> <span style="color:#f92672">not</span> d[i]:
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">continue</span>
</span></span><span style="display:flex;"><span>            x <span style="color:#f92672">=</span> i<span style="color:#f92672">*</span><span style="color:#ae81ff">2</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">if</span> i<span style="color:#f92672">==</span>x: <span style="color:#75715e"># 0*2 = 0</span>
</span></span><span style="display:flex;"><span>                d[x]<span style="color:#f92672">-=</span><span style="color:#ae81ff">1</span>
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">if</span> d[x]:
</span></span><span style="display:flex;"><span>                    d[x]<span style="color:#f92672">-=</span><span style="color:#ae81ff">1</span> <span style="color:#75715e"># 匹配成功</span>
</span></span><span style="display:flex;"><span>                    cnt<span style="color:#f92672">+=</span><span style="color:#ae81ff">1</span>
</span></span><span style="display:flex;"><span>                    res<span style="color:#f92672">.</span>append(i)
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">else</span>:
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">if</span> d[x]:
</span></span><span style="display:flex;"><span>                    d[x]<span style="color:#f92672">-=</span><span style="color:#ae81ff">1</span> <span style="color:#75715e"># 匹配成功</span>
</span></span><span style="display:flex;"><span>                    d[i]<span style="color:#f92672">-=</span><span style="color:#ae81ff">1</span>
</span></span><span style="display:flex;"><span>                    cnt<span style="color:#f92672">+=</span><span style="color:#ae81ff">1</span>
</span></span><span style="display:flex;"><span>                    res<span style="color:#f92672">.</span>append(i)
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> cnt<span style="color:#f92672">&gt;=</span>n<span style="color:#f92672">//</span><span style="color:#ae81ff">2</span>:
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">return</span> res[:n<span style="color:#f92672">//</span><span style="color:#ae81ff">2</span>]
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> []
</span></span></code></pre></div><p><strong>实现思路</strong>：首先使用 <code>Counter</code> 统计数组 <code>changed</code> 中各个元素的出现次数。然后将字典中键为 <code>0</code> 的元素（如果存在）弹出，因为原始数组中不可能有 <code>0</code>。接着判断字典中键为 <code>0</code> 的元素出现次数是否为偶数，如果不是偶数则无法构造原始数组，直接返回空数组。然后初始化一个由 <code>0</code> 组成的数组 <code>ans</code>，长度为 <code>cnt_0</code> 的一半。接下来遍历字典中的键值对，对于每个键 <code>x</code>，判断是否存在其一半的键值对，并将 <code>x</code> 加入结果数组 <code>ans</code> 中相应次数。最后返回结果数组 <code>ans</code>。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-py" data-lang="py"><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Solution</span>:
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">def</span> <span style="color:#a6e22e">findOriginalArray</span>(self, changed: List[int]) <span style="color:#f92672">-&gt;</span> List[int]:
</span></span><span style="display:flex;"><span>        cnt <span style="color:#f92672">=</span> Counter(changed)
</span></span><span style="display:flex;"><span>        cnt_0 <span style="color:#f92672">=</span> cnt<span style="color:#f92672">.</span>pop(<span style="color:#ae81ff">0</span>, <span style="color:#ae81ff">0</span>)
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> cnt_0<span style="color:#f92672">&amp;</span><span style="color:#ae81ff">1</span>:
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">return</span> []
</span></span><span style="display:flex;"><span>        ans <span style="color:#f92672">=</span> [<span style="color:#ae81ff">0</span>]<span style="color:#f92672">*</span>(cnt_0<span style="color:#f92672">//</span><span style="color:#ae81ff">2</span>)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">for</span> x <span style="color:#f92672">in</span> cnt:
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">if</span> x<span style="color:#f92672">%</span><span style="color:#ae81ff">2</span><span style="color:#f92672">==</span><span style="color:#ae81ff">0</span> <span style="color:#f92672">and</span> cnt[x<span style="color:#f92672">//</span><span style="color:#ae81ff">2</span>]:
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">continue</span>
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">while</span> x <span style="color:#f92672">in</span> cnt:
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">if</span> cnt[<span style="color:#ae81ff">2</span><span style="color:#f92672">*</span>x]<span style="color:#f92672">&lt;</span>cnt[x]:
</span></span><span style="display:flex;"><span>                    <span style="color:#66d9ef">return</span> []
</span></span><span style="display:flex;"><span>                ans<span style="color:#f92672">.</span>extend([x]<span style="color:#f92672">*</span>(cnt[x]))
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">if</span> cnt[<span style="color:#ae81ff">2</span><span style="color:#f92672">*</span>x]<span style="color:#f92672">&gt;</span>cnt[x]:
</span></span><span style="display:flex;"><span>                    cnt[<span style="color:#ae81ff">2</span><span style="color:#f92672">*</span>x]<span style="color:#f92672">-=</span>cnt[x]
</span></span><span style="display:flex;"><span>                    x<span style="color:#f92672">*=</span><span style="color:#ae81ff">2</span>
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">else</span>:
</span></span><span style="display:flex;"><span>                    x<span style="color:#f92672">*=</span><span style="color:#ae81ff">4</span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> ans
</span></span></code></pre></div><h3 id="1883-准时抵达会议现场的最小跳过休息次数httpsleetcodecnproblemsminimum-skips-to-arrive-at-meeting-on-time"><a href="https://leetcode.cn/problems/minimum-skips-to-arrive-at-meeting-on-time/">1883. 准时抵达会议现场的最小跳过休息次数</a><a hidden class="anchor" aria-hidden="true" href="#1883-准时抵达会议现场的最小跳过休息次数httpsleetcodecnproblemsminimum-skips-to-arrive-at-meeting-on-time">#</a></h3>
<ul>
<li>
<p><strong>题目大意</strong>：题目给出了一组道路的长度和行驶速度，以及剩余可用时间。要求计算在给定的时间内，最少跳过休息次数，以准时抵达会议现场。</p>
</li>
<li>
<p><strong>实现思路</strong>：动态规划。使用二维数组dp[i][j]表示到达第i条路，跳过j次休息的最小距离。初始化dp数组，然后遍历每一条路，在遍历的过程中更新dp数组。最后检查是否有方案可以在规定时间内到达会议现场，如果有，返回跳过休息的最小次数，否则返回-1。</p>
</li>
</ul>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-py" data-lang="py"><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Solution</span>:
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">def</span> <span style="color:#a6e22e">minSkips</span>(self, dist: List[int], speed: int, hoursBefore: int) <span style="color:#f92672">-&gt;</span> int:
</span></span><span style="display:flex;"><span>        n <span style="color:#f92672">=</span> len(dist)
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> sum(dist) <span style="color:#f92672">&gt;</span> hoursBefore <span style="color:#f92672">*</span> speed:
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">return</span> <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        dp <span style="color:#f92672">=</span> [[inf] <span style="color:#f92672">*</span> (n <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>) <span style="color:#66d9ef">for</span> _ <span style="color:#f92672">in</span> range(n <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>)]
</span></span><span style="display:flex;"><span>        dp[<span style="color:#ae81ff">0</span>][<span style="color:#ae81ff">0</span>] <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">for</span> i <span style="color:#f92672">in</span> range(<span style="color:#ae81ff">1</span>, n):
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">for</span> j <span style="color:#f92672">in</span> range(i<span style="color:#f92672">+</span><span style="color:#ae81ff">1</span>): <span style="color:#75715e"># 到第i条路，跳过次数为j的最小距离</span>
</span></span><span style="display:flex;"><span>                <span style="color:#75715e"># 不跳过第 i 条路</span>
</span></span><span style="display:flex;"><span>                dp[i][j] <span style="color:#f92672">=</span> min(dp[i][j], (dp[i<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>][j] <span style="color:#f92672">+</span> dist[i<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>] <span style="color:#f92672">+</span> speed <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>)<span style="color:#f92672">//</span>speed<span style="color:#f92672">*</span>speed)
</span></span><span style="display:flex;"><span>                <span style="color:#75715e"># 跳过第 i 条路</span>
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">if</span> j:
</span></span><span style="display:flex;"><span>                    dp[i][j] <span style="color:#f92672">=</span> min(dp[i][j], dp[i <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>][j <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>] <span style="color:#f92672">+</span> dist[i<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>])
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">for</span> j <span style="color:#f92672">in</span> range(n): <span style="color:#75715e"># 可以跳0~n-1次(最后一条边不用跳)</span>
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">if</span> dp[n<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>][j]<span style="color:#f92672">+</span>dist[<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>] <span style="color:#f92672">&lt;=</span> hoursBefore <span style="color:#f92672">*</span> speed:
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">return</span> j
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>
</span></span></code></pre></div><h3 id="39-组合总和httpsleetcodecnproblemscombination-sum"><a href="https://leetcode.cn/problems/combination-sum/">39. 组合总和</a><a hidden class="anchor" aria-hidden="true" href="#39-组合总和httpsleetcodecnproblemscombination-sum">#</a></h3>
<ul>
<li>
<p><strong>题目大意</strong> ：给定一个无重复元素的整数数组 <code>candidates</code> 和一个目标整数 <code>target</code>，找出 <code>candidates</code> 中可以使数字和为目标数 <code>target</code> 的所有不同组合，并以列表形式返回。可以无限制重复选择 <code>candidates</code> 中的同一个数字。</p>
</li>
<li>
<p><strong>实现思路</strong> ：</p>
</li>
</ul>
<ol>
<li>使用深度优先搜索<code>（DFS）</code>进行组合搜索。</li>
<li>定义一个辅助函数 <code>dfs(i, s)</code>，其中 i 表示当前遍历到的 <code>candidates</code> 数组的索引，<code>s</code> 表示当前已经选取的数字的和。</li>
<li>在 <code>dfs</code> 函数中，如果 s 大于等于 <code>target</code> 或者已经遍历到数组末尾，则进行以下判断：
<ul>
<li>如果 s 等于 <code>target</code>，则将当前的组合 <code>ls</code> 加入结果列表 <code>ret</code> 中。</li>
<li>如果 s 大于 <code>target</code> 或者已经遍历到数组末尾，则直接返回。</li>
</ul>
</li>
<li>在 <code>dfs</code> 函数中，分别尝试两种情况：
<ul>
<li>不选择当前数字，继续向后搜索：<code>dfs(i+1, s)</code>。</li>
<li>选择当前数字，继续向后搜索：将当前数字加入组合 ls 中，更新 s，并递归调用 <code>dfs(i, s+c[i])</code>。</li>
</ul>
</li>
<li>在递归调用之后，需要将当前选择的数字从组合 <code>ls</code> 中弹出，保证不影响后续搜索。</li>
<li>最终返回结果列表 <code>ret</code>。</li>
</ol>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-py" data-lang="py"><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Solution</span>:
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">def</span> <span style="color:#a6e22e">combinationSum</span>(self, c: List[int], t: int) <span style="color:#f92672">-&gt;</span> List[List[int]]:
</span></span><span style="display:flex;"><span>        n <span style="color:#f92672">=</span> len(c)
</span></span><span style="display:flex;"><span>        ret, ls <span style="color:#f92672">=</span> [], []
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">def</span> <span style="color:#a6e22e">dfs</span>(i, s):
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">if</span> s<span style="color:#f92672">&gt;=</span>t <span style="color:#f92672">or</span> i<span style="color:#f92672">==</span>n:
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">if</span> s<span style="color:#f92672">==</span>t:
</span></span><span style="display:flex;"><span>                    ret<span style="color:#f92672">.</span>append(ls[:])
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">return</span>
</span></span><span style="display:flex;"><span>            dfs(i<span style="color:#f92672">+</span><span style="color:#ae81ff">1</span>, s)
</span></span><span style="display:flex;"><span>            ls<span style="color:#f92672">.</span>append(c[i])
</span></span><span style="display:flex;"><span>            dfs(i, s<span style="color:#f92672">+</span>c[i])
</span></span><span style="display:flex;"><span>            ls<span style="color:#f92672">.</span>pop()
</span></span><span style="display:flex;"><span>        dfs(<span style="color:#ae81ff">0</span>, <span style="color:#ae81ff">0</span>)
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> ret
</span></span></code></pre></div><h3 id="216-组合总和-iiihttpsleetcodecnproblemscombination-sum-iii"><a href="https://leetcode.cn/problems/combination-sum-iii/">216. 组合总和 III</a><a hidden class="anchor" aria-hidden="true" href="#216-组合总和-iiihttpsleetcodecnproblemscombination-sum-iii">#</a></h3>
<ul>
<li>
<p><strong>题目大意</strong>：找出所有相加之和为n的k个数的组合，要求使用数字1到9，每个数字最多使用一次，返回所有可能的有效组合的列表。列表不能包含相同的组合两次，组合可以以任何顺序返回。</p>
</li>
<li>
<p><strong>实现思路</strong>：使用深度优先搜索（DFS）的方法，从1到9的数字中进行遍历，每次选择一个数字或不选择，直到满足条件为止。递归过程中，维护一个列表ls，记录当前已选数字的集合，如果当前集合的数字个数等于k且它们的和等于n，则将其加入结果列表ret中。</p>
</li>
</ul>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-py" data-lang="py"><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Solution</span>:
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">def</span> <span style="color:#a6e22e">combinationSum3</span>(self, k: int, n: int) <span style="color:#f92672">-&gt;</span> List[List[int]]:
</span></span><span style="display:flex;"><span>        ret, ls <span style="color:#f92672">=</span> [], []
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">def</span> <span style="color:#a6e22e">dfs</span>(i, s, cnt):
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">if</span> i<span style="color:#f92672">==</span><span style="color:#ae81ff">10</span> <span style="color:#f92672">or</span> s<span style="color:#f92672">&gt;=</span>n <span style="color:#f92672">or</span> cnt<span style="color:#f92672">&gt;=</span>k:
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">if</span> s<span style="color:#f92672">==</span>n <span style="color:#f92672">and</span> cnt<span style="color:#f92672">==</span>k:
</span></span><span style="display:flex;"><span>                    ret<span style="color:#f92672">.</span>append(ls[:])
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">return</span>
</span></span><span style="display:flex;"><span>            dfs(i<span style="color:#f92672">+</span><span style="color:#ae81ff">1</span>, s, cnt)
</span></span><span style="display:flex;"><span>            ls<span style="color:#f92672">.</span>append(i)
</span></span><span style="display:flex;"><span>            dfs(i<span style="color:#f92672">+</span><span style="color:#ae81ff">1</span>, s<span style="color:#f92672">+</span>i, cnt<span style="color:#f92672">+</span><span style="color:#ae81ff">1</span>)
</span></span><span style="display:flex;"><span>            ls<span style="color:#f92672">.</span>pop()
</span></span><span style="display:flex;"><span>        dfs(<span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">0</span>, <span style="color:#ae81ff">0</span>)
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> ret
</span></span></code></pre></div><h3 id="377-组合总和-httpsleetcodecnproblemscombination-sum-iv"><a href="https://leetcode.cn/problems/combination-sum-iv/">377. 组合总和 Ⅳ</a><a hidden class="anchor" aria-hidden="true" href="#377-组合总和-httpsleetcodecnproblemscombination-sum-iv">#</a></h3>
<ul>
<li>
<p><strong>题目大意</strong>：给定一个由不同整数组成的数组nums和一个目标整数target，要求从nums中找出总和为target的元素组合的个数。</p>
</li>
<li>
<p><strong>实现思路</strong>：这是一个典型的动态规划问题。使用递归+记忆化搜索（Memoization）的方法来解决。定义dfs函数，参数为当前的和s，函数返回当前和s能够组成的组合数目。递归的终止条件是当前和s大于等于目标target，则返回1（如果s等于target，则表示找到一种组合）。否则，遍历数组nums中的每个数，对每个数进行递归调用dfs(s+i)，累加得到的组合数目。使用cache装饰器对dfs函数进行记忆化搜索，避免重复计算。最终返回dfs(0)，即从初始和为0开始的组合数目。</p>
</li>
</ul>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-py" data-lang="py"><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Solution</span>:
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">def</span> <span style="color:#a6e22e">combinationSum4</span>(self, nums: List[int], target: int) <span style="color:#f92672">-&gt;</span> int:
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">@cache</span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">def</span> <span style="color:#a6e22e">dfs</span>(s):
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">if</span> s<span style="color:#f92672">&gt;=</span>target:
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">if</span> s<span style="color:#f92672">==</span>target:
</span></span><span style="display:flex;"><span>                    <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">1</span>
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>
</span></span><span style="display:flex;"><span>            cnt <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">for</span> i <span style="color:#f92672">in</span> nums:
</span></span><span style="display:flex;"><span>                cnt <span style="color:#f92672">+=</span> dfs(s<span style="color:#f92672">+</span>i)
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">return</span> cnt
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> dfs(<span style="color:#ae81ff">0</span>)
</span></span></code></pre></div>

  </div>

  <footer class="post-footer">
    <ul class="post-tags">
      <li><a href="https://kennems.github.io/tags/leetcode%E7%AC%94%E8%AE%B0/">LeetCode笔记</a></li>
    </ul>
        
    
    <ul id="categories">
      
        <li><a href="https://kennems.github.io/categories/leetcode">LeetCode</a> </li>
      
    </ul>
    
    
<nav class="paginav">
  <a class="prev" href="https://kennems.github.io/posts/tech/leetcode%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98202404/">
    <span class="title">« 上一页</span>
    <br>
    <span>LeetCode每日一题（202404）</span>
  </a>
  <a class="next" href="https://kennems.github.io/posts/tech/%E5%89%91%E6%8C%87offer/">
    <span class="title">下一页 »</span>
    <br>
    <span>剑指Offer</span>
  </a>
</nav>

  </footer>
</article>
    </main>
    
<footer class="footer">
        <span>&copy; 2025 <a href="https://kennems.github.io/">Kennem&#39;s Blog</a></span> · 

    <span>
        Powered by
        <a href="https://gohugo.io/" rel="noopener noreferrer" target="_blank">Hugo</a> &
        <a href="https://github.com/adityatelange/hugo-PaperMod/" rel="noopener" target="_blank">PaperMod</a>
    </span>
</footer>
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)" class="top-link" id="top-link" accesskey="g">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
        <path d="M12 6H0l6-6z" />
    </svg>
</a>

<script>
    let menu = document.getElementById('menu')
    if (menu) {
        menu.scrollLeft = localStorage.getItem("menu-scroll-position");
        menu.onscroll = function () {
            localStorage.setItem("menu-scroll-position", menu.scrollLeft);
        }
    }

    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.pushState(null, null, `#${id}`);
            }
        });
    });

</script>
<script>
    var mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };

</script>
<script>
    document.getElementById("theme-toggle").addEventListener("click", () => {
        if (document.body.className.includes("dark")) {
            document.body.classList.remove('dark');
            localStorage.setItem("pref-theme", 'light');
        } else {
            document.body.classList.add('dark');
            localStorage.setItem("pref-theme", 'dark');
        }
    })

</script>
<script>
    document.querySelectorAll('pre > code').forEach((codeblock) => {
        const container = codeblock.parentNode.parentNode;

        const copybutton = document.createElement('button');
        copybutton.classList.add('copy-code');
        copybutton.innerHTML = '复制';

        function copyingDone() {
            copybutton.innerHTML = '已复制！';
            setTimeout(() => {
                copybutton.innerHTML = '复制';
            }, 2000);
        }

        copybutton.addEventListener('click', (cb) => {
            if ('clipboard' in navigator) {
                navigator.clipboard.writeText(codeblock.textContent);
                copyingDone();
                return;
            }

            const range = document.createRange();
            range.selectNodeContents(codeblock);
            const selection = window.getSelection();
            selection.removeAllRanges();
            selection.addRange(range);
            try {
                document.execCommand('copy');
                copyingDone();
            } catch (e) { };
            selection.removeRange(range);
        });

        if (container.classList.contains("highlight")) {
            container.appendChild(copybutton);
        } else if (container.parentNode.firstChild == container) {
            
        } else if (codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName == "TABLE") {
            
            codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(copybutton);
        } else {
            
            codeblock.parentNode.appendChild(copybutton);
        }
    });
</script>
<footer class="footer">
    <script async src="https://busuanzi.sukap.cn/busuanzi.pure.mini.js"></script>
    <span id="busuanzi_container">
        <link rel="stylesheet" href="//maxcdn.bootstrapcdn.com/font-awesome/4.3.0/css/font-awesome.min.css">
        Visitors: <span id="busuanzi_value_page_uv"></span>
        Views: <span id="busuanzi_value_page_pv"></span>

        
    </span>
</footer>



</body>

</html>
