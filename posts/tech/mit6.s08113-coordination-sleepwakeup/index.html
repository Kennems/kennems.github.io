<!DOCTYPE html>
<html lang="zh" dir="auto">

<head><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="index, follow">

<meta name="msvalidate.01" content="DF5FE493CC759E62BFE073BEA8EFD472" />
<title>MIT6.S081(13)-Coordination (sleep&amp;wakeup) | Kennem&#39;s Blog</title>
<meta name="keywords" content="MIT6.S081">
<meta name="description" content="MIT6.S081(13)-Coordination (sleep&amp;wakeup)">
<meta name="author" content="ShowGuan">
<link rel="canonical" href="https://kennems.github.io/posts/tech/mit6.s08113-coordination-sleepwakeup/">
<link crossorigin="anonymous" href="/assets/css/stylesheet.b0b75e963d4643f817dc4da6eda116517a285285a07b77f8da8234e4fa6e6f57.css" integrity="sha256-sLdelj1GQ/gX3E2m7aEWUXooUoWge3f42oI05Ppub1c=" rel="preload stylesheet" as="style">
<link rel="icon" href="https://kennems.github.io/img/sun.png">
<link rel="icon" type="image/png" sizes="16x16" href="https://kennems.github.io/img/sun.png">
<link rel="icon" type="image/png" sizes="32x32" href="https://kennems.github.io/img/sun.png">
<link rel="apple-touch-icon" href="https://kennems.github.io/img/sun.png">
<link rel="mask-icon" href="https://kennems.github.io/img/sun.png">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<link rel="alternate" hreflang="zh" href="https://kennems.github.io/posts/tech/mit6.s08113-coordination-sleepwakeup/">
<noscript>
    <style>
        #theme-toggle,
        .top-link {
            display: none;
        }

    </style>
    <style>
        @media (prefers-color-scheme: dark) {
            :root {
                --theme: rgb(29, 30, 32);
                --entry: rgb(46, 46, 51);
                --primary: rgb(218, 218, 219);
                --secondary: rgb(155, 156, 157);
                --tertiary: rgb(65, 66, 68);
                --content: rgb(196, 196, 197);
                --code-block-bg: rgb(46, 46, 51);
                --code-bg: rgb(55, 56, 62);
                --border: rgb(51, 51, 51);
            }

            .list {
                background: var(--theme);
            }

            .list:not(.dark)::-webkit-scrollbar-track {
                background: 0 0;
            }

            .list:not(.dark)::-webkit-scrollbar-thumb {
                border-color: var(--theme);
            }
        }

    </style>
</noscript>

<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.2/dist/katex.min.css" integrity="sha384-MlJdn/WNKDGXveldHDdyRP1R4CTHr3FeuDNfhsLPYrq2t0UBkUdK2jyTnXPEK1NQ" crossorigin="anonymous">

<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.2/dist/katex.min.js" integrity="sha384-VQ8d8WVFw0yHhCk5E8I86oOhv48xLpnDZx5T9GogA/Y84DcCKWXDmSDfn13bzFZY" crossorigin="anonymous"></script>

<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.2/dist/contrib/auto-render.min.js" integrity="sha384-+XBljXPPiv+OzfbB3cVmLHf4hdUFHlWNZN5spNQ7rmHTXpd7WvJum6fIACpNNfIR" crossorigin="anonymous"
    onload="renderMathInElement(document.body);"></script>


<script>
document.addEventListener("DOMContentLoaded", function() {
    renderMathInElement(document.body, {
        delimiters: [
            {left: "$$", right: "$$", display: true},
            {left: "$", right: "$", display: false}
        ]
    });
});
</script>


<link href="https://fonts.cdnfonts.com/css/code-new-roman" rel="stylesheet">
                
  

<meta property="og:title" content="MIT6.S081(13)-Coordination (sleep&amp;wakeup)" />
<meta property="og:description" content="MIT6.S081(13)-Coordination (sleep&amp;wakeup)" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://kennems.github.io/posts/tech/mit6.s08113-coordination-sleepwakeup/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2024-09-29T19:30:13+08:00" />
<meta property="article:modified_time" content="2024-10-03T19:20:13+08:00" />

<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="MIT6.S081(13)-Coordination (sleep&amp;wakeup)"/>
<meta name="twitter:description" content="MIT6.S081(13)-Coordination (sleep&amp;wakeup)"/>


<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BreadcrumbList",
  "itemListElement": [
    {
      "@type": "ListItem",
      "position":  1 ,
      "name": "üìöÊñáÁ´†",
      "item": "https://kennems.github.io/posts/"
    }, 
    {
      "@type": "ListItem",
      "position":  2 ,
      "name": "üíªÊäÄÊúØ",
      "item": "https://kennems.github.io/posts/tech/"
    }, 
    {
      "@type": "ListItem",
      "position":  3 ,
      "name": "MIT6.S081(13)-Coordination (sleep\u0026wakeup)",
      "item": "https://kennems.github.io/posts/tech/mit6.s08113-coordination-sleepwakeup/"
    }
  ]
}
</script>
<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "MIT6.S081(13)-Coordination (sleep\u0026wakeup)",
  "name": "MIT6.S081(13)-Coordination (sleep\u0026wakeup)",
  "description": "MIT6.S081(13)-Coordination (sleep\u0026wakeup)",
  "keywords": [
    "MIT6.S081"
  ],
  "articleBody": "MIT6.S081(13)-Coordination (sleep\u0026wakeup) plan Re-emphasize a few points about xv6 thread switching sequence coordination sleep \u0026 wakeup lost wakeup problem termination\nWhy hold p-\u003elock across swtch()? this is an important point and affects many situations in xv6 [diagram: P1, STACK1, swtch, STACK_SCHED] yield:\nacquire(\u0026p-\u003elock); p-\u003estate = RUNNABLE; swtch(); scheduler:\nswtch(); release(\u0026p-\u003elock); the main point of holding p-\u003elock across swtch(): prevent another core‚Äôs scheduler from seeing p-\u003estate == RUNNABLE until after the original core has stopped executing the thread and after the original core has stopped using the thread‚Äôs stack\nWhy does sched() forbid spinlocks from being held when yielding the CPU? (other than p-\u003elock) i.e. sched() checks that noff == 1 on a single-core machine, imagine this:\nP1 P2\racq(L)\rsched()\racq(L) this is a deadlock: P2 will spin until P1 releases ‚Äì and P2 won‚Äôt yield the CPU but P1 won‚Äôt release until it runs again with multiple cores, deadlock can also arise; more spinlocks must be involved solution: do not hold spinlocks and yield the CPU!\ntopic: sequence coordination threads need to wait for specific events or conditions: wait for disk read to complete (event is from an interrupt) wait for pipe writer to produce data (event is from a thread) wait for any child to exit\ncoordination is a fundamental building-block for thread programming.\noften straightforward to use. but (like locks) subject to rules that sometimes present difficult puzzles.\nwhy not just have a while-loop that spins until event happens? pipe read:\nwhile buffer is empty {\r} pipe write:\nput data in buffer better solution: coordination primitives that yield the CPU\nthere are a bunch e.g. barriers, semaphores, event queues. xv6 uses sleep \u0026 wakeup\nexample: uartwrite() and uartintr() in uart.c I have modified these functions! not the same as default xv6 see ‚Äúcode‚Äù link on schedule page the basic idea: the UART can only accept one (really a few) bytes of output at a time takes a long time to send each byte, perhaps millisecond processes writing the console must wait until UART sends prev char the UART interrupts after it has sent each character writing thread should give up the CPU until then write() calls uartwrite() uartwrite() writes first byte (if it can) uartwrite() calls sleep() to wait for the UART‚Äôs interrupt uartintr() calls wakeup() the ‚Äú\u0026tx_chan‚Äù argument serves to link the sleep and wakeup simple and flexible: sleep/wakeup don‚Äôt need to understand what you‚Äôre waiting for no need to allocate explicit coordination objects\nWhy the lock argument to sleep()? sadly you cannot design sleep() as cleanly as you might hope sleep() cannot simply be ‚Äúwait for this event‚Äù the problem is called ‚Äúlost wakeups‚Äù it lurks behind all sequence coordination schemes, and is a pain here‚Äôs the story\nsuppose just sleep(chan); how would we implement? here‚Äôs a BROKEN sleep/wakeup broken_sleep(chan) sleeps on a ‚Äúchannel‚Äù, a number/address identifies the condition/event we are waiting for\np-\u003estate = SLEEPING;\rp-\u003echan = chan;\rsched();\rwakeup(chan) ‚Äã wakeup wakes up all threads sleeping on chan ‚Äã may wake up more than one thread\nfor each p:\rif p-\u003estate == SLEEPING \u0026\u0026 p-\u003echan == chan:\rp-\u003estate = RUNNABLE how would uart code use this (broken) sleep/wakeup? int done uartwrite(buf): for each char c: while not done: sleep(\u0026done) send c done = false uartintr(): done = true wakeup(\u0026done) done==true is the condition we're waiting for \u0026done is the sleep channel (not really related to the condition)\nbut what about locking? driver‚Äôs data structures e.g. done\nUART hardware\nboth uartwrite() and uartintr() need to lock should uartwrite() hold a lock for the whole sequence? no: then uartintr() can‚Äôt get lock and set done maybe uartwrite() could release the lock before sleep()? let‚Äôs try it ‚Äì modify uart.c to call broken_sleep()\nrelease(\u0026uart_tx_lock); broken_sleep(\u0026tx_chan); acquire(\u0026uart_tx_lock); what goes wrong when uartwrite() releases the lock before broken_sleep()? uartwrite() saw that the previous character wasn‚Äôt yet done being sent interrupt occurred after release(), before broken_sleep() uartwrite() went to sleep EVEN THOUGH UART TX WAS DONE now there is nothing to wake up uartwrite(), it will sleep forever\nthis is the ‚Äúlost wakeup‚Äù problem.\nwe need to eliminate the window between uartwrite()‚Äôs check of the condition, and sleep() marking the process as asleep. we‚Äôll use locks to prevent wakeup() from running during the entire window.\nwe‚Äôll change the sleep() interface and the way it‚Äôs used. we‚Äôll require that there be a lock that protects the condition, and that the callers of both sleep() and wakeup() hold the ‚Äúcondition lock‚Äù sleep(chan, lock) caller must hold lock sleep releases lock, re-acquires before returning wakeup(chan) caller must hold lock (repair uart.c)\nlet‚Äôs look at wakeup(chan) in proc.c it scans the process table, looking for SLEEPING and chan it grabs each p-\u003elock remember also that caller acquired condition lock before calling wakeup() so wakeup() holds BOTH the condition lock and each p-\u003elock\nlet‚Äôs look at sleep() in proc.c sleep must release the condition lock since we can‚Äôt hold locks when calling swtch(), other than p-\u003elock\nQ: how can sleep() prevent wakeup() from running after it releases the condition lock? A: acquire p-\u003elock before releasing condition lock since wakeup() holds both locks, it‚Äôs enough for sleep() to hold either in order to force wakeup() to spin rather than look at this process now wakeup() can‚Äôt proceed until after swtch() completes so wakeup() is guaranteed to see p-\u003estate==SLEEPING and p-\u003echan==chan thus: no lost wakeups!\nnote that uartwrite() wraps the sleep() in a loop i.e. re-checks the condition after sleep() returns, may sleep again\ntwo reasons: ‚Äã maybe multiple waiters, another thread might have consumed the event ‚Äã kill() wakes up processes even when condition isn‚Äôt true all uses of sleep are wrapped in a loop, so they re-check\nAnother example: piperead() the condition is data waiting to be read (nread != nwrite) pipewrite() calls wakeup() at the end what is the race if piperead() used broken_sleep()? note the the loop around sleep() multiple processes may be reading the same pipe why the wakeup() at the end of piperead()?\nthe sleep/wakeup interface/rules are a little complex sleep() doesn‚Äôt need to understand the condition, but it needs the condition lock sleep/wakeup is pretty flexible, though low-level there are other schemes that are cleaner but perhaps less general-purpose e.g. the counting semaphore in today‚Äôs reading all have to cope with lost wakeups, one way or another\nanother coordination challenge ‚Äì how to terminate a thread? a puzzle: we want need to free resources that might still be in use\nproblem: thread X cannot just destroy thread Y what if Y is executing on another core? what if Y holds locks? what if Y is in the middle of a complex update to important data structures?\nproblem: a thread cannot free all of its own resources e.g. its own stack, which it is still using e.g. its struct context, which it may need to call swtch()\nxv6 has two ways to get rid of processes: exit() and kill() ordinary case: process voluntarily quits with exit() system call some freeing in exit(), some in parent‚Äôs wait() exit() in proc.c:\nclose open files\rchange parent of children to PID 1 (init)\rwake up wait()ing parent\rp-\u003estate = ZOMBIE ‚Äã dying but not yet dead ‚Äã won‚Äôt run again ‚Äã won‚Äôt (yet) be re-allocated by fork(), eithe¬∑r ‚Äã (note stack and proc[] entry are still allocated‚Ä¶) ‚Äã swtch() to scheduler wait() in proc.c (parent, or init, will eventually call): ‚Äã sleep()s waiting for any child exit() ‚Äã scans proc[] table for children with p-\u003estate==ZOMBIE ‚Äã calls freeproc() ‚Äã (p-\u003elock held‚Ä¶) ‚Äã trapframe, pagetable, ‚Ä¶, p-\u003estate=UNUSED thus: wait() is not just for app convenience, but for O/S as well ‚Äã every process must be wait()ed for ‚Äã thus the re-parenting of children of an exiting process some complexity due to ‚Äã child exits concurrently with its own parent ‚Äã parent-then-child locking order to avoid deadlock\nwhat about kill(pid)? problem: may not be safe to forcibly terminate a process it might be executing in the kernel using its kernel stack, page table, proc[] entry, trapframe it might hold locks e.g. in the middle of fork()ing a new process and must finish to restore invariants so: kill() can‚Äôt directly destroy the target! solution: kill() sets p-\u003ekilled flag, nothing else the target process itself checks for p-\u003ekilled and calls exit() itself look for ‚Äúif(p-\u003ekilled) exit(-1);‚Äù in usertrap() no locks are held at that point so it‚Äôs safe to exit()\nwhat if kill() target is sleep()ing? in that case it doesn‚Äôt hold locks, and isn‚Äôt executing! is it OK for kill() destroy the target right away? might be OK: waiting for console input might not be OK: waiting for disk midway through file creation\nxv6 solution to kill() of sleep()ing process see kill() in proc.c changes SLEEPING to RUNNABLE ‚Äì like wakeup() so sleep() will return, probably before condition is true some sleep loops check for p-\u003ekilled e.g. piperead(), consoleread() otherwise read could hang indefinitely for a killed process some sleep loops don‚Äôt check p-\u003ekilled e.g. virtio_disk.c OK not to check p-\u003ekilled since disk reads are pretty quick so a kill()ed process may continue for a while but usertrap() will exit() after the system call finishes\nxv6 spec for kill if target is in user space will die next time it makes a system call or takes a timer interrupt if target is in the kernel target will never execute another user instruction but may spend quite a while yet in the kernel\nSummary sleep/wakeup let threads wait for specific events concurrency means we have to worry about lost wakeups termination is a pain in threading systems\nLab: locks Memory allocator (moderate) ‰ºòÂåñxv6ÁöÑÂÜÖÂ≠òÂàÜÈÖçÂô®ÔºåÂáèÂ∞ëÈîÅ‰∫âÁî®„ÄÇÂΩìÂâçÁöÑÂÆûÁé∞‰ΩøÁî®‰∏Ä‰∏™ÂÖ®Â±ÄÁöÑËá™Áî±ÂàóË°®ÂíåÂçï‰∏ÄÁöÑÈîÅ‰øùÊä§ÔºåÂØºËá¥Â§öÊ†∏Á≥ªÁªü‰∏≠Â§ö‰∏™ËøõÁ®ãÂπ∂ÂèëÊâßË°åÊó∂ÈîÅ‰∫âÁî®‰∏•Èáç„ÄÇ‰Ω†ÈúÄË¶ÅÂ∞ÜÂçï‰∏ÄËá™Áî±ÂàóË°®Êîπ‰∏∫ÊØè‰∏™CPUÈÉΩÊúâËá™Â∑±ÁöÑËá™Áî±ÂàóË°®ÔºåÊØè‰∏™Ëá™Áî±ÂàóË°®ÊúâËá™Â∑±ÁöÑÈîÅ„ÄÇËøôÊ†∑ÔºåÂ§ö‰∏™CPUÂèØ‰ª•Âπ∂Ë°åËøõË°åÂÜÖÂ≠òÂàÜÈÖçÂíåÈáäÊîæÔºå‰ªéËÄåÂáèÂ∞ëÈîÅ‰∫âÁî®„ÄÇ\n‰ªªÂä°ÂàÜËß£Ôºö ÂàõÂª∫ÊØè‰∏™CPUÁöÑËá™Áî±ÂàóË°®Ôºö ÊØè‰∏™CPUÊúâËá™Â∑±Áã¨Á´ãÁöÑËá™Áî±ÂÜÖÂ≠òÂùóÂàóË°®ÔºåÂπ∂‰∏îÊØè‰∏™ÂàóË°®ÊúâËá™Â∑±ÁöÑÈîÅ„ÄÇ ‰ΩøÁî®NCPUÔºàÂú®param.h‰∏≠ÂÆö‰πâÔºâÁ°ÆÂÆöCPUÁöÑÊï∞Èáè„ÄÇ ‰∏∫ÊØè‰∏™CPUÂàõÂª∫‰∏Ä‰∏™ÂØπÂ∫îÁöÑÈîÅÔºåÁî®‰∫é‰øùÊä§ÂÖ∂Ëá™Áî±ÂàóË°®„ÄÇ ‰øÆÊîπfreerangeÂáΩÊï∞Ôºö freerangeÂ∫îËØ•Ê†πÊçÆÂΩìÂâçCPUÔºåÂ∞ÜÁ©∫Èó≤ÂÜÖÂ≠òÂùóÂàÜÈÖçÂà∞ÂΩìÂâçCPUÁöÑËá™Áî±ÂàóË°®‰∏≠„ÄÇ‰Ω†ÂèØ‰ª•‰ΩøÁî®cpuidÊù•Ëé∑ÂèñÂΩìÂâçCPUÁºñÂè∑Ôºå‰ΩÜË¶ÅÁ°Æ‰øùË∞ÉÁî®ÂÆÉÊó∂‰∏≠Êñ≠Â∑≤ÂÖ≥Èó≠„ÄÇ ‰ΩøÁî®push_off()Âíåpop_off()Êù•ÂÖ≥Èó≠ÂíåÂºÄÂêØ‰∏≠Êñ≠Ôºå‰øùËØÅË∞ÉÁî®cpuidÊó∂ÁöÑÂÆâÂÖ®ÊÄß„ÄÇ ÂÆûÁé∞ÂÜÖÂ≠òÂàÜÈÖçÂíåÈáäÊîæÔºö ‰øÆÊîπkallocÂíåkfreeÔºå‰ΩøÂÆÉ‰ª¨Âè™Êìç‰ΩúÂΩìÂâçCPUÁöÑËá™Áî±ÂàóË°®„ÄÇÈÄöËøá‰ΩøÁî®ÂΩìÂâçCPUÁöÑÈîÅÊù•‰øùÊä§Âπ∂ÂèëËÆøÈóÆ„ÄÇ ÂΩìÊüê‰∏™CPUÁöÑËá™Áî±ÂàóË°®‰∏∫Á©∫Êó∂ÔºåÈúÄË¶Å‰ªéÂÖ∂‰ªñCPUÁöÑËá™Áî±ÂàóË°®‰∏≠‚ÄúÂÅ∑Âèñ‚ÄùÂÜÖÂ≠òÂùó„ÄÇ ÂÆûÁé∞Ë∑®CPUÁöÑÂÜÖÂ≠ò‚ÄúÂÅ∑Âèñ‚ÄùÔºö Â¶ÇÊûúÂΩìÂâçCPUÁöÑËá™Áî±ÂàóË°®‰∏∫Á©∫ÔºåÊü•ÊâæÂÖ∂‰ªñCPUÁöÑËá™Áî±ÂàóË°®ÔºåÂ∞ùËØï‰ªé‰∏≠‚ÄúÂÅ∑Âèñ‚ÄùÈÉ®ÂàÜÂÜÖÂ≠ò„ÄÇ ‚ÄúÂÅ∑Âèñ‚ÄùËøáÁ®ãÂèØËÉΩÂºïÂÖ•ÈîÅ‰∫âÁî®Ôºå‰ΩÜÁî±‰∫éÂÅ∑ÂèñÂèëÁîüËæÉÂ∞ëÔºåÂèØ‰ª•Â∞Ü‰∫âÁî®ÊéßÂà∂Âú®ËæÉ‰ΩéËåÉÂõ¥„ÄÇ ÈîÅÁöÑÂëΩÂêçÔºö Ê†πÊçÆË¶ÅÊ±ÇÔºåÊâÄÊúâÊ∂âÂèäÁöÑÈîÅÂøÖÈ°ª‰ª•‚Äúkmem‚ÄùÂºÄÂ§¥„ÄÇ‰Ω†ÂèØ‰ª•‰ΩøÁî®initlockÂáΩÊï∞Êù•ÂàùÂßãÂåñÈîÅÔºåÂπ∂‰ΩøÁî®ÂêàÈÄÇÁöÑÂêçÁß∞ÔºàÂ¶Çkmem_cpu0„ÄÅkmem_cpu1Á≠âÔºâ„ÄÇ ÊµãËØïÔºö ËøêË°åkalloctestÔºåËßÇÂØükmemÈîÅÁöÑ‰∫âÁî®ÊÉÖÂÜµÔºå‰∫âÁî®Ê¨°Êï∞Â∫îÊòéÊòæÂáèÂ∞ë„ÄÇ ËøêË°åusertests sbrkmuchÊµãËØïÂÜÖÂ≠òÂàÜÈÖçÂô®ÔºåÁ°Æ‰øùÊâÄÊúâÂÜÖÂ≠òÂàÜÈÖçÂíåÈáäÊîæÂäüËÉΩÊ≠£Â∏∏„ÄÇ ÂÆûÁé∞Ê≠•È™§Ôºö 1„ÄÅÂÆö‰πâÊØè‰∏™CPUÁöÑËá™Áî±ÂàóË°®Ôºö Âú®kmemÁªìÊûÑ‰∏≠ÔºåÊ∑ªÂä†‰∏Ä‰∏™Êï∞ÁªÑ‰øùÂ≠òÊØè‰∏™CPUÁöÑËá™Áî±ÂàóË°®ÂíåÂØπÂ∫îÁöÑÈîÅ struct { struct spinlock lock[NCPU]; struct run *freelist[NCPU]; } kmem; 2„ÄÅÂàùÂßãÂåñÊØè‰∏™CPUÁöÑÈîÅÂíåËá™Áî±ÂàóË°®Ôºö Âú®freerangeÂáΩÊï∞‰∏≠Ôºå‰∏∫ÂΩìÂâçCPUÁöÑËá™Áî±ÂàóË°®ÂàÜÈÖçÂÜÖÂ≠òÔºåÂπ∂Áî®initlock‰∏∫ÊØè‰∏™CPUÁöÑÈîÅËøõË°åÂàùÂßãÂåñÔºö 3„ÄÅ‰øÆÊîπkallocÂáΩÊï∞Ôºö ‰ΩøÁî®ÂΩìÂâçCPUÁöÑËá™Áî±ÂàóË°®ÂàÜÈÖçÂÜÖÂ≠òÔºåÂπ∂Âú®ÂàóË°®‰∏∫Á©∫Êó∂‰ªéÂÖ∂‰ªñCPUÁöÑËá™Áî±ÂàóË°®‰∏≠‚ÄúÂÅ∑Âèñ‚ÄùÂÜÖÂ≠òÔºö void * kalloc(void) { struct run *r; int id = cpuid(); push_off(); // ÂÖ≥Èó≠‰∏≠Êñ≠ÔºåÈò≤Ê≠¢Á´ûÊÄÅ acquire(\u0026kmem.lock[id]); r = kmem.freelist[id]; // ‰ªéÂΩìÂâçCPUÁöÑÁ©∫Èó≤ÂàóË°®‰∏≠ÂàÜÈÖç if (r) { kmem.freelist[id] = r-\u003enext; } // Â¶ÇÊûúÂΩìÂâçCPUÁ©∫Èó≤ÂàóË°®‰∏∫Á©∫ÔºåÂ∞ùËØï‰ªéÂÖ∂‰ªñCPUÁ™ÉÂèñÂÜÖÂ≠ò release(\u0026kmem.lock[id]); if (r == 0) { for (int i = 0; i \u003c NCPU; i++) { if (i != id) { acquire(\u0026kmem.lock[i]); r = kmem.freelist[i]; if (r) { kmem.freelist[i] = r-\u003enext; release(\u0026kmem.lock[i]); break; } release(\u0026kmem.lock[i]); } } } pop_off(); if (r) memset((char *)r, 5, PGSIZE); // fill with junk return (void *)r; } 4„ÄÅ‰øÆÊîπkfreeÂáΩÊï∞Ôºö Â∞ÜÈáäÊîæÁöÑÂÜÖÂ≠òÂùóÊîæÂÖ•ÂΩìÂâçCPUÁöÑËá™Áî±ÂàóË°®ÔºåÂπ∂‰ΩøÁî®ÂΩìÂâçCPUÁöÑÈîÅ‰øùÊä§Ôºö 5„ÄÅ(‰πãÂâçÁ¨¨3Ê≠•‰∏≠Â∑≤ÁªèÂåÖÊã¨‰∏ãÈù¢ÁöÑ‰ª£Á†ÅÂÆûÁé∞ÔºâÂÆûÁé∞‚ÄúÂÅ∑Âèñ‚ÄùÊú∫Âà∂Ôºö Âú®kallocÂáΩÊï∞‰∏≠ÔºåÂΩìÂΩìÂâçCPUÁöÑËá™Áî±ÂàóË°®‰∏∫Á©∫Êó∂ÔºåÈÅçÂéÜÂÖ∂‰ªñCPUÁöÑËá™Áî±ÂàóË°®Âπ∂‚ÄúÂÅ∑Âèñ‚ÄùÂÜÖÂ≠òÂùóÔºåÂÖ∑‰ΩìÈÄªËæëÂèØËÉΩÂ¶Ç‰∏ãÔºö for (int i = 0; i \u003c NCPU; i++) { if (i != id) { acquire(\u0026kmem.lock[i]); r = kmem.freelist[i]; if (r) { kmem.freelist[i] = r-\u003enext; release(\u0026kmem.lock[i]); break; } release(\u0026kmem.lock[i]); } } ÊúÄÁªàÊ£ÄÊü•Ôºö ËøêË°åkalloctestÂíåusertests sbrkmuchÔºåÁ°Æ‰øùÊâÄÊúâÂÜÖÂ≠òÂàÜÈÖç„ÄÅÈáäÊîæÂíåÂπ∂ÂèëÂ§ÑÁêÜÊ≠£Â∏∏ÔºåÂêåÊó∂ÈîÅ‰∫âÁî®ÊòæËëóÂáèÂ∞ë„ÄÇ Buffer cache (hard) ‰øÆÊîπ xv6 ÁöÑÂùóÁºìÂ≠òÔºàblock cacheÔºâÊú∫Âà∂ÔºåÂáèÂ∞ëÂ§ö‰∏™ËøõÁ®ãÂêåÊó∂ËÆøÈóÆÁºìÂ≠òÊó∂ÂØπÈîÅ bcache.lock ÁöÑ‰∫âÁî®„ÄÇ‰Ω†ÈúÄË¶ÅÁâπÂà´‰ºòÂåñ bget Âíå brelse ÂáΩÊï∞ÔºåÁ°Æ‰øùÂπ∂ÂèëËØªÂèñÂíåÈáäÊîæ‰∏çÂêåÁöÑÁºìÂ≠òÂùóÊó∂‰∏ç‰ºöÂÜ≤Á™Å„ÄÇÊúÄÁªàÁöÑÁõÆÊ†áÊòØËÆ©ËøêË°å bcachetest Êó∂ÔºåÊâÄÊúâ‰∏éÂùóÁºìÂ≠òÁõ∏ÂÖ≥ÁöÑÈîÅÁöÑËé∑ÂèñÊ¨°Êï∞Êé•ËøëÈõ∂ÔºàÁêÜÊÉ≥ÊÉÖÂÜµ‰∏ãÊÄªÂíåÂ∞è‰∫é500Ôºâ„ÄÇÊ≠§Â§ñÔºå‰Ω†ÈúÄË¶ÅÈÄöËøá usertests ÊµãËØïÔºåÂπ∂‰∏îÁ°Æ‰øùÂÆûÁé∞‰∏≠ÁöÑÈîÅÂêçÈÉΩ‰ª•‚Äúbcache‚ÄùÂºÄÂ§¥„ÄÇ\nÂÆûÁé∞Ê≠•È™§ËØ¶ÁªÜËØ¥ÊòéÔºö ÁêÜËß£Áé∞ÊúâÈîÅ‰∫âÁî®Ôºö bcache.lock ‰øùÊä§‰∫ÜÁºìÂ≠òÂùóÂàóË°®„ÄÅÁºìÂ≠òÂùóÁöÑÂºïÁî®ËÆ°Êï∞ b-\u003erefcnt ‰ª•ÂèäÁºìÂ≠òÂùóÁöÑÊ†áËØÜ b-\u003edev Âíå b-\u003eblockno„ÄÇÂ§ö‰∏™ËøõÁ®ãÂêåÊó∂ËÆøÈóÆÊó∂ÂèØËÉΩÂèëÁîüÈîÅ‰∫âÁî®„ÄÇ ‰ΩøÁî®ÂìàÂ∏åË°®Êõø‰ª£ÂÖ®Â±ÄÁºìÂ≠òÈîÅÔºö ‰ΩøÁî®‰∏Ä‰∏™ÂìàÂ∏åË°®Êù•Â≠òÂÇ®ÁºìÂ≠òÂùóÔºåÂπ∂‰∏∫ÊØè‰∏™ÂìàÂ∏åÊ°∂ËÆæÁΩÆÂçïÁã¨ÁöÑÈîÅ„ÄÇÈÄöËøáÂìàÂ∏åÂàÜÊ°∂Êú∫Âà∂Ôºå‰Ω†ÂèØ‰ª•ÂáèÂ∞ëÂπ∂ÂèëËÆøÈóÆ‰∏çÂêåÁºìÂ≠òÂùóÊó∂ÂØπÂêå‰∏Ä‰∏™ÈîÅÁöÑ‰∫âÁî®„ÄÇ ÂèØ‰ª•ÈÄâÊã©‰ΩøÁî®‰∏Ä‰∏™Ë¥®Êï∞Ôºà‰æãÂ¶Ç13Ôºâ‰Ωú‰∏∫ÂìàÂ∏åÊ°∂ÁöÑÊï∞ÈáèÔºå‰ª•ÂáèÂ∞ëÂìàÂ∏åÂÜ≤Á™ÅÁöÑÊ¶ÇÁéá„ÄÇ ‰øÆÊîπ bget Âíå brelseÔºö bgetÔºöËøôÊòØËé∑ÂèñÁºìÂ≠òÂùóÁöÑÂáΩÊï∞„ÄÇ‰Ω†ÈúÄË¶Å‰øÆÊîπÂÆÉÔºå‰ΩøÂæóÂú®Êü•ÊâæÂíåËé∑ÂèñÁºìÂ≠òÂùóÊó∂ÔºåÂè™ÂØπÁõ∏Â∫îÁöÑÂìàÂ∏åÊ°∂ËøõË°åÂä†ÈîÅÔºåËÄå‰∏çÊòØÂÖ®Â±ÄÂä†ÈîÅ„ÄÇÂêåÊó∂ÔºåÁ°Æ‰øùÂ¶ÇÊûúÁºìÂ≠ò‰∏≠Ê≤°ÊúâÂØπÂ∫îÁöÑÂùóÔºåÈúÄË¶ÅÈÄâÊã©‰∏Ä‰∏™ÊõøÊç¢ÂùóÊó∂ÔºåÊõøÊç¢ÈÄªËæëÊòØÂéüÂ≠êÁöÑÔºåÂπ∂‰∏îÈò≤Ê≠¢ÂìàÂ∏åÂÜ≤Á™ÅÂØºËá¥ÁöÑÊ≠ªÈîÅ„ÄÇ brelseÔºöËøôÊòØÈáäÊîæÁºìÂ≠òÂùóÁöÑÂáΩÊï∞„ÄÇ‰Ω†ÂèØ‰ª•ÈÄöËøá‰ΩøÁî®Êó∂Èó¥Êà≥ÔºàÂ¶Ç ticksÔºâÊù•ËÆ∞ÂΩïÁºìÂ≠òÂùóÁöÑÊúÄÂêé‰ΩøÁî®Êó∂Èó¥Ôºå‰ªéËÄåÈÅøÂÖçÂú®ÈáäÊîæÂùóÊó∂ÂøÖÈ°ªËé∑ÂèñÂÖ®Â±Ä bcache.lock„ÄÇÂΩì brelse Ë¢´Ë∞ÉÁî®Êó∂ÔºåÂè™ÈúÄË¶ÅÊõ¥Êñ∞Êó∂Èó¥Êà≥ÔºåËÄå‰∏çÈúÄË¶ÅÂä†ÈîÅ„ÄÇ ÊõøÊç¢ÁºìÂ≠òÂùóÁöÑÁÆ°ÁêÜÊú∫Âà∂Ôºö ÂèñÊ∂àÂÖ®Â±ÄÁºìÂ≠òÂùóÈìæË°®ÔºàÂ¶Ç bcache.head Á≠âÔºâÔºåËÄåÊòØÈÄöËøáÊó∂Èó¥Êà≥ËÆ∞ÂΩïÁºìÂ≠òÂùóÁöÑÊúÄÂêé‰ΩøÁî®Êó∂Èó¥„ÄÇËøôÊ†∑Ôºå‰Ω†ÂèØ‰ª•Âú® bget ‰∏≠Ê†πÊçÆÊó∂Èó¥Êà≥ÈÄâÊã©ÊúÄËøëÊú™‰ΩøÁî®ÁöÑÁºìÂ≠òÂùóÔºåËÄå‰∏çÈúÄË¶ÅÈÅçÂéÜÂÖ®Â±ÄÂàóË°®„ÄÇ Èò≤Ê≠¢Ê≠ªÈîÅÔºö Âú®ÁºìÂ≠òÊõøÊç¢ÂíåÂìàÂ∏åÊ°∂ÁßªÂä®Êó∂ÔºåÂèØËÉΩÈúÄË¶ÅÊåÅÊúâÂ§ö‰∏™ÈîÅÔºàÂ¶ÇÂÖ®Â±Ä bcache.lock ÂíåÂìàÂ∏åÊ°∂ÈîÅÔºâ„ÄÇ‰Ω†ÈúÄË¶ÅÂ∞èÂøÉÈÅøÂÖçÂú®ÈîÅÁöÑÈ°∫Â∫è‰∏äÂá∫Áé∞Ê≠ªÈîÅÁöÑÊÉÖÂÜµÔºåÁâπÂà´ÊòØÂú®ÁºìÂ≠òÂùó‰ªé‰∏Ä‰∏™ÂìàÂ∏åÊ°∂ÁßªÂä®Âà∞Âè¶‰∏Ä‰∏™Ê°∂Êó∂„ÄÇ ÈÄêÊ≠•Ë∞ÉËØïÔºö ‰Ω†ÂèØ‰ª•Âú®ÂÆûÁé∞ÂìàÂ∏åÊ°∂ÈîÅÂêéÔºåÂÖà‰øùÁïô bget ÂºÄÂßãÂíåÁªìÊùüÊó∂ÁöÑÂÖ®Â±ÄÈîÅ bcache.lockÔºå‰ª•Á°Æ‰øùÊ≤°ÊúâÁ´û‰∫âÊù°‰ª∂„ÄÇ‰∏ÄÊó¶È™åËØÅ‰ª£Á†ÅÊ≤°ÊúâÁ´ûÊÄÅÊù°‰ª∂ÂêéÔºåÂÜçÁßªÈô§ÂÖ®Â±ÄÈîÅÔºåÂ§ÑÁêÜÂπ∂ÂèëÈóÆÈ¢ò„ÄÇ ÂèØ‰ª•ËøêË°å make CPUS=1 qemu ËøõË°åÂçïÊ†∏ÊµãËØïÔºåÁ°Æ‰øùÂàùÊ≠•ÂÆûÁé∞Ê≠£Á°ÆÂêéÔºåÂÜçÊâ©Â±ïÂà∞Â§öÊ†∏ÁéØÂ¢É„ÄÇ usertests‰∏çÈÄöËøá\n// Buffer cache. // // The buffer cache is a linked list of buf structures holding // cached copies of disk block contents. Caching disk blocks // in memory reduces the number of disk reads and also provides // a synchronization point for disk blocks used by multiple processes. // // Interface: // * To get a buffer for a particular disk block, call bread. // * After changing buffer data, call bwrite to write it to disk. // * When done with the buffer, call brelse. // * Do not use the buffer after calling brelse. // * Only one process at a time can use a buffer, // so do not keep them longer than necessary. #include \"types.h\" #include \"param.h\" #include \"spinlock.h\" #include \"sleeplock.h\" #include \"riscv.h\" #include \"defs.h\" #include \"fs.h\" #include \"buf.h\" #define NBUCKETS 23 // ÂìàÂ∏åÊ°∂Êï∞ÈáèÔºå‰ΩøÁî®Ë¥®Êï∞‰ª•ÂáèÂ∞ëÂÜ≤Á™Å struct { struct spinlock lock; struct buf buf[NBUF]; // ÂÆûÈôÖÁöÑÁºìÂ≠òÂùó struct { struct buf *head; // ÊØè‰∏™Ê°∂ÁöÑÁºìÂ≠òÂùóÈìæË°® struct spinlock lock; // ÊØè‰∏™Ê°∂ÁöÑÈîÅ } buckets[NBUCKETS]; } bcache; // ËÆ°ÁÆóÂùóÂè∑ÂíåËÆæÂ§áÂè∑ÁöÑÂìàÂ∏åÂÄº static uint hash(uint dev, uint blockno) { return (dev ^ blockno) % NBUCKETS; } void binit(void) { struct buf *b; initlock(\u0026bcache.lock, \"bcache\"); // ÂàùÂßãÂåñÊØè‰∏™Ê°∂ÁöÑÈîÅ for (int i = 0; i \u003c NBUCKETS; i++) { initlock(\u0026bcache.buckets[i].lock, \"bcache.bucket\"); bcache.buckets[i].head = 0; } // ÂàùÂßãÂåñÁºìÂ≠òÂùó for (b = bcache.buf; b \u003c bcache.buf + NBUF; b++) { initsleeplock(\u0026b-\u003elock, \"buffer\"); b-\u003erefcnt = 0; } } // ‰øÆÊîπ bget ÂáΩÊï∞ËøõË°åÂìàÂ∏åË°®Êü•Êâæ // ‰∏∫‰∫Ü‰ΩøÁî®ÂìàÂ∏åË°®Ôºåbget ÂáΩÊï∞ÈúÄË¶ÅËøõË°å‰ª•‰∏ã‰øÆÊîπÔºö // ËÆ°ÁÆóÂùóÂè∑ÁöÑÂìàÂ∏åÂÄºÔºåÁ°ÆÂÆöÊâÄÂú®Ê°∂„ÄÇ // Ëé∑ÂèñÊ°∂ÁöÑÈîÅÔºåÂπ∂Âú®Ê°∂‰∏≠Êü•ÊâæÂùó„ÄÇ // Â¶ÇÊûúÊú™ÊâæÂà∞ÂùóÔºåÂàôÈÄâÊã©‰∏Ä‰∏™Êú™‰ΩøÁî®ÊàñÊúÄËøëÊúÄÂ∞ë‰ΩøÁî®ÁöÑÂùóËøõË°åÊõøÊç¢„ÄÇ static struct buf * bget(uint dev, uint blockno) { struct buf *b; uint h = hash(dev, blockno); acquire(\u0026bcache.buckets[h].lock); // Âú®Ê°∂‰∏≠Êü•ÊâæÂùó for (b = bcache.buckets[h].head; b; b = b-\u003enext) { if (b-\u003edev == dev \u0026\u0026 b-\u003eblockno == blockno) { b-\u003erefcnt++; release(\u0026bcache.buckets[h].lock); acquiresleep(\u0026b-\u003elock); return b; } } // Â¶ÇÊûúÊú™ÊâæÂà∞ÂùóÔºåÂ∞ùËØïÊâæÂà∞‰∏Ä‰∏™Êú™‰ΩøÁî®ÁöÑÂùóÊàñÊõøÊç¢ÊúÄËøëÊúÄÂ∞ë‰ΩøÁî®ÁöÑÂùó struct buf *lru = 0; for (b = bcache.buf; b \u003c bcache.buf + NBUF; b++) { if (b-\u003erefcnt == 0 \u0026\u0026 (lru == 0 || b-\u003elastuse \u003c lru-\u003elastuse)) lru = b; } if (lru == 0) panic(\"bget: no buffers\"); release(\u0026bcache.buckets[h].lock); // ‰ªéÊóßÊ°∂‰∏≠ÁßªÈô§Âùó h = hash(lru-\u003edev, lru-\u003eblockno); acquire(\u0026bcache.buckets[h].lock); struct buf **prev = \u0026bcache.buckets[h].head; for (b = bcache.buckets[h].head; b; prev = \u0026b-\u003enext, b = b-\u003enext) { if (b == lru) { *prev = b-\u003enext; break; } } // Â∞ÜÊñ∞ÂùóÊèíÂÖ•ÈÄÇÂΩìÁöÑÊ°∂ lru-\u003edev = dev; lru-\u003eblockno = blockno; lru-\u003evalid = 0; lru-\u003erefcnt = 1; lru-\u003elastuse = ticks; release(\u0026bcache.buckets[h].lock); h = hash(dev, blockno); acquire(\u0026bcache.buckets[h].lock); lru-\u003enext = bcache.buckets[h].head; bcache.buckets[h].head = lru; release(\u0026bcache.buckets[h].lock); acquiresleep(\u0026lru-\u003elock); return lru; } // Return a locked buf with the contents of the indicated block. struct buf * bread(uint dev, uint blockno) { struct buf *b; b = bget(dev, blockno); if (!b-\u003evalid) { virtio_disk_rw(b, 0); b-\u003evalid = 1; } return b; } // Write b's contents to disk. Must be locked. void bwrite(struct buf *b) { if (!holdingsleep(\u0026b-\u003elock)) panic(\"bwrite\"); virtio_disk_rw(b, 1); } // Release a locked buffer. // Move to the head of the most-recently-used list. void brelse(struct buf *b) { if (!holdingsleep(\u0026b-\u003elock)) panic(\"brelse\"); releasesleep(\u0026b-\u003elock); uint h = hash(b-\u003edev, b-\u003eblockno); acquire(\u0026bcache.buckets[h].lock); b-\u003erefcnt--; if (b-\u003erefcnt == 0) { // Âùó‰∏çÂÜçË¢´‰ΩøÁî®ÔºåÊõ¥Êñ∞Êó∂Èó¥Êà≥ b-\u003elastuse = ticks; } release(\u0026bcache.buckets[h].lock); } void bpin(struct buf *b) { uint h = hash(b-\u003edev, b-\u003eblockno); acquire(\u0026bcache.buckets[h].lock); b-\u003erefcnt++; release(\u0026bcache.buckets[h].lock); } void bunpin(struct buf *b) { uint h = hash(b-\u003edev, b-\u003eblockno); acquire(\u0026bcache.buckets[h].lock); b-\u003erefcnt--; release(\u0026bcache.buckets[h].lock); } // Buffer cache. // // The buffer cache is a linked list of buf structures holding // cached copies of disk block contents. Caching disk blocks // in memory reduces the number of disk reads and also provides // a synchronization point for disk blocks used by multiple processes. // // Interface: // * To get a buffer for a particular disk block, call bread. // * After changing buffer data, call bwrite to write it to disk. // * When done with the buffer, call brelse. // * Do not use the buffer after calling brelse. // * Only one process at a time can use a buffer, // so do not keep them longer than necessary. #include \"types.h\" #include \"param.h\" #include \"spinlock.h\" #include \"sleeplock.h\" #include \"riscv.h\" #include \"defs.h\" #include \"fs.h\" #include \"buf.h\" #define NBUCKET 13 #undef NBUF #define NBUF (NBUCKET * 3) struct { struct spinlock lock; struct buf buf[NBUF]; } bcache; struct bucket { struct spinlock lock; struct buf head; }hashtable[NBUCKET]; int hash(uint dev, uint blockno) { return blockno % NBUCKET; } void binit(void) { struct buf *b; initlock(\u0026bcache.lock, \"bcache\"); for(b = bcache.buf; b \u003c bcache.buf+NBUF; b++){ initsleeplock(\u0026b-\u003elock, \"buffer\"); } b = bcache.buf; for (int i = 0; i \u003c NBUCKET; i++) { initlock(\u0026hashtable[i].lock, \"bcache_bucket\"); for (int j = 0; j \u003c NBUF / NBUCKET; j++) { b-\u003eblockno = i; b-\u003enext = hashtable[i].head.next; hashtable[i].head.next = b; b++; } } } // Look through buffer cache for block on device dev. // If not found, allocate a buffer. // In either case, return locked buffer. static struct buf* bget(uint dev, uint blockno) { // printf(\"dev: %d blockno: %d Status: \", dev, blockno); struct buf *b; int idx = hash(dev, blockno); struct bucket* bucket = hashtable + idx; acquire(\u0026bucket-\u003elock); // Is the block already cached? for(b = bucket-\u003ehead.next; b != 0; b = b-\u003enext){ if(b-\u003edev == dev \u0026\u0026 b-\u003eblockno == blockno){ b-\u003erefcnt++; release(\u0026bucket-\u003elock); acquiresleep(\u0026b-\u003elock); // printf(\"Cached %p\\n\", b); return b; } } // Not cached. // First try to find in current bucket. int min_time = 0x8fffffff; struct buf* replace_buf = 0; for(b = bucket-\u003ehead.next; b != 0; b = b-\u003enext){ if(b-\u003erefcnt == 0 \u0026\u0026 b-\u003etimestamp \u003c min_time) { replace_buf = b; min_time = b-\u003etimestamp; } } if(replace_buf) { // printf(\"Local %d %p\\n\", idx, replace_buf); goto find; } // Try to find in other bucket. acquire(\u0026bcache.lock); refind: for(b = bcache.buf; b \u003c bcache.buf + NBUF; b++) { if(b-\u003erefcnt == 0 \u0026\u0026 b-\u003etimestamp \u003c min_time) { replace_buf = b; min_time = b-\u003etimestamp; } } if (replace_buf) { // remove from old bucket int ridx = hash(replace_buf-\u003edev, replace_buf-\u003eblockno); acquire(\u0026hashtable[ridx].lock); if(replace_buf-\u003erefcnt != 0) // be used in another bucket's local find between finded and acquire { release(\u0026hashtable[ridx].lock); goto refind; } struct buf *pre = \u0026hashtable[ridx].head; struct buf *p = hashtable[ridx].head.next; while (p != replace_buf) { pre = pre-\u003enext; p = p-\u003enext; } pre-\u003enext = p-\u003enext; release(\u0026hashtable[ridx].lock); // add to current bucket replace_buf-\u003enext = hashtable[idx].head.next; hashtable[idx].head.next = replace_buf; release(\u0026bcache.lock); // printf(\"Global %d -\u003e %d %p\\n\", ridx, idx, replace_buf); goto find; } else { panic(\"bget: no buffers\"); } find: replace_buf-\u003edev = dev; replace_buf-\u003eblockno = blockno; replace_buf-\u003evalid = 0; replace_buf-\u003erefcnt = 1; release(\u0026bucket-\u003elock); acquiresleep(\u0026replace_buf-\u003elock); return replace_buf; } // Return a locked buf with the contents of the indicated block. struct buf* bread(uint dev, uint blockno) { struct buf *b; b = bget(dev, blockno); if(!b-\u003evalid) { virtio_disk_rw(b, 0); b-\u003evalid = 1; } return b; } // Write b's contents to disk. Must be locked. void bwrite(struct buf *b) { if(!holdingsleep(\u0026b-\u003elock)) panic(\"bwrite\"); virtio_disk_rw(b, 1); } // Release a locked buffer. // Move to the head of the most-recently-used list. void brelse(struct buf *b) { if(!holdingsleep(\u0026b-\u003elock)) panic(\"brelse\"); releasesleep(\u0026b-\u003elock); int idx = hash(b-\u003edev, b-\u003eblockno); acquire(\u0026hashtable[idx].lock); b-\u003erefcnt--; if (b-\u003erefcnt == 0) { // no one is waiting for it. b-\u003etimestamp = ticks; } release(\u0026hashtable[idx].lock); } void bpin(struct buf *b) { int idx = hash(b-\u003edev, b-\u003eblockno); acquire(\u0026hashtable[idx].lock); b-\u003erefcnt++; release(\u0026hashtable[idx].lock); } void bunpin(struct buf *b) { int idx = hash(b-\u003edev, b-\u003eblockno); acquire(\u0026hashtable[idx].lock); b-\u003erefcnt--; release(\u0026hashtable[idx].lock); } ÂÆûÁé∞Ê≠•È™§ 1„ÄÅÂÆö‰πâÊ°∂Â§ßÂ∞èÔºå‰ª•ÂèäÂÖ®Â±ÄÁöÑbufferÂ§ßÂ∞è 2„ÄÅÊ∑ªÂä†bucketÁªìÊûÑ‰Ωì 3„ÄÅÂÆûÁé∞ÂìàÂ∏åÂáΩÊï∞ 4„ÄÅÂàùÂßãÂåñÂÆûÁé∞ÂÖ®Â±ÄbufferÂàùÂßãÂåñÔºå‰ª•ÂèäÊØè‰∏™Ê°∂ÂÜÖÁöÑbufferÂàùÂßãÂåñ void binit(void) { struct buf *b; initlock(\u0026bcache.lock, \"bcache\"); for (b = bcache.buf; b \u003c bcache.buf + NBUF; b++) { initsleeplock(\u0026b-\u003elock, \"buffer\"); b-\u003erefcnt = 0; } b = bcache.buf; for (int i = 0; i \u003c NBUCKET; i++) { initlock(\u0026hashtable[i].lock, \"bcache_bucket\"); for (int j = 0; j \u003c NBUF / NBUCKET; j++) { b-\u003eblockno = i; b-\u003erefcnt = 0; b-\u003enext = hashtable[i].head.next; hashtable[i].head.next = b; b++; } } } 5„ÄÅÈáçÁÇπÔºå ÈáçÊûÑbget()ÔºåÊ°∂ÂÜÖÂØªÊâæÊòØÂê¶Â∑≤ÁªèÁºìÂ≠ò-\u003eÊ°∂ÂÜÖÂØªÊâæÁ©∫ÁôΩÁºìÂ≠ò -\u003eÂØªÊâæÂÖ®Â±ÄÁ©∫ÁôΩÁºìÂ≠ò static struct buf * find_replacement_in_bucket(struct bucket *bucket, uint *min_time) { struct buf *replace_buf = 0; struct buf *b; for (b = bucket-\u003ehead.next; b != 0; b = b-\u003enext) { if (b-\u003erefcnt == 0 \u0026\u0026 (*min_time == 0 || b-\u003etimestamp \u003c *min_time)) { replace_buf = b; *min_time = b-\u003etimestamp; } } return replace_buf; } static struct buf * find_replacement_in_global(struct buf *replace_buf, uint *min_time) { struct buf *b; for (b = bcache.buf; b \u003c bcache.buf + NBUF; b++) { if (b-\u003erefcnt == 0 \u0026\u0026 (*min_time == 0 || b-\u003etimestamp \u003c *min_time)) { replace_buf = b; *min_time = b-\u003etimestamp; } } return replace_buf; } static void move_buf_to_bucket(struct buf *replace_buf, int idx) { int ridx = hash(replace_buf-\u003edev, replace_buf-\u003eblockno); acquire(\u0026hashtable[ridx].lock); if (replace_buf-\u003erefcnt == 0) { struct buf *pre = \u0026hashtable[ridx].head; struct buf *p = hashtable[ridx].head.next; while (p != replace_buf) { pre = pre-\u003enext; p = p-\u003enext; } pre-\u003enext = p-\u003enext; release(\u0026hashtable[ridx].lock); // Add to current bucket replace_buf-\u003enext = hashtable[idx].head.next; hashtable[idx].head.next = replace_buf; } else { release(\u0026hashtable[ridx].lock); } } static struct buf* bget(uint dev, uint blockno) { struct buf *b; int h = hash(dev, blockno); struct bucket *bucket = \u0026hashtable[h]; acquire(\u0026bucket-\u003elock); // Check if block is already cached Ê°∂ÂÜÖÂØªÊâæ for (b = bucket-\u003ehead.next; b != 0; b = b-\u003enext) { if (b-\u003edev == dev \u0026\u0026 b-\u003eblockno == blockno) { b-\u003erefcnt++; release(\u0026bucket-\u003elock); acquiresleep(\u0026b-\u003elock); return b; } } // Not cached, find replacement buffer Ê°∂ÂÜÖÁöÑÁ©∫ÁôΩbuf uint min_time = 0; struct buf *replace_buf; replace_buf = find_replacement_in_bucket(bucket, \u0026min_time); if (!replace_buf) { acquire(\u0026bcache.lock); // ÂØªÊâæÊ°∂Â§ñÁöÑÁ©∫ÁôΩbuf replace_buf = find_replacement_in_global(replace_buf, \u0026min_time); if (replace_buf) { move_buf_to_bucket(replace_buf, h); } else { release(\u0026bcache.lock); panic(\"bget: no buffers\"); } release(\u0026bcache.lock); } // Initialize and return the replacement buffer replace_buf-\u003edev = dev; replace_buf-\u003eblockno = blockno; replace_buf-\u003evalid = 0; replace_buf-\u003erefcnt = 1; release(\u0026bucket-\u003elock); acquiresleep(\u0026replace_buf-\u003elock); return replace_buf; } 6„ÄÅÈîÅÁöÑÈáäÊîæÔºåÊõ¥Êñ∞ÂºïÁî®ËÆ°Êï∞ÔºåÂΩìrefcnt == 0Êó∂Êõ¥Êñ∞Êó∂Èó¥Êà≥ 7„ÄÅÊõ¥Êñ∞ bpin() Âíå bunpin(), Âè™ÈúÄË¶ÅÊåÅÊúâÂØπÂ∫îÊ°∂ÁöÑÈîÅÂç≥ÂèØ\n",
  "wordCount" : "5655",
  "inLanguage": "zh",
  "datePublished": "2024-09-29T19:30:13+08:00",
  "dateModified": "2024-10-03T19:20:13+08:00",
  "author":{
    "@type": "Person",
    "name": "ShowGuan"
  },
  "mainEntityOfPage": {
    "@type": "WebPage",
    "@id": "https://kennems.github.io/posts/tech/mit6.s08113-coordination-sleepwakeup/"
  },
  "publisher": {
    "@type": "Organization",
    "name": "Kennem's Blog",
    "logo": {
      "@type": "ImageObject",
      "url": "https://kennems.github.io/img/sun.png"
    }
  }
}
</script>
<script src="https://cdn.jsdelivr.net/npm/jquery@3.5.1/dist/jquery.min.js"></script>
<link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.css" />
<script src="https://cdn.jsdelivr.net/gh/fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.js"></script>




</head>

<body class="" id="top">
<script>
    if (localStorage.getItem("pref-theme") === "dark") {
        document.body.classList.add('dark');
    } else if (localStorage.getItem("pref-theme") === "light") {
        document.body.classList.remove('dark')
    } else if (window.matchMedia('(prefers-color-scheme: dark)').matches) {
        document.body.classList.add('dark');
    }

</script>

<header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="https://kennems.github.io/" accesskey="h" title="Kennem&#39;s Blog (Alt + H)">
                <img src="https://kennems.github.io/img/sun.png" alt="" aria-label="logo"
                    height="35">Kennem&#39;s Blog</a>
            <div class="logo-switches">
                <button id="theme-toggle" accesskey="t" title="(Alt + T)">
                    <svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
                    </svg>
                    <svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <circle cx="12" cy="12" r="5"></circle>
                        <line x1="12" y1="1" x2="12" y2="3"></line>
                        <line x1="12" y1="21" x2="12" y2="23"></line>
                        <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                        <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                        <line x1="1" y1="12" x2="3" y2="12"></line>
                        <line x1="21" y1="12" x2="23" y2="12"></line>
                        <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                        <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
                    </svg>
                </button>
            </div>
        </div>
        <ul id="menu">
            <li>
                <a href="https://kennems.github.io/" title="üè†‰∏ªÈ°µ">
                    <span>üè†‰∏ªÈ°µ</span>
                </a>
            </li>
            <li>
                <a href="https://kennems.github.io/search" title="üîçÊêúÁ¥¢ (Alt &#43; /)" accesskey=/>
                    <span>üîçÊêúÁ¥¢</span>
                </a>
            </li>
            <li>
                <a href="https://kennems.github.io/posts" title="üìöÊñáÁ´†">
                    <span>üìöÊñáÁ´†</span>
                </a>
            </li>
            <li>
                <a href="https://kennems.github.io/archives" title="‚è±Êó∂Èó¥ËΩ¥">
                    <span>‚è±Êó∂Èó¥ËΩ¥</span>
                </a>
            </li>
            <li>
                <a href="https://kennems.github.io/tags" title="üîñÊ†áÁ≠æ">
                    <span>üîñÊ†áÁ≠æ</span>
                </a>
            </li>
            <li>
                <a href="https://kennems.github.io/categories" title="üóÇÔ∏èÂàÜÁ±ª">
                    <span>üóÇÔ∏èÂàÜÁ±ª</span>
                </a>
            </li>
            <li>
                <a href="https://kennems.github.io/about" title="üôãüèª‚Äç‚ôÇÔ∏èÂÖ≥‰∫é">
                    <span>üôãüèª‚Äç‚ôÇÔ∏èÂÖ≥‰∫é</span>
                </a>
            </li>
        </ul>
    </nav>
</header>
<main class="main">

<article class="post-single">
  <header class="post-header">
    <div class="breadcrumbs"><a href="https://kennems.github.io/">‰∏ªÈ°µ</a>&nbsp;¬ª&nbsp;<a href="https://kennems.github.io/posts/">üìöÊñáÁ´†</a>&nbsp;¬ª&nbsp;<a href="https://kennems.github.io/posts/tech/">üíªÊäÄÊúØ</a></div>
    <h1 class="post-title entry-hint-parent">
      MIT6.S081(13)-Coordination (sleep&amp;wakeup)
    </h1>
    <div class="post-description">
      MIT6.S081(13)-Coordination (sleep&amp;wakeup)
    </div>
    <div class="post-meta"><span title='2024-09-29 19:30:13 +0800 CST'>2024-09-29</span>&nbsp;¬∑&nbsp;12 ÂàÜÈíü&nbsp;¬∑&nbsp;5655 Â≠ó&nbsp;¬∑&nbsp;updated:&nbsp;2024-10-03&nbsp;¬∑&nbsp;ShowGuan

</div>
    
     <div class="post-password">
        
    </div>
  </header> <aside id="toc-container" class="toc-container wide">
    <div class="toc">
        <details  open>
            <summary accesskey="c" title="(Alt + C)">
                <span class="details">ÁõÆÂΩï</span>
            </summary>

            <div class="inner"><ul>
                    <li>
                        <a href="#mit6s08113-coordination-sleepwakeup" aria-label="MIT6.S081(13)-Coordination (sleep&amp;wakeup)">MIT6.S081(13)-Coordination (sleep&amp;wakeup)</a><ul>
                            
                    <li>
                        <a href="#plan" aria-label="plan">plan</a></li>
                    <li>
                        <a href="#why-hold-p-lock-across-swtch" aria-label="Why hold p-&gt;lock across swtch()?">Why hold <code>p-&gt;lock</code> across <code>swtch()</code>?</a><ul>
                            
                    <li>
                        <a href="#why-does-sched-forbid-spinlocks-from-being-held-when-yielding-the-cpu" aria-label="Why does sched() forbid spinlocks from being held when yielding the CPU?">Why does <code>sched()</code> forbid spinlocks from being held when yielding the CPU?</a></li></ul>
                    </li>
                    <li>
                        <a href="#topic-sequence-coordination" aria-label="topic: sequence coordination">topic: sequence coordination</a></li>
                    <li>
                        <a href="#why-not-just-have-a-while-loop-that-spins-until-event-happens" aria-label="why not just have a while-loop that spins until event happens?">why not just have a while-loop that spins until event happens?</a></li>
                    <li>
                        <a href="#example-uartwrite-and-uartintr-in-uartc" aria-label="example: uartwrite() and uartintr() in uart.c">example: <code>uartwrite()</code> and <code>uartintr()</code> in <code>uart.c</code></a></li>
                    <li>
                        <a href="#why-the-lock-argument-to-sleep" aria-label="Why the lock argument to sleep()?">Why the lock argument to <code>sleep()</code>?</a></li>
                    <li>
                        <a href="#suppose-just-sleepchan-how-would-we-implement" aria-label="suppose just sleep(chan); how would we implement?">suppose just <code>sleep(chan)</code>; how would we implement?</a></li>
                    <li>
                        <a href="#how-would-uart-code-use-this-broken-sleepwakeup" aria-label="how would uart code use this (broken) sleep/wakeup?">how would uart code use this (broken) sleep/wakeup?</a></li>
                    <li>
                        <a href="#but-what-about-locking" aria-label="but what about locking?">but what about locking?</a><ul>
                            
                    <li>
                        <a href="#what-goes-wrong-when-uartwrite-releases-the-lock-before-broken_sleep" aria-label="what goes wrong when uartwrite() releases the lock before broken_sleep()?">what goes wrong when uartwrite() releases the lock before broken_sleep()?</a></li>
                    <li>
                        <a href="#lets-look-at-wakeupchan-in-procc" aria-label="let&rsquo;s look at wakeup(chan) in proc.c">let&rsquo;s look at <code>wakeup(chan)</code> in <code>proc.c</code></a></li>
                    <li>
                        <a href="#q-how-can-sleep-prevent-wakeup-from-running-after-it-releases-the-condition-lock" aria-label="Q: how can sleep() prevent wakeup() from running after it releases the condition lock?">Q: how can <code>sleep()</code> prevent <code>wakeup()</code> from running after it releases the condition lock?</a><ul>
                            
                    <li>
                        <a href="#note-that-uartwrite-wraps-the-sleep-in-a-loop" aria-label="note that uartwrite() wraps the sleep() in a loop">note that <code>uartwrite()</code> wraps the sleep() in a loop</a><ul>
                            
                    <li>
                        <a href="#two-reasons" aria-label="two reasons:">two reasons:</a></li></ul>
                    </li></ul>
                    </li></ul>
                    </li>
                    <li>
                        <a href="#another-example-piperead" aria-label="Another example: piperead()">Another example: <code>piperead()</code></a></li>
                    <li>
                        <a href="#the-sleepwakeup-interfacerules-are-a-little-complex" aria-label="the sleep/wakeup interface/rules are a little complex">the sleep/wakeup interface/rules are a little complex</a></li>
                    <li>
                        <a href="#another-coordination-challenge----how-to-terminate-a-thread" aria-label="another coordination challenge &ndash; how to terminate a thread?">another coordination challenge &ndash; how to terminate a thread?</a></li>
                    <li>
                        <a href="#problem-thread-x-cannot-just-destroy-thread-y" aria-label="problem: thread X cannot just destroy thread Y">problem: thread X cannot just destroy thread Y</a></li>
                    <li>
                        <a href="#problem-a-thread-cannot-free-all-of-its-own-resources" aria-label="problem: a thread cannot free all of its own resources">problem: a thread cannot free all of its own resources</a></li>
                    <li>
                        <a href="#xv6-has-two-ways-to-get-rid-of-processes-exit-and-kill" aria-label="xv6 has two ways to get rid of processes: exit() and kill()">xv6 has two ways to get rid of processes: exit() and kill()</a></li>
                    <li>
                        <a href="#ordinary-case-process-voluntarily-quits-with-exit-system-call" aria-label="ordinary case: process voluntarily quits with exit() system call">ordinary case: process voluntarily quits with exit() system call</a></li>
                    <li>
                        <a href="#what-about-killpid" aria-label="what about kill(pid)?">what about <code>kill(pid)</code>?</a></li>
                    <li>
                        <a href="#what-if-kill-target-is-sleeping" aria-label="what if kill() target is sleep()ing?">what if <code>kill()</code> target is sleep()ing?</a></li>
                    <li>
                        <a href="#xv6-solution-to-kill-of-sleeping-process" aria-label="xv6 solution to kill() of sleep()ing process">xv6 solution to <code>kill()</code> of sleep()ing process</a></li>
                    <li>
                        <a href="#xv6-spec-for-kill" aria-label="xv6 spec for kill">xv6 spec for kill</a></li>
                    <li>
                        <a href="#summary" aria-label="Summary">Summary</a></li></ul>
                    </li>
                    <li>
                        <a href="#lab-lockshttpspdoscsailmitedu6s0812020labslockhtml" aria-label="Lab: locks"><a href="https://pdos.csail.mit.edu/6.S081/2020/labs/lock.html">Lab: locks</a></a><ul>
                            
                    <li>
                        <a href="#memory-allocator-moderatehttpspdoscsailmitedu6s0812020labsguidancehtml" aria-label="Memory allocator (moderate)">Memory allocator (<a href="https://pdos.csail.mit.edu/6.S081/2020/labs/guidance.html">moderate</a>)</a><ul>
                            
                    <li>
                        <a href="#%e4%bb%bb%e5%8a%a1%e5%88%86%e8%a7%a3" aria-label="‰ªªÂä°ÂàÜËß£Ôºö">‰ªªÂä°ÂàÜËß£Ôºö</a></li>
                    <li>
                        <a href="#%e5%ae%9e%e7%8e%b0%e6%ad%a5%e9%aa%a4" aria-label="ÂÆûÁé∞Ê≠•È™§Ôºö">ÂÆûÁé∞Ê≠•È™§Ôºö</a><ul>
                            
                    <li>
                        <a href="#1%e5%ae%9a%e4%b9%89%e6%af%8f%e4%b8%aacpu%e7%9a%84%e8%87%aa%e7%94%b1%e5%88%97%e8%a1%a8-%e5%9c%a8kmem%e7%bb%93%e6%9e%84%e4%b8%ad%e6%b7%bb%e5%8a%a0%e4%b8%80%e4%b8%aa%e6%95%b0%e7%bb%84%e4%bf%9d%e5%ad%98%e6%af%8f%e4%b8%aacpu%e7%9a%84%e8%87%aa%e7%94%b1%e5%88%97%e8%a1%a8%e5%92%8c%e5%af%b9%e5%ba%94%e7%9a%84%e9%94%81" aria-label="1„ÄÅÂÆö‰πâÊØè‰∏™CPUÁöÑËá™Áî±ÂàóË°®Ôºö Âú®kmemÁªìÊûÑ‰∏≠ÔºåÊ∑ªÂä†‰∏Ä‰∏™Êï∞ÁªÑ‰øùÂ≠òÊØè‰∏™CPUÁöÑËá™Áî±ÂàóË°®ÂíåÂØπÂ∫îÁöÑÈîÅ">1„ÄÅÂÆö‰πâÊØè‰∏™CPUÁöÑËá™Áî±ÂàóË°®Ôºö Âú®<code>kmem</code>ÁªìÊûÑ‰∏≠ÔºåÊ∑ªÂä†‰∏Ä‰∏™Êï∞ÁªÑ‰øùÂ≠òÊØè‰∏™CPUÁöÑËá™Áî±ÂàóË°®ÂíåÂØπÂ∫îÁöÑÈîÅ</a></li>
                    <li>
                        <a href="#2%e5%88%9d%e5%a7%8b%e5%8c%96%e6%af%8f%e4%b8%aacpu%e7%9a%84%e9%94%81%e5%92%8c%e8%87%aa%e7%94%b1%e5%88%97%e8%a1%a8-%e5%9c%a8freerange%e5%87%bd%e6%95%b0%e4%b8%ad%e4%b8%ba%e5%bd%93%e5%89%8dcpu%e7%9a%84%e8%87%aa%e7%94%b1%e5%88%97%e8%a1%a8%e5%88%86%e9%85%8d%e5%86%85%e5%ad%98%e5%b9%b6%e7%94%a8initlock%e4%b8%ba%e6%af%8f%e4%b8%aacpu%e7%9a%84%e9%94%81%e8%bf%9b%e8%a1%8c%e5%88%9d%e5%a7%8b%e5%8c%96" aria-label="2„ÄÅÂàùÂßãÂåñÊØè‰∏™CPUÁöÑÈîÅÂíåËá™Áî±ÂàóË°®Ôºö Âú®freerangeÂáΩÊï∞‰∏≠Ôºå‰∏∫ÂΩìÂâçCPUÁöÑËá™Áî±ÂàóË°®ÂàÜÈÖçÂÜÖÂ≠òÔºåÂπ∂Áî®initlock‰∏∫ÊØè‰∏™CPUÁöÑÈîÅËøõË°åÂàùÂßãÂåñÔºö">2„ÄÅÂàùÂßãÂåñÊØè‰∏™CPUÁöÑÈîÅÂíåËá™Áî±ÂàóË°®Ôºö Âú®<code>freerange</code>ÂáΩÊï∞‰∏≠Ôºå‰∏∫ÂΩìÂâçCPUÁöÑËá™Áî±ÂàóË°®ÂàÜÈÖçÂÜÖÂ≠òÔºåÂπ∂Áî®<code>initlock</code>‰∏∫ÊØè‰∏™CPUÁöÑÈîÅËøõË°åÂàùÂßãÂåñÔºö</a></li>
                    <li>
                        <a href="#3%e4%bf%ae%e6%94%b9kalloc%e5%87%bd%e6%95%b0-%e4%bd%bf%e7%94%a8%e5%bd%93%e5%89%8dcpu%e7%9a%84%e8%87%aa%e7%94%b1%e5%88%97%e8%a1%a8%e5%88%86%e9%85%8d%e5%86%85%e5%ad%98%e5%b9%b6%e5%9c%a8%e5%88%97%e8%a1%a8%e4%b8%ba%e7%a9%ba%e6%97%b6%e4%bb%8e%e5%85%b6%e4%bb%96cpu%e7%9a%84%e8%87%aa%e7%94%b1%e5%88%97%e8%a1%a8%e4%b8%ad%e5%81%b7%e5%8f%96%e5%86%85%e5%ad%98" aria-label="3„ÄÅ‰øÆÊîπkallocÂáΩÊï∞Ôºö ‰ΩøÁî®ÂΩìÂâçCPUÁöÑËá™Áî±ÂàóË°®ÂàÜÈÖçÂÜÖÂ≠òÔºåÂπ∂Âú®ÂàóË°®‰∏∫Á©∫Êó∂‰ªéÂÖ∂‰ªñCPUÁöÑËá™Áî±ÂàóË°®‰∏≠‚ÄúÂÅ∑Âèñ‚ÄùÂÜÖÂ≠òÔºö">3„ÄÅ‰øÆÊîπ<code>kalloc</code>ÂáΩÊï∞Ôºö ‰ΩøÁî®ÂΩìÂâçCPUÁöÑËá™Áî±ÂàóË°®ÂàÜÈÖçÂÜÖÂ≠òÔºåÂπ∂Âú®ÂàóË°®‰∏∫Á©∫Êó∂‰ªéÂÖ∂‰ªñCPUÁöÑËá™Áî±ÂàóË°®‰∏≠‚ÄúÂÅ∑Âèñ‚ÄùÂÜÖÂ≠òÔºö</a></li>
                    <li>
                        <a href="#4%e4%bf%ae%e6%94%b9kfree%e5%87%bd%e6%95%b0-%e5%b0%86%e9%87%8a%e6%94%be%e7%9a%84%e5%86%85%e5%ad%98%e5%9d%97%e6%94%be%e5%85%a5%e5%bd%93%e5%89%8dcpu%e7%9a%84%e8%87%aa%e7%94%b1%e5%88%97%e8%a1%a8%e5%b9%b6%e4%bd%bf%e7%94%a8%e5%bd%93%e5%89%8dcpu%e7%9a%84%e9%94%81%e4%bf%9d%e6%8a%a4" aria-label="4„ÄÅ‰øÆÊîπkfreeÂáΩÊï∞Ôºö Â∞ÜÈáäÊîæÁöÑÂÜÖÂ≠òÂùóÊîæÂÖ•ÂΩìÂâçCPUÁöÑËá™Áî±ÂàóË°®ÔºåÂπ∂‰ΩøÁî®ÂΩìÂâçCPUÁöÑÈîÅ‰øùÊä§Ôºö">4„ÄÅ‰øÆÊîπ<code>kfree</code>ÂáΩÊï∞Ôºö Â∞ÜÈáäÊîæÁöÑÂÜÖÂ≠òÂùóÊîæÂÖ•ÂΩìÂâçCPUÁöÑËá™Áî±ÂàóË°®ÔºåÂπ∂‰ΩøÁî®ÂΩìÂâçCPUÁöÑÈîÅ‰øùÊä§Ôºö</a></li>
                    <li>
                        <a href="#5%e4%b9%8b%e5%89%8d%e7%ac%ac3%e6%ad%a5%e4%b8%ad%e5%b7%b2%e7%bb%8f%e5%8c%85%e6%8b%ac%e4%b8%8b%e9%9d%a2%e7%9a%84%e4%bb%a3%e7%a0%81%e5%ae%9e%e7%8e%b0%e5%ae%9e%e7%8e%b0%e5%81%b7%e5%8f%96%e6%9c%ba%e5%88%b6-%e5%9c%a8kalloc%e5%87%bd%e6%95%b0%e4%b8%ad%e5%bd%93%e5%bd%93%e5%89%8dcpu%e7%9a%84%e8%87%aa%e7%94%b1%e5%88%97%e8%a1%a8%e4%b8%ba%e7%a9%ba%e6%97%b6%e9%81%8d%e5%8e%86%e5%85%b6%e4%bb%96cpu%e7%9a%84%e8%87%aa%e7%94%b1%e5%88%97%e8%a1%a8%e5%b9%b6%e5%81%b7%e5%8f%96%e5%86%85%e5%ad%98%e5%9d%97%e5%85%b7%e4%bd%93%e9%80%bb%e8%be%91%e5%8f%af%e8%83%bd%e5%a6%82%e4%b8%8b" aria-label="5„ÄÅ(‰πãÂâçÁ¨¨3Ê≠•‰∏≠Â∑≤ÁªèÂåÖÊã¨‰∏ãÈù¢ÁöÑ‰ª£Á†ÅÂÆûÁé∞ÔºâÂÆûÁé∞‚ÄúÂÅ∑Âèñ‚ÄùÊú∫Âà∂Ôºö Âú®kallocÂáΩÊï∞‰∏≠ÔºåÂΩìÂΩìÂâçCPUÁöÑËá™Áî±ÂàóË°®‰∏∫Á©∫Êó∂ÔºåÈÅçÂéÜÂÖ∂‰ªñCPUÁöÑËá™Áî±ÂàóË°®Âπ∂‚ÄúÂÅ∑Âèñ‚ÄùÂÜÖÂ≠òÂùóÔºåÂÖ∑‰ΩìÈÄªËæëÂèØËÉΩÂ¶Ç‰∏ãÔºö">5„ÄÅ(‰πãÂâçÁ¨¨3Ê≠•‰∏≠Â∑≤ÁªèÂåÖÊã¨‰∏ãÈù¢ÁöÑ‰ª£Á†ÅÂÆûÁé∞ÔºâÂÆûÁé∞‚ÄúÂÅ∑Âèñ‚ÄùÊú∫Âà∂Ôºö Âú®<code>kalloc</code>ÂáΩÊï∞‰∏≠ÔºåÂΩìÂΩìÂâçCPUÁöÑËá™Áî±ÂàóË°®‰∏∫Á©∫Êó∂ÔºåÈÅçÂéÜÂÖ∂‰ªñCPUÁöÑËá™Áî±ÂàóË°®Âπ∂‚ÄúÂÅ∑Âèñ‚ÄùÂÜÖÂ≠òÂùóÔºåÂÖ∑‰ΩìÈÄªËæëÂèØËÉΩÂ¶Ç‰∏ãÔºö</a></li></ul>
                    </li>
                    <li>
                        <a href="#%e6%9c%80%e7%bb%88%e6%a3%80%e6%9f%a5" aria-label="ÊúÄÁªàÊ£ÄÊü•Ôºö">ÊúÄÁªàÊ£ÄÊü•Ôºö</a></li></ul>
                    </li>
                    <li>
                        <a href="#buffer-cache-hardhttpspdoscsailmitedu6s0812020labsguidancehtml" aria-label="Buffer cache (hard)">Buffer cache (<a href="https://pdos.csail.mit.edu/6.S081/2020/labs/guidance.html">hard</a>)</a><ul>
                            
                    <li>
                        <a href="#%e5%ae%9e%e7%8e%b0%e6%ad%a5%e9%aa%a4%e8%af%a6%e7%bb%86%e8%af%b4%e6%98%8e" aria-label="ÂÆûÁé∞Ê≠•È™§ËØ¶ÁªÜËØ¥ÊòéÔºö">ÂÆûÁé∞Ê≠•È™§ËØ¶ÁªÜËØ¥ÊòéÔºö</a></li>
                    <li>
                        <a href="#%e5%ae%9e%e7%8e%b0%e6%ad%a5%e9%aa%a4-1" aria-label="ÂÆûÁé∞Ê≠•È™§">ÂÆûÁé∞Ê≠•È™§</a><ul>
                            
                    <li>
                        <a href="#1%e5%ae%9a%e4%b9%89%e6%a1%b6%e5%a4%a7%e5%b0%8f%e4%bb%a5%e5%8f%8a%e5%85%a8%e5%b1%80%e7%9a%84buffer%e5%a4%a7%e5%b0%8f" aria-label="1„ÄÅÂÆö‰πâÊ°∂Â§ßÂ∞èÔºå‰ª•ÂèäÂÖ®Â±ÄÁöÑbufferÂ§ßÂ∞è">1„ÄÅÂÆö‰πâÊ°∂Â§ßÂ∞èÔºå‰ª•ÂèäÂÖ®Â±ÄÁöÑbufferÂ§ßÂ∞è</a></li>
                    <li>
                        <a href="#2%e6%b7%bb%e5%8a%a0bucket%e7%bb%93%e6%9e%84%e4%bd%93" aria-label="2„ÄÅÊ∑ªÂä†bucketÁªìÊûÑ‰Ωì">2„ÄÅÊ∑ªÂä†bucketÁªìÊûÑ‰Ωì</a></li>
                    <li>
                        <a href="#3%e5%ae%9e%e7%8e%b0%e5%93%88%e5%b8%8c%e5%87%bd%e6%95%b0" aria-label="3„ÄÅÂÆûÁé∞ÂìàÂ∏åÂáΩÊï∞">3„ÄÅÂÆûÁé∞ÂìàÂ∏åÂáΩÊï∞</a></li>
                    <li>
                        <a href="#4%e5%88%9d%e5%a7%8b%e5%8c%96%e5%ae%9e%e7%8e%b0%e5%85%a8%e5%b1%80buffer%e5%88%9d%e5%a7%8b%e5%8c%96%e4%bb%a5%e5%8f%8a%e6%af%8f%e4%b8%aa%e6%a1%b6%e5%86%85%e7%9a%84buffer%e5%88%9d%e5%a7%8b%e5%8c%96" aria-label="4„ÄÅÂàùÂßãÂåñÂÆûÁé∞ÂÖ®Â±ÄbufferÂàùÂßãÂåñÔºå‰ª•ÂèäÊØè‰∏™Ê°∂ÂÜÖÁöÑbufferÂàùÂßãÂåñ">4„ÄÅÂàùÂßãÂåñÂÆûÁé∞ÂÖ®Â±ÄbufferÂàùÂßãÂåñÔºå‰ª•ÂèäÊØè‰∏™Ê°∂ÂÜÖÁöÑbufferÂàùÂßãÂåñ</a></li>
                    <li>
                        <a href="#5%e9%87%8d%e7%82%b9-%e9%87%8d%e6%9e%84bget%e6%a1%b6%e5%86%85%e5%af%bb%e6%89%be%e6%98%af%e5%90%a6%e5%b7%b2%e7%bb%8f%e7%bc%93%e5%ad%98-%e6%a1%b6%e5%86%85%e5%af%bb%e6%89%be%e7%a9%ba%e7%99%bd%e7%bc%93%e5%ad%98--%e5%af%bb%e6%89%be%e5%85%a8%e5%b1%80%e7%a9%ba%e7%99%bd%e7%bc%93%e5%ad%98" aria-label="5„ÄÅÈáçÁÇπÔºå ÈáçÊûÑbget()ÔºåÊ°∂ÂÜÖÂØªÊâæÊòØÂê¶Â∑≤ÁªèÁºìÂ≠ò-&gt;Ê°∂ÂÜÖÂØªÊâæÁ©∫ÁôΩÁºìÂ≠ò -&gt;ÂØªÊâæÂÖ®Â±ÄÁ©∫ÁôΩÁºìÂ≠ò">5„ÄÅÈáçÁÇπÔºå ÈáçÊûÑ<code>bget()</code>ÔºåÊ°∂ÂÜÖÂØªÊâæÊòØÂê¶Â∑≤ÁªèÁºìÂ≠ò<code>-&gt;</code>Ê°∂ÂÜÖÂØªÊâæÁ©∫ÁôΩÁºìÂ≠ò <code>-&gt;</code>ÂØªÊâæÂÖ®Â±ÄÁ©∫ÁôΩÁºìÂ≠ò</a></li>
                    <li>
                        <a href="#6%e9%94%81%e7%9a%84%e9%87%8a%e6%94%be%e6%9b%b4%e6%96%b0%e5%bc%95%e7%94%a8%e8%ae%a1%e6%95%b0%e5%bd%93refcnt--0%e6%97%b6%e6%9b%b4%e6%96%b0%e6%97%b6%e9%97%b4%e6%88%b3" aria-label="6„ÄÅÈîÅÁöÑÈáäÊîæÔºåÊõ¥Êñ∞ÂºïÁî®ËÆ°Êï∞ÔºåÂΩìrefcnt == 0Êó∂Êõ¥Êñ∞Êó∂Èó¥Êà≥">6„ÄÅÈîÅÁöÑÈáäÊîæÔºåÊõ¥Êñ∞ÂºïÁî®ËÆ°Êï∞ÔºåÂΩì<code>refcnt == 0</code>Êó∂Êõ¥Êñ∞Êó∂Èó¥Êà≥</a>
                    </li>
                </ul>
                </li>
                </ul>
                </li>
                </ul>
                </li>
                </ul>
            </div>
        </details>
    </div>
</aside>
<script>
    let activeElement;
    let elements;
    window.addEventListener('DOMContentLoaded', function (event) {
        checkTocPosition();

        elements = document.querySelectorAll('h1[id],h2[id],h3[id],h4[id],h5[id],h6[id]');
         
         activeElement = elements[0];
         const id = encodeURI(activeElement.getAttribute('id')).toLowerCase();
         document.querySelector(`.inner ul li a[href="#${id}"]`).classList.add('active');
     }, false);

    window.addEventListener('resize', function(event) {
        checkTocPosition();
    }, false);

    window.addEventListener('scroll', () => {
        
        activeElement = Array.from(elements).find((element) => {
            if ((getOffsetTop(element) - window.pageYOffset) > 0 && 
                (getOffsetTop(element) - window.pageYOffset) < window.innerHeight/2) {
                return element;
            }
        }) || activeElement

        elements.forEach(element => {
             const id = encodeURI(element.getAttribute('id')).toLowerCase();
             if (element === activeElement){
                 document.querySelector(`.inner ul li a[href="#${id}"]`).classList.add('active');
             } else {
                 document.querySelector(`.inner ul li a[href="#${id}"]`).classList.remove('active');
             }
         })
     }, false);

    const main = parseInt(getComputedStyle(document.body).getPropertyValue('--article-width'), 10);
    const toc = parseInt(getComputedStyle(document.body).getPropertyValue('--toc-width'), 10);
    const gap = parseInt(getComputedStyle(document.body).getPropertyValue('--gap'), 10);

    function checkTocPosition() {
        const width = document.body.scrollWidth;

        if (width - main - (toc * 2) - (gap * 4) > 0) {
            document.getElementById("toc-container").classList.add("wide");
        } else {
            document.getElementById("toc-container").classList.remove("wide");
        }
    }

    function getOffsetTop(element) {
        if (!element.getClientRects().length) {
            return 0;
        }
        let rect = element.getBoundingClientRect();
        let win = element.ownerDocument.defaultView;
        return rect.top + win.pageYOffset;   
    }
</script>

  <div class="post-content"><h1 id="mit6s08113-coordination-sleepwakeup">MIT6.S081(13)-Coordination (sleep&amp;wakeup)<a hidden class="anchor" aria-hidden="true" href="#mit6s08113-coordination-sleepwakeup">#</a></h1>
<h2 id="plan">plan<a hidden class="anchor" aria-hidden="true" href="#plan">#</a></h2>
<p>Re-emphasize a few points about xv6 thread switching
sequence coordination
sleep &amp; wakeup
lost wakeup problem
termination</p>
<h2 id="why-hold-p-lock-across-swtch">Why hold <code>p-&gt;lock</code> across <code>swtch()</code>?<a hidden class="anchor" aria-hidden="true" href="#why-hold-p-lock-across-swtch">#</a></h2>
<p>this is an important point and affects many situations in xv6
[diagram: P1, STACK1, swtch, STACK_SCHED]
<strong>yield:</strong></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span>     <span style="color:#a6e22e">acquire</span>(<span style="color:#f92672">&amp;</span>p<span style="color:#f92672">-&gt;</span>lock);
</span></span><span style="display:flex;"><span>     p<span style="color:#f92672">-&gt;</span>state <span style="color:#f92672">=</span> RUNNABLE;
</span></span><span style="display:flex;"><span>     <span style="color:#a6e22e">swtch</span>();
</span></span></code></pre></div><p><strong>scheduler:</strong></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span>     <span style="color:#a6e22e">swtch</span>();
</span></span><span style="display:flex;"><span>     <span style="color:#a6e22e">release</span>(<span style="color:#f92672">&amp;</span>p<span style="color:#f92672">-&gt;</span>lock);
</span></span></code></pre></div><p>the main point of holding <code>p-&gt;lock</code> across <code>swtch()</code>:
prevent another core&rsquo;s scheduler from seeing <code>p-&gt;state</code> == <code>RUNNABLE</code>
until after the original core has stopped executing the thread
and after the original core has stopped using the thread&rsquo;s stack</p>
<h3 id="why-does-sched-forbid-spinlocks-from-being-held-when-yielding-the-cpu">Why does <code>sched()</code> forbid spinlocks from being held when yielding the CPU?<a hidden class="anchor" aria-hidden="true" href="#why-does-sched-forbid-spinlocks-from-being-held-when-yielding-the-cpu">#</a></h3>
<p>(other than <code>p-&gt;lock</code>)
i.e. <code>sched()</code> checks that <code>noff == 1</code>
on a single-core machine, imagine this:</p>
<pre tabindex="0"><code>     P1           P2
     acq(L)
     sched()
                  acq(L)
</code></pre><p>this is a deadlock:
P2 will spin until P1 releases &ndash; and P2 won&rsquo;t yield the CPU
but P1 won&rsquo;t release until it runs again
with multiple cores, deadlock can also arise; more spinlocks must be involved
<strong>solution</strong>: do not hold spinlocks and yield the CPU!</p>
<h2 id="topic-sequence-coordination">topic: sequence coordination<a hidden class="anchor" aria-hidden="true" href="#topic-sequence-coordination">#</a></h2>
<p>threads need to wait for specific events or conditions:
wait for disk read to complete (event is from an interrupt)
wait for pipe writer to produce data (event is from a thread)
wait for any child to exit</p>
<p>coordination is a fundamental building-block for thread programming.</p>
<p>often straightforward to use.
but (like locks) subject to rules that sometimes present difficult puzzles.</p>
<h2 id="why-not-just-have-a-while-loop-that-spins-until-event-happens">why not just have a while-loop that spins until event happens?<a hidden class="anchor" aria-hidden="true" href="#why-not-just-have-a-while-loop-that-spins-until-event-happens">#</a></h2>
<p><strong>pipe read</strong>:</p>
<pre tabindex="0"><code>    while buffer is empty {
    }
</code></pre><p><strong>pipe write</strong>:</p>
<pre tabindex="0"><code>    put data in buffer
</code></pre><p><strong>better solution</strong>: coordination primitives that yield the CPU</p>
<p>there are a bunch e.g. <code>barriers</code>, <code>semaphores</code>, <code>event queues</code>.
xv6 uses <code>sleep &amp; wakeup</code></p>
<h2 id="example-uartwrite-and-uartintr-in-uartc">example: <code>uartwrite()</code> and <code>uartintr()</code> in <code>uart.c</code><a hidden class="anchor" aria-hidden="true" href="#example-uartwrite-and-uartintr-in-uartc">#</a></h2>
<p>I have modified these functions!
not the same as default xv6
see &ldquo;code&rdquo; link on schedule page
<strong>the basic idea</strong>:
the <code>UART</code> can only accept one (really a few) bytes of output at a time
takes a long time to send each byte, perhaps millisecond
processes writing the console must wait until UART sends prev char
the <code>UART</code> interrupts after it has sent each character
writing thread should give up the CPU until then
<code>write()</code> calls <code>uartwrite()</code>
<code>uartwrite()</code> writes first byte (if it can)
<code>uartwrite()</code> calls <code>sleep()</code> to wait for the UART&rsquo;s interrupt
<code>uartintr()</code> calls <code>wakeup()</code>
the &ldquo;<code>&amp;tx_chan</code>&rdquo; argument serves to link the sleep and wakeup
simple and flexible:
<code>sleep/wakeup</code> don&rsquo;t need to understand what you&rsquo;re waiting for
no need to allocate explicit coordination objects</p>
<h2 id="why-the-lock-argument-to-sleep">Why the lock argument to <code>sleep()</code>?<a hidden class="anchor" aria-hidden="true" href="#why-the-lock-argument-to-sleep">#</a></h2>
<p>sadly you cannot design <code>sleep()</code> as cleanly as you might hope
<code>sleep()</code> cannot simply be &ldquo;wait for this event&rdquo;
the problem is called &ldquo;lost wakeups&rdquo;
it lurks behind all sequence coordination schemes, and is a pain
here&rsquo;s the story</p>
<h2 id="suppose-just-sleepchan-how-would-we-implement">suppose just <code>sleep(chan)</code>; how would we implement?<a hidden class="anchor" aria-hidden="true" href="#suppose-just-sleepchan-how-would-we-implement">#</a></h2>
<p>here&rsquo;s a BROKEN sleep/wakeup
<code>broken_sleep(chan)</code>
sleeps on a &ldquo;channel&rdquo;, a number/address
identifies the condition/event we are waiting for</p>
<pre tabindex="0"><code>    p-&gt;state = SLEEPING;
    p-&gt;chan = chan;
    sched();
  wakeup(chan)
</code></pre><p>‚Äã    wakeup wakes up all threads sleeping on chan
‚Äã    may wake up more than one thread</p>
<pre tabindex="0"><code>    for each p:
      if p-&gt;state == SLEEPING &amp;&amp; p-&gt;chan == chan:
        p-&gt;state = RUNNABLE
</code></pre><h2 id="how-would-uart-code-use-this-broken-sleepwakeup">how would uart code use this (broken) sleep/wakeup?<a hidden class="anchor" aria-hidden="true" href="#how-would-uart-code-use-this-broken-sleepwakeup">#</a></h2>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span>  <span style="color:#66d9ef">int</span> done
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">uartwrite</span>(buf)<span style="color:#f92672">:</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span> each <span style="color:#66d9ef">char</span> c:
</span></span><span style="display:flex;"><span>      <span style="color:#66d9ef">while</span> not done:
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">sleep</span>(<span style="color:#f92672">&amp;</span>done)
</span></span><span style="display:flex;"><span>      send c
</span></span><span style="display:flex;"><span>      done <span style="color:#f92672">=</span> false
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">uartintr</span>()<span style="color:#f92672">:</span>
</span></span><span style="display:flex;"><span>    done <span style="color:#f92672">=</span> true
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">wakeup</span>(<span style="color:#f92672">&amp;</span>done)
</span></span><span style="display:flex;"><span>  done<span style="color:#f92672">==</span>true is the condition we<span style="color:#960050;background-color:#1e0010">&#39;</span>re waiting <span style="color:#66d9ef">for</span>
</span></span></code></pre></div><p>&amp;done is the sleep channel (not really related to the condition)</p>
<h2 id="but-what-about-locking">but what about locking?<a hidden class="anchor" aria-hidden="true" href="#but-what-about-locking">#</a></h2>
<p>driver&rsquo;s data structures e.g. done</p>
<p>UART hardware</p>
<p>both <code>uartwrite()</code> and <code>uartintr()</code> need to lock
should <code>uartwrite()</code> hold a lock for the whole sequence?
no: then <code>uartintr()</code> can&rsquo;t get lock and set done
maybe <code>uartwrite()</code> could release the lock before <code>sleep()</code>?
let&rsquo;s try it &ndash; modify <code>uart.c</code> to call <code>broken_sleep()</code></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#a6e22e">release</span>(<span style="color:#f92672">&amp;</span>uart_tx_lock);
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">broken_sleep</span>(<span style="color:#f92672">&amp;</span>tx_chan);
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">acquire</span>(<span style="color:#f92672">&amp;</span>uart_tx_lock);
</span></span></code></pre></div><h3 id="what-goes-wrong-when-uartwrite-releases-the-lock-before-broken_sleep">what goes wrong when uartwrite() releases the lock before broken_sleep()?<a hidden class="anchor" aria-hidden="true" href="#what-goes-wrong-when-uartwrite-releases-the-lock-before-broken_sleep">#</a></h3>
<p><code>uartwrite()</code> saw that the previous character wasn&rsquo;t yet done being sent
interrupt occurred after <code>release()</code>, before <code>broken_sleep()</code>
<code>uartwrite()</code> went to sleep EVEN THOUGH UART TX WAS DONE
now there is nothing to wake up uartwrite(), it will sleep forever</p>
<p>this is the &ldquo;lost wakeup&rdquo; problem.</p>
<p>we need to eliminate the window between uartwrite()&rsquo;s check of
the condition, and sleep() marking the process as asleep.
we&rsquo;ll use locks to prevent wakeup() from running during the entire window.</p>
<p>we&rsquo;ll change the sleep() interface and the way it&rsquo;s used.
we&rsquo;ll require that there be a lock that protects the
condition, and that the callers of both sleep() and
wakeup() hold the &ldquo;condition lock&rdquo;
sleep(chan, lock)
caller must hold lock
sleep releases lock, re-acquires before returning
wakeup(chan)
caller must hold lock
(repair uart.c)</p>
<h3 id="lets-look-at-wakeupchan-in-procc">let&rsquo;s look at <code>wakeup(chan)</code> in <code>proc.c</code><a hidden class="anchor" aria-hidden="true" href="#lets-look-at-wakeupchan-in-procc">#</a></h3>
<p>it scans the process table, looking for <code>SLEEPING</code> and chan
it grabs each <code>p-&gt;lock</code>
remember also that caller acquired condition lock before calling wakeup()
so wakeup() holds BOTH the condition lock and each <code>p-&gt;lock</code></p>
<p>let&rsquo;s look at <code>sleep()</code> in <code>proc.c</code>
sleep <em>must</em> release the condition lock
since we can&rsquo;t hold locks when calling swtch(), other than p-&gt;lock</p>
<h3 id="q-how-can-sleep-prevent-wakeup-from-running-after-it-releases-the-condition-lock">Q: how can <code>sleep()</code> prevent <code>wakeup()</code> from running after it releases the condition lock?<a hidden class="anchor" aria-hidden="true" href="#q-how-can-sleep-prevent-wakeup-from-running-after-it-releases-the-condition-lock">#</a></h3>
<p>A: acquire <code>p-&gt;lock</code> before releasing condition lock
since <code>wakeup()</code> holds <em>both</em> locks, it&rsquo;s enough for <code>sleep()</code> to hold <em>either</em>
in order to force wakeup() to spin rather than look at this process
now wakeup() can&rsquo;t proceed until after swtch() completes
so wakeup() is guaranteed to see <code>p-&gt;state==SLEEPING</code> and <code>p-&gt;chan==chan</code>
thus: no lost wakeups!</p>
<h4 id="note-that-uartwrite-wraps-the-sleep-in-a-loop">note that <code>uartwrite()</code> wraps the sleep() in a loop<a hidden class="anchor" aria-hidden="true" href="#note-that-uartwrite-wraps-the-sleep-in-a-loop">#</a></h4>
<p>i.e. re-checks the condition after <code>sleep()</code> returns, may sleep again</p>
<h5 id="two-reasons">two reasons:<a hidden class="anchor" aria-hidden="true" href="#two-reasons">#</a></h5>
<p>‚Äã    maybe multiple waiters, another thread might have consumed the event
‚Äã    <code>kill()</code> wakes up processes even when condition isn&rsquo;t true
all uses of sleep are wrapped in a loop, so they <strong>re-check</strong></p>
<h2 id="another-example-piperead">Another example: <code>piperead()</code><a hidden class="anchor" aria-hidden="true" href="#another-example-piperead">#</a></h2>
<p>the condition is data waiting to be read (nread != nwrite)
pipewrite() calls wakeup() at the end
what is the race if piperead() used broken_sleep()?
note the the loop around sleep()
multiple processes may be reading the same pipe
why the wakeup() at the end of piperead()?</p>
<h2 id="the-sleepwakeup-interfacerules-are-a-little-complex">the sleep/wakeup interface/rules are a little complex<a hidden class="anchor" aria-hidden="true" href="#the-sleepwakeup-interfacerules-are-a-little-complex">#</a></h2>
<p><code>sleep()</code> doesn&rsquo;t need to understand the condition, but it needs the condition lock
sleep/wakeup is pretty flexible, though low-level
there are other schemes that are cleaner but perhaps less general-purpose
e.g. the counting semaphore in today&rsquo;s reading
all have to cope with lost wakeups, one way or another</p>
<hr>
<h2 id="another-coordination-challenge----how-to-terminate-a-thread">another coordination challenge &ndash; how to terminate a thread?<a hidden class="anchor" aria-hidden="true" href="#another-coordination-challenge----how-to-terminate-a-thread">#</a></h2>
<p>a puzzle: we want need to free resources that might still be in use</p>
<h2 id="problem-thread-x-cannot-just-destroy-thread-y">problem: thread X cannot just destroy thread Y<a hidden class="anchor" aria-hidden="true" href="#problem-thread-x-cannot-just-destroy-thread-y">#</a></h2>
<p>what if Y is executing on another core?
what if Y holds locks?
what if Y is in the middle of a complex update to important data structures?</p>
<h2 id="problem-a-thread-cannot-free-all-of-its-own-resources">problem: a thread cannot free all of its own resources<a hidden class="anchor" aria-hidden="true" href="#problem-a-thread-cannot-free-all-of-its-own-resources">#</a></h2>
<p>e.g. its own stack, which it is still using
e.g. its struct context, which it may need to call <code>swtch()</code></p>
<h2 id="xv6-has-two-ways-to-get-rid-of-processes-exit-and-kill">xv6 has two ways to get rid of processes: exit() and kill()<a hidden class="anchor" aria-hidden="true" href="#xv6-has-two-ways-to-get-rid-of-processes-exit-and-kill">#</a></h2>
<h2 id="ordinary-case-process-voluntarily-quits-with-exit-system-call">ordinary case: process voluntarily quits with exit() system call<a hidden class="anchor" aria-hidden="true" href="#ordinary-case-process-voluntarily-quits-with-exit-system-call">#</a></h2>
<p>some freeing in <code>exit()</code>, some in parent&rsquo;s <code>wait()</code>
<code>exit()</code> in <code>proc.c</code>:</p>
<pre tabindex="0"><code>    close open files
    change parent of children to PID 1 (init)
    wake up wait()ing parent
    p-&gt;state = ZOMBIE
</code></pre><p>‚Äã      dying but not yet dead
‚Äã      won&rsquo;t run again
‚Äã      won&rsquo;t (yet) be re-allocated by <code>fork()</code>, eithe¬∑r
‚Äã    (note stack and proc[] entry are still allocated&hellip;)
‚Äã    <code>swtch()</code> to scheduler
<code>wait()</code> in <code>proc.c</code> (parent, or init, will eventually call):
‚Äã    sleep()s waiting for any child exit()
‚Äã    scans proc[] table for children with <code>p-&gt;state==ZOMBIE</code>
‚Äã    calls freeproc()
‚Äã      (<code>p-&gt;lock</code> held&hellip;)
‚Äã      trapframe, pagetable, &hellip;, <code>p-&gt;state=UNUSED</code>
thus: <code>wait()</code> is not just for app convenience, but for O/S as well
‚Äã    <em>every</em> process must be wait()ed for
‚Äã    thus the re-parenting of children of an exiting process
some complexity due to
‚Äã     child exits concurrently with its own parent
‚Äã     parent-then-child locking order to avoid deadlock</p>
<h2 id="what-about-killpid">what about <code>kill(pid)</code>?<a hidden class="anchor" aria-hidden="true" href="#what-about-killpid">#</a></h2>
<p>problem: may not be safe to forcibly terminate a process
it might be executing in the kernel
using its kernel stack, page table, proc[] entry, trapframe
it might hold locks
e.g. in the middle of fork()ing a new process
and must finish to restore invariants
so: kill() can&rsquo;t directly destroy the target!
solution:
kill() sets p-&gt;killed flag, nothing else
the target process itself checks for p-&gt;killed
and calls exit() itself
look for &ldquo;if(p-&gt;killed) exit(-1);&rdquo; in usertrap()
no locks are held at that point
so it&rsquo;s safe to exit()</p>
<h2 id="what-if-kill-target-is-sleeping">what if <code>kill()</code> target is sleep()ing?<a hidden class="anchor" aria-hidden="true" href="#what-if-kill-target-is-sleeping">#</a></h2>
<p>in that case it doesn&rsquo;t hold locks, and isn&rsquo;t executing!
is it OK for kill() destroy the target right away?
might be OK:
waiting for console input
might not be OK:
waiting for disk midway through file creation</p>
<h2 id="xv6-solution-to-kill-of-sleeping-process">xv6 solution to <code>kill()</code> of sleep()ing process<a hidden class="anchor" aria-hidden="true" href="#xv6-solution-to-kill-of-sleeping-process">#</a></h2>
<p>see kill() in <code>proc.c</code>
changes SLEEPING to RUNNABLE &ndash; like wakeup()
so sleep() will return, probably before condition is true
some sleep loops check for p-&gt;killed
e.g. piperead(), consoleread()
otherwise read could hang indefinitely for a killed process
some sleep loops don&rsquo;t check p-&gt;killed
e.g. virtio_disk.c
OK not to check p-&gt;killed since disk reads are pretty quick
so a kill()ed process may continue for a while
but usertrap() will exit() after the system call finishes</p>
<h2 id="xv6-spec-for-kill">xv6 spec for kill<a hidden class="anchor" aria-hidden="true" href="#xv6-spec-for-kill">#</a></h2>
<p>if target is in user space
will die next time it makes a system call or takes a timer interrupt
if target is in the kernel
target will never execute another user instruction
but may spend quite a while yet in the kernel</p>
<h2 id="summary">Summary<a hidden class="anchor" aria-hidden="true" href="#summary">#</a></h2>
<p>sleep/wakeup let threads wait for specific events
concurrency means we have to worry about lost wakeups
termination is a pain in threading systems</p>
<h1 id="lab-lockshttpspdoscsailmitedu6s0812020labslockhtml"><a href="https://pdos.csail.mit.edu/6.S081/2020/labs/lock.html">Lab: locks</a><a hidden class="anchor" aria-hidden="true" href="#lab-lockshttpspdoscsailmitedu6s0812020labslockhtml">#</a></h1>
<h2 id="memory-allocator-moderatehttpspdoscsailmitedu6s0812020labsguidancehtml">Memory allocator (<a href="https://pdos.csail.mit.edu/6.S081/2020/labs/guidance.html">moderate</a>)<a hidden class="anchor" aria-hidden="true" href="#memory-allocator-moderatehttpspdoscsailmitedu6s0812020labsguidancehtml">#</a></h2>
<p>‰ºòÂåñxv6ÁöÑÂÜÖÂ≠òÂàÜÈÖçÂô®ÔºåÂáèÂ∞ëÈîÅ‰∫âÁî®„ÄÇÂΩìÂâçÁöÑÂÆûÁé∞‰ΩøÁî®‰∏Ä‰∏™ÂÖ®Â±ÄÁöÑËá™Áî±ÂàóË°®ÂíåÂçï‰∏ÄÁöÑÈîÅ‰øùÊä§ÔºåÂØºËá¥Â§öÊ†∏Á≥ªÁªü‰∏≠Â§ö‰∏™ËøõÁ®ãÂπ∂ÂèëÊâßË°åÊó∂ÈîÅ‰∫âÁî®‰∏•Èáç„ÄÇ‰Ω†ÈúÄË¶ÅÂ∞ÜÂçï‰∏ÄËá™Áî±ÂàóË°®Êîπ‰∏∫ÊØè‰∏™CPUÈÉΩÊúâËá™Â∑±ÁöÑËá™Áî±ÂàóË°®ÔºåÊØè‰∏™Ëá™Áî±ÂàóË°®ÊúâËá™Â∑±ÁöÑÈîÅ„ÄÇËøôÊ†∑ÔºåÂ§ö‰∏™CPUÂèØ‰ª•Âπ∂Ë°åËøõË°åÂÜÖÂ≠òÂàÜÈÖçÂíåÈáäÊîæÔºå‰ªéËÄåÂáèÂ∞ëÈîÅ‰∫âÁî®„ÄÇ</p>
<h3 id="‰ªªÂä°ÂàÜËß£">‰ªªÂä°ÂàÜËß£Ôºö<a hidden class="anchor" aria-hidden="true" href="#‰ªªÂä°ÂàÜËß£">#</a></h3>
<ol>
<li><strong>ÂàõÂª∫ÊØè‰∏™CPUÁöÑËá™Áî±ÂàóË°®</strong>Ôºö
<ul>
<li>ÊØè‰∏™CPUÊúâËá™Â∑±Áã¨Á´ãÁöÑËá™Áî±ÂÜÖÂ≠òÂùóÂàóË°®ÔºåÂπ∂‰∏îÊØè‰∏™ÂàóË°®ÊúâËá™Â∑±ÁöÑÈîÅ„ÄÇ</li>
<li>‰ΩøÁî®<code>NCPU</code>ÔºàÂú®<code>param.h</code>‰∏≠ÂÆö‰πâÔºâÁ°ÆÂÆöCPUÁöÑÊï∞Èáè„ÄÇ</li>
<li>‰∏∫ÊØè‰∏™CPUÂàõÂª∫‰∏Ä‰∏™ÂØπÂ∫îÁöÑÈîÅÔºåÁî®‰∫é‰øùÊä§ÂÖ∂Ëá™Áî±ÂàóË°®„ÄÇ</li>
</ul>
</li>
<li><strong>‰øÆÊîπ<code>freerange</code>ÂáΩÊï∞</strong>Ôºö
<ul>
<li><code>freerange</code>Â∫îËØ•Ê†πÊçÆÂΩìÂâçCPUÔºåÂ∞ÜÁ©∫Èó≤ÂÜÖÂ≠òÂùóÂàÜÈÖçÂà∞ÂΩìÂâçCPUÁöÑËá™Áî±ÂàóË°®‰∏≠„ÄÇ‰Ω†ÂèØ‰ª•‰ΩøÁî®<code>cpuid</code>Êù•Ëé∑ÂèñÂΩìÂâçCPUÁºñÂè∑Ôºå‰ΩÜË¶ÅÁ°Æ‰øùË∞ÉÁî®ÂÆÉÊó∂‰∏≠Êñ≠Â∑≤ÂÖ≥Èó≠„ÄÇ</li>
<li>‰ΩøÁî®<code>push_off()</code>Âíå<code>pop_off()</code>Êù•ÂÖ≥Èó≠ÂíåÂºÄÂêØ‰∏≠Êñ≠Ôºå‰øùËØÅË∞ÉÁî®<code>cpuid</code>Êó∂ÁöÑÂÆâÂÖ®ÊÄß„ÄÇ</li>
</ul>
</li>
<li><strong>ÂÆûÁé∞ÂÜÖÂ≠òÂàÜÈÖçÂíåÈáäÊîæ</strong>Ôºö
<ul>
<li>‰øÆÊîπ<code>kalloc</code>Âíå<code>kfree</code>Ôºå‰ΩøÂÆÉ‰ª¨Âè™Êìç‰ΩúÂΩìÂâçCPUÁöÑËá™Áî±ÂàóË°®„ÄÇÈÄöËøá‰ΩøÁî®ÂΩìÂâçCPUÁöÑÈîÅÊù•‰øùÊä§Âπ∂ÂèëËÆøÈóÆ„ÄÇ</li>
<li>ÂΩìÊüê‰∏™CPUÁöÑËá™Áî±ÂàóË°®‰∏∫Á©∫Êó∂ÔºåÈúÄË¶Å‰ªéÂÖ∂‰ªñCPUÁöÑËá™Áî±ÂàóË°®‰∏≠‚ÄúÂÅ∑Âèñ‚ÄùÂÜÖÂ≠òÂùó„ÄÇ</li>
</ul>
</li>
<li><strong>ÂÆûÁé∞Ë∑®CPUÁöÑÂÜÖÂ≠ò‚ÄúÂÅ∑Âèñ‚Äù</strong>Ôºö
<ul>
<li>Â¶ÇÊûúÂΩìÂâçCPUÁöÑËá™Áî±ÂàóË°®‰∏∫Á©∫ÔºåÊü•ÊâæÂÖ∂‰ªñCPUÁöÑËá™Áî±ÂàóË°®ÔºåÂ∞ùËØï‰ªé‰∏≠‚ÄúÂÅ∑Âèñ‚ÄùÈÉ®ÂàÜÂÜÖÂ≠ò„ÄÇ</li>
<li>‚ÄúÂÅ∑Âèñ‚ÄùËøáÁ®ãÂèØËÉΩÂºïÂÖ•ÈîÅ‰∫âÁî®Ôºå‰ΩÜÁî±‰∫éÂÅ∑ÂèñÂèëÁîüËæÉÂ∞ëÔºåÂèØ‰ª•Â∞Ü‰∫âÁî®ÊéßÂà∂Âú®ËæÉ‰ΩéËåÉÂõ¥„ÄÇ</li>
</ul>
</li>
<li><strong>ÈîÅÁöÑÂëΩÂêç</strong>Ôºö
<ul>
<li>Ê†πÊçÆË¶ÅÊ±ÇÔºåÊâÄÊúâÊ∂âÂèäÁöÑÈîÅÂøÖÈ°ª‰ª•‚Äúkmem‚ÄùÂºÄÂ§¥„ÄÇ‰Ω†ÂèØ‰ª•‰ΩøÁî®<code>initlock</code>ÂáΩÊï∞Êù•ÂàùÂßãÂåñÈîÅÔºåÂπ∂‰ΩøÁî®ÂêàÈÄÇÁöÑÂêçÁß∞ÔºàÂ¶Ç<code>kmem_cpu0</code>„ÄÅ<code>kmem_cpu1</code>Á≠âÔºâ„ÄÇ</li>
</ul>
</li>
<li><strong>ÊµãËØï</strong>Ôºö
<ul>
<li>ËøêË°å<code>kalloctest</code>ÔºåËßÇÂØükmemÈîÅÁöÑ‰∫âÁî®ÊÉÖÂÜµÔºå‰∫âÁî®Ê¨°Êï∞Â∫îÊòéÊòæÂáèÂ∞ë„ÄÇ</li>
<li>ËøêË°å<code>usertests sbrkmuch</code>ÊµãËØïÂÜÖÂ≠òÂàÜÈÖçÂô®ÔºåÁ°Æ‰øùÊâÄÊúâÂÜÖÂ≠òÂàÜÈÖçÂíåÈáäÊîæÂäüËÉΩÊ≠£Â∏∏„ÄÇ</li>
</ul>
</li>
</ol>
<h3 id="ÂÆûÁé∞Ê≠•È™§">ÂÆûÁé∞Ê≠•È™§Ôºö<a hidden class="anchor" aria-hidden="true" href="#ÂÆûÁé∞Ê≠•È™§">#</a></h3>
<h4 id="1ÂÆö‰πâÊØè‰∏™cpuÁöÑËá™Áî±ÂàóË°®-Âú®kmemÁªìÊûÑ‰∏≠Ê∑ªÂä†‰∏Ä‰∏™Êï∞ÁªÑ‰øùÂ≠òÊØè‰∏™cpuÁöÑËá™Áî±ÂàóË°®ÂíåÂØπÂ∫îÁöÑÈîÅ">1„ÄÅÂÆö‰πâÊØè‰∏™CPUÁöÑËá™Áî±ÂàóË°®Ôºö Âú®<code>kmem</code>ÁªìÊûÑ‰∏≠ÔºåÊ∑ªÂä†‰∏Ä‰∏™Êï∞ÁªÑ‰øùÂ≠òÊØè‰∏™CPUÁöÑËá™Áî±ÂàóË°®ÂíåÂØπÂ∫îÁöÑÈîÅ<a hidden class="anchor" aria-hidden="true" href="#1ÂÆö‰πâÊØè‰∏™cpuÁöÑËá™Áî±ÂàóË°®-Âú®kmemÁªìÊûÑ‰∏≠Ê∑ªÂä†‰∏Ä‰∏™Êï∞ÁªÑ‰øùÂ≠òÊØè‰∏™cpuÁöÑËá™Áî±ÂàóË°®ÂíåÂØπÂ∫îÁöÑÈîÅ">#</a></h4>
<p>

    <div class="post-img-view">
        <a data-fancybox="gallery" href="https://raw.githubusercontent.com/Kennems/blog-image/main/image-20241003143642968.png">
            <img src="https://raw.githubusercontent.com/Kennems/blog-image/main/image-20241003143642968.png" alt="image-20241003143642968"  />
        </a>
    </div>

</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#66d9ef">struct</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">struct</span> spinlock lock[NCPU];
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">struct</span> run <span style="color:#f92672">*</span>freelist[NCPU];
</span></span><span style="display:flex;"><span>} kmem;
</span></span></code></pre></div><h4 id="2ÂàùÂßãÂåñÊØè‰∏™cpuÁöÑÈîÅÂíåËá™Áî±ÂàóË°®-Âú®freerangeÂáΩÊï∞‰∏≠‰∏∫ÂΩìÂâçcpuÁöÑËá™Áî±ÂàóË°®ÂàÜÈÖçÂÜÖÂ≠òÂπ∂Áî®initlock‰∏∫ÊØè‰∏™cpuÁöÑÈîÅËøõË°åÂàùÂßãÂåñ">2„ÄÅÂàùÂßãÂåñÊØè‰∏™CPUÁöÑÈîÅÂíåËá™Áî±ÂàóË°®Ôºö Âú®<code>freerange</code>ÂáΩÊï∞‰∏≠Ôºå‰∏∫ÂΩìÂâçCPUÁöÑËá™Áî±ÂàóË°®ÂàÜÈÖçÂÜÖÂ≠òÔºåÂπ∂Áî®<code>initlock</code>‰∏∫ÊØè‰∏™CPUÁöÑÈîÅËøõË°åÂàùÂßãÂåñÔºö<a hidden class="anchor" aria-hidden="true" href="#2ÂàùÂßãÂåñÊØè‰∏™cpuÁöÑÈîÅÂíåËá™Áî±ÂàóË°®-Âú®freerangeÂáΩÊï∞‰∏≠‰∏∫ÂΩìÂâçcpuÁöÑËá™Áî±ÂàóË°®ÂàÜÈÖçÂÜÖÂ≠òÂπ∂Áî®initlock‰∏∫ÊØè‰∏™cpuÁöÑÈîÅËøõË°åÂàùÂßãÂåñ">#</a></h4>
<p>

    <div class="post-img-view">
        <a data-fancybox="gallery" href="https://raw.githubusercontent.com/Kennems/blog-image/main/image-20241003143820586.png">
            <img src="https://raw.githubusercontent.com/Kennems/blog-image/main/image-20241003143820586.png" alt="image-20241003143820586"  />
        </a>
    </div>

</p>
<h4 id="3‰øÆÊîπkallocÂáΩÊï∞-‰ΩøÁî®ÂΩìÂâçcpuÁöÑËá™Áî±ÂàóË°®ÂàÜÈÖçÂÜÖÂ≠òÂπ∂Âú®ÂàóË°®‰∏∫Á©∫Êó∂‰ªéÂÖ∂‰ªñcpuÁöÑËá™Áî±ÂàóË°®‰∏≠ÂÅ∑ÂèñÂÜÖÂ≠ò">3„ÄÅ‰øÆÊîπ<code>kalloc</code>ÂáΩÊï∞Ôºö ‰ΩøÁî®ÂΩìÂâçCPUÁöÑËá™Áî±ÂàóË°®ÂàÜÈÖçÂÜÖÂ≠òÔºåÂπ∂Âú®ÂàóË°®‰∏∫Á©∫Êó∂‰ªéÂÖ∂‰ªñCPUÁöÑËá™Áî±ÂàóË°®‰∏≠‚ÄúÂÅ∑Âèñ‚ÄùÂÜÖÂ≠òÔºö<a hidden class="anchor" aria-hidden="true" href="#3‰øÆÊîπkallocÂáΩÊï∞-‰ΩøÁî®ÂΩìÂâçcpuÁöÑËá™Áî±ÂàóË°®ÂàÜÈÖçÂÜÖÂ≠òÂπ∂Âú®ÂàóË°®‰∏∫Á©∫Êó∂‰ªéÂÖ∂‰ªñcpuÁöÑËá™Áî±ÂàóË°®‰∏≠ÂÅ∑ÂèñÂÜÖÂ≠ò">#</a></h4>
<p>

    <div class="post-img-view">
        <a data-fancybox="gallery" href="https://raw.githubusercontent.com/Kennems/blog-image/main/image-20241003144029474.png">
            <img src="https://raw.githubusercontent.com/Kennems/blog-image/main/image-20241003144029474.png" alt="image-20241003144029474"  />
        </a>
    </div>

</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#66d9ef">void</span> <span style="color:#f92672">*</span>
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">kalloc</span>(<span style="color:#66d9ef">void</span>)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">struct</span> run <span style="color:#f92672">*</span>r;
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">int</span> id <span style="color:#f92672">=</span> <span style="color:#a6e22e">cpuid</span>();
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">push_off</span>(); <span style="color:#75715e">// ÂÖ≥Èó≠‰∏≠Êñ≠ÔºåÈò≤Ê≠¢Á´ûÊÄÅ
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  <span style="color:#a6e22e">acquire</span>(<span style="color:#f92672">&amp;</span>kmem.lock[id]);
</span></span><span style="display:flex;"><span>  r <span style="color:#f92672">=</span> kmem.freelist[id]; <span style="color:#75715e">// ‰ªéÂΩìÂâçCPUÁöÑÁ©∫Èó≤ÂàóË°®‰∏≠ÂàÜÈÖç
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  <span style="color:#66d9ef">if</span> (r)
</span></span><span style="display:flex;"><span>  {
</span></span><span style="display:flex;"><span>    kmem.freelist[id] <span style="color:#f92672">=</span> r<span style="color:#f92672">-&gt;</span>next;
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>  <span style="color:#75715e">// Â¶ÇÊûúÂΩìÂâçCPUÁ©∫Èó≤ÂàóË°®‰∏∫Á©∫ÔºåÂ∞ùËØï‰ªéÂÖ∂‰ªñCPUÁ™ÉÂèñÂÜÖÂ≠ò
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  <span style="color:#a6e22e">release</span>(<span style="color:#f92672">&amp;</span>kmem.lock[id]);
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">if</span> (r <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span>)
</span></span><span style="display:flex;"><span>  {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; i <span style="color:#f92672">&lt;</span> NCPU; i<span style="color:#f92672">++</span>)
</span></span><span style="display:flex;"><span>    {
</span></span><span style="display:flex;"><span>      <span style="color:#66d9ef">if</span> (i <span style="color:#f92672">!=</span> id)
</span></span><span style="display:flex;"><span>      {
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">acquire</span>(<span style="color:#f92672">&amp;</span>kmem.lock[i]);
</span></span><span style="display:flex;"><span>        r <span style="color:#f92672">=</span> kmem.freelist[i];
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> (r)
</span></span><span style="display:flex;"><span>        {
</span></span><span style="display:flex;"><span>          kmem.freelist[i] <span style="color:#f92672">=</span> r<span style="color:#f92672">-&gt;</span>next;
</span></span><span style="display:flex;"><span>          <span style="color:#a6e22e">release</span>(<span style="color:#f92672">&amp;</span>kmem.lock[i]);
</span></span><span style="display:flex;"><span>          <span style="color:#66d9ef">break</span>;
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">release</span>(<span style="color:#f92672">&amp;</span>kmem.lock[i]);
</span></span><span style="display:flex;"><span>      }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">pop_off</span>();
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">if</span> (r)
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">memset</span>((<span style="color:#66d9ef">char</span> <span style="color:#f92672">*</span>)r, <span style="color:#ae81ff">5</span>, PGSIZE); <span style="color:#75715e">// fill with junk
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  <span style="color:#66d9ef">return</span> (<span style="color:#66d9ef">void</span> <span style="color:#f92672">*</span>)r;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h4 id="4‰øÆÊîπkfreeÂáΩÊï∞-Â∞ÜÈáäÊîæÁöÑÂÜÖÂ≠òÂùóÊîæÂÖ•ÂΩìÂâçcpuÁöÑËá™Áî±ÂàóË°®Âπ∂‰ΩøÁî®ÂΩìÂâçcpuÁöÑÈîÅ‰øùÊä§">4„ÄÅ‰øÆÊîπ<code>kfree</code>ÂáΩÊï∞Ôºö Â∞ÜÈáäÊîæÁöÑÂÜÖÂ≠òÂùóÊîæÂÖ•ÂΩìÂâçCPUÁöÑËá™Áî±ÂàóË°®ÔºåÂπ∂‰ΩøÁî®ÂΩìÂâçCPUÁöÑÈîÅ‰øùÊä§Ôºö<a hidden class="anchor" aria-hidden="true" href="#4‰øÆÊîπkfreeÂáΩÊï∞-Â∞ÜÈáäÊîæÁöÑÂÜÖÂ≠òÂùóÊîæÂÖ•ÂΩìÂâçcpuÁöÑËá™Áî±ÂàóË°®Âπ∂‰ΩøÁî®ÂΩìÂâçcpuÁöÑÈîÅ‰øùÊä§">#</a></h4>
<p>

    <div class="post-img-view">
        <a data-fancybox="gallery" href="https://raw.githubusercontent.com/Kennems/blog-image/main/image-20241003144110207.png">
            <img src="https://raw.githubusercontent.com/Kennems/blog-image/main/image-20241003144110207.png" alt="image-20241003144110207"  />
        </a>
    </div>

</p>
<h4 id="5‰πãÂâçÁ¨¨3Ê≠•‰∏≠Â∑≤ÁªèÂåÖÊã¨‰∏ãÈù¢ÁöÑ‰ª£Á†ÅÂÆûÁé∞ÂÆûÁé∞ÂÅ∑ÂèñÊú∫Âà∂-Âú®kallocÂáΩÊï∞‰∏≠ÂΩìÂΩìÂâçcpuÁöÑËá™Áî±ÂàóË°®‰∏∫Á©∫Êó∂ÈÅçÂéÜÂÖ∂‰ªñcpuÁöÑËá™Áî±ÂàóË°®Âπ∂ÂÅ∑ÂèñÂÜÖÂ≠òÂùóÂÖ∑‰ΩìÈÄªËæëÂèØËÉΩÂ¶Ç‰∏ã">5„ÄÅ(‰πãÂâçÁ¨¨3Ê≠•‰∏≠Â∑≤ÁªèÂåÖÊã¨‰∏ãÈù¢ÁöÑ‰ª£Á†ÅÂÆûÁé∞ÔºâÂÆûÁé∞‚ÄúÂÅ∑Âèñ‚ÄùÊú∫Âà∂Ôºö Âú®<code>kalloc</code>ÂáΩÊï∞‰∏≠ÔºåÂΩìÂΩìÂâçCPUÁöÑËá™Áî±ÂàóË°®‰∏∫Á©∫Êó∂ÔºåÈÅçÂéÜÂÖ∂‰ªñCPUÁöÑËá™Áî±ÂàóË°®Âπ∂‚ÄúÂÅ∑Âèñ‚ÄùÂÜÖÂ≠òÂùóÔºåÂÖ∑‰ΩìÈÄªËæëÂèØËÉΩÂ¶Ç‰∏ãÔºö<a hidden class="anchor" aria-hidden="true" href="#5‰πãÂâçÁ¨¨3Ê≠•‰∏≠Â∑≤ÁªèÂåÖÊã¨‰∏ãÈù¢ÁöÑ‰ª£Á†ÅÂÆûÁé∞ÂÆûÁé∞ÂÅ∑ÂèñÊú∫Âà∂-Âú®kallocÂáΩÊï∞‰∏≠ÂΩìÂΩìÂâçcpuÁöÑËá™Áî±ÂàóË°®‰∏∫Á©∫Êó∂ÈÅçÂéÜÂÖ∂‰ªñcpuÁöÑËá™Áî±ÂàóË°®Âπ∂ÂÅ∑ÂèñÂÜÖÂ≠òÂùóÂÖ∑‰ΩìÈÄªËæëÂèØËÉΩÂ¶Ç‰∏ã">#</a></h4>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; i <span style="color:#f92672">&lt;</span> NCPU; i<span style="color:#f92672">++</span>)
</span></span><span style="display:flex;"><span>    {
</span></span><span style="display:flex;"><span>      <span style="color:#66d9ef">if</span> (i <span style="color:#f92672">!=</span> id)
</span></span><span style="display:flex;"><span>      {
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">acquire</span>(<span style="color:#f92672">&amp;</span>kmem.lock[i]);
</span></span><span style="display:flex;"><span>        r <span style="color:#f92672">=</span> kmem.freelist[i];
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> (r)
</span></span><span style="display:flex;"><span>        {
</span></span><span style="display:flex;"><span>          kmem.freelist[i] <span style="color:#f92672">=</span> r<span style="color:#f92672">-&gt;</span>next;
</span></span><span style="display:flex;"><span>          <span style="color:#a6e22e">release</span>(<span style="color:#f92672">&amp;</span>kmem.lock[i]);
</span></span><span style="display:flex;"><span>          <span style="color:#66d9ef">break</span>;
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">release</span>(<span style="color:#f92672">&amp;</span>kmem.lock[i]);
</span></span><span style="display:flex;"><span>      }
</span></span><span style="display:flex;"><span>    }
</span></span></code></pre></div><h3 id="ÊúÄÁªàÊ£ÄÊü•">ÊúÄÁªàÊ£ÄÊü•Ôºö<a hidden class="anchor" aria-hidden="true" href="#ÊúÄÁªàÊ£ÄÊü•">#</a></h3>
<ul>
<li>ËøêË°å<code>kalloctest</code>Âíå<code>usertests sbrkmuch</code>ÔºåÁ°Æ‰øùÊâÄÊúâÂÜÖÂ≠òÂàÜÈÖç„ÄÅÈáäÊîæÂíåÂπ∂ÂèëÂ§ÑÁêÜÊ≠£Â∏∏ÔºåÂêåÊó∂ÈîÅ‰∫âÁî®ÊòæËëóÂáèÂ∞ë„ÄÇ</li>
</ul>
<h2 id="buffer-cache-hardhttpspdoscsailmitedu6s0812020labsguidancehtml">Buffer cache (<a href="https://pdos.csail.mit.edu/6.S081/2020/labs/guidance.html">hard</a>)<a hidden class="anchor" aria-hidden="true" href="#buffer-cache-hardhttpspdoscsailmitedu6s0812020labsguidancehtml">#</a></h2>
<p>‰øÆÊîπ xv6 ÁöÑÂùóÁºìÂ≠òÔºàblock cacheÔºâÊú∫Âà∂ÔºåÂáèÂ∞ëÂ§ö‰∏™ËøõÁ®ãÂêåÊó∂ËÆøÈóÆÁºìÂ≠òÊó∂ÂØπÈîÅ <code>bcache.lock</code> ÁöÑ‰∫âÁî®„ÄÇ‰Ω†ÈúÄË¶ÅÁâπÂà´‰ºòÂåñ <code>bget</code> Âíå <code>brelse</code> ÂáΩÊï∞ÔºåÁ°Æ‰øùÂπ∂ÂèëËØªÂèñÂíåÈáäÊîæ‰∏çÂêåÁöÑÁºìÂ≠òÂùóÊó∂‰∏ç‰ºöÂÜ≤Á™Å„ÄÇÊúÄÁªàÁöÑÁõÆÊ†áÊòØËÆ©ËøêË°å <code>bcachetest</code> Êó∂ÔºåÊâÄÊúâ‰∏éÂùóÁºìÂ≠òÁõ∏ÂÖ≥ÁöÑÈîÅÁöÑËé∑ÂèñÊ¨°Êï∞Êé•ËøëÈõ∂ÔºàÁêÜÊÉ≥ÊÉÖÂÜµ‰∏ãÊÄªÂíåÂ∞è‰∫é500Ôºâ„ÄÇÊ≠§Â§ñÔºå‰Ω†ÈúÄË¶ÅÈÄöËøá <code>usertests</code> ÊµãËØïÔºåÂπ∂‰∏îÁ°Æ‰øùÂÆûÁé∞‰∏≠ÁöÑÈîÅÂêçÈÉΩ‰ª•‚Äú<code>bcache</code>‚ÄùÂºÄÂ§¥„ÄÇ</p>
<h3 id="ÂÆûÁé∞Ê≠•È™§ËØ¶ÁªÜËØ¥Êòé">ÂÆûÁé∞Ê≠•È™§ËØ¶ÁªÜËØ¥ÊòéÔºö<a hidden class="anchor" aria-hidden="true" href="#ÂÆûÁé∞Ê≠•È™§ËØ¶ÁªÜËØ¥Êòé">#</a></h3>
<ol>
<li><strong>ÁêÜËß£Áé∞ÊúâÈîÅ‰∫âÁî®</strong>Ôºö
<ul>
<li><code>bcache.lock</code> ‰øùÊä§‰∫ÜÁºìÂ≠òÂùóÂàóË°®„ÄÅÁºìÂ≠òÂùóÁöÑÂºïÁî®ËÆ°Êï∞ <code>b-&gt;refcnt</code> ‰ª•ÂèäÁºìÂ≠òÂùóÁöÑÊ†áËØÜ <code>b-&gt;dev</code> Âíå <code>b-&gt;blockno</code>„ÄÇÂ§ö‰∏™ËøõÁ®ãÂêåÊó∂ËÆøÈóÆÊó∂ÂèØËÉΩÂèëÁîüÈîÅ‰∫âÁî®„ÄÇ</li>
</ul>
</li>
<li><strong>‰ΩøÁî®ÂìàÂ∏åË°®Êõø‰ª£ÂÖ®Â±ÄÁºìÂ≠òÈîÅ</strong>Ôºö
<ul>
<li>‰ΩøÁî®‰∏Ä‰∏™ÂìàÂ∏åË°®Êù•Â≠òÂÇ®ÁºìÂ≠òÂùóÔºåÂπ∂‰∏∫ÊØè‰∏™ÂìàÂ∏åÊ°∂ËÆæÁΩÆÂçïÁã¨ÁöÑÈîÅ„ÄÇÈÄöËøáÂìàÂ∏åÂàÜÊ°∂Êú∫Âà∂Ôºå‰Ω†ÂèØ‰ª•ÂáèÂ∞ëÂπ∂ÂèëËÆøÈóÆ‰∏çÂêåÁºìÂ≠òÂùóÊó∂ÂØπÂêå‰∏Ä‰∏™ÈîÅÁöÑ‰∫âÁî®„ÄÇ</li>
<li>ÂèØ‰ª•ÈÄâÊã©‰ΩøÁî®‰∏Ä‰∏™Ë¥®Êï∞Ôºà‰æãÂ¶Ç13Ôºâ‰Ωú‰∏∫ÂìàÂ∏åÊ°∂ÁöÑÊï∞ÈáèÔºå‰ª•ÂáèÂ∞ëÂìàÂ∏åÂÜ≤Á™ÅÁöÑÊ¶ÇÁéá„ÄÇ</li>
</ul>
</li>
<li><strong>‰øÆÊîπ <code>bget</code> Âíå <code>brelse</code></strong>Ôºö
<ul>
<li><code>bget</code>ÔºöËøôÊòØËé∑ÂèñÁºìÂ≠òÂùóÁöÑÂáΩÊï∞„ÄÇ‰Ω†ÈúÄË¶Å‰øÆÊîπÂÆÉÔºå‰ΩøÂæóÂú®Êü•ÊâæÂíåËé∑ÂèñÁºìÂ≠òÂùóÊó∂ÔºåÂè™ÂØπÁõ∏Â∫îÁöÑÂìàÂ∏åÊ°∂ËøõË°åÂä†ÈîÅÔºåËÄå‰∏çÊòØÂÖ®Â±ÄÂä†ÈîÅ„ÄÇÂêåÊó∂ÔºåÁ°Æ‰øùÂ¶ÇÊûúÁºìÂ≠ò‰∏≠Ê≤°ÊúâÂØπÂ∫îÁöÑÂùóÔºåÈúÄË¶ÅÈÄâÊã©‰∏Ä‰∏™ÊõøÊç¢ÂùóÊó∂ÔºåÊõøÊç¢ÈÄªËæëÊòØÂéüÂ≠êÁöÑÔºåÂπ∂‰∏îÈò≤Ê≠¢ÂìàÂ∏åÂÜ≤Á™ÅÂØºËá¥ÁöÑÊ≠ªÈîÅ„ÄÇ</li>
<li><code>brelse</code>ÔºöËøôÊòØÈáäÊîæÁºìÂ≠òÂùóÁöÑÂáΩÊï∞„ÄÇ‰Ω†ÂèØ‰ª•ÈÄöËøá‰ΩøÁî®Êó∂Èó¥Êà≥ÔºàÂ¶Ç <code>ticks</code>ÔºâÊù•ËÆ∞ÂΩïÁºìÂ≠òÂùóÁöÑÊúÄÂêé‰ΩøÁî®Êó∂Èó¥Ôºå‰ªéËÄåÈÅøÂÖçÂú®ÈáäÊîæÂùóÊó∂ÂøÖÈ°ªËé∑ÂèñÂÖ®Â±Ä <code>bcache.lock</code>„ÄÇÂΩì <code>brelse</code> Ë¢´Ë∞ÉÁî®Êó∂ÔºåÂè™ÈúÄË¶ÅÊõ¥Êñ∞Êó∂Èó¥Êà≥ÔºåËÄå‰∏çÈúÄË¶ÅÂä†ÈîÅ„ÄÇ</li>
</ul>
</li>
<li><strong>ÊõøÊç¢ÁºìÂ≠òÂùóÁöÑÁÆ°ÁêÜÊú∫Âà∂</strong>Ôºö
<ul>
<li>ÂèñÊ∂àÂÖ®Â±ÄÁºìÂ≠òÂùóÈìæË°®ÔºàÂ¶Ç <code>bcache.head</code> Á≠âÔºâÔºåËÄåÊòØÈÄöËøáÊó∂Èó¥Êà≥ËÆ∞ÂΩïÁºìÂ≠òÂùóÁöÑÊúÄÂêé‰ΩøÁî®Êó∂Èó¥„ÄÇËøôÊ†∑Ôºå‰Ω†ÂèØ‰ª•Âú® <code>bget</code> ‰∏≠Ê†πÊçÆÊó∂Èó¥Êà≥ÈÄâÊã©ÊúÄËøëÊú™‰ΩøÁî®ÁöÑÁºìÂ≠òÂùóÔºåËÄå‰∏çÈúÄË¶ÅÈÅçÂéÜÂÖ®Â±ÄÂàóË°®„ÄÇ</li>
</ul>
</li>
<li><strong>Èò≤Ê≠¢Ê≠ªÈîÅ</strong>Ôºö
<ul>
<li>Âú®ÁºìÂ≠òÊõøÊç¢ÂíåÂìàÂ∏åÊ°∂ÁßªÂä®Êó∂ÔºåÂèØËÉΩÈúÄË¶ÅÊåÅÊúâÂ§ö‰∏™ÈîÅÔºàÂ¶ÇÂÖ®Â±Ä <code>bcache.lock</code> ÂíåÂìàÂ∏åÊ°∂ÈîÅÔºâ„ÄÇ‰Ω†ÈúÄË¶ÅÂ∞èÂøÉÈÅøÂÖçÂú®ÈîÅÁöÑÈ°∫Â∫è‰∏äÂá∫Áé∞Ê≠ªÈîÅÁöÑÊÉÖÂÜµÔºåÁâπÂà´ÊòØÂú®ÁºìÂ≠òÂùó‰ªé‰∏Ä‰∏™ÂìàÂ∏åÊ°∂ÁßªÂä®Âà∞Âè¶‰∏Ä‰∏™Ê°∂Êó∂„ÄÇ</li>
</ul>
</li>
<li><strong>ÈÄêÊ≠•Ë∞ÉËØï</strong>Ôºö
<ul>
<li>‰Ω†ÂèØ‰ª•Âú®ÂÆûÁé∞ÂìàÂ∏åÊ°∂ÈîÅÂêéÔºåÂÖà‰øùÁïô <code>bget</code> ÂºÄÂßãÂíåÁªìÊùüÊó∂ÁöÑÂÖ®Â±ÄÈîÅ <code>bcache.lock</code>Ôºå‰ª•Á°Æ‰øùÊ≤°ÊúâÁ´û‰∫âÊù°‰ª∂„ÄÇ‰∏ÄÊó¶È™åËØÅ‰ª£Á†ÅÊ≤°ÊúâÁ´ûÊÄÅÊù°‰ª∂ÂêéÔºåÂÜçÁßªÈô§ÂÖ®Â±ÄÈîÅÔºåÂ§ÑÁêÜÂπ∂ÂèëÈóÆÈ¢ò„ÄÇ</li>
<li>ÂèØ‰ª•ËøêË°å <code>make CPUS=1 qemu</code> ËøõË°åÂçïÊ†∏ÊµãËØïÔºåÁ°Æ‰øùÂàùÊ≠•ÂÆûÁé∞Ê≠£Á°ÆÂêéÔºåÂÜçÊâ©Â±ïÂà∞Â§öÊ†∏ÁéØÂ¢É„ÄÇ</li>
</ul>
</li>
</ol>
<p>usertests‰∏çÈÄöËøá</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#75715e">// Buffer cache.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">//
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">// The buffer cache is a linked list of buf structures holding
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">// cached copies of disk block contents.  Caching disk blocks
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">// in memory reduces the number of disk reads and also provides
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">// a synchronization point for disk blocks used by multiple processes.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">//
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">// Interface:
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">// * To get a buffer for a particular disk block, call bread.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">// * After changing buffer data, call bwrite to write it to disk.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">// * When done with the buffer, call brelse.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">// * Do not use the buffer after calling brelse.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">// * Only one process at a time can use a buffer,
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">//     so do not keep them longer than necessary.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&#34;types.h&#34;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&#34;param.h&#34;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&#34;spinlock.h&#34;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&#34;sleeplock.h&#34;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&#34;riscv.h&#34;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&#34;defs.h&#34;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&#34;fs.h&#34;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&#34;buf.h&#34;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">#define NBUCKETS 23 </span><span style="color:#75715e">// ÂìàÂ∏åÊ°∂Êï∞ÈáèÔºå‰ΩøÁî®Ë¥®Êï∞‰ª•ÂáèÂ∞ëÂÜ≤Á™Å
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">struct</span>
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">struct</span> spinlock lock;
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">struct</span> buf buf[NBUF]; <span style="color:#75715e">// ÂÆûÈôÖÁöÑÁºìÂ≠òÂùó
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  <span style="color:#66d9ef">struct</span>
</span></span><span style="display:flex;"><span>  {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">struct</span> buf <span style="color:#f92672">*</span>head;     <span style="color:#75715e">// ÊØè‰∏™Ê°∂ÁöÑÁºìÂ≠òÂùóÈìæË°®
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">struct</span> spinlock lock; <span style="color:#75715e">// ÊØè‰∏™Ê°∂ÁöÑÈîÅ
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  } buckets[NBUCKETS];
</span></span><span style="display:flex;"><span>} bcache;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// ËÆ°ÁÆóÂùóÂè∑ÂíåËÆæÂ§áÂè∑ÁöÑÂìàÂ∏åÂÄº
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">static</span> uint
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">hash</span>(uint dev, uint blockno)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">return</span> (dev <span style="color:#f92672">^</span> blockno) <span style="color:#f92672">%</span> NBUCKETS;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">binit</span>(<span style="color:#66d9ef">void</span>)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">struct</span> buf <span style="color:#f92672">*</span>b;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">initlock</span>(<span style="color:#f92672">&amp;</span>bcache.lock, <span style="color:#e6db74">&#34;bcache&#34;</span>);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#75715e">// ÂàùÂßãÂåñÊØè‰∏™Ê°∂ÁöÑÈîÅ
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; i <span style="color:#f92672">&lt;</span> NBUCKETS; i<span style="color:#f92672">++</span>)
</span></span><span style="display:flex;"><span>  {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">initlock</span>(<span style="color:#f92672">&amp;</span>bcache.buckets[i].lock, <span style="color:#e6db74">&#34;bcache.bucket&#34;</span>);
</span></span><span style="display:flex;"><span>    bcache.buckets[i].head <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#75715e">// ÂàùÂßãÂåñÁºìÂ≠òÂùó
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  <span style="color:#66d9ef">for</span> (b <span style="color:#f92672">=</span> bcache.buf; b <span style="color:#f92672">&lt;</span> bcache.buf <span style="color:#f92672">+</span> NBUF; b<span style="color:#f92672">++</span>)
</span></span><span style="display:flex;"><span>  {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">initsleeplock</span>(<span style="color:#f92672">&amp;</span>b<span style="color:#f92672">-&gt;</span>lock, <span style="color:#e6db74">&#34;buffer&#34;</span>);
</span></span><span style="display:flex;"><span>    b<span style="color:#f92672">-&gt;</span>refcnt <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// ‰øÆÊîπ bget ÂáΩÊï∞ËøõË°åÂìàÂ∏åË°®Êü•Êâæ
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">//     ‰∏∫‰∫Ü‰ΩøÁî®ÂìàÂ∏åË°®Ôºåbget ÂáΩÊï∞ÈúÄË¶ÅËøõË°å‰ª•‰∏ã‰øÆÊîπÔºö
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">//         ËÆ°ÁÆóÂùóÂè∑ÁöÑÂìàÂ∏åÂÄºÔºåÁ°ÆÂÆöÊâÄÂú®Ê°∂„ÄÇ
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">//         Ëé∑ÂèñÊ°∂ÁöÑÈîÅÔºåÂπ∂Âú®Ê°∂‰∏≠Êü•ÊâæÂùó„ÄÇ
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">//         Â¶ÇÊûúÊú™ÊâæÂà∞ÂùóÔºåÂàôÈÄâÊã©‰∏Ä‰∏™Êú™‰ΩøÁî®ÊàñÊúÄËøëÊúÄÂ∞ë‰ΩøÁî®ÁöÑÂùóËøõË°åÊõøÊç¢„ÄÇ
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">static</span> <span style="color:#66d9ef">struct</span> buf <span style="color:#f92672">*</span>
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">bget</span>(uint dev, uint blockno)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">struct</span> buf <span style="color:#f92672">*</span>b;
</span></span><span style="display:flex;"><span>  uint h <span style="color:#f92672">=</span> <span style="color:#a6e22e">hash</span>(dev, blockno);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">acquire</span>(<span style="color:#f92672">&amp;</span>bcache.buckets[h].lock);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#75715e">// Âú®Ê°∂‰∏≠Êü•ÊâæÂùó
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  <span style="color:#66d9ef">for</span> (b <span style="color:#f92672">=</span> bcache.buckets[h].head; b; b <span style="color:#f92672">=</span> b<span style="color:#f92672">-&gt;</span>next)
</span></span><span style="display:flex;"><span>  {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> (b<span style="color:#f92672">-&gt;</span>dev <span style="color:#f92672">==</span> dev <span style="color:#f92672">&amp;&amp;</span> b<span style="color:#f92672">-&gt;</span>blockno <span style="color:#f92672">==</span> blockno)
</span></span><span style="display:flex;"><span>    {
</span></span><span style="display:flex;"><span>      b<span style="color:#f92672">-&gt;</span>refcnt<span style="color:#f92672">++</span>;
</span></span><span style="display:flex;"><span>      <span style="color:#a6e22e">release</span>(<span style="color:#f92672">&amp;</span>bcache.buckets[h].lock);
</span></span><span style="display:flex;"><span>      <span style="color:#a6e22e">acquiresleep</span>(<span style="color:#f92672">&amp;</span>b<span style="color:#f92672">-&gt;</span>lock);
</span></span><span style="display:flex;"><span>      <span style="color:#66d9ef">return</span> b;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#75715e">// Â¶ÇÊûúÊú™ÊâæÂà∞ÂùóÔºåÂ∞ùËØïÊâæÂà∞‰∏Ä‰∏™Êú™‰ΩøÁî®ÁöÑÂùóÊàñÊõøÊç¢ÊúÄËøëÊúÄÂ∞ë‰ΩøÁî®ÁöÑÂùó
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  <span style="color:#66d9ef">struct</span> buf <span style="color:#f92672">*</span>lru <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">for</span> (b <span style="color:#f92672">=</span> bcache.buf; b <span style="color:#f92672">&lt;</span> bcache.buf <span style="color:#f92672">+</span> NBUF; b<span style="color:#f92672">++</span>)
</span></span><span style="display:flex;"><span>  {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> (b<span style="color:#f92672">-&gt;</span>refcnt <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span> <span style="color:#f92672">&amp;&amp;</span> (lru <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span> <span style="color:#f92672">||</span> b<span style="color:#f92672">-&gt;</span>lastuse <span style="color:#f92672">&lt;</span> lru<span style="color:#f92672">-&gt;</span>lastuse))
</span></span><span style="display:flex;"><span>      lru <span style="color:#f92672">=</span> b;
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">if</span> (lru <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span>)
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">panic</span>(<span style="color:#e6db74">&#34;bget: no buffers&#34;</span>);
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">release</span>(<span style="color:#f92672">&amp;</span>bcache.buckets[h].lock);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#75715e">// ‰ªéÊóßÊ°∂‰∏≠ÁßªÈô§Âùó
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  h <span style="color:#f92672">=</span> <span style="color:#a6e22e">hash</span>(lru<span style="color:#f92672">-&gt;</span>dev, lru<span style="color:#f92672">-&gt;</span>blockno);
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">acquire</span>(<span style="color:#f92672">&amp;</span>bcache.buckets[h].lock);
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">struct</span> buf <span style="color:#f92672">**</span>prev <span style="color:#f92672">=</span> <span style="color:#f92672">&amp;</span>bcache.buckets[h].head;
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">for</span> (b <span style="color:#f92672">=</span> bcache.buckets[h].head; b; prev <span style="color:#f92672">=</span> <span style="color:#f92672">&amp;</span>b<span style="color:#f92672">-&gt;</span>next, b <span style="color:#f92672">=</span> b<span style="color:#f92672">-&gt;</span>next)
</span></span><span style="display:flex;"><span>  {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> (b <span style="color:#f92672">==</span> lru)
</span></span><span style="display:flex;"><span>    {
</span></span><span style="display:flex;"><span>      <span style="color:#f92672">*</span>prev <span style="color:#f92672">=</span> b<span style="color:#f92672">-&gt;</span>next;
</span></span><span style="display:flex;"><span>      <span style="color:#66d9ef">break</span>;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#75715e">// Â∞ÜÊñ∞ÂùóÊèíÂÖ•ÈÄÇÂΩìÁöÑÊ°∂
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  lru<span style="color:#f92672">-&gt;</span>dev <span style="color:#f92672">=</span> dev;
</span></span><span style="display:flex;"><span>  lru<span style="color:#f92672">-&gt;</span>blockno <span style="color:#f92672">=</span> blockno;
</span></span><span style="display:flex;"><span>  lru<span style="color:#f92672">-&gt;</span>valid <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>  lru<span style="color:#f92672">-&gt;</span>refcnt <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span>  lru<span style="color:#f92672">-&gt;</span>lastuse <span style="color:#f92672">=</span> ticks;
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">release</span>(<span style="color:#f92672">&amp;</span>bcache.buckets[h].lock);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  h <span style="color:#f92672">=</span> <span style="color:#a6e22e">hash</span>(dev, blockno);
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">acquire</span>(<span style="color:#f92672">&amp;</span>bcache.buckets[h].lock);
</span></span><span style="display:flex;"><span>  lru<span style="color:#f92672">-&gt;</span>next <span style="color:#f92672">=</span> bcache.buckets[h].head;
</span></span><span style="display:flex;"><span>  bcache.buckets[h].head <span style="color:#f92672">=</span> lru;
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">release</span>(<span style="color:#f92672">&amp;</span>bcache.buckets[h].lock);
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">acquiresleep</span>(<span style="color:#f92672">&amp;</span>lru<span style="color:#f92672">-&gt;</span>lock);
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">return</span> lru;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// Return a locked buf with the contents of the indicated block.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">struct</span> buf <span style="color:#f92672">*</span>
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">bread</span>(uint dev, uint blockno)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">struct</span> buf <span style="color:#f92672">*</span>b;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  b <span style="color:#f92672">=</span> <span style="color:#a6e22e">bget</span>(dev, blockno);
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">if</span> (<span style="color:#f92672">!</span>b<span style="color:#f92672">-&gt;</span>valid)
</span></span><span style="display:flex;"><span>  {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">virtio_disk_rw</span>(b, <span style="color:#ae81ff">0</span>);
</span></span><span style="display:flex;"><span>    b<span style="color:#f92672">-&gt;</span>valid <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">return</span> b;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// Write b&#39;s contents to disk.  Must be locked.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">bwrite</span>(<span style="color:#66d9ef">struct</span> buf <span style="color:#f92672">*</span>b)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">if</span> (<span style="color:#f92672">!</span><span style="color:#a6e22e">holdingsleep</span>(<span style="color:#f92672">&amp;</span>b<span style="color:#f92672">-&gt;</span>lock))
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">panic</span>(<span style="color:#e6db74">&#34;bwrite&#34;</span>);
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">virtio_disk_rw</span>(b, <span style="color:#ae81ff">1</span>);
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// Release a locked buffer.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">// Move to the head of the most-recently-used list.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">brelse</span>(<span style="color:#66d9ef">struct</span> buf <span style="color:#f92672">*</span>b)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">if</span> (<span style="color:#f92672">!</span><span style="color:#a6e22e">holdingsleep</span>(<span style="color:#f92672">&amp;</span>b<span style="color:#f92672">-&gt;</span>lock))
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">panic</span>(<span style="color:#e6db74">&#34;brelse&#34;</span>);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">releasesleep</span>(<span style="color:#f92672">&amp;</span>b<span style="color:#f92672">-&gt;</span>lock);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  uint h <span style="color:#f92672">=</span> <span style="color:#a6e22e">hash</span>(b<span style="color:#f92672">-&gt;</span>dev, b<span style="color:#f92672">-&gt;</span>blockno);
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">acquire</span>(<span style="color:#f92672">&amp;</span>bcache.buckets[h].lock);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  b<span style="color:#f92672">-&gt;</span>refcnt<span style="color:#f92672">--</span>;
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">if</span> (b<span style="color:#f92672">-&gt;</span>refcnt <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span>)
</span></span><span style="display:flex;"><span>  {
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// Âùó‰∏çÂÜçË¢´‰ΩøÁî®ÔºåÊõ¥Êñ∞Êó∂Èó¥Êà≥
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    b<span style="color:#f92672">-&gt;</span>lastuse <span style="color:#f92672">=</span> ticks;
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">release</span>(<span style="color:#f92672">&amp;</span>bcache.buckets[h].lock);
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">bpin</span>(<span style="color:#66d9ef">struct</span> buf <span style="color:#f92672">*</span>b)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>  uint h <span style="color:#f92672">=</span> <span style="color:#a6e22e">hash</span>(b<span style="color:#f92672">-&gt;</span>dev, b<span style="color:#f92672">-&gt;</span>blockno);
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">acquire</span>(<span style="color:#f92672">&amp;</span>bcache.buckets[h].lock);
</span></span><span style="display:flex;"><span>  b<span style="color:#f92672">-&gt;</span>refcnt<span style="color:#f92672">++</span>;
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">release</span>(<span style="color:#f92672">&amp;</span>bcache.buckets[h].lock);
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">bunpin</span>(<span style="color:#66d9ef">struct</span> buf <span style="color:#f92672">*</span>b)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>  uint h <span style="color:#f92672">=</span> <span style="color:#a6e22e">hash</span>(b<span style="color:#f92672">-&gt;</span>dev, b<span style="color:#f92672">-&gt;</span>blockno);
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">acquire</span>(<span style="color:#f92672">&amp;</span>bcache.buckets[h].lock);
</span></span><span style="display:flex;"><span>  b<span style="color:#f92672">-&gt;</span>refcnt<span style="color:#f92672">--</span>;
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">release</span>(<span style="color:#f92672">&amp;</span>bcache.buckets[h].lock);
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#75715e">// Buffer cache.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">//
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">// The buffer cache is a linked list of buf structures holding
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">// cached copies of disk block contents.  Caching disk blocks
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">// in memory reduces the number of disk reads and also provides
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">// a synchronization point for disk blocks used by multiple processes.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">//
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">// Interface:
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">// * To get a buffer for a particular disk block, call bread.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">// * After changing buffer data, call bwrite to write it to disk.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">// * When done with the buffer, call brelse.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">// * Do not use the buffer after calling brelse.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">// * Only one process at a time can use a buffer,
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">//     so do not keep them longer than necessary.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&#34;types.h&#34;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&#34;param.h&#34;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&#34;spinlock.h&#34;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&#34;sleeplock.h&#34;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&#34;riscv.h&#34;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&#34;defs.h&#34;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&#34;fs.h&#34;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&#34;buf.h&#34;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">#define NBUCKET 13
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#undef NBUF
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#define NBUF (NBUCKET * 3)
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">struct</span> {
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">struct</span> spinlock lock;
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">struct</span> buf buf[NBUF];
</span></span><span style="display:flex;"><span>} bcache;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">struct</span> bucket {
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">struct</span> spinlock lock;
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">struct</span> buf head;
</span></span><span style="display:flex;"><span>}hashtable[NBUCKET];
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span>
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">hash</span>(uint dev, uint blockno)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">return</span> blockno <span style="color:#f92672">%</span> NBUCKET;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">void</span>
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">binit</span>(<span style="color:#66d9ef">void</span>)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">struct</span> buf <span style="color:#f92672">*</span>b;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">initlock</span>(<span style="color:#f92672">&amp;</span>bcache.lock, <span style="color:#e6db74">&#34;bcache&#34;</span>);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">for</span>(b <span style="color:#f92672">=</span> bcache.buf; b <span style="color:#f92672">&lt;</span> bcache.buf<span style="color:#f92672">+</span>NBUF; b<span style="color:#f92672">++</span>){
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">initsleeplock</span>(<span style="color:#f92672">&amp;</span>b<span style="color:#f92672">-&gt;</span>lock, <span style="color:#e6db74">&#34;buffer&#34;</span>);
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  b <span style="color:#f92672">=</span> bcache.buf;
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; i <span style="color:#f92672">&lt;</span> NBUCKET; i<span style="color:#f92672">++</span>) {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">initlock</span>(<span style="color:#f92672">&amp;</span>hashtable[i].lock, <span style="color:#e6db74">&#34;bcache_bucket&#34;</span>);
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> j <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; j <span style="color:#f92672">&lt;</span> NBUF <span style="color:#f92672">/</span> NBUCKET; j<span style="color:#f92672">++</span>) {
</span></span><span style="display:flex;"><span>      b<span style="color:#f92672">-&gt;</span>blockno <span style="color:#f92672">=</span> i;
</span></span><span style="display:flex;"><span>      b<span style="color:#f92672">-&gt;</span>next <span style="color:#f92672">=</span> hashtable[i].head.next;
</span></span><span style="display:flex;"><span>      hashtable[i].head.next <span style="color:#f92672">=</span> b;
</span></span><span style="display:flex;"><span>      b<span style="color:#f92672">++</span>;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// Look through buffer cache for block on device dev.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">// If not found, allocate a buffer.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">// In either case, return locked buffer.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">static</span> <span style="color:#66d9ef">struct</span> buf<span style="color:#f92672">*</span>
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">bget</span>(uint dev, uint blockno)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>  <span style="color:#75715e">// printf(&#34;dev: %d blockno: %d Status: &#34;, dev, blockno);
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  <span style="color:#66d9ef">struct</span> buf <span style="color:#f92672">*</span>b;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">int</span> idx <span style="color:#f92672">=</span> <span style="color:#a6e22e">hash</span>(dev, blockno);
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">struct</span> bucket<span style="color:#f92672">*</span> bucket <span style="color:#f92672">=</span> hashtable <span style="color:#f92672">+</span> idx;
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">acquire</span>(<span style="color:#f92672">&amp;</span>bucket<span style="color:#f92672">-&gt;</span>lock);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#75715e">// Is the block already cached?
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  <span style="color:#66d9ef">for</span>(b <span style="color:#f92672">=</span> bucket<span style="color:#f92672">-&gt;</span>head.next; b <span style="color:#f92672">!=</span> <span style="color:#ae81ff">0</span>; b <span style="color:#f92672">=</span> b<span style="color:#f92672">-&gt;</span>next){
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span>(b<span style="color:#f92672">-&gt;</span>dev <span style="color:#f92672">==</span> dev <span style="color:#f92672">&amp;&amp;</span> b<span style="color:#f92672">-&gt;</span>blockno <span style="color:#f92672">==</span> blockno){
</span></span><span style="display:flex;"><span>      b<span style="color:#f92672">-&gt;</span>refcnt<span style="color:#f92672">++</span>;
</span></span><span style="display:flex;"><span>      <span style="color:#a6e22e">release</span>(<span style="color:#f92672">&amp;</span>bucket<span style="color:#f92672">-&gt;</span>lock);
</span></span><span style="display:flex;"><span>      <span style="color:#a6e22e">acquiresleep</span>(<span style="color:#f92672">&amp;</span>b<span style="color:#f92672">-&gt;</span>lock);
</span></span><span style="display:flex;"><span>      <span style="color:#75715e">// printf(&#34;Cached %p\n&#34;, b);
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>      <span style="color:#66d9ef">return</span> b;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#75715e">// Not cached.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  <span style="color:#75715e">// First try to find in current bucket.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  <span style="color:#66d9ef">int</span> min_time <span style="color:#f92672">=</span> <span style="color:#ae81ff">0x8fffffff</span>;
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">struct</span> buf<span style="color:#f92672">*</span> replace_buf <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">for</span>(b <span style="color:#f92672">=</span> bucket<span style="color:#f92672">-&gt;</span>head.next; b <span style="color:#f92672">!=</span> <span style="color:#ae81ff">0</span>; b <span style="color:#f92672">=</span> b<span style="color:#f92672">-&gt;</span>next){
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span>(b<span style="color:#f92672">-&gt;</span>refcnt <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span> <span style="color:#f92672">&amp;&amp;</span> b<span style="color:#f92672">-&gt;</span>timestamp <span style="color:#f92672">&lt;</span> min_time) {
</span></span><span style="display:flex;"><span>      replace_buf <span style="color:#f92672">=</span> b;
</span></span><span style="display:flex;"><span>      min_time <span style="color:#f92672">=</span> b<span style="color:#f92672">-&gt;</span>timestamp;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">if</span>(replace_buf) {
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// printf(&#34;Local %d %p\n&#34;, idx, replace_buf);
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">goto</span> find;
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#75715e">// Try to find in other bucket.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  <span style="color:#a6e22e">acquire</span>(<span style="color:#f92672">&amp;</span>bcache.lock);
</span></span><span style="display:flex;"><span>  refind:
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">for</span>(b <span style="color:#f92672">=</span> bcache.buf; b <span style="color:#f92672">&lt;</span> bcache.buf <span style="color:#f92672">+</span> NBUF; b<span style="color:#f92672">++</span>) {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span>(b<span style="color:#f92672">-&gt;</span>refcnt <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span> <span style="color:#f92672">&amp;&amp;</span> b<span style="color:#f92672">-&gt;</span>timestamp <span style="color:#f92672">&lt;</span> min_time) {
</span></span><span style="display:flex;"><span>      replace_buf <span style="color:#f92672">=</span> b;
</span></span><span style="display:flex;"><span>      min_time <span style="color:#f92672">=</span> b<span style="color:#f92672">-&gt;</span>timestamp;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">if</span> (replace_buf) {
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// remove from old bucket
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">int</span> ridx <span style="color:#f92672">=</span> <span style="color:#a6e22e">hash</span>(replace_buf<span style="color:#f92672">-&gt;</span>dev, replace_buf<span style="color:#f92672">-&gt;</span>blockno);
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">acquire</span>(<span style="color:#f92672">&amp;</span>hashtable[ridx].lock);
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span>(replace_buf<span style="color:#f92672">-&gt;</span>refcnt <span style="color:#f92672">!=</span> <span style="color:#ae81ff">0</span>)  <span style="color:#75715e">// be used in another bucket&#39;s local find between finded and acquire
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    {
</span></span><span style="display:flex;"><span>      <span style="color:#a6e22e">release</span>(<span style="color:#f92672">&amp;</span>hashtable[ridx].lock);
</span></span><span style="display:flex;"><span>      <span style="color:#66d9ef">goto</span> refind;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">struct</span> buf <span style="color:#f92672">*</span>pre <span style="color:#f92672">=</span> <span style="color:#f92672">&amp;</span>hashtable[ridx].head;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">struct</span> buf <span style="color:#f92672">*</span>p <span style="color:#f92672">=</span> hashtable[ridx].head.next;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">while</span> (p <span style="color:#f92672">!=</span> replace_buf) {
</span></span><span style="display:flex;"><span>      pre <span style="color:#f92672">=</span> pre<span style="color:#f92672">-&gt;</span>next;
</span></span><span style="display:flex;"><span>      p <span style="color:#f92672">=</span> p<span style="color:#f92672">-&gt;</span>next;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    pre<span style="color:#f92672">-&gt;</span>next <span style="color:#f92672">=</span> p<span style="color:#f92672">-&gt;</span>next;
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">release</span>(<span style="color:#f92672">&amp;</span>hashtable[ridx].lock);
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// add to current bucket
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    replace_buf<span style="color:#f92672">-&gt;</span>next <span style="color:#f92672">=</span> hashtable[idx].head.next;
</span></span><span style="display:flex;"><span>    hashtable[idx].head.next <span style="color:#f92672">=</span> replace_buf;
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">release</span>(<span style="color:#f92672">&amp;</span>bcache.lock);
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// printf(&#34;Global %d -&gt; %d %p\n&#34;, ridx, idx, replace_buf);
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">goto</span> find;
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">else</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">panic</span>(<span style="color:#e6db74">&#34;bget: no buffers&#34;</span>);
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  find:
</span></span><span style="display:flex;"><span>  replace_buf<span style="color:#f92672">-&gt;</span>dev <span style="color:#f92672">=</span> dev;
</span></span><span style="display:flex;"><span>  replace_buf<span style="color:#f92672">-&gt;</span>blockno <span style="color:#f92672">=</span> blockno;
</span></span><span style="display:flex;"><span>  replace_buf<span style="color:#f92672">-&gt;</span>valid <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>  replace_buf<span style="color:#f92672">-&gt;</span>refcnt <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">release</span>(<span style="color:#f92672">&amp;</span>bucket<span style="color:#f92672">-&gt;</span>lock);
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">acquiresleep</span>(<span style="color:#f92672">&amp;</span>replace_buf<span style="color:#f92672">-&gt;</span>lock);
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">return</span> replace_buf;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// Return a locked buf with the contents of the indicated block.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">struct</span> buf<span style="color:#f92672">*</span>
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">bread</span>(uint dev, uint blockno)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">struct</span> buf <span style="color:#f92672">*</span>b;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  b <span style="color:#f92672">=</span> <span style="color:#a6e22e">bget</span>(dev, blockno);
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">if</span>(<span style="color:#f92672">!</span>b<span style="color:#f92672">-&gt;</span>valid) {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">virtio_disk_rw</span>(b, <span style="color:#ae81ff">0</span>);
</span></span><span style="display:flex;"><span>    b<span style="color:#f92672">-&gt;</span>valid <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">return</span> b;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// Write b&#39;s contents to disk.  Must be locked.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">void</span>
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">bwrite</span>(<span style="color:#66d9ef">struct</span> buf <span style="color:#f92672">*</span>b)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">if</span>(<span style="color:#f92672">!</span><span style="color:#a6e22e">holdingsleep</span>(<span style="color:#f92672">&amp;</span>b<span style="color:#f92672">-&gt;</span>lock))
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">panic</span>(<span style="color:#e6db74">&#34;bwrite&#34;</span>);
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">virtio_disk_rw</span>(b, <span style="color:#ae81ff">1</span>);
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// Release a locked buffer.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">// Move to the head of the most-recently-used list.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">void</span>
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">brelse</span>(<span style="color:#66d9ef">struct</span> buf <span style="color:#f92672">*</span>b)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">if</span>(<span style="color:#f92672">!</span><span style="color:#a6e22e">holdingsleep</span>(<span style="color:#f92672">&amp;</span>b<span style="color:#f92672">-&gt;</span>lock))
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">panic</span>(<span style="color:#e6db74">&#34;brelse&#34;</span>);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">releasesleep</span>(<span style="color:#f92672">&amp;</span>b<span style="color:#f92672">-&gt;</span>lock);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">int</span> idx <span style="color:#f92672">=</span> <span style="color:#a6e22e">hash</span>(b<span style="color:#f92672">-&gt;</span>dev, b<span style="color:#f92672">-&gt;</span>blockno);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">acquire</span>(<span style="color:#f92672">&amp;</span>hashtable[idx].lock);
</span></span><span style="display:flex;"><span>  b<span style="color:#f92672">-&gt;</span>refcnt<span style="color:#f92672">--</span>;
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">if</span> (b<span style="color:#f92672">-&gt;</span>refcnt <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span>) {
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// no one is waiting for it.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    b<span style="color:#f92672">-&gt;</span>timestamp <span style="color:#f92672">=</span> ticks;
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>  
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">release</span>(<span style="color:#f92672">&amp;</span>hashtable[idx].lock);
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">void</span>
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">bpin</span>(<span style="color:#66d9ef">struct</span> buf <span style="color:#f92672">*</span>b) {
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">int</span> idx <span style="color:#f92672">=</span> <span style="color:#a6e22e">hash</span>(b<span style="color:#f92672">-&gt;</span>dev, b<span style="color:#f92672">-&gt;</span>blockno);
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">acquire</span>(<span style="color:#f92672">&amp;</span>hashtable[idx].lock);
</span></span><span style="display:flex;"><span>  b<span style="color:#f92672">-&gt;</span>refcnt<span style="color:#f92672">++</span>;
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">release</span>(<span style="color:#f92672">&amp;</span>hashtable[idx].lock);
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">void</span>
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">bunpin</span>(<span style="color:#66d9ef">struct</span> buf <span style="color:#f92672">*</span>b) {
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">int</span> idx <span style="color:#f92672">=</span> <span style="color:#a6e22e">hash</span>(b<span style="color:#f92672">-&gt;</span>dev, b<span style="color:#f92672">-&gt;</span>blockno);
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">acquire</span>(<span style="color:#f92672">&amp;</span>hashtable[idx].lock);
</span></span><span style="display:flex;"><span>  b<span style="color:#f92672">-&gt;</span>refcnt<span style="color:#f92672">--</span>;
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">release</span>(<span style="color:#f92672">&amp;</span>hashtable[idx].lock);
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h3 id="ÂÆûÁé∞Ê≠•È™§-1">ÂÆûÁé∞Ê≠•È™§<a hidden class="anchor" aria-hidden="true" href="#ÂÆûÁé∞Ê≠•È™§-1">#</a></h3>
<h4 id="1ÂÆö‰πâÊ°∂Â§ßÂ∞è‰ª•ÂèäÂÖ®Â±ÄÁöÑbufferÂ§ßÂ∞è">1„ÄÅÂÆö‰πâÊ°∂Â§ßÂ∞èÔºå‰ª•ÂèäÂÖ®Â±ÄÁöÑbufferÂ§ßÂ∞è<a hidden class="anchor" aria-hidden="true" href="#1ÂÆö‰πâÊ°∂Â§ßÂ∞è‰ª•ÂèäÂÖ®Â±ÄÁöÑbufferÂ§ßÂ∞è">#</a></h4>
<p>

    <div class="post-img-view">
        <a data-fancybox="gallery" href="https://raw.githubusercontent.com/Kennems/blog-image/main/image-20241003221945296.png">
            <img src="https://raw.githubusercontent.com/Kennems/blog-image/main/image-20241003221945296.png" alt="image-20241003221945296"  />
        </a>
    </div>

</p>
<h4 id="2Ê∑ªÂä†bucketÁªìÊûÑ‰Ωì">2„ÄÅÊ∑ªÂä†bucketÁªìÊûÑ‰Ωì<a hidden class="anchor" aria-hidden="true" href="#2Ê∑ªÂä†bucketÁªìÊûÑ‰Ωì">#</a></h4>
<p>

    <div class="post-img-view">
        <a data-fancybox="gallery" href="https://raw.githubusercontent.com/Kennems/blog-image/main/image-20241003222201632.png">
            <img src="https://raw.githubusercontent.com/Kennems/blog-image/main/image-20241003222201632.png" alt="image-20241003222201632"  />
        </a>
    </div>

</p>
<h4 id="3ÂÆûÁé∞ÂìàÂ∏åÂáΩÊï∞">3„ÄÅÂÆûÁé∞ÂìàÂ∏åÂáΩÊï∞<a hidden class="anchor" aria-hidden="true" href="#3ÂÆûÁé∞ÂìàÂ∏åÂáΩÊï∞">#</a></h4>
<p>

    <div class="post-img-view">
        <a data-fancybox="gallery" href="https://raw.githubusercontent.com/Kennems/blog-image/main/image-20241003222230144.png">
            <img src="https://raw.githubusercontent.com/Kennems/blog-image/main/image-20241003222230144.png" alt="image-20241003222230144"  />
        </a>
    </div>

</p>
<h4 id="4ÂàùÂßãÂåñÂÆûÁé∞ÂÖ®Â±ÄbufferÂàùÂßãÂåñ‰ª•ÂèäÊØè‰∏™Ê°∂ÂÜÖÁöÑbufferÂàùÂßãÂåñ">4„ÄÅÂàùÂßãÂåñÂÆûÁé∞ÂÖ®Â±ÄbufferÂàùÂßãÂåñÔºå‰ª•ÂèäÊØè‰∏™Ê°∂ÂÜÖÁöÑbufferÂàùÂßãÂåñ<a hidden class="anchor" aria-hidden="true" href="#4ÂàùÂßãÂåñÂÆûÁé∞ÂÖ®Â±ÄbufferÂàùÂßãÂåñ‰ª•ÂèäÊØè‰∏™Ê°∂ÂÜÖÁöÑbufferÂàùÂßãÂåñ">#</a></h4>
<p>

    <div class="post-img-view">
        <a data-fancybox="gallery" href="https://raw.githubusercontent.com/Kennems/blog-image/main/image-20241003222319841.png">
            <img src="https://raw.githubusercontent.com/Kennems/blog-image/main/image-20241003222319841.png" alt="image-20241003222319841"  />
        </a>
    </div>

</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#66d9ef">void</span> 
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">binit</span>(<span style="color:#66d9ef">void</span>)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">struct</span> buf <span style="color:#f92672">*</span>b;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">initlock</span>(<span style="color:#f92672">&amp;</span>bcache.lock, <span style="color:#e6db74">&#34;bcache&#34;</span>);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">for</span> (b <span style="color:#f92672">=</span> bcache.buf; b <span style="color:#f92672">&lt;</span> bcache.buf <span style="color:#f92672">+</span> NBUF; b<span style="color:#f92672">++</span>)
</span></span><span style="display:flex;"><span>  {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">initsleeplock</span>(<span style="color:#f92672">&amp;</span>b<span style="color:#f92672">-&gt;</span>lock, <span style="color:#e6db74">&#34;buffer&#34;</span>);
</span></span><span style="display:flex;"><span>    b<span style="color:#f92672">-&gt;</span>refcnt <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  b <span style="color:#f92672">=</span> bcache.buf;
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; i <span style="color:#f92672">&lt;</span> NBUCKET; i<span style="color:#f92672">++</span>)
</span></span><span style="display:flex;"><span>  {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">initlock</span>(<span style="color:#f92672">&amp;</span>hashtable[i].lock, <span style="color:#e6db74">&#34;bcache_bucket&#34;</span>);
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> j <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; j <span style="color:#f92672">&lt;</span> NBUF <span style="color:#f92672">/</span> NBUCKET; j<span style="color:#f92672">++</span>)
</span></span><span style="display:flex;"><span>    {
</span></span><span style="display:flex;"><span>      b<span style="color:#f92672">-&gt;</span>blockno <span style="color:#f92672">=</span> i;
</span></span><span style="display:flex;"><span>      b<span style="color:#f92672">-&gt;</span>refcnt <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>      b<span style="color:#f92672">-&gt;</span>next <span style="color:#f92672">=</span> hashtable[i].head.next;
</span></span><span style="display:flex;"><span>      hashtable[i].head.next <span style="color:#f92672">=</span> b;
</span></span><span style="display:flex;"><span>      b<span style="color:#f92672">++</span>;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h4 id="5ÈáçÁÇπ-ÈáçÊûÑbgetÊ°∂ÂÜÖÂØªÊâæÊòØÂê¶Â∑≤ÁªèÁºìÂ≠ò-Ê°∂ÂÜÖÂØªÊâæÁ©∫ÁôΩÁºìÂ≠ò--ÂØªÊâæÂÖ®Â±ÄÁ©∫ÁôΩÁºìÂ≠ò">5„ÄÅÈáçÁÇπÔºå ÈáçÊûÑ<code>bget()</code>ÔºåÊ°∂ÂÜÖÂØªÊâæÊòØÂê¶Â∑≤ÁªèÁºìÂ≠ò<code>-&gt;</code>Ê°∂ÂÜÖÂØªÊâæÁ©∫ÁôΩÁºìÂ≠ò <code>-&gt;</code>ÂØªÊâæÂÖ®Â±ÄÁ©∫ÁôΩÁºìÂ≠ò<a hidden class="anchor" aria-hidden="true" href="#5ÈáçÁÇπ-ÈáçÊûÑbgetÊ°∂ÂÜÖÂØªÊâæÊòØÂê¶Â∑≤ÁªèÁºìÂ≠ò-Ê°∂ÂÜÖÂØªÊâæÁ©∫ÁôΩÁºìÂ≠ò--ÂØªÊâæÂÖ®Â±ÄÁ©∫ÁôΩÁºìÂ≠ò">#</a></h4>
<p>

    <div class="post-img-view">
        <a data-fancybox="gallery" href="https://raw.githubusercontent.com/Kennems/blog-image/main/image-20241003222531184.png">
            <img src="https://raw.githubusercontent.com/Kennems/blog-image/main/image-20241003222531184.png" alt="image-20241003222531184"  />
        </a>
    </div>

</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#66d9ef">static</span> <span style="color:#66d9ef">struct</span> buf <span style="color:#f92672">*</span>
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">find_replacement_in_bucket</span>(<span style="color:#66d9ef">struct</span> bucket <span style="color:#f92672">*</span>bucket, uint <span style="color:#f92672">*</span>min_time)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">struct</span> buf <span style="color:#f92672">*</span>replace_buf <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">struct</span> buf <span style="color:#f92672">*</span>b;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">for</span> (b <span style="color:#f92672">=</span> bucket<span style="color:#f92672">-&gt;</span>head.next; b <span style="color:#f92672">!=</span> <span style="color:#ae81ff">0</span>; b <span style="color:#f92672">=</span> b<span style="color:#f92672">-&gt;</span>next)
</span></span><span style="display:flex;"><span>  {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> (b<span style="color:#f92672">-&gt;</span>refcnt <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span> <span style="color:#f92672">&amp;&amp;</span> (<span style="color:#f92672">*</span>min_time <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span> <span style="color:#f92672">||</span> b<span style="color:#f92672">-&gt;</span>timestamp <span style="color:#f92672">&lt;</span> <span style="color:#f92672">*</span>min_time))
</span></span><span style="display:flex;"><span>    {
</span></span><span style="display:flex;"><span>      replace_buf <span style="color:#f92672">=</span> b;
</span></span><span style="display:flex;"><span>      <span style="color:#f92672">*</span>min_time <span style="color:#f92672">=</span> b<span style="color:#f92672">-&gt;</span>timestamp;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">return</span> replace_buf;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">static</span> <span style="color:#66d9ef">struct</span> buf <span style="color:#f92672">*</span>
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">find_replacement_in_global</span>(<span style="color:#66d9ef">struct</span> buf <span style="color:#f92672">*</span>replace_buf, uint <span style="color:#f92672">*</span>min_time)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">struct</span> buf <span style="color:#f92672">*</span>b;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">for</span> (b <span style="color:#f92672">=</span> bcache.buf; b <span style="color:#f92672">&lt;</span> bcache.buf <span style="color:#f92672">+</span> NBUF; b<span style="color:#f92672">++</span>)
</span></span><span style="display:flex;"><span>  {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> (b<span style="color:#f92672">-&gt;</span>refcnt <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span> <span style="color:#f92672">&amp;&amp;</span> (<span style="color:#f92672">*</span>min_time <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span> <span style="color:#f92672">||</span> b<span style="color:#f92672">-&gt;</span>timestamp <span style="color:#f92672">&lt;</span> <span style="color:#f92672">*</span>min_time))
</span></span><span style="display:flex;"><span>    {
</span></span><span style="display:flex;"><span>      replace_buf <span style="color:#f92672">=</span> b;
</span></span><span style="display:flex;"><span>      <span style="color:#f92672">*</span>min_time <span style="color:#f92672">=</span> b<span style="color:#f92672">-&gt;</span>timestamp;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">return</span> replace_buf;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">static</span> <span style="color:#66d9ef">void</span> 
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">move_buf_to_bucket</span>(<span style="color:#66d9ef">struct</span> buf <span style="color:#f92672">*</span>replace_buf, <span style="color:#66d9ef">int</span> idx)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">int</span> ridx <span style="color:#f92672">=</span> <span style="color:#a6e22e">hash</span>(replace_buf<span style="color:#f92672">-&gt;</span>dev, replace_buf<span style="color:#f92672">-&gt;</span>blockno);
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">acquire</span>(<span style="color:#f92672">&amp;</span>hashtable[ridx].lock);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">if</span> (replace_buf<span style="color:#f92672">-&gt;</span>refcnt <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span>)
</span></span><span style="display:flex;"><span>  {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">struct</span> buf <span style="color:#f92672">*</span>pre <span style="color:#f92672">=</span> <span style="color:#f92672">&amp;</span>hashtable[ridx].head;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">struct</span> buf <span style="color:#f92672">*</span>p <span style="color:#f92672">=</span> hashtable[ridx].head.next;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">while</span> (p <span style="color:#f92672">!=</span> replace_buf)
</span></span><span style="display:flex;"><span>    {
</span></span><span style="display:flex;"><span>      pre <span style="color:#f92672">=</span> pre<span style="color:#f92672">-&gt;</span>next;
</span></span><span style="display:flex;"><span>      p <span style="color:#f92672">=</span> p<span style="color:#f92672">-&gt;</span>next;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    pre<span style="color:#f92672">-&gt;</span>next <span style="color:#f92672">=</span> p<span style="color:#f92672">-&gt;</span>next;
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">release</span>(<span style="color:#f92672">&amp;</span>hashtable[ridx].lock);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// Add to current bucket
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    replace_buf<span style="color:#f92672">-&gt;</span>next <span style="color:#f92672">=</span> hashtable[idx].head.next;
</span></span><span style="display:flex;"><span>    hashtable[idx].head.next <span style="color:#f92672">=</span> replace_buf;
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">else</span>
</span></span><span style="display:flex;"><span>  {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">release</span>(<span style="color:#f92672">&amp;</span>hashtable[ridx].lock);
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">static</span> <span style="color:#66d9ef">struct</span> buf<span style="color:#f92672">*</span>
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">bget</span>(uint dev, uint blockno)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">struct</span> buf <span style="color:#f92672">*</span>b;
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">int</span> h <span style="color:#f92672">=</span> <span style="color:#a6e22e">hash</span>(dev, blockno);
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">struct</span> bucket <span style="color:#f92672">*</span>bucket <span style="color:#f92672">=</span> <span style="color:#f92672">&amp;</span>hashtable[h];
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">acquire</span>(<span style="color:#f92672">&amp;</span>bucket<span style="color:#f92672">-&gt;</span>lock);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#75715e">// Check if block is already cached Ê°∂ÂÜÖÂØªÊâæ
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  <span style="color:#66d9ef">for</span> (b <span style="color:#f92672">=</span> bucket<span style="color:#f92672">-&gt;</span>head.next; b <span style="color:#f92672">!=</span> <span style="color:#ae81ff">0</span>; b <span style="color:#f92672">=</span> b<span style="color:#f92672">-&gt;</span>next)
</span></span><span style="display:flex;"><span>  {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> (b<span style="color:#f92672">-&gt;</span>dev <span style="color:#f92672">==</span> dev <span style="color:#f92672">&amp;&amp;</span> b<span style="color:#f92672">-&gt;</span>blockno <span style="color:#f92672">==</span> blockno)
</span></span><span style="display:flex;"><span>    {
</span></span><span style="display:flex;"><span>      b<span style="color:#f92672">-&gt;</span>refcnt<span style="color:#f92672">++</span>;
</span></span><span style="display:flex;"><span>      <span style="color:#a6e22e">release</span>(<span style="color:#f92672">&amp;</span>bucket<span style="color:#f92672">-&gt;</span>lock);
</span></span><span style="display:flex;"><span>      <span style="color:#a6e22e">acquiresleep</span>(<span style="color:#f92672">&amp;</span>b<span style="color:#f92672">-&gt;</span>lock);
</span></span><span style="display:flex;"><span>      <span style="color:#66d9ef">return</span> b;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#75715e">// Not cached, find replacement buffer Ê°∂ÂÜÖÁöÑÁ©∫ÁôΩbuf
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  uint min_time <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">struct</span> buf <span style="color:#f92672">*</span>replace_buf;
</span></span><span style="display:flex;"><span>  replace_buf <span style="color:#f92672">=</span> <span style="color:#a6e22e">find_replacement_in_bucket</span>(bucket, <span style="color:#f92672">&amp;</span>min_time);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">if</span> (<span style="color:#f92672">!</span>replace_buf)
</span></span><span style="display:flex;"><span>  {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">acquire</span>(<span style="color:#f92672">&amp;</span>bcache.lock);
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// ÂØªÊâæÊ°∂Â§ñÁöÑÁ©∫ÁôΩbuf
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    replace_buf <span style="color:#f92672">=</span> <span style="color:#a6e22e">find_replacement_in_global</span>(replace_buf, <span style="color:#f92672">&amp;</span>min_time);
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> (replace_buf)
</span></span><span style="display:flex;"><span>    {
</span></span><span style="display:flex;"><span>      <span style="color:#a6e22e">move_buf_to_bucket</span>(replace_buf, h);
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">else</span>
</span></span><span style="display:flex;"><span>    {
</span></span><span style="display:flex;"><span>      <span style="color:#a6e22e">release</span>(<span style="color:#f92672">&amp;</span>bcache.lock);
</span></span><span style="display:flex;"><span>      <span style="color:#a6e22e">panic</span>(<span style="color:#e6db74">&#34;bget: no buffers&#34;</span>);
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">release</span>(<span style="color:#f92672">&amp;</span>bcache.lock);
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#75715e">// Initialize and return the replacement buffer
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  replace_buf<span style="color:#f92672">-&gt;</span>dev <span style="color:#f92672">=</span> dev;
</span></span><span style="display:flex;"><span>  replace_buf<span style="color:#f92672">-&gt;</span>blockno <span style="color:#f92672">=</span> blockno;
</span></span><span style="display:flex;"><span>  replace_buf<span style="color:#f92672">-&gt;</span>valid <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>  replace_buf<span style="color:#f92672">-&gt;</span>refcnt <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">release</span>(<span style="color:#f92672">&amp;</span>bucket<span style="color:#f92672">-&gt;</span>lock);
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">acquiresleep</span>(<span style="color:#f92672">&amp;</span>replace_buf<span style="color:#f92672">-&gt;</span>lock);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">return</span> replace_buf;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h4 id="6ÈîÅÁöÑÈáäÊîæÊõ¥Êñ∞ÂºïÁî®ËÆ°Êï∞ÂΩìrefcnt--0Êó∂Êõ¥Êñ∞Êó∂Èó¥Êà≥">6„ÄÅÈîÅÁöÑÈáäÊîæÔºåÊõ¥Êñ∞ÂºïÁî®ËÆ°Êï∞ÔºåÂΩì<code>refcnt == 0</code>Êó∂Êõ¥Êñ∞Êó∂Èó¥Êà≥<a hidden class="anchor" aria-hidden="true" href="#6ÈîÅÁöÑÈáäÊîæÊõ¥Êñ∞ÂºïÁî®ËÆ°Êï∞ÂΩìrefcnt--0Êó∂Êõ¥Êñ∞Êó∂Èó¥Êà≥">#</a></h4>
<p>

    <div class="post-img-view">
        <a data-fancybox="gallery" href="https://raw.githubusercontent.com/Kennems/blog-image/main/image-20241003223158291.png">
            <img src="https://raw.githubusercontent.com/Kennems/blog-image/main/image-20241003223158291.png" alt="image-20241003223158291"  />
        </a>
    </div>

</p>
<p>7„ÄÅÊõ¥Êñ∞ <code>bpin()</code> Âíå <code>bunpin()</code>, Âè™ÈúÄË¶ÅÊåÅÊúâÂØπÂ∫îÊ°∂ÁöÑÈîÅÂç≥ÂèØ</p>
<p>

    <div class="post-img-view">
        <a data-fancybox="gallery" href="https://raw.githubusercontent.com/Kennems/blog-image/main/image-20241003223237895.png">
            <img src="https://raw.githubusercontent.com/Kennems/blog-image/main/image-20241003223237895.png" alt="image-20241003223237895"  />
        </a>
    </div>

</p>


  </div>

  <footer class="post-footer">
    <ul class="post-tags">
      <li><a href="https://kennems.github.io/tags/mit6.s081/">MIT6.S081</a></li>
    </ul>
        
    
    <ul id="categories">
      
        <li><a href="https://kennems.github.io/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F">Êìç‰ΩúÁ≥ªÁªü</a> </li>
      
    </ul>
    
    
<nav class="paginav">
  <a class="prev" href="https://kennems.github.io/posts/tech/prompt/">
    <span class="title">¬´ ‰∏ä‰∏ÄÈ°µ</span>
    <br>
    <span>Prompt</span>
  </a>
  <a class="next" href="https://kennems.github.io/posts/tech/%E5%91%A8%E8%B5%9B240924/">
    <span class="title">‰∏ã‰∏ÄÈ°µ ¬ª</span>
    <br>
    <span>LeetCodeÂë®Ëµõ416(250922)</span>
  </a>
</nav>

  </footer>
</article>
    </main>
    
<footer class="footer">
    <span>&copy; 2024 <a href="https://kennems.github.io/">Kennem&#39;s Blog</a></span>
    <span>
        Powered by
        <a href="https://gohugo.io/" rel="noopener noreferrer" target="_blank">Hugo</a> &
        <a href="https://github.com/adityatelange/hugo-PaperMod/" rel="noopener" target="_blank">PaperMod</a>
    </span>
</footer>
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)" class="top-link" id="top-link" accesskey="g">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
        <path d="M12 6H0l6-6z" />
    </svg>
</a>

<script>
    let menu = document.getElementById('menu')
    if (menu) {
        menu.scrollLeft = localStorage.getItem("menu-scroll-position");
        menu.onscroll = function () {
            localStorage.setItem("menu-scroll-position", menu.scrollLeft);
        }
    }

    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.pushState(null, null, `#${id}`);
            }
        });
    });

</script>
<script>
    var mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };

</script>
<script>
    document.getElementById("theme-toggle").addEventListener("click", () => {
        if (document.body.className.includes("dark")) {
            document.body.classList.remove('dark');
            localStorage.setItem("pref-theme", 'light');
        } else {
            document.body.classList.add('dark');
            localStorage.setItem("pref-theme", 'dark');
        }
    })

</script>
<script>
    document.querySelectorAll('pre > code').forEach((codeblock) => {
        const container = codeblock.parentNode.parentNode;

        const copybutton = document.createElement('button');
        copybutton.classList.add('copy-code');
        copybutton.innerHTML = 'Â§çÂà∂';

        function copyingDone() {
            copybutton.innerHTML = 'Â∑≤Â§çÂà∂ÔºÅ';
            setTimeout(() => {
                copybutton.innerHTML = 'Â§çÂà∂';
            }, 2000);
        }

        copybutton.addEventListener('click', (cb) => {
            if ('clipboard' in navigator) {
                navigator.clipboard.writeText(codeblock.textContent);
                copyingDone();
                return;
            }

            const range = document.createRange();
            range.selectNodeContents(codeblock);
            const selection = window.getSelection();
            selection.removeAllRanges();
            selection.addRange(range);
            try {
                document.execCommand('copy');
                copyingDone();
            } catch (e) { };
            selection.removeRange(range);
        });

        if (container.classList.contains("highlight")) {
            container.appendChild(copybutton);
        } else if (container.parentNode.firstChild == container) {
            
        } else if (codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName == "TABLE") {
            
            codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(copybutton);
        } else {
            
            codeblock.parentNode.appendChild(copybutton);
        }
    });
</script>
<footer class="footer">
    <script async src="https://busuanzi.sukap.cn/busuanzi.pure.mini.js"></script>
    <span id="busuanzi_container">
        <link rel="stylesheet" href="//maxcdn.bootstrapcdn.com/font-awesome/4.3.0/css/font-awesome.min.css">
        Visitors: <span id="busuanzi_value_page_uv"></span>
        Views: <span id="busuanzi_value_page_pv"></span>

        
    </span>
</footer>



</body>

</html>
