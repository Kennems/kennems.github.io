<!DOCTYPE html>
<html lang="zh" dir="auto">

<head><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="index, follow">

<meta name="msvalidate.01" content="DF5FE493CC759E62BFE073BEA8EFD472" />
<title>训练营第八天笔记 | Kennem&#39;s Blog</title>
<meta name="keywords" content="Android">
<meta name="description" content="Android学习笔记">
<meta name="author" content="ShowGuan">
<link rel="canonical" href="https://kennems.github.io/posts/tech/%E7%AC%AC%E5%85%AB%E5%A4%A9%E7%AC%94%E8%AE%B0/">
<link crossorigin="anonymous" href="/assets/css/stylesheet.b0b75e963d4643f817dc4da6eda116517a285285a07b77f8da8234e4fa6e6f57.css" integrity="sha256-sLdelj1GQ/gX3E2m7aEWUXooUoWge3f42oI05Ppub1c=" rel="preload stylesheet" as="style">
<link rel="icon" href="https://kennems.github.io/img/sun.png">
<link rel="icon" type="image/png" sizes="16x16" href="https://kennems.github.io/img/sun.png">
<link rel="icon" type="image/png" sizes="32x32" href="https://kennems.github.io/img/sun.png">
<link rel="apple-touch-icon" href="https://kennems.github.io/img/sun.png">
<link rel="mask-icon" href="https://kennems.github.io/img/sun.png">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<link rel="alternate" hreflang="zh" href="https://kennems.github.io/posts/tech/%E7%AC%AC%E5%85%AB%E5%A4%A9%E7%AC%94%E8%AE%B0/">
<noscript>
    <style>
        #theme-toggle,
        .top-link {
            display: none;
        }

    </style>
    <style>
        @media (prefers-color-scheme: dark) {
            :root {
                --theme: rgb(29, 30, 32);
                --entry: rgb(46, 46, 51);
                --primary: rgb(218, 218, 219);
                --secondary: rgb(155, 156, 157);
                --tertiary: rgb(65, 66, 68);
                --content: rgb(196, 196, 197);
                --code-block-bg: rgb(46, 46, 51);
                --code-bg: rgb(55, 56, 62);
                --border: rgb(51, 51, 51);
            }

            .list {
                background: var(--theme);
            }

            .list:not(.dark)::-webkit-scrollbar-track {
                background: 0 0;
            }

            .list:not(.dark)::-webkit-scrollbar-thumb {
                border-color: var(--theme);
            }
        }

    </style>
</noscript>

<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.2/dist/katex.min.css" integrity="sha384-MlJdn/WNKDGXveldHDdyRP1R4CTHr3FeuDNfhsLPYrq2t0UBkUdK2jyTnXPEK1NQ" crossorigin="anonymous">

<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.2/dist/katex.min.js" integrity="sha384-VQ8d8WVFw0yHhCk5E8I86oOhv48xLpnDZx5T9GogA/Y84DcCKWXDmSDfn13bzFZY" crossorigin="anonymous"></script>

<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.2/dist/contrib/auto-render.min.js" integrity="sha384-+XBljXPPiv+OzfbB3cVmLHf4hdUFHlWNZN5spNQ7rmHTXpd7WvJum6fIACpNNfIR" crossorigin="anonymous"
    onload="renderMathInElement(document.body);"></script>


<script>
document.addEventListener("DOMContentLoaded", function() {
    renderMathInElement(document.body, {
        delimiters: [
            {left: "$$", right: "$$", display: true},
            {left: "$", right: "$", display: false}
        ]
    });
});
</script>


<link href="https://fonts.cdnfonts.com/css/code-new-roman" rel="stylesheet">
                
  

<meta property="og:title" content="训练营第八天笔记" />
<meta property="og:description" content="Android学习笔记" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://kennems.github.io/posts/tech/%E7%AC%AC%E5%85%AB%E5%A4%A9%E7%AC%94%E8%AE%B0/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2024-07-13T22:30:13+08:00" />
<meta property="article:modified_time" content="2024-07-13T22:20:13+08:00" />

<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="训练营第八天笔记"/>
<meta name="twitter:description" content="Android学习笔记"/>


<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BreadcrumbList",
  "itemListElement": [
    {
      "@type": "ListItem",
      "position":  1 ,
      "name": "📚文章",
      "item": "https://kennems.github.io/posts/"
    }, 
    {
      "@type": "ListItem",
      "position":  2 ,
      "name": "💻技术",
      "item": "https://kennems.github.io/posts/tech/"
    }, 
    {
      "@type": "ListItem",
      "position":  3 ,
      "name": "训练营第八天笔记",
      "item": "https://kennems.github.io/posts/tech/%E7%AC%AC%E5%85%AB%E5%A4%A9%E7%AC%94%E8%AE%B0/"
    }
  ]
}
</script>
<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "训练营第八天笔记",
  "name": "训练营第八天笔记",
  "description": "Android学习笔记",
  "keywords": [
    "Android"
  ],
  "articleBody": "第八天笔记 自定义控件的实现 View 绘制过程 Activity 和 View 的关系 Window 类：负责在 Activity 中展示内容（具体实现为 PhoneWindow 类） DecorView：Window 创建出根布局 DecorView（继承自 FrameLayout） 单个 View 的绘制步骤 系统根据布局树完成界面绘制，单个 View 需要经过三个步骤：\n计算 View 的宽高：measure 计算 View 的位置：layout 绘制 View 的内容：draw 布局树逐级向下调用 布局树的绘制过程从上到下逐级调用，具体步骤如下：\n测量： performMeasure() measure() onMeasure() 布局： performLayout() layout() onLayout() 绘制： performDraw() draw() onDraw() 视图树调用流程图 位置的描述依赖坐标系 Android 的坐标系定义为： 屏幕的左上角为坐标原点 向右为 x 轴增大方向 向下为 y 轴增大方向 自定义 View draw 函数 作用：绘制内容在给定的 Canvas 上\n调用时机：要保证 layout 之后再调用这个方法\n注意事项：自定义 View 时考虑优先重写 onDraw 方法而不是这个方法\n继承关系：如果一定要重写 draw 方法，要记得调用父类方法\n实现步骤：有 7 个绘制步骤：\n绘制背景 其余步骤依次类推 位置的描述依赖坐标系 Android 的坐标系定义为： 屏幕的左上角为坐标原点 向右为 x 轴增大方向 向下为 y 轴增大方向 draw 函数 作用：绘制内容在给定的 Canvas 上。\n调用时机：要保证 layout 之后再调用这个方法。\n注意事项：自定义 View 时考虑优先重写 onDraw 方法而不是这个方法。\n继承关系：如果一定要重写 draw 方法，要记得调用父类方法。\n实现步骤：有 7 个绘制步骤：\n绘制背景 如有必要，保存画布图层以准备淡入淡出动画 绘制内容 绘制子 View（即调用 childView.draw） 如有必要，绘制淡入淡出并恢复图层 绘制装饰（例如滚动条） 如有必要，绘制默认焦点高亮 /** * Manually render this view (and all of its children) to the given Canvas. * The view must have already done a full layout before this function is * called. When implementing a view, implement * {@link #onDraw(android.graphics.Canvas)} instead of overriding this method. * If you do need to override this method, call the superclass version. * * @param canvas The Canvas to which the View is rendered. */ @CallSuper public void draw(Canvas canvas) { final int privateFlags = mPrivateFlags; mPrivateFlags = (privateFlags \u0026 ~PFLAG_DIRTY_MASK) | PFLAG_DRAWN; /* * Draw traversal performs several drawing steps which must be executed * in the appropriate order: * * 1. Draw the background * 2. If necessary, save the canvas' layers to prepare for fading * 3. Draw view's content * 4. Draw children * 5. If necessary, draw the fading edges and restore layers * 6. Draw decorations (scrollbars for instance) * 7. If necessary, draw the default focus highlight */ } onDraw 函数 调用时机：在 7 个绘制步骤中的第三步。 实现：绘制内容。 protected void onDraw(Canvas canvas) { // Step 1, draw the background, if needed int saveCount; drawBackground(canvas); // skip step 2 \u0026 5 if possible (common case) final int viewFlags = mViewFlags; boolean horizontalEdges = (viewFlags \u0026 FADING_EDGE_HORIZONTAL) != 0; boolean verticalEdges = (viewFlags \u0026 FADING_EDGE_VERTICAL) != 0; if (!verticalEdges \u0026\u0026 !horizontalEdges) { // Step 3, draw the content onDraw(canvas); } } 绘制内容在给定的 Canvas 上 Canvas 类：Android 中用于绘制图形的重要类。它包含了许多绘图方法，主要可以分为以下几类：\n绘制基本的几何形状，如矩形、圆形、椭圆等 使用路径（Path）定义复杂的图形 drawRect(RectF rect, Paint paint) drawPath(Path path, Paint paint) drawCircle(float cx, float cy, float radius, Paint paint) drawOval(RectF oval, Paint paint) 用于在画布上绘制文本 绘制位图图像 drawText(String text, float x, float y, Paint paint) drawBitmap(Bitmap bitmap, float left, float top, Paint paint) 设置绘制的颜色和样式 drawColor(int color): 设置绘制的颜色 drawPaint(Paint paint): 设置绘制的样式 对画布进行变换 translate(float dx, float dy): 平移变换 rotate(float degrees): 旋转变换 在画布上创建和操作图层，实现图层效果 save(): 保存当前画布的状态 restore(): 恢复之前保存的画布状态 Paint 类配合提供绘制参数 Paint paint = new Paint(); paint.setColor(Color.RED); // 设置颜色 paint.setTextSize(24); // 设置文字大小 paint.setTypeface(Typeface.create(Typeface.DEFAULT, Typeface.BOLD)); // 设置字体样式 paint.setStrokeWidth(2); // 设置绘制线条宽度 paint.setAntiAlias(true); // 启用抗锯齿 Path 类配合描述复杂图形 Path path = new Path(); path.moveTo(x: 100, y: 200); // 从当前位置移动到指定位置（不画线） path.lineTo(x: 100, y: 200); // 从前点绘制一条线到指定点 RectF oval = new RectF(left: 100, top: 100, right: 300, bottom: 600); // 绘制圆线 path.arcTo(oval, startAngle: 100, sweepAngle: 180, forceMoveTo: true); // 绘制弧线 path.close(); // 连接当前点和起始点 自定义 ViewGroup measure 函数 作用: 计算 View 的宽高 调用 onMeasure 完成真正的计算工作，且子类应该重写 onMeasure final 修饰该方法，不可重写 public final void measure(int widthMeasureSpec, int heightMeasureSpec) { boolean optical = isLayoutModeOptical() != this; if (optical != isLayoutModeOptical(mParent)) { // ... 相关代码 } } onMeasure 函数\n作用: 计算 View 的宽高，应由子类重写，以提供对其内容的准确有效的测量。 约定: 重写此方法时，必须调用 setMeasuredDimension(width, height) 来存储测量好的宽度和高度。 没有 final 修饰符，可重写 protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) { setMeasuredDimension(getDefaultSize(getSuggestedMinimumWidth(), widthMeasureSpec), getDefaultSize(getSuggestedMinimumHeight(), heightMeasureSpec)); } MeasureSpec 类 MeasureSpec 包含两部分信息：\n低 30 位为 SpecSize，即尺寸 高 2 位为 SpecMode，即测量模式 @Override protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) { int widthSpecMode = MeasureSpec.getMode(widthMeasureSpec); int widthSpecSize = MeasureSpec.getSize(widthMeasureSpec); int heightSpecMode = MeasureSpec.getMode(heightMeasureSpec); int heightSpecSize = MeasureSpec.getSize(heightMeasureSpec); int newWidthSpec = MeasureSpec.makeMeasureSpec(1, MeasureSpec.AT_MOST); } MeasureSpec 高 2 位为 SpecMode，即测量模式 测量模式 说明 UNSPECIFIED 父 View 对子 View 的大小不做限制 EXACTLY 父 View 计算好了子 View 具体的宽高，子 View 的最终大小就是 SpecSize 指定的值 AT_MOST 父 View 指定了一个可用大小 SpecSize，子 View 的大小不能大于这个值 onMeasure 函数\n作用: 计算 View 的宽高，应由子类重写，以提供对其内容的准确有效的测量。 约定: 重写此方法时，必须调用 setMeasuredDimension(width, height) 来存储测量好的宽度和高度。 没有 final 修饰符，可重写 protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) { setMeasuredDimension(getDefaultSize(getSuggestedMinimumWidth(), widthMeasureSpec), getDefaultSize(getSuggestedMinimumHeight(), heightMeasureSpec)); } MeasureSpec 类 MeasureSpec 包含两部分信息：\n低 30 位为 SpecSize，即尺寸 高 2 位为 SpecMode，即测量模式 @Override protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) { int widthSpecMode = MeasureSpec.getMode(widthMeasureSpec); int widthSpecSize = MeasureSpec.getSize(widthMeasureSpec); int heightSpecMode = MeasureSpec.getMode(heightMeasureSpec); int heightSpecSize = MeasureSpec.getSize(heightMeasureSpec); int newWidthSpec = MeasureSpec.makeMeasureSpec(1, MeasureSpec.AT_MOST); } MeasureSpec 高 2 位为 SpecMode，即测量模式 测量模式 说明 UNSPECIFIED 父 View 对子 View 的大小不做限制 EXACTLY 父 View 计算好了子 View 具体的宽高，子 View 的最终大小就是 SpecSize 指定的值 AT_MOST 父 View 指定了一个可用大小 SpecSize，子 View 的大小不能大于这个值 ViewGroup 中 MeasureSpec 计算公式 子 View 的布局参数（通过 childView.getLayoutParams() 获取） + 父 View 的测量要求 = 子 View 的 MeasureSpec\n测量模式 精确值 MATCH_PARENT WRAP_CONTENT EXACTLY SpecSize: View Group SizeSpecMode: EXACTLY SpecSize: View Group SizeSpecMode: EXACTLY SpecSize: View Group SizeSpecMode: AT_MOST AT_MOST SpecSize: View Group SizeSpecMode: AT_MOST SpecSize: View Group SizeSpecMode: AT_MOST SpecSize: View Group SizeSpecMode: AT_MOST UNSPECIFIED SpecSize: 0SpecMode: UNSPECIFIED SpecSize: 0SpecMode: UNSPECIFIED SpecSize: 0SpecMode: UNSPECIFIED onMeasure 函数实现 父 View 测量要求（MeasureSpec）作为 onMeasure 的入参传入：UNSPECIFIED, EXACTLY, AT_MOST 实现： 根据公式：子 View 布局参数（+ 父 View 测量要求）= 子 View 测量要求 将子 View 测量要求作为参数，调用子 View 的 measure 方法 根据当前 ViewGroup 布局策略计算自己的宽高 调用 setMeasuredDimension(int, int) 保存计算好的宽高 layout 函数 布局机制的第二阶段（第一阶段是测量） 作用: 给所有子 View 分配位置 实现: 在这个阶段，每个父 View 调用其所有子 View 的 layout 方法来确定它们的位置。 派生类不应覆盖此方法，子 View 的派生类应覆盖 onLayout 方法。 public void layout(int l, int t, int r, int b) { if ((mPrivateFlags \u0026 PFLAG3_MEASURE_NEEDED_BEFORE_LAYOUT) != 0) { onMeasure(mOldWidthMeasureSpec, mOldHeightMeasureSpec); mPrivateFlags3 \u0026= ~PFLAG3_MEASURE_NEEDED_BEFORE_LAYOUT; } ... } onLayout 函数 被 layout 方法调用 作用: 为该 View 的子 View 分配位置 有子 View 的派生类应重写该方法，并对每个子 View 调用 layout 方法，通常是使用在测量过程中存储的子 View 尺寸来完成的。 . onLayout 方法 定义：在 layout 被调用时，分配每个子 View 的位置和尺寸。 参数： changed：此视图的尺寸或位置是否发生变化。 left：相对于父视图的左边位置。 top：相对于父视图的顶部位置。 right：相对于父视图的右边位置。 bottom：相对于父视图的底部位置。 2. 使用在测量过程中存储的子 View 尺寸来完成布局 在 onLayout 方法中调用子视图的 layout 方法，使用 getMeasuredWidth 和 getMeasuredHeight 获取子视图的宽度和高度。 3. getMeasuredHeight 和 getHeight 的区别 getMeasuredWidth / getMeasuredHeight： 作用：获取 View 测量的宽高。 赋值时机：measure 过程中。 赋值方法：setMeasuredDimension。 值大小：一般情况下二者获取的宽高值相等。 getWidth / getHeight：gtcg 作用：获取 View 最终的宽高。 赋值时机：layout 过程中。 赋值方法：layout 中传递的 4 个参数之间的运算。 4. 如何定义标签间距？ 自定义属性：\n在 res/values/ 新建 attrs.xml 文件，定义标签间距的属性。\n示例代码：\n\u003c?xml version=\"1.0\" encoding=\"utf-8\"?\u003e ",
  "wordCount" : "5169",
  "inLanguage": "zh",
  "datePublished": "2024-07-13T22:30:13+08:00",
  "dateModified": "2024-07-13T22:20:13+08:00",
  "author":{
    "@type": "Person",
    "name": "ShowGuan"
  },
  "mainEntityOfPage": {
    "@type": "WebPage",
    "@id": "https://kennems.github.io/posts/tech/%E7%AC%AC%E5%85%AB%E5%A4%A9%E7%AC%94%E8%AE%B0/"
  },
  "publisher": {
    "@type": "Organization",
    "name": "Kennem's Blog",
    "logo": {
      "@type": "ImageObject",
      "url": "https://kennems.github.io/img/sun.png"
    }
  }
}
</script>
<script src="https://cdn.jsdelivr.net/npm/jquery@3.5.1/dist/jquery.min.js"></script>
<link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.css" />
<script src="https://cdn.jsdelivr.net/gh/fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.js"></script>




</head>

<body class="" id="top">
<script>
    if (localStorage.getItem("pref-theme") === "dark") {
        document.body.classList.add('dark');
    } else if (localStorage.getItem("pref-theme") === "light") {
        document.body.classList.remove('dark')
    } else if (window.matchMedia('(prefers-color-scheme: dark)').matches) {
        document.body.classList.add('dark');
    }

</script>

<header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="https://kennems.github.io/" accesskey="h" title="Kennem&#39;s Blog (Alt + H)">
                <img src="https://kennems.github.io/img/sun.png" alt="" aria-label="logo"
                    height="35">Kennem&#39;s Blog</a>
            <div class="logo-switches">
                <button id="theme-toggle" accesskey="t" title="(Alt + T)">
                    <svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
                    </svg>
                    <svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <circle cx="12" cy="12" r="5"></circle>
                        <line x1="12" y1="1" x2="12" y2="3"></line>
                        <line x1="12" y1="21" x2="12" y2="23"></line>
                        <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                        <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                        <line x1="1" y1="12" x2="3" y2="12"></line>
                        <line x1="21" y1="12" x2="23" y2="12"></line>
                        <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                        <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
                    </svg>
                </button>
            </div>
        </div>
        <ul id="menu">
            <li>
                <a href="https://kennems.github.io/" title="🏠主页">
                    <span>🏠主页</span>
                </a>
            </li>
            <li>
                <a href="https://kennems.github.io/search" title="🔍搜索 (Alt &#43; /)" accesskey=/>
                    <span>🔍搜索</span>
                </a>
            </li>
            <li>
                <a href="https://kennems.github.io/posts" title="📚文章">
                    <span>📚文章</span>
                </a>
            </li>
            <li>
                <a href="https://kennems.github.io/archives" title="⏱时间轴">
                    <span>⏱时间轴</span>
                </a>
            </li>
            <li>
                <a href="https://kennems.github.io/tags" title="🔖标签">
                    <span>🔖标签</span>
                </a>
            </li>
            <li>
                <a href="https://kennems.github.io/categories" title="🗂️分类">
                    <span>🗂️分类</span>
                </a>
            </li>
            <li>
                <a href="https://kennems.github.io/about" title="🙋🏻‍♂️关于">
                    <span>🙋🏻‍♂️关于</span>
                </a>
            </li>
        </ul>
    </nav>
</header>
<main class="main">

<article class="post-single">
  <header class="post-header">
    <div class="breadcrumbs"><a href="https://kennems.github.io/">主页</a>&nbsp;»&nbsp;<a href="https://kennems.github.io/posts/">📚文章</a>&nbsp;»&nbsp;<a href="https://kennems.github.io/posts/tech/">💻技术</a></div>
    <h1 class="post-title entry-hint-parent">
      训练营第八天笔记
    </h1>
    <div class="post-description">
      Android学习笔记
    </div>
    <div class="post-meta"><span title='2024-07-13 22:30:13 +0800 CST'>2024-07-13</span>&nbsp;·&nbsp;11 分钟&nbsp;·&nbsp;5169 字&nbsp;·&nbsp;updated:&nbsp;2024-07-13&nbsp;·&nbsp;ShowGuan

</div>
    
     <div class="post-password">
        
    </div>
  </header> <aside id="toc-container" class="toc-container wide">
    <div class="toc">
        <details  open>
            <summary accesskey="c" title="(Alt + C)">
                <span class="details">目录</span>
            </summary>

            <div class="inner"><ul>
                    <li>
                        <a href="#%e7%ac%ac%e5%85%ab%e5%a4%a9%e7%ac%94%e8%ae%b0" aria-label="第八天笔记">第八天笔记</a><ul>
                            
                    <li>
                        <a href="#%e8%87%aa%e5%ae%9a%e4%b9%89%e6%8e%a7%e4%bb%b6%e7%9a%84%e5%ae%9e%e7%8e%b0" aria-label="自定义控件的实现">自定义控件的实现</a><ul>
                            <ul>
                            
                    <li>
                        <a href="#view-%e7%bb%98%e5%88%b6%e8%bf%87%e7%a8%8b" aria-label="View 绘制过程">View 绘制过程</a><ul>
                            
                    <li>
                        <a href="#activity-%e5%92%8c-view-%e7%9a%84%e5%85%b3%e7%b3%bb" aria-label="Activity 和 View 的关系">Activity 和 View 的关系</a></li>
                    <li>
                        <a href="#%e5%8d%95%e4%b8%aa-view-%e7%9a%84%e7%bb%98%e5%88%b6%e6%ad%a5%e9%aa%a4" aria-label="单个 View 的绘制步骤">单个 View 的绘制步骤</a></li></ul>
                    </li>
                    <li>
                        <a href="#%e5%b8%83%e5%b1%80%e6%a0%91%e9%80%90%e7%ba%a7%e5%90%91%e4%b8%8b%e8%b0%83%e7%94%a8" aria-label="布局树逐级向下调用">布局树逐级向下调用</a></li>
                    <li>
                        <a href="#%e8%a7%86%e5%9b%be%e6%a0%91%e8%b0%83%e7%94%a8%e6%b5%81%e7%a8%8b%e5%9b%be" aria-label="视图树调用流程图">视图树调用流程图</a></li>
                    <li>
                        <a href="#%e4%bd%8d%e7%bd%ae%e7%9a%84%e6%8f%8f%e8%bf%b0%e4%be%9d%e8%b5%96%e5%9d%90%e6%a0%87%e7%b3%bb" aria-label="位置的描述依赖坐标系">位置的描述依赖坐标系</a></li>
                    <li>
                        <a href="#%e8%87%aa%e5%ae%9a%e4%b9%89-view" aria-label="自定义 View">自定义 View</a><ul>
                            
                    <li>
                        <a href="#draw-%e5%87%bd%e6%95%b0" aria-label="draw 函数">draw 函数</a></li></ul>
                    </li>
                    <li>
                        <a href="#%e4%bd%8d%e7%bd%ae%e7%9a%84%e6%8f%8f%e8%bf%b0%e4%be%9d%e8%b5%96%e5%9d%90%e6%a0%87%e7%b3%bb-1" aria-label="位置的描述依赖坐标系">位置的描述依赖坐标系</a><ul>
                            
                    <li>
                        <a href="#draw-%e5%87%bd%e6%95%b0-1" aria-label="draw 函数">draw 函数</a></li>
                    <li>
                        <a href="#ondraw-%e5%87%bd%e6%95%b0" aria-label="onDraw 函数">onDraw 函数</a></li></ul>
                    </li>
                    <li>
                        <a href="#%e7%bb%98%e5%88%b6%e5%86%85%e5%ae%b9%e5%9c%a8%e7%bb%99%e5%ae%9a%e7%9a%84-canvas-%e4%b8%8a" aria-label="绘制内容在给定的 Canvas 上">绘制内容在给定的 Canvas 上</a></li>
                    <li>
                        <a href="#%e8%ae%be%e7%bd%ae%e7%bb%98%e5%88%b6%e7%9a%84%e9%a2%9c%e8%89%b2%e5%92%8c%e6%a0%b7%e5%bc%8f" aria-label="设置绘制的颜色和样式">设置绘制的颜色和样式</a></li>
                    <li>
                        <a href="#%e5%af%b9%e7%94%bb%e5%b8%83%e8%bf%9b%e8%a1%8c%e5%8f%98%e6%8d%a2" aria-label="对画布进行变换">对画布进行变换</a></li>
                    <li>
                        <a href="#%e5%9c%a8%e7%94%bb%e5%b8%83%e4%b8%8a%e5%88%9b%e5%bb%ba%e5%92%8c%e6%93%8d%e4%bd%9c%e5%9b%be%e5%b1%82%e5%ae%9e%e7%8e%b0%e5%9b%be%e5%b1%82%e6%95%88%e6%9e%9c" aria-label="在画布上创建和操作图层，实现图层效果">在画布上创建和操作图层，实现图层效果</a></li>
                    <li>
                        <a href="#paint-%e7%b1%bb%e9%85%8d%e5%90%88%e6%8f%90%e4%be%9b%e7%bb%98%e5%88%b6%e5%8f%82%e6%95%b0" aria-label="Paint 类配合提供绘制参数">Paint 类配合提供绘制参数</a></li>
                    <li>
                        <a href="#path-%e7%b1%bb%e9%85%8d%e5%90%88%e6%8f%8f%e8%bf%b0%e5%a4%8d%e6%9d%82%e5%9b%be%e5%bd%a2" aria-label="Path 类配合描述复杂图形">Path 类配合描述复杂图形</a></li>
                    <li>
                        <a href="#%e8%87%aa%e5%ae%9a%e4%b9%89-viewgroup" aria-label="自定义 ViewGroup">自定义 ViewGroup</a><ul>
                            
                    <li>
                        <a href="#measure-%e5%87%bd%e6%95%b0" aria-label="measure 函数">measure 函数</a></li></ul>
                    </li>
                    <li>
                        <a href="#measurespec-%e7%b1%bb" aria-label="MeasureSpec 类">MeasureSpec 类</a></li>
                    <li>
                        <a href="#measurespec-%e9%ab%98-2-%e4%bd%8d%e4%b8%ba-specmode%e5%8d%b3%e6%b5%8b%e9%87%8f%e6%a8%a1%e5%bc%8f" aria-label="MeasureSpec 高 2 位为 SpecMode，即测量模式">MeasureSpec 高 2 位为 SpecMode，即测量模式</a></li></ul>
                        
                    <li>
                        <a href="#measurespec-%e7%b1%bb-1" aria-label="MeasureSpec 类">MeasureSpec 类</a><ul>
                            
                    <li>
                        <a href="#measurespec-%e9%ab%98-2-%e4%bd%8d%e4%b8%ba-specmode%e5%8d%b3%e6%b5%8b%e9%87%8f%e6%a8%a1%e5%bc%8f-1" aria-label="MeasureSpec 高 2 位为 SpecMode，即测量模式">MeasureSpec 高 2 位为 SpecMode，即测量模式</a></li></ul>
                    </li>
                    <li>
                        <a href="#viewgroup-%e4%b8%ad-measurespec-%e8%ae%a1%e7%ae%97%e5%85%ac%e5%bc%8f" aria-label="ViewGroup 中 MeasureSpec 计算公式">ViewGroup 中 MeasureSpec 计算公式</a></li>
                    <li>
                        <a href="#onmeasure-%e5%87%bd%e6%95%b0%e5%ae%9e%e7%8e%b0" aria-label="onMeasure 函数实现">onMeasure 函数实现</a></li>
                    <li>
                        <a href="#layout-%e5%87%bd%e6%95%b0" aria-label="layout 函数">layout 函数</a></li>
                    <li>
                        <a href="#onlayout-%e5%87%bd%e6%95%b0" aria-label="onLayout 函数">onLayout 函数</a><ul>
                            
                    <li>
                        <a href="#-onlayout-%e6%96%b9%e6%b3%95" aria-label=". onLayout 方法">. <code>onLayout</code> 方法</a></li>
                    <li>
                        <a href="#2-%e4%bd%bf%e7%94%a8%e5%9c%a8%e6%b5%8b%e9%87%8f%e8%bf%87%e7%a8%8b%e4%b8%ad%e5%ad%98%e5%82%a8%e7%9a%84%e5%ad%90-view-%e5%b0%ba%e5%af%b8%e6%9d%a5%e5%ae%8c%e6%88%90%e5%b8%83%e5%b1%80" aria-label="2. 使用在测量过程中存储的子 View 尺寸来完成布局">2. 使用在测量过程中存储的子 <code>View</code> 尺寸来完成布局</a></li>
                    <li>
                        <a href="#3-getmeasuredheight-%e5%92%8c-getheight-%e7%9a%84%e5%8c%ba%e5%88%ab" aria-label="3. getMeasuredHeight 和 getHeight 的区别">3. <code>getMeasuredHeight</code> 和 <code>getHeight</code> 的区别</a></li>
                    <li>
                        <a href="#4-%e5%a6%82%e4%bd%95%e5%ae%9a%e4%b9%89%e6%a0%87%e7%ad%be%e9%97%b4%e8%b7%9d" aria-label="4. 如何定义标签间距？">4. 如何定义标签间距？</a></li>
                    <li>
                        <a href="#1-%e8%87%aa%e5%ae%9a%e4%b9%89%e5%b1%9e%e6%80%a7%e4%b8%8e%e6%a0%87%e7%ad%be%e9%97%b4%e8%b7%9d" aria-label="1. 自定义属性与标签间距">1. 自定义属性与标签间距</a></li>
                    <li>
                        <a href="#2-%e5%9c%a8-xml-%e4%b8%ad%e4%bd%bf%e7%94%a8%e5%b1%9e%e6%80%a7" aria-label="2. 在 XML 中使用属性">2. 在 XML 中使用属性</a></li>
                    <li>
                        <a href="#3-%e5%93%8d%e5%ba%94%e6%89%8b%e5%8a%bf%e6%93%8d%e4%bd%9c" aria-label="3. 响应手势操作">3. 响应手势操作</a></li></ul>
                    </li></ul>
                    </li>
                    <li>
                        <a href="#gesturedetector-%e7%b1%bb%e5%8f%8a%e5%85%b6%e5%9b%9e%e8%b0%83%e6%96%b9%e6%b3%95" aria-label="GestureDetector 类及其回调方法">GestureDetector 类及其回调方法</a><ul>
                            <ul>
                            
                    <li>
                        <a href="#motionevent-%e4%ba%8b%e4%bb%b6%e7%b1%bb%e5%9e%8b" aria-label="MotionEvent 事件类型">MotionEvent 事件类型</a></li>
                    <li>
                        <a href="#%e4%ba%8b%e4%bb%b6%e4%bd%8d%e7%bd%ae" aria-label="事件位置">事件位置</a></li>
                    <li>
                        <a href="#%e6%89%8b%e5%8a%bf%e7%9a%84%e7%bb%84%e5%90%88" aria-label="手势的组合">手势的组合</a></li>
                    <li>
                        <a href="#%e5%b8%b8%e8%a7%81%e6%89%8b%e5%8a%bf%e7%9a%84%e4%ba%8b%e4%bb%b6%e7%bb%84%e5%90%88" aria-label="常见手势的事件组合">常见手势的事件组合</a></li>
                    <li>
                        <a href="#gesturedetector-%e7%b1%bb" aria-label="GestureDetector 类">GestureDetector 类</a></li>
                    <li>
                        <a href="#%e4%bd%bf%e7%94%a8-ontouchevent-%e6%96%b9%e6%b3%95%e6%88%96-ontouchlistener-%e5%a4%84%e7%90%86%e6%89%8b%e5%8a%bf" aria-label="使用 onTouchEvent 方法或 onTouchListener 处理手势">使用 onTouchEvent 方法或 onTouchListener 处理手势</a></li>
                    <li>
                        <a href="#%e6%89%8b%e5%8a%bf%e5%88%86%e5%8f%91%e5%8f%8a%e5%93%8d%e5%ba%94%e8%bf%87%e7%a8%8bview-%e5%a4%84%e7%90%86%e6%b5%81%e7%a8%8b" aria-label="手势分发及响应过程：View 处理流程">手势分发及响应过程：View 处理流程</a></li>
                    <li>
                        <a href="#%e6%89%8b%e5%8a%bf%e5%88%86%e5%8f%91%e5%8f%8a%e5%93%8d%e5%ba%94%e8%bf%87%e7%a8%8bviewgroup-%e5%a4%84%e7%90%86%e6%b5%81%e7%a8%8b" aria-label="手势分发及响应过程：ViewGroup 处理流程">手势分发及响应过程：ViewGroup 处理流程</a></li>
                    <li>
                        <a href="#onintercepttouchevent" aria-label="onInterceptTouchEvent">onInterceptTouchEvent</a></li>
                    <li>
                        <a href="#%e6%89%a9%e5%b1%95%e5%86%85%e5%ae%b9" aria-label="扩展内容">扩展内容</a></li>
                    <li>
                        <a href="#%e8%af%be%e5%90%8e%e9%98%85%e8%af%bb" aria-label="课后阅读">课后阅读</a>
                    </li>
                </ul>
                </li>
                </ul>
                </ul>
                </li>
                </ul>
            </div>
        </details>
    </div>
</aside>
<script>
    let activeElement;
    let elements;
    window.addEventListener('DOMContentLoaded', function (event) {
        checkTocPosition();

        elements = document.querySelectorAll('h1[id],h2[id],h3[id],h4[id],h5[id],h6[id]');
         
         activeElement = elements[0];
         const id = encodeURI(activeElement.getAttribute('id')).toLowerCase();
         document.querySelector(`.inner ul li a[href="#${id}"]`).classList.add('active');
     }, false);

    window.addEventListener('resize', function(event) {
        checkTocPosition();
    }, false);

    window.addEventListener('scroll', () => {
        
        activeElement = Array.from(elements).find((element) => {
            if ((getOffsetTop(element) - window.pageYOffset) > 0 && 
                (getOffsetTop(element) - window.pageYOffset) < window.innerHeight/2) {
                return element;
            }
        }) || activeElement

        elements.forEach(element => {
             const id = encodeURI(element.getAttribute('id')).toLowerCase();
             if (element === activeElement){
                 document.querySelector(`.inner ul li a[href="#${id}"]`).classList.add('active');
             } else {
                 document.querySelector(`.inner ul li a[href="#${id}"]`).classList.remove('active');
             }
         })
     }, false);

    const main = parseInt(getComputedStyle(document.body).getPropertyValue('--article-width'), 10);
    const toc = parseInt(getComputedStyle(document.body).getPropertyValue('--toc-width'), 10);
    const gap = parseInt(getComputedStyle(document.body).getPropertyValue('--gap'), 10);

    function checkTocPosition() {
        const width = document.body.scrollWidth;

        if (width - main - (toc * 2) - (gap * 4) > 0) {
            document.getElementById("toc-container").classList.add("wide");
        } else {
            document.getElementById("toc-container").classList.remove("wide");
        }
    }

    function getOffsetTop(element) {
        if (!element.getClientRects().length) {
            return 0;
        }
        let rect = element.getBoundingClientRect();
        let win = element.ownerDocument.defaultView;
        return rect.top + win.pageYOffset;   
    }
</script>

  <div class="post-content"><h1 id="第八天笔记">第八天笔记<a hidden class="anchor" aria-hidden="true" href="#第八天笔记">#</a></h1>
<h2 id="自定义控件的实现">自定义控件的实现<a hidden class="anchor" aria-hidden="true" href="#自定义控件的实现">#</a></h2>
<h4 id="view-绘制过程">View 绘制过程<a hidden class="anchor" aria-hidden="true" href="#view-绘制过程">#</a></h4>
<h5 id="activity-和-view-的关系">Activity 和 View 的关系<a hidden class="anchor" aria-hidden="true" href="#activity-和-view-的关系">#</a></h5>
<ol>
<li><strong>Window 类</strong>：负责在 <code>Activity</code> 中展示内容（具体实现为 <code>PhoneWindow</code> 类）</li>
<li><strong>DecorView</strong>：<code>Window</code> 创建出根布局 <code>DecorView</code>（继承自 <code>FrameLayout</code>）</li>
</ol>
<h5 id="单个-view-的绘制步骤">单个 View 的绘制步骤<a hidden class="anchor" aria-hidden="true" href="#单个-view-的绘制步骤">#</a></h5>
<p>系统根据布局树完成界面绘制，单个 View 需要经过三个步骤：</p>
<ol>
<li><strong>计算 View 的宽高</strong>：<code>measure</code></li>
<li><strong>计算 View 的位置</strong>：<code>layout</code></li>
<li><strong>绘制 View 的内容</strong>：<code>draw</code></li>
</ol>
<h4 id="布局树逐级向下调用">布局树逐级向下调用<a hidden class="anchor" aria-hidden="true" href="#布局树逐级向下调用">#</a></h4>
<p>布局树的绘制过程从上到下逐级调用，具体步骤如下：</p>
<ul>
<li><strong>测量</strong>：
<ul>
<li><code>performMeasure()</code></li>
<li><code>measure()</code></li>
<li><code>onMeasure()</code></li>
</ul>
</li>
<li><strong>布局</strong>：
<ul>
<li><code>performLayout()</code></li>
<li><code>layout()</code></li>
<li><code>onLayout()</code></li>
</ul>
</li>
<li><strong>绘制</strong>：
<ul>
<li><code>performDraw()</code></li>
<li><code>draw()</code></li>
<li><code>onDraw()</code></li>
</ul>
</li>
</ul>
<h4 id="视图树调用流程图">视图树调用流程图<a hidden class="anchor" aria-hidden="true" href="#视图树调用流程图">#</a></h4>
<p>

    <div class="post-img-view">
        <a data-fancybox="gallery" href="https://cdn.jsdelivr.net/gh/kennems/blog-image/image-20240712233046788.png">
            <img src="https://cdn.jsdelivr.net/gh/kennems/blog-image/image-20240712233046788.png" alt="image-20240712233046788"  />
        </a>
    </div>

</p>
<h4 id="位置的描述依赖坐标系">位置的描述依赖坐标系<a hidden class="anchor" aria-hidden="true" href="#位置的描述依赖坐标系">#</a></h4>
<ul>
<li>Android 的坐标系定义为：
<ul>
<li>屏幕的左上角为坐标原点</li>
<li>向右为 x 轴增大方向</li>
<li>向下为 y 轴增大方向</li>
</ul>
</li>
</ul>
<h4 id="自定义-view">自定义 View<a hidden class="anchor" aria-hidden="true" href="#自定义-view">#</a></h4>
<h5 id="draw-函数">draw 函数<a hidden class="anchor" aria-hidden="true" href="#draw-函数">#</a></h5>
<ol>
<li>
<p><strong>作用</strong>：绘制内容在给定的 Canvas 上</p>
</li>
<li>
<p><strong>调用时机</strong>：要保证 layout 之后再调用这个方法</p>
</li>
<li>
<p><strong>注意事项</strong>：自定义 View 时考虑优先重写 onDraw 方法而不是这个方法</p>
</li>
<li>
<p><strong>继承关系</strong>：如果一定要重写 draw 方法，要记得调用父类方法</p>
</li>
<li>
<p>实现步骤：有 7 个绘制步骤：</p>
<ul>
<li>绘制背景</li>
</ul>
</li>
</ol>
<ul>
<li>其余步骤依次类推</li>
</ul>
<h4 id="位置的描述依赖坐标系-1">位置的描述依赖坐标系<a hidden class="anchor" aria-hidden="true" href="#位置的描述依赖坐标系-1">#</a></h4>
<ul>
<li>Android 的坐标系定义为：
<ul>
<li>屏幕的左上角为坐标原点</li>
<li>向右为 x 轴增大方向</li>
<li>向下为 y 轴增大方向</li>
</ul>
</li>
</ul>
<p>

    <div class="post-img-view">
        <a data-fancybox="gallery" href="https://cdn.jsdelivr.net/gh/kennems/blog-image/image-20240713082308372.png">
            <img src="https://cdn.jsdelivr.net/gh/kennems/blog-image/image-20240713082308372.png" alt="image-20240713082308372"  />
        </a>
    </div>

</p>
<h5 id="draw-函数-1">draw 函数<a hidden class="anchor" aria-hidden="true" href="#draw-函数-1">#</a></h5>
<ol>
<li>
<p><strong>作用</strong>：绘制内容在给定的 Canvas 上。</p>
</li>
<li>
<p><strong>调用时机</strong>：要保证 layout 之后再调用这个方法。</p>
</li>
<li>
<p><strong>注意事项</strong>：自定义 View 时考虑优先重写 <code>onDraw</code> 方法而不是这个方法。</p>
</li>
<li>
<p><strong>继承关系</strong>：如果一定要重写 <code>draw</code> 方法，要记得调用父类方法。</p>
</li>
<li>
<p><strong>实现步骤</strong>：有 7 个绘制步骤：</p>
<ol>
<li>绘制背景</li>
<li>如有必要，保存画布图层以准备淡入淡出动画</li>
<li><strong>绘制内容</strong></li>
<li>绘制子 View（即调用 <code>childView.draw</code>）</li>
<li>如有必要，绘制淡入淡出并恢复图层</li>
<li>绘制装饰（例如滚动条）</li>
<li>如有必要，绘制默认焦点高亮</li>
</ol>
</li>
</ol>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#75715e">/**
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"> * Manually render this view (and all of its children) to the given Canvas.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"> * The view must have already done a full layout before this function is
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"> * called. When implementing a view, implement
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"> * {@link #onDraw(android.graphics.Canvas)} instead of overriding this method.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"> * If you do need to override this method, call the superclass version.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"> *
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"> * @param canvas The Canvas to which the View is rendered.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"> */</span>
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">@CallSuper</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">draw</span>(Canvas canvas) {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">final</span> <span style="color:#66d9ef">int</span> privateFlags <span style="color:#f92672">=</span> mPrivateFlags;
</span></span><span style="display:flex;"><span>    mPrivateFlags <span style="color:#f92672">=</span> (privateFlags <span style="color:#f92672">&amp;</span> <span style="color:#f92672">~</span>PFLAG_DIRTY_MASK) <span style="color:#f92672">|</span> PFLAG_DRAWN;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">/*
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">     * Draw traversal performs several drawing steps which must be executed
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">     * in the appropriate order:
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">     *
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">     *      1. Draw the background
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">     *      2. If necessary, save the canvas&#39; layers to prepare for fading
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">     *      3. Draw view&#39;s content
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">     *      4. Draw children
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">     *      5. If necessary, draw the fading edges and restore layers
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">     *      6. Draw decorations (scrollbars for instance)
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">     *      7. If necessary, draw the default focus highlight
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">     */</span>
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h5 id="ondraw-函数">onDraw 函数<a hidden class="anchor" aria-hidden="true" href="#ondraw-函数">#</a></h5>
<ol>
<li><strong>调用时机</strong>：在 7 个绘制步骤中的第三步。</li>
<li><strong>实现</strong>：绘制内容。</li>
</ol>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#66d9ef">protected</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">onDraw</span>(Canvas canvas) {
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// Step 1, draw the background, if needed</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> saveCount;
</span></span><span style="display:flex;"><span>    drawBackground(canvas);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// skip step 2 &amp; 5 if possible (common case)</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">final</span> <span style="color:#66d9ef">int</span> viewFlags <span style="color:#f92672">=</span> mViewFlags;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">boolean</span> horizontalEdges <span style="color:#f92672">=</span> (viewFlags <span style="color:#f92672">&amp;</span> FADING_EDGE_HORIZONTAL) <span style="color:#f92672">!=</span> 0;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">boolean</span> verticalEdges <span style="color:#f92672">=</span> (viewFlags <span style="color:#f92672">&amp;</span> FADING_EDGE_VERTICAL) <span style="color:#f92672">!=</span> 0;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> (<span style="color:#f92672">!</span>verticalEdges <span style="color:#f92672">&amp;&amp;</span> <span style="color:#f92672">!</span>horizontalEdges) {
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// Step 3, draw the content</span>
</span></span><span style="display:flex;"><span>        onDraw(canvas);
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h4 id="绘制内容在给定的-canvas-上">绘制内容在给定的 Canvas 上<a hidden class="anchor" aria-hidden="true" href="#绘制内容在给定的-canvas-上">#</a></h4>
<p>Canvas 类：Android 中用于绘制图形的重要类。它包含了许多绘图方法，主要可以分为以下几类：</p>
<table>
<thead>
<tr>
<th style="text-align:left">绘制基本的几何形状，如矩形、圆形、椭圆等</th>
<th style="text-align:left">使用路径（<code>Path</code>）定义复杂的图形</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">drawRect(RectF rect, Paint paint)</td>
<td style="text-align:left">drawPath(Path path, Paint paint)</td>
</tr>
<tr>
<td style="text-align:left">drawCircle(float cx, float cy, float radius, Paint paint)</td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:left">drawOval(RectF oval, Paint paint)</td>
<td style="text-align:left"></td>
</tr>
</tbody>
</table>
<table>
<thead>
<tr>
<th style="text-align:left">用于在画布上绘制文本</th>
<th style="text-align:left">绘制位图图像</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">drawText(String text, float x, float y, Paint paint)</td>
<td style="text-align:left">drawBitmap(Bitmap bitmap, float left, float top, Paint paint)</td>
</tr>
</tbody>
</table>
<h4 id="设置绘制的颜色和样式">设置绘制的颜色和样式<a hidden class="anchor" aria-hidden="true" href="#设置绘制的颜色和样式">#</a></h4>
<ul>
<li><strong>drawColor(int color)</strong>: 设置绘制的颜色</li>
<li><strong>drawPaint(Paint paint)</strong>: 设置绘制的样式</li>
</ul>
<h4 id="对画布进行变换">对画布进行变换<a hidden class="anchor" aria-hidden="true" href="#对画布进行变换">#</a></h4>
<ul>
<li><strong>translate(float dx, float dy)</strong>: 平移变换</li>
<li><strong>rotate(float degrees)</strong>: 旋转变换</li>
</ul>
<h4 id="在画布上创建和操作图层实现图层效果">在画布上创建和操作图层，实现图层效果<a hidden class="anchor" aria-hidden="true" href="#在画布上创建和操作图层实现图层效果">#</a></h4>
<ul>
<li><strong>save()</strong>: 保存当前画布的状态</li>
<li><strong>restore()</strong>: 恢复之前保存的画布状态</li>
</ul>
<h4 id="paint-类配合提供绘制参数">Paint 类配合提供绘制参数<a hidden class="anchor" aria-hidden="true" href="#paint-类配合提供绘制参数">#</a></h4>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span>Paint paint <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> Paint();
</span></span><span style="display:flex;"><span>paint.<span style="color:#a6e22e">setColor</span>(Color.<span style="color:#a6e22e">RED</span>); <span style="color:#75715e">// 设置颜色</span>
</span></span><span style="display:flex;"><span>paint.<span style="color:#a6e22e">setTextSize</span>(24); <span style="color:#75715e">// 设置文字大小</span>
</span></span><span style="display:flex;"><span>paint.<span style="color:#a6e22e">setTypeface</span>(Typeface.<span style="color:#a6e22e">create</span>(Typeface.<span style="color:#a6e22e">DEFAULT</span>, Typeface.<span style="color:#a6e22e">BOLD</span>)); <span style="color:#75715e">// 设置字体样式</span>
</span></span><span style="display:flex;"><span>paint.<span style="color:#a6e22e">setStrokeWidth</span>(2); <span style="color:#75715e">// 设置绘制线条宽度</span>
</span></span><span style="display:flex;"><span>paint.<span style="color:#a6e22e">setAntiAlias</span>(<span style="color:#66d9ef">true</span>); <span style="color:#75715e">// 启用抗锯齿</span>
</span></span></code></pre></div><h4 id="path-类配合描述复杂图形">Path 类配合描述复杂图形<a hidden class="anchor" aria-hidden="true" href="#path-类配合描述复杂图形">#</a></h4>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span>Path path <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> Path();
</span></span><span style="display:flex;"><span>path.<span style="color:#a6e22e">moveTo</span>(x: 100, y: 200); <span style="color:#75715e">// 从当前位置移动到指定位置（不画线）</span>
</span></span><span style="display:flex;"><span>path.<span style="color:#a6e22e">lineTo</span>(x: 100, y: 200); <span style="color:#75715e">// 从前点绘制一条线到指定点</span>
</span></span><span style="display:flex;"><span>RectF oval <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> RectF(left: 100, top: 100, right: 300, bottom: 600); <span style="color:#75715e">// 绘制圆线</span>
</span></span><span style="display:flex;"><span>path.<span style="color:#a6e22e">arcTo</span>(oval, startAngle: 100, sweepAngle: 180, forceMoveTo: <span style="color:#66d9ef">true</span>); <span style="color:#75715e">// 绘制弧线</span>
</span></span><span style="display:flex;"><span>path.<span style="color:#a6e22e">close</span>(); <span style="color:#75715e">// 连接当前点和起始点</span>
</span></span></code></pre></div><h4 id="自定义-viewgroup">自定义 ViewGroup<a hidden class="anchor" aria-hidden="true" href="#自定义-viewgroup">#</a></h4>
<h5 id="measure-函数">measure 函数<a hidden class="anchor" aria-hidden="true" href="#measure-函数">#</a></h5>
<ol>
<li><strong>作用</strong>: 计算 View 的宽高</li>
<li><strong>调用 onMeasure 完成真正的计算工作，且子类应该重写 onMeasure</strong></li>
<li><strong>final 修饰该方法，不可重写</strong></li>
</ol>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">final</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">measure</span>(<span style="color:#66d9ef">int</span> widthMeasureSpec, <span style="color:#66d9ef">int</span> heightMeasureSpec) {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">boolean</span> optical <span style="color:#f92672">=</span> isLayoutModeOptical() <span style="color:#f92672">!=</span> <span style="color:#66d9ef">this</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> (optical <span style="color:#f92672">!=</span> isLayoutModeOptical(mParent)) {
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// ... 相关代码</span>
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>onMeasure 函数</p>
<ol>
<li><strong>作用</strong>: 计算 View 的宽高，应由子类重写，以提供对其内容的准确有效的测量。</li>
<li><strong>约定</strong>: 重写此方法时，必须调用 <code>setMeasuredDimension(width, height)</code> 来存储测量好的宽度和高度。</li>
<li><strong>没有 final 修饰符，可重写</strong></li>
</ol>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#66d9ef">protected</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">onMeasure</span>(<span style="color:#66d9ef">int</span> widthMeasureSpec, <span style="color:#66d9ef">int</span> heightMeasureSpec) {
</span></span><span style="display:flex;"><span>    setMeasuredDimension(getDefaultSize(getSuggestedMinimumWidth(), widthMeasureSpec),
</span></span><span style="display:flex;"><span>                         getDefaultSize(getSuggestedMinimumHeight(), heightMeasureSpec));
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h4 id="measurespec-类">MeasureSpec 类<a hidden class="anchor" aria-hidden="true" href="#measurespec-类">#</a></h4>
<p>MeasureSpec 包含两部分信息：</p>
<ul>
<li><strong>低 30 位为 SpecSize</strong>，即尺寸</li>
<li><strong>高 2 位为 SpecMode</strong>，即测量模式</li>
</ul>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#a6e22e">@Override</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">protected</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">onMeasure</span>(<span style="color:#66d9ef">int</span> widthMeasureSpec, <span style="color:#66d9ef">int</span> heightMeasureSpec) {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> widthSpecMode <span style="color:#f92672">=</span> MeasureSpec.<span style="color:#a6e22e">getMode</span>(widthMeasureSpec);
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> widthSpecSize <span style="color:#f92672">=</span> MeasureSpec.<span style="color:#a6e22e">getSize</span>(widthMeasureSpec);
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> heightSpecMode <span style="color:#f92672">=</span> MeasureSpec.<span style="color:#a6e22e">getMode</span>(heightMeasureSpec);
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> heightSpecSize <span style="color:#f92672">=</span> MeasureSpec.<span style="color:#a6e22e">getSize</span>(heightMeasureSpec);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> newWidthSpec <span style="color:#f92672">=</span> MeasureSpec.<span style="color:#a6e22e">makeMeasureSpec</span>(1, MeasureSpec.<span style="color:#a6e22e">AT_MOST</span>);
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h4 id="measurespec-高-2-位为-specmode即测量模式">MeasureSpec 高 2 位为 SpecMode，即测量模式<a hidden class="anchor" aria-hidden="true" href="#measurespec-高-2-位为-specmode即测量模式">#</a></h4>
<table>
<thead>
<tr>
<th style="text-align:left">测量模式</th>
<th style="text-align:left">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left"><strong>UNSPECIFIED</strong></td>
<td style="text-align:left">父 View 对子 View 的大小不做限制</td>
</tr>
<tr>
<td style="text-align:left"><strong>EXACTLY</strong></td>
<td style="text-align:left">父 View 计算好了子 View 具体的宽高，子 View 的最终大小就是 SpecSize 指定的值</td>
</tr>
<tr>
<td style="text-align:left"><strong>AT_MOST</strong></td>
<td style="text-align:left">父 View 指定了一个可用大小 SpecSize，子 View 的大小不能大于这个值</td>
</tr>
</tbody>
</table>
<p>onMeasure 函数</p>
<ol>
<li><strong>作用</strong>: 计算 View 的宽高，应由子类重写，以提供对其内容的准确有效的测量。</li>
<li><strong>约定</strong>: 重写此方法时，必须调用 <code>setMeasuredDimension(width, height)</code> 来存储测量好的宽度和高度。</li>
<li><strong>没有 final 修饰符，可重写</strong></li>
</ol>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#66d9ef">protected</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">onMeasure</span>(<span style="color:#66d9ef">int</span> widthMeasureSpec, <span style="color:#66d9ef">int</span> heightMeasureSpec) {
</span></span><span style="display:flex;"><span>    setMeasuredDimension(getDefaultSize(getSuggestedMinimumWidth(), widthMeasureSpec),
</span></span><span style="display:flex;"><span>                         getDefaultSize(getSuggestedMinimumHeight(), heightMeasureSpec));
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h3 id="measurespec-类-1">MeasureSpec 类<a hidden class="anchor" aria-hidden="true" href="#measurespec-类-1">#</a></h3>
<p>MeasureSpec 包含两部分信息：</p>
<ul>
<li><strong>低 30 位为 SpecSize</strong>，即尺寸</li>
<li><strong>高 2 位为 SpecMode</strong>，即测量模式</li>
</ul>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#a6e22e">@Override</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">protected</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">onMeasure</span>(<span style="color:#66d9ef">int</span> widthMeasureSpec, <span style="color:#66d9ef">int</span> heightMeasureSpec) {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> widthSpecMode <span style="color:#f92672">=</span> MeasureSpec.<span style="color:#a6e22e">getMode</span>(widthMeasureSpec);
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> widthSpecSize <span style="color:#f92672">=</span> MeasureSpec.<span style="color:#a6e22e">getSize</span>(widthMeasureSpec);
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> heightSpecMode <span style="color:#f92672">=</span> MeasureSpec.<span style="color:#a6e22e">getMode</span>(heightMeasureSpec);
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> heightSpecSize <span style="color:#f92672">=</span> MeasureSpec.<span style="color:#a6e22e">getSize</span>(heightMeasureSpec);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> newWidthSpec <span style="color:#f92672">=</span> MeasureSpec.<span style="color:#a6e22e">makeMeasureSpec</span>(1, MeasureSpec.<span style="color:#a6e22e">AT_MOST</span>);
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h4 id="measurespec-高-2-位为-specmode即测量模式-1">MeasureSpec 高 2 位为 SpecMode，即测量模式<a hidden class="anchor" aria-hidden="true" href="#measurespec-高-2-位为-specmode即测量模式-1">#</a></h4>
<table>
<thead>
<tr>
<th style="text-align:left">测量模式</th>
<th style="text-align:left">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left"><strong>UNSPECIFIED</strong></td>
<td style="text-align:left">父 View 对子 View 的大小不做限制</td>
</tr>
<tr>
<td style="text-align:left"><strong>EXACTLY</strong></td>
<td style="text-align:left">父 View 计算好了子 View 具体的宽高，子 View 的最终大小就是 SpecSize 指定的值</td>
</tr>
<tr>
<td style="text-align:left"><strong>AT_MOST</strong></td>
<td style="text-align:left">父 View 指定了一个可用大小 SpecSize，子 View 的大小不能大于这个值</td>
</tr>
</tbody>
</table>
<h3 id="viewgroup-中-measurespec-计算公式">ViewGroup 中 MeasureSpec 计算公式<a hidden class="anchor" aria-hidden="true" href="#viewgroup-中-measurespec-计算公式">#</a></h3>
<p>子 View 的布局参数（通过 <code>childView.getLayoutParams()</code> 获取） + 父 View 的测量要求 = 子 View 的 MeasureSpec</p>
<table>
<thead>
<tr>
<th style="text-align:left">测量模式</th>
<th style="text-align:left">精确值</th>
<th style="text-align:left">MATCH_PARENT</th>
<th style="text-align:left">WRAP_CONTENT</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left"><strong>EXACTLY</strong></td>
<td style="text-align:left">SpecSize: View Group Size<!-- raw HTML omitted -->SpecMode: EXACTLY</td>
<td style="text-align:left">SpecSize: View Group Size<!-- raw HTML omitted -->SpecMode: EXACTLY</td>
<td style="text-align:left">SpecSize: View Group Size<!-- raw HTML omitted -->SpecMode: AT_MOST</td>
</tr>
<tr>
<td style="text-align:left"><strong>AT_MOST</strong></td>
<td style="text-align:left">SpecSize: View Group Size<!-- raw HTML omitted -->SpecMode: AT_MOST</td>
<td style="text-align:left">SpecSize: View Group Size<!-- raw HTML omitted -->SpecMode: AT_MOST</td>
<td style="text-align:left">SpecSize: View Group Size<!-- raw HTML omitted -->SpecMode: AT_MOST</td>
</tr>
<tr>
<td style="text-align:left"><strong>UNSPECIFIED</strong></td>
<td style="text-align:left">SpecSize: 0<!-- raw HTML omitted -->SpecMode: UNSPECIFIED</td>
<td style="text-align:left">SpecSize: 0<!-- raw HTML omitted -->SpecMode: UNSPECIFIED</td>
<td style="text-align:left">SpecSize: 0<!-- raw HTML omitted -->SpecMode: UNSPECIFIED</td>
</tr>
</tbody>
</table>
<h3 id="onmeasure-函数实现">onMeasure 函数实现<a hidden class="anchor" aria-hidden="true" href="#onmeasure-函数实现">#</a></h3>
<ol>
<li>父 View 测量要求（MeasureSpec）作为 <code>onMeasure</code> 的入参传入：UNSPECIFIED, EXACTLY, AT_MOST</li>
<li>实现：
<ul>
<li>根据公式：子 View 布局参数（+ 父 View 测量要求）= 子 View 测量要求</li>
<li>将子 View 测量要求作为参数，调用子 View 的 <code>measure</code> 方法</li>
<li>根据当前 ViewGroup 布局策略计算自己的宽高</li>
</ul>
</li>
<li>调用 <code>setMeasuredDimension(int, int)</code> 保存计算好的宽高</li>
</ol>
<p>

    <div class="post-img-view">
        <a data-fancybox="gallery" href="https://cdn.jsdelivr.net/gh/kennems/blog-image/image-20240713082807039.png">
            <img src="https://cdn.jsdelivr.net/gh/kennems/blog-image/image-20240713082807039.png" alt="image-20240713082807039"  />
        </a>
    </div>

</p>
<p>

    <div class="post-img-view">
        <a data-fancybox="gallery" href="https://cdn.jsdelivr.net/gh/kennems/blog-image/image-20240713082742405.png">
            <img src="https://cdn.jsdelivr.net/gh/kennems/blog-image/image-20240713082742405.png" alt="image-20240713082742405"  />
        </a>
    </div>

</p>
<p>

    <div class="post-img-view">
        <a data-fancybox="gallery" href="https://cdn.jsdelivr.net/gh/kennems/blog-image/image-20240713082941059.png">
            <img src="https://cdn.jsdelivr.net/gh/kennems/blog-image/image-20240713082941059.png" alt="image-20240713082941059"  />
        </a>
    </div>

</p>
<p>

    <div class="post-img-view">
        <a data-fancybox="gallery" href="https://cdn.jsdelivr.net/gh/kennems/blog-image/image-20240713083337961.png">
            <img src="https://cdn.jsdelivr.net/gh/kennems/blog-image/image-20240713083337961.png" alt="image-20240713083337961"  />
        </a>
    </div>

</p>
<p>

    <div class="post-img-view">
        <a data-fancybox="gallery" href="https://cdn.jsdelivr.net/gh/kennems/blog-image/image-20240713083552156.png">
            <img src="https://cdn.jsdelivr.net/gh/kennems/blog-image/image-20240713083552156.png" alt="image-20240713083552156"  />
        </a>
    </div>

</p>
<p>

    <div class="post-img-view">
        <a data-fancybox="gallery" href="https://cdn.jsdelivr.net/gh/kennems/blog-image/image-20240713083644893.png">
            <img src="https://cdn.jsdelivr.net/gh/kennems/blog-image/image-20240713083644893.png" alt="image-20240713083644893"  />
        </a>
    </div>

</p>
<p>

    <div class="post-img-view">
        <a data-fancybox="gallery" href="https://cdn.jsdelivr.net/gh/kennems/blog-image/image-20240713084000207.png">
            <img src="https://cdn.jsdelivr.net/gh/kennems/blog-image/image-20240713084000207.png" alt="image-20240713084000207"  />
        </a>
    </div>

</p>
<p>

    <div class="post-img-view">
        <a data-fancybox="gallery" href="https://cdn.jsdelivr.net/gh/kennems/blog-image/image-20240713084410284.png">
            <img src="https://cdn.jsdelivr.net/gh/kennems/blog-image/image-20240713084410284.png" alt="image-20240713084410284"  />
        </a>
    </div>

</p>
<p>

    <div class="post-img-view">
        <a data-fancybox="gallery" href="https://cdn.jsdelivr.net/gh/kennems/blog-image/image-20240713085322344.png">
            <img src="https://cdn.jsdelivr.net/gh/kennems/blog-image/image-20240713085322344.png" alt="image-20240713085322344"  />
        </a>
    </div>

</p>
<p>

    <div class="post-img-view">
        <a data-fancybox="gallery" href="https://cdn.jsdelivr.net/gh/kennems/blog-image/image-20240713085649491.png">
            <img src="https://cdn.jsdelivr.net/gh/kennems/blog-image/image-20240713085649491.png" alt="image-20240713085649491"  />
        </a>
    </div>

</p>
<p>

    <div class="post-img-view">
        <a data-fancybox="gallery" href="https://cdn.jsdelivr.net/gh/kennems/blog-image/image-20240713093401104.png">
            <img src="https://cdn.jsdelivr.net/gh/kennems/blog-image/image-20240713093401104.png" alt="image-20240713093401104"  />
        </a>
    </div>

</p>
<h3 id="layout-函数">layout 函数<a hidden class="anchor" aria-hidden="true" href="#layout-函数">#</a></h3>
<ol>
<li>布局机制的第二阶段（第一阶段是测量）</li>
<li><strong>作用</strong>: 给所有子 View 分配位置</li>
<li><strong>实现</strong>: 在这个阶段，每个父 View 调用其所有子 View 的 <code>layout</code> 方法来确定它们的位置。</li>
<li>派生类不应覆盖此方法，子 View 的派生类应覆盖 <code>onLayout</code> 方法。</li>
</ol>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">layout</span>(<span style="color:#66d9ef">int</span> l, <span style="color:#66d9ef">int</span> t, <span style="color:#66d9ef">int</span> r, <span style="color:#66d9ef">int</span> b) {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> ((mPrivateFlags <span style="color:#f92672">&amp;</span> PFLAG3_MEASURE_NEEDED_BEFORE_LAYOUT) <span style="color:#f92672">!=</span> 0) {
</span></span><span style="display:flex;"><span>        onMeasure(mOldWidthMeasureSpec, mOldHeightMeasureSpec);
</span></span><span style="display:flex;"><span>        mPrivateFlags3 <span style="color:#f92672">&amp;=</span> <span style="color:#f92672">~</span>PFLAG3_MEASURE_NEEDED_BEFORE_LAYOUT;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    ...
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h3 id="onlayout-函数">onLayout 函数<a hidden class="anchor" aria-hidden="true" href="#onlayout-函数">#</a></h3>
<ol>
<li>被 <code>layout</code> 方法调用</li>
<li><strong>作用</strong>: 为该 View 的子 View 分配位置</li>
<li>有子 View 的派生类应重写该方法，并对每个子 View 调用 <code>layout</code> 方法，通常是使用在测量过程中存储的子 View 尺寸来完成的。</li>
</ol>
<h4 id="-onlayout-方法">. <code>onLayout</code> 方法<a hidden class="anchor" aria-hidden="true" href="#-onlayout-方法">#</a></h4>
<ul>
<li><strong>定义</strong>：在 <code>layout</code> 被调用时，分配每个子 <code>View</code> 的位置和尺寸。</li>
<li>参数：
<ul>
<li><code>changed</code>：此视图的尺寸或位置是否发生变化。</li>
<li><code>left</code>：相对于父视图的左边位置。</li>
<li><code>top</code>：相对于父视图的顶部位置。</li>
<li><code>right</code>：相对于父视图的右边位置。</li>
<li><code>bottom</code>：相对于父视图的底部位置。</li>
</ul>
</li>
</ul>
<h4 id="2-使用在测量过程中存储的子-view-尺寸来完成布局">2. 使用在测量过程中存储的子 <code>View</code> 尺寸来完成布局<a hidden class="anchor" aria-hidden="true" href="#2-使用在测量过程中存储的子-view-尺寸来完成布局">#</a></h4>
<ul>
<li>在 <code>onLayout</code> 方法中调用子视图的 <code>layout</code> 方法，使用 <code>getMeasuredWidth</code> 和 <code>getMeasuredHeight</code> 获取子视图的宽度和高度。</li>
</ul>
<h4 id="3-getmeasuredheight-和-getheight-的区别">3. <code>getMeasuredHeight</code> 和 <code>getHeight</code> 的区别<a hidden class="anchor" aria-hidden="true" href="#3-getmeasuredheight-和-getheight-的区别">#</a></h4>
<ul>
<li><code>getMeasuredWidth</code> / <code>getMeasuredHeight</code>：
<ul>
<li><strong>作用</strong>：获取 <code>View</code> 测量的宽高。</li>
<li><strong>赋值时机</strong>：<code>measure</code> 过程中。</li>
<li><strong>赋值方法</strong>：<code>setMeasuredDimension</code>。</li>
<li><strong>值大小</strong>：一般情况下二者获取的宽高值相等。</li>
</ul>
</li>
<li><code>getWidth</code> / <code>getHeight</code>：gtcg
<ul>
<li><strong>作用</strong>：获取 <code>View</code> 最终的宽高。</li>
<li><strong>赋值时机</strong>：<code>layout</code> 过程中。</li>
<li><strong>赋值方法</strong>：<code>layout</code> 中传递的 4 个参数之间的运算。</li>
</ul>
</li>
</ul>
<h4 id="4-如何定义标签间距">4. 如何定义标签间距？<a hidden class="anchor" aria-hidden="true" href="#4-如何定义标签间距">#</a></h4>
<ul>
<li>
<p>自定义属性：</p>
<ul>
<li>
<p>在 <code>res/values/</code> 新建 <code>attrs.xml</code> 文件，定义标签间距的属性。</p>
</li>
<li>
<p>示例代码：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-xml" data-lang="xml"><span style="display:flex;"><span><span style="color:#75715e">&lt;?xml version=&#34;1.0&#34; encoding=&#34;utf-8&#34;?&gt;</span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">&lt;resources&gt;</span>
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">&lt;declare-styleable</span> <span style="color:#a6e22e">name=</span><span style="color:#e6db74">&#34;TagCloud&#34;</span><span style="color:#f92672">&gt;</span>
</span></span><span style="display:flex;"><span>        <span style="color:#f92672">&lt;attr</span> <span style="color:#a6e22e">name=</span><span style="color:#e6db74">&#34;hMargin&#34;</span> <span style="color:#a6e22e">format=</span><span style="color:#e6db74">&#34;dimension&#34;</span><span style="color:#f92672">/&gt;</span>
</span></span><span style="display:flex;"><span>        <span style="color:#f92672">&lt;attr</span> <span style="color:#a6e22e">name=</span><span style="color:#e6db74">&#34;vMargin&#34;</span> <span style="color:#a6e22e">format=</span><span style="color:#e6db74">&#34;dimension&#34;</span><span style="color:#f92672">/&gt;</span>
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">&lt;/declare-styleable&gt;</span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">&lt;/resources&gt;</span>
</span></span></code></pre></div></li>
</ul>
</li>
</ul>
<h4 id="1-自定义属性与标签间距">1. 自定义属性与标签间距<a hidden class="anchor" aria-hidden="true" href="#1-自定义属性与标签间距">#</a></h4>
<p><strong>定义自定义属性 <code>gravity</code>：</strong></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-xml" data-lang="xml"><span style="display:flex;"><span><span style="color:#f92672">&lt;attr</span> <span style="color:#a6e22e">name=</span><span style="color:#e6db74">&#34;gravity&#34;</span><span style="color:#f92672">&gt;</span>
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">&lt;flag</span> <span style="color:#a6e22e">name=</span><span style="color:#e6db74">&#34;top&#34;</span> <span style="color:#a6e22e">value=</span><span style="color:#e6db74">&#34;0x30&#34;</span> <span style="color:#f92672">/&gt;</span>
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">&lt;flag</span> <span style="color:#a6e22e">name=</span><span style="color:#e6db74">&#34;bottom&#34;</span> <span style="color:#a6e22e">value=</span><span style="color:#e6db74">&#34;0x50&#34;</span> <span style="color:#f92672">/&gt;</span>
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">&lt;flag</span> <span style="color:#a6e22e">name=</span><span style="color:#e6db74">&#34;left&#34;</span> <span style="color:#a6e22e">value=</span><span style="color:#e6db74">&#34;0x03&#34;</span> <span style="color:#f92672">/&gt;</span>
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">&lt;flag</span> <span style="color:#a6e22e">name=</span><span style="color:#e6db74">&#34;right&#34;</span> <span style="color:#a6e22e">value=</span><span style="color:#e6db74">&#34;0x05&#34;</span> <span style="color:#f92672">/&gt;</span>
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">&lt;flag</span> <span style="color:#a6e22e">name=</span><span style="color:#e6db74">&#34;center_vertical&#34;</span> <span style="color:#a6e22e">value=</span><span style="color:#e6db74">&#34;0x10&#34;</span> <span style="color:#f92672">/&gt;</span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">&lt;/attr&gt;</span>
</span></span></code></pre></div><p><strong>定义混合类型属性 <code>background</code>：</strong></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-xml" data-lang="xml"><span style="display:flex;"><span><span style="color:#f92672">&lt;attr</span> <span style="color:#a6e22e">name=</span><span style="color:#e6db74">&#34;background&#34;</span> <span style="color:#a6e22e">format=</span><span style="color:#e6db74">&#34;reference|color&#34;</span> <span style="color:#f92672">/&gt;</span>
</span></span></code></pre></div><h4 id="2-在-xml-中使用属性">2. 在 XML 中使用属性<a hidden class="anchor" aria-hidden="true" href="#2-在-xml-中使用属性">#</a></h4>
<p><strong>示例代码：</strong></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-xml" data-lang="xml"><span style="display:flex;"><span><span style="color:#75715e">&lt;?xml version=&#34;1.0&#34; encoding=&#34;utf-8&#34;?&gt;</span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">&lt;LinearLayout</span> <span style="color:#a6e22e">xmlns:android=</span><span style="color:#e6db74">&#34;http://schemas.android.com/apk/res/android&#34;</span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">android:id=</span><span style="color:#e6db74">&#34;@+id/parent&#34;</span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">android:layout_width=</span><span style="color:#e6db74">&#34;match_parent&#34;</span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">android:layout_height=</span><span style="color:#e6db74">&#34;match_parent&#34;</span><span style="color:#f92672">&gt;</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">&lt;com.xiaomi.customview.TagCloud</span>
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">xmlns:app=</span><span style="color:#e6db74">&#34;http://schemas.android.com/apk/res-auto&#34;</span>
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">android:id=</span><span style="color:#e6db74">&#34;@+id/cloud&#34;</span>
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">android:layout_width=</span><span style="color:#e6db74">&#34;match_parent&#34;</span>
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">android:layout_height=</span><span style="color:#e6db74">&#34;match_parent&#34;</span>
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">app:hMargin=</span><span style="color:#e6db74">&#34;40dp&#34;</span>
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">app:vMargin=</span><span style="color:#e6db74">&#34;20dp&#34;</span> <span style="color:#f92672">/&gt;</span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">&lt;/LinearLayout&gt;</span>
</span></span></code></pre></div><p><strong>在 Java 代码中获取属性：</strong></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#66d9ef">public</span> <span style="color:#a6e22e">TagCloud</span>(<span style="color:#a6e22e">@NonNull</span> Context context, <span style="color:#a6e22e">@Nullable</span> AttributeSet attrs) {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">super</span>(context, attrs);
</span></span><span style="display:flex;"><span>    TypedArray a <span style="color:#f92672">=</span> context.<span style="color:#a6e22e">obtainStyledAttributes</span>(attrs, R.<span style="color:#a6e22e">styleable</span>.<span style="color:#a6e22e">TagCloud</span>);
</span></span><span style="display:flex;"><span>    horizontalMargin <span style="color:#f92672">=</span> a.<span style="color:#a6e22e">getDimension</span>(R.<span style="color:#a6e22e">styleable</span>.<span style="color:#a6e22e">TagCloud_hMargin</span>, 20);
</span></span><span style="display:flex;"><span>    verticalMargin <span style="color:#f92672">=</span> a.<span style="color:#a6e22e">getDimension</span>(R.<span style="color:#a6e22e">styleable</span>.<span style="color:#a6e22e">TagCloud_vMargin</span>, 10);
</span></span><span style="display:flex;"><span>    a.<span style="color:#a6e22e">recycle</span>();
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>

    <div class="post-img-view">
        <a data-fancybox="gallery" href="https://cdn.jsdelivr.net/gh/kennems/blog-image/image-20240713113546574.png">
            <img src="https://cdn.jsdelivr.net/gh/kennems/blog-image/image-20240713113546574.png" alt="image-20240713113546574"  />
        </a>
    </div>

</p>
<h4 id="3-响应手势操作">3. 响应手势操作<a hidden class="anchor" aria-hidden="true" href="#3-响应手势操作">#</a></h4>
<p><strong>MotionEvent 类（运动事件）包含：ACTION（事件类型）+ 事件位置</strong></p>
<p>

    <div class="post-img-view">
        <a data-fancybox="gallery" href="https://cdn.jsdelivr.net/gh/kennems/blog-image/image-20240713133727615.png">
            <img src="https://cdn.jsdelivr.net/gh/kennems/blog-image/image-20240713133727615.png" alt="image-20240713133727615"  />
        </a>
    </div>

</p>
<p>

    <div class="post-img-view">
        <a data-fancybox="gallery" href="https://cdn.jsdelivr.net/gh/kennems/blog-image/image-20240713134209323.png">
            <img src="https://cdn.jsdelivr.net/gh/kennems/blog-image/image-20240713134209323.png" alt="image-20240713134209323"  />
        </a>
    </div>

</p>
<p>

    <div class="post-img-view">
        <a data-fancybox="gallery" href="https://cdn.jsdelivr.net/gh/kennems/blog-image/image-20240713134539951.png">
            <img src="https://cdn.jsdelivr.net/gh/kennems/blog-image/image-20240713134539951.png" alt="image-20240713134539951"  />
        </a>
    </div>

</p>
<p>

    <div class="post-img-view">
        <a data-fancybox="gallery" href="https://cdn.jsdelivr.net/gh/kennems/blog-image/image-20240713134633563.png">
            <img src="https://cdn.jsdelivr.net/gh/kennems/blog-image/image-20240713134633563.png" alt="image-20240713134633563"  />
        </a>
    </div>

</p>
<p>

    <div class="post-img-view">
        <a data-fancybox="gallery" href="https://cdn.jsdelivr.net/gh/kennems/blog-image/image-20240713140303133.png">
            <img src="https://cdn.jsdelivr.net/gh/kennems/blog-image/image-20240713140303133.png" alt="image-20240713140303133"  />
        </a>
    </div>

</p>
<p>

    <div class="post-img-view">
        <a data-fancybox="gallery" href="https://cdn.jsdelivr.net/gh/kennems/blog-image/image-20240713140511226.png">
            <img src="https://cdn.jsdelivr.net/gh/kennems/blog-image/image-20240713140511226.png" alt="image-20240713140511226"  />
        </a>
    </div>

</p>
<p><code>onInterceptTouchEvent</code>:</p>
<p>**用途:**当先分发给子View处理,且子View的dispatchTouchEvent返回true(子View表示会消费这个事件),当前ViewGroup依然有捕获的能力</p>
<p><strong>场景</strong>:支持滑动的ViewGroup中的子View做了事件消费,第一个事件action_down发生在该子View范围内,该子View的dispatchTouchEvent方法返回true</p>
<p>第二个事件是action_move,此时当前ViewGroup判断为滑动手势,由自己开始消费(onInterceptTouchEvent返回true控制这事件),并且给子View分发action_cancel事件(帮助子View结束此组手势)</p>
<p><strong>事件类型：</strong></p>
<ul>
<li><code>ACTION_DOWN</code>：按下</li>
<li><code>ACTION_POINTER_DOWN</code>：第 n 个手指按下</li>
<li><code>ACTION_MOVE</code>：移动</li>
<li><code>ACTION_UP</code>：抬起</li>
<li><code>ACTION_POINTER_UP</code>：多指按下的前提下，抬起一个手指</li>
<li><code>ACTION_CANCEL</code>：取消</li>
</ul>
<p><strong>事件位置：</strong></p>
<ul>
<li><code>(x, y)</code> 坐标</li>
</ul>
<p><strong>示例代码：</strong></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#a6e22e">@Override</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">boolean</span> <span style="color:#a6e22e">onTouchEvent</span>(MotionEvent event) {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">switch</span> (event.<span style="color:#a6e22e">getAction</span>()) {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">case</span> MotionEvent.<span style="color:#a6e22e">ACTION_DOWN</span>:
</span></span><span style="display:flex;"><span>            <span style="color:#75715e">// 处理按下事件</span>
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">break</span>;
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">case</span> MotionEvent.<span style="color:#a6e22e">ACTION_MOVE</span>:
</span></span><span style="display:flex;"><span>            <span style="color:#75715e">// 处理移动事件</span>
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">break</span>;
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">case</span> MotionEvent.<span style="color:#a6e22e">ACTION_UP</span>:
</span></span><span style="display:flex;"><span>            <span style="color:#75715e">// 处理抬起事件</span>
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">break</span>;
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">case</span> MotionEvent.<span style="color:#a6e22e">ACTION_CANCEL</span>:
</span></span><span style="display:flex;"><span>            <span style="color:#75715e">// 处理取消事件</span>
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">break</span>;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">true</span>;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p><strong>用户的真实有意义的手势是由多个 MotionEvent（运动事件）组合而成</strong></p>
<p><strong>例如：</strong></p>
<ul>
<li>用户滑动手势：
<ul>
<li>DOWN事件</li>
<li>MOVE事件（若干个）</li>
<li>UP事件</li>
<li>进入另一个视图时的CANCEL事件</li>
</ul>
</li>
</ul>
<p><strong>示例流程图：</strong></p>
<pre tabindex="0"><code class="language-mermaid" data-lang="mermaid">    requirementDiagram

    requirement test_req {
    id: 1
    text: the test text.
    risk: high
    verifymethod: test
    }

    element test_entity {
    type: simulation
    }

    test_entity - satisfies -&gt; test_req
</code></pre><h2 id="gesturedetector-类及其回调方法">GestureDetector 类及其回调方法<a hidden class="anchor" aria-hidden="true" href="#gesturedetector-类及其回调方法">#</a></h2>
<ol>
<li><strong>onDown(MotionEvent e)</strong>:
<ul>
<li>用户按下屏幕时调用，表示屏幕已经被触摸。</li>
<li>返回 <code>false</code>。</li>
</ul>
</li>
<li><strong>onShowPress(MotionEvent e)</strong>:
<ul>
<li>用户按下屏幕一段时间后，但未完成其他手势时调用。</li>
<li>无返回值。</li>
</ul>
</li>
<li><strong>onSingleTapUp(MotionEvent e)</strong>:
<ul>
<li>用户轻触屏幕时调用，且未发生滑动或长按。</li>
<li>返回 <code>false</code>。</li>
</ul>
</li>
<li><strong>onScroll(MotionEvent e1, MotionEvent e2, float distanceX, float distanceY)</strong>:
<ul>
<li>用户在屏幕上滑动时调用，提供起始事件和当前事件之间的滑动距离。</li>
<li>返回 <code>false</code>。</li>
</ul>
</li>
<li><strong>onLongPress(MotionEvent e)</strong>:
<ul>
<li>用户长按屏幕时调用，用于处理长按事件。</li>
<li>无返回值。</li>
</ul>
</li>
<li><strong>onFling(MotionEvent e1, MotionEvent e2, float velocityX, float velocityY)</strong>:
<ul>
<li>用户快速滑动后松开时调用，提供起始事件、当前事件以及滑动速度。</li>
<li>返回 <code>false</code>。</li>
</ul>
</li>
</ol>
<h4 id="motionevent-事件类型">MotionEvent 事件类型<a hidden class="anchor" aria-hidden="true" href="#motionevent-事件类型">#</a></h4>
<ul>
<li><strong>ACTION_UP</strong>: 抬起</li>
<li><strong>ACTION_POINTER_UP</strong>: 多指按下的前提下，抬起一个手指</li>
<li><strong>ACTION_CANCEL</strong>: 取消</li>
</ul>
<h4 id="事件位置">事件位置<a hidden class="anchor" aria-hidden="true" href="#事件位置">#</a></h4>
<ul>
<li>事件位置为 <code>(x, y)</code> 坐标系。</li>
</ul>
<h4 id="手势的组合">手势的组合<a hidden class="anchor" aria-hidden="true" href="#手势的组合">#</a></h4>
<p>用户的真实手势是由多个 MotionEvent（运动事件）组合而成。例如：</p>
<ul>
<li>DOWN事件 -&gt; MOVE事件 -&gt; UP事件 -&gt; CANCEL事件</li>
</ul>
<h4 id="常见手势的事件组合">常见手势的事件组合<a hidden class="anchor" aria-hidden="true" href="#常见手势的事件组合">#</a></h4>
<ul>
<li><strong>点击</strong>: <code>down + up</code></li>
<li><strong>长按</strong>: <code>down</code>（持续一段时间没有 <code>move</code> 和 <code>up</code> 事件）</li>
<li><strong>滑动</strong>: <code>down + move + up</code></li>
<li><strong>双击</strong>: <code>down + up + down + up</code></li>
<li><strong>双指放大/缩小</strong>: <code>down + pointer_down + move + pointer_up + up</code></li>
<li><strong>长按拖动</strong>: <code>down + move + up</code>（满足触发长按的阈值）</li>
<li><strong>边缘滑动</strong>: <code>down + move + up</code>（区别在于事件位置在边缘）</li>
</ul>
<h4 id="gesturedetector-类">GestureDetector 类<a hidden class="anchor" aria-hidden="true" href="#gesturedetector-类">#</a></h4>
<ul>
<li><strong>作用</strong>: 提供封装好的手势判断结果。</li>
</ul>
<h4 id="使用-ontouchevent-方法或-ontouchlistener-处理手势">使用 onTouchEvent 方法或 onTouchListener 处理手势<a hidden class="anchor" aria-hidden="true" href="#使用-ontouchevent-方法或-ontouchlistener-处理手势">#</a></h4>
<p>通过重写 <code>onTouchEvent</code> 方法或注册 <code>onTouchListener</code>，可以将 <code>MotionEvent</code> 交给 <code>GestureDetector</code> 进行处理。</p>
<ul>
<li><strong>重写 onTouchEvent 方法</strong>:</li>
</ul>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#a6e22e">@Override</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">boolean</span> <span style="color:#a6e22e">onTouchEvent</span>(MotionEvent event) {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> mDetector.<span style="color:#a6e22e">onTouchEvent</span>(event);
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><ul>
<li><strong>注册 onTouchListener</strong>:</li>
</ul>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span>findViewById(R.<span style="color:#a6e22e">id</span>.<span style="color:#a6e22e">parent</span>).<span style="color:#a6e22e">setOnTouchListener</span>(<span style="color:#66d9ef">new</span> View.<span style="color:#a6e22e">OnTouchListener</span>() {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">@Override</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">boolean</span> <span style="color:#a6e22e">onTouch</span>(View v, MotionEvent event) {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> mDetector.<span style="color:#a6e22e">onTouchEvent</span>(event);
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>});
</span></span></code></pre></div><h4 id="手势分发及响应过程view-处理流程">手势分发及响应过程：View 处理流程<a hidden class="anchor" aria-hidden="true" href="#手势分发及响应过程view-处理流程">#</a></h4>
<ul>
<li><strong>流程图</strong>:</li>
</ul>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-markdown" data-lang="markdown"><span style="display:flex;"><span>开始
</span></span><span style="display:flex;"><span> └── View.dispatchTouchEvent()（分发事件）
</span></span><span style="display:flex;"><span>      ├── 是否注册了Touch事件监听
</span></span><span style="display:flex;"><span>      │    ├── true：View.onTouch()
</span></span><span style="display:flex;"><span>      │    │    ├── true：事件消费，不再向下分发
</span></span><span style="display:flex;"><span>      │    │    └── false：事件无法消费，继续向下分发
</span></span><span style="display:flex;"><span>      │    └── false：onTouchEvent()
</span></span><span style="display:flex;"><span>      │         ├── 是否注册了点击事件
</span></span><span style="display:flex;"><span>      │         │    ├── true：performClick() -&gt; onClick()
</span></span><span style="display:flex;"><span>      │         │    └── false：事件结束
</span></span><span style="display:flex;"><span>      └── 结果
</span></span></code></pre></div><ul>
<li><strong>事件处理</strong>:
<ul>
<li>如果我们认为一个有意义的手势是由 <code>ACTION_DOWN</code> 开始的一组 <code>MotionEvent</code> 事件组成，所以如果需要响应手势，第一个 <code>ACTION_DOWN</code> 就应该开始消费，即 <code>onTouch</code> 返回 <code>true</code>（且整个手势都应该持续返回 <code>true</code>）。如果返回 <code>false</code>，那么后续父 View 将不会把该组事件分发到当前 View。</li>
</ul>
</li>
</ul>
<h4 id="手势分发及响应过程viewgroup-处理流程">手势分发及响应过程：ViewGroup 处理流程<a hidden class="anchor" aria-hidden="true" href="#手势分发及响应过程viewgroup-处理流程">#</a></h4>
<ul>
<li><strong>流程图</strong>:</li>
</ul>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-markdown" data-lang="markdown"><span style="display:flex;"><span>开始
</span></span><span style="display:flex;"><span> └── ViewGroup.dispatchTouchEvent()（接收传递的事件）
</span></span><span style="display:flex;"><span>      ├── ViewGroup.onInterceptTouchEvent()（拦截事件）
</span></span><span style="display:flex;"><span>      │    ├── true：不允许事件继续向子View传递
</span></span><span style="display:flex;"><span>      │    │    └── ViewGroup交给dispatchTouchEvent()（即View.dispatchTouchEvent()）
</span></span><span style="display:flex;"><span>      │    │         ├── 自己处理该事件 -&gt; onTouchEvent() -&gt; performClick() -&gt; onClick()
</span></span><span style="display:flex;"><span>      │    └── false：允许事件继续向子View传递
</span></span><span style="display:flex;"><span>      │         ├── 找到被点击的子View（遍历所有子View）
</span></span><span style="display:flex;"><span>      │         │    ├── 找到被点击的子View
</span></span><span style="display:flex;"><span>      │         │    │    └── 调用子View的dispatchTouchEvent()（实现了事件传递：ViewGroup -&gt; View）
</span></span><span style="display:flex;"><span>      │         │    └── 找不到被点击的子View（如点击了空白处）
</span></span><span style="display:flex;"><span>      └── 结果
</span></span></code></pre></div><ul>
<li><strong>事件处理</strong>:
<ul>
<li><code>ViewGroup</code> 通过 <code>dispatchTouchEvent()</code> 分发事件，事件分发到子 View 时，会调用 <code>onInterceptTouchEvent()</code> 判断是否拦截事件。</li>
<li>如果拦截事件，<code>ViewGroup</code> 自己处理事件；如果不拦截，继续向子 View 传递，找到被点击的子 View 并调用其 <code>dispatchTouchEvent()</code> 进行事件传递和处理。</li>
</ul>
</li>
</ul>
<h4 id="onintercepttouchevent">onInterceptTouchEvent<a hidden class="anchor" aria-hidden="true" href="#onintercepttouchevent">#</a></h4>
<ul>
<li><strong>作用</strong>: 即使事件是无分发给子 View 处理，且子 View 的 <code>dispatchTouchEvent</code> 返回 <code>true</code>（子 View 表示会消费这个事件），当前 <code>ViewGroup</code> 依然有拦截的能力。</li>
<li><strong>场景</strong>: 支持该功能的 <code>ViewGroup</code> 中的子 <code>View</code> 做了事件消费，第一个事件 <code>action_down</code> 发生在该子 <code>View</code> 范围内，该子 <code>View</code> 的 <code>dispatchTouchEvent</code> 方法返回 <code>true</code>。第二个事件是 <code>action_move</code>，此时当前 <code>ViewGroup</code> 判断为滑动手势，由自己开始消费（<code>onInterceptTouchEvent</code> 返回 <code>true</code> 拦截该事件），并且给子 <code>View</code> 分发 <code>action_cancel</code> 事件（帮助子 <code>View</code> 结束此组手势响应）。</li>
</ul>
<h4 id="扩展内容">扩展内容<a hidden class="anchor" aria-hidden="true" href="#扩展内容">#</a></h4>
<ul>
<li>
<p><strong>GestureDetector#OnDoubleTapListener</strong></p>
<ul>
<li><strong>作用</strong>: 检测双击手势。</li>
<li><strong>使用</strong>: 使用方式同 <code>GestureDetector</code>。</li>
</ul>
</li>
<li>
<p><strong>ScaleGestureDetector 类</strong></p>
<ul>
<li><strong>作用</strong>: 检测双指缩放手势。</li>
<li><strong>使用</strong>: 使用方式同 <code>GestureDetector</code>。</li>
</ul>
</li>
<li>
<p><strong>ViewDragHelper / DragShadowBuilder 类</strong></p>
<ul>
<li>
<p><strong>相同的作用</strong>: 都是帮助实现拖拽逻辑的辅助类。</p>
</li>
<li>
<p><strong>不同的能力和场景</strong>:</p>
<table>
<thead>
<tr>
<th style="text-align:left"></th>
<th style="text-align:left">ViewDragHelper</th>
<th style="text-align:left">DragShadowBuilder</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left"><strong>场景</strong></td>
<td style="text-align:left">针对 <code>ViewGroup</code> 中拖拽子 <code>View</code> 的场景</td>
<td style="text-align:left">适用于更多场景，甚至支持跨进程拖动传递数据</td>
</tr>
<tr>
<td style="text-align:left"><strong>使用难易</strong></td>
<td style="text-align:left">简单</td>
<td style="text-align:left">复杂</td>
</tr>
</tbody>
</table>
</li>
</ul>
</li>
</ul>
<p>

    <div class="post-img-view">
        <a data-fancybox="gallery" href="https://cdn.jsdelivr.net/gh/kennems/blog-image/image-20240713153302141.png">
            <img src="https://cdn.jsdelivr.net/gh/kennems/blog-image/image-20240713153302141.png" alt="image-20240713153302141"  />
        </a>
    </div>

</p>
<p>

    <div class="post-img-view">
        <a data-fancybox="gallery" href="https://cdn.jsdelivr.net/gh/kennems/blog-image/image-20240713153454685.png">
            <img src="https://cdn.jsdelivr.net/gh/kennems/blog-image/image-20240713153454685.png" alt="image-20240713153454685"  />
        </a>
    </div>

</p>
<h4 id="课后阅读">课后阅读<a hidden class="anchor" aria-hidden="true" href="#课后阅读">#</a></h4>
<ul>
<li><a href="https://developer.android.com/develop/ui/views/layout/custom-views/custom-components?hl=zh-cn">Android 开发者指南: 自定义视图组件</a></li>
</ul>
<p>

    <div class="post-img-view">
        <a data-fancybox="gallery" href="https://cdn.jsdelivr.net/gh/kennems/blog-image/image-20240713154329674.png">
            <img src="https://cdn.jsdelivr.net/gh/kennems/blog-image/image-20240713154329674.png" alt="image-20240713154329674"  />
        </a>
    </div>

</p>
<p>

    <div class="post-img-view">
        <a data-fancybox="gallery" href="https://cdn.jsdelivr.net/gh/kennems/blog-image/image-20240713155113608.png">
            <img src="https://cdn.jsdelivr.net/gh/kennems/blog-image/image-20240713155113608.png" alt="image-20240713155113608"  />
        </a>
    </div>

</p>
<p>

    <div class="post-img-view">
        <a data-fancybox="gallery" href="https://cdn.jsdelivr.net/gh/kennems/blog-image/image-20240713160548223.png">
            <img src="https://cdn.jsdelivr.net/gh/kennems/blog-image/image-20240713160548223.png" alt="image-20240713160548223"  />
        </a>
    </div>

</p>
<p>

    <div class="post-img-view">
        <a data-fancybox="gallery" href="C:%5cUsers%5czg%5cAppData%5cRoaming%5cTypora%5ctypora-user-images%5cimage-20240713160558214.png">
            <img src="C:%5cUsers%5czg%5cAppData%5cRoaming%5cTypora%5ctypora-user-images%5cimage-20240713160558214.png" alt="image-20240713160558214"  />
        </a>
    </div>

j</p>


  </div>

  <footer class="post-footer">
    <ul class="post-tags">
      <li><a href="https://kennems.github.io/tags/android/">Android</a></li>
    </ul>
        
    
    <ul id="categories">
      
        <li><a href="https://kennems.github.io/categories/android%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0">Android学习笔记</a> </li>
      
    </ul>
    
    
<nav class="paginav">
  <a class="prev" href="https://kennems.github.io/posts/tech/%E7%AC%AC%E4%B9%9D%E5%A4%A9%E7%AC%94%E8%AE%B0/">
    <span class="title">« 上一页</span>
    <br>
    <span>训练营第九天笔记</span>
  </a>
  <a class="next" href="https://kennems.github.io/posts/tech/%E7%AC%AC%E4%B8%83%E5%A4%A9%E7%AC%94%E8%AE%B0/">
    <span class="title">下一页 »</span>
    <br>
    <span>训练营第七天笔记</span>
  </a>
</nav>

  </footer>
</article>
    </main>
    
<footer class="footer">
    <span>&copy; 2024 <a href="https://kennems.github.io/">Kennem&#39;s Blog</a></span>
    <span>
        Powered by
        <a href="https://gohugo.io/" rel="noopener noreferrer" target="_blank">Hugo</a> &
        <a href="https://github.com/adityatelange/hugo-PaperMod/" rel="noopener" target="_blank">PaperMod</a>
    </span>
</footer>
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)" class="top-link" id="top-link" accesskey="g">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
        <path d="M12 6H0l6-6z" />
    </svg>
</a>

<script>
    let menu = document.getElementById('menu')
    if (menu) {
        menu.scrollLeft = localStorage.getItem("menu-scroll-position");
        menu.onscroll = function () {
            localStorage.setItem("menu-scroll-position", menu.scrollLeft);
        }
    }

    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.pushState(null, null, `#${id}`);
            }
        });
    });

</script>
<script>
    var mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };

</script>
<script>
    document.getElementById("theme-toggle").addEventListener("click", () => {
        if (document.body.className.includes("dark")) {
            document.body.classList.remove('dark');
            localStorage.setItem("pref-theme", 'light');
        } else {
            document.body.classList.add('dark');
            localStorage.setItem("pref-theme", 'dark');
        }
    })

</script>
<script>
    document.querySelectorAll('pre > code').forEach((codeblock) => {
        const container = codeblock.parentNode.parentNode;

        const copybutton = document.createElement('button');
        copybutton.classList.add('copy-code');
        copybutton.innerHTML = '复制';

        function copyingDone() {
            copybutton.innerHTML = '已复制！';
            setTimeout(() => {
                copybutton.innerHTML = '复制';
            }, 2000);
        }

        copybutton.addEventListener('click', (cb) => {
            if ('clipboard' in navigator) {
                navigator.clipboard.writeText(codeblock.textContent);
                copyingDone();
                return;
            }

            const range = document.createRange();
            range.selectNodeContents(codeblock);
            const selection = window.getSelection();
            selection.removeAllRanges();
            selection.addRange(range);
            try {
                document.execCommand('copy');
                copyingDone();
            } catch (e) { };
            selection.removeRange(range);
        });

        if (container.classList.contains("highlight")) {
            container.appendChild(copybutton);
        } else if (container.parentNode.firstChild == container) {
            
        } else if (codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName == "TABLE") {
            
            codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(copybutton);
        } else {
            
            codeblock.parentNode.appendChild(copybutton);
        }
    });
</script>
<footer class="footer">
    <script async src="https://busuanzi.sukap.cn/busuanzi.pure.mini.js"></script>
    <span id="busuanzi_container">
        <link rel="stylesheet" href="//maxcdn.bootstrapcdn.com/font-awesome/4.3.0/css/font-awesome.min.css">
        Visitors: <span id="busuanzi_value_page_uv"></span>
        Views: <span id="busuanzi_value_page_pv"></span>

        
    </span>
</footer>



</body>

</html>
