<!DOCTYPE html>
<html lang="en" dir="auto">

<head><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="index, follow">
<title>Guan</title>
<meta name="keywords" content="">
<meta name="description" content="acwing算法学习 [TOC]
第一章 课上：学思想
课下：背代码
题目，一道题写好几遍
理解没有任何意义，体力活&#43;脑力活
记忆力 毅力/自制力
沉下心背东西
快速排序算法模板 —— 模板题 AcWing 785. 快速排序 分治
1、确定分界点，l、r、（l&#43;r)/2 随机
2、调整区间，分为两边，左边小于等于x,右边大于等于x
3、递归处理左右两段
void quick_sort(int q[], int l, int r) { if (l &gt;= r) return; int i = l - 1, j = r &#43; 1, x = q[l &#43; r &gt;&gt; 1]; while (i &lt; j) { do i &#43;&#43; ; while (q[i] &lt; x); do j -- ; while (q[j] &gt; x); if (i &lt; j) swap(q[i], q[j]); } quick_sort(q, l, j), quick_sort(q, j &#43; 1, r); } -std=c&#43;&#43;11 归并排序算法模板 —— 模板题 AcWing 787.">
<meta name="author" content="">
<link rel="canonical" href="https://showguan.github.io/posts/acwing/">
<link crossorigin="anonymous" href="/assets/css/stylesheet.4599eadb9eb2ad3d0a8d6827b41a8fda8f2f4af226b63466c09c5fddbc8706b7.css" integrity="sha256-RZnq256yrT0KjWgntBqP2o8vSvImtjRmwJxf3byHBrc=" rel="preload stylesheet" as="style">
<link rel="icon" href="https://showguan.github.io/favicon.ico">
<link rel="icon" type="image/png" sizes="16x16" href="https://showguan.github.io/favicon-16x16.png">
<link rel="icon" type="image/png" sizes="32x32" href="https://showguan.github.io/favicon-32x32.png">
<link rel="apple-touch-icon" href="https://showguan.github.io/apple-touch-icon.png">
<link rel="mask-icon" href="https://showguan.github.io/safari-pinned-tab.svg">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<link rel="alternate" hreflang="en" href="https://showguan.github.io/posts/acwing/">
<noscript>
    <style>
        #theme-toggle,
        .top-link {
            display: none;
        }

    </style>
    <style>
        @media (prefers-color-scheme: dark) {
            :root {
                --theme: rgb(29, 30, 32);
                --entry: rgb(46, 46, 51);
                --primary: rgb(218, 218, 219);
                --secondary: rgb(155, 156, 157);
                --tertiary: rgb(65, 66, 68);
                --content: rgb(196, 196, 197);
                --code-block-bg: rgb(46, 46, 51);
                --code-bg: rgb(55, 56, 62);
                --border: rgb(51, 51, 51);
            }

            .list {
                background: var(--theme);
            }

            .list:not(.dark)::-webkit-scrollbar-track {
                background: 0 0;
            }

            .list:not(.dark)::-webkit-scrollbar-thumb {
                border-color: var(--theme);
            }
        }

    </style>
</noscript><meta property="og:title" content="" />
<meta property="og:description" content="acwing算法学习 [TOC]
第一章 课上：学思想
课下：背代码
题目，一道题写好几遍
理解没有任何意义，体力活&#43;脑力活
记忆力 毅力/自制力
沉下心背东西
快速排序算法模板 —— 模板题 AcWing 785. 快速排序 分治
1、确定分界点，l、r、（l&#43;r)/2 随机
2、调整区间，分为两边，左边小于等于x,右边大于等于x
3、递归处理左右两段
void quick_sort(int q[], int l, int r) { if (l &gt;= r) return; int i = l - 1, j = r &#43; 1, x = q[l &#43; r &gt;&gt; 1]; while (i &lt; j) { do i &#43;&#43; ; while (q[i] &lt; x); do j -- ; while (q[j] &gt; x); if (i &lt; j) swap(q[i], q[j]); } quick_sort(q, l, j), quick_sort(q, j &#43; 1, r); } -std=c&#43;&#43;11 归并排序算法模板 —— 模板题 AcWing 787." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://showguan.github.io/posts/acwing/" /><meta property="article:section" content="posts" />



<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content=""/>
<meta name="twitter:description" content="acwing算法学习 [TOC]
第一章 课上：学思想
课下：背代码
题目，一道题写好几遍
理解没有任何意义，体力活&#43;脑力活
记忆力 毅力/自制力
沉下心背东西
快速排序算法模板 —— 模板题 AcWing 785. 快速排序 分治
1、确定分界点，l、r、（l&#43;r)/2 随机
2、调整区间，分为两边，左边小于等于x,右边大于等于x
3、递归处理左右两段
void quick_sort(int q[], int l, int r) { if (l &gt;= r) return; int i = l - 1, j = r &#43; 1, x = q[l &#43; r &gt;&gt; 1]; while (i &lt; j) { do i &#43;&#43; ; while (q[i] &lt; x); do j -- ; while (q[j] &gt; x); if (i &lt; j) swap(q[i], q[j]); } quick_sort(q, l, j), quick_sort(q, j &#43; 1, r); } -std=c&#43;&#43;11 归并排序算法模板 —— 模板题 AcWing 787."/>


<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BreadcrumbList",
  "itemListElement": [
    {
      "@type": "ListItem",
      "position":  1 ,
      "name": "Posts",
      "item": "https://showguan.github.io/posts/"
    }, 
    {
      "@type": "ListItem",
      "position":  2 ,
      "name": "",
      "item": "https://showguan.github.io/posts/acwing/"
    }
  ]
}
</script>
<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "",
  "name": "",
  "description": "acwing算法学习 [TOC]\n第一章 课上：学思想\n课下：背代码\n题目，一道题写好几遍\n理解没有任何意义，体力活+脑力活\n记忆力 毅力/自制力\n沉下心背东西\n快速排序算法模板 —— 模板题 AcWing 785. 快速排序 分治\n1、确定分界点，l、r、（l+r)/2 随机\n2、调整区间，分为两边，左边小于等于x,右边大于等于x\n3、递归处理左右两段\nvoid quick_sort(int q[], int l, int r) { if (l \u0026gt;= r) return; int i = l - 1, j = r + 1, x = q[l + r \u0026gt;\u0026gt; 1]; while (i \u0026lt; j) { do i ++ ; while (q[i] \u0026lt; x); do j -- ; while (q[j] \u0026gt; x); if (i \u0026lt; j) swap(q[i], q[j]); } quick_sort(q, l, j), quick_sort(q, j + 1, r); } -std=c++11 归并排序算法模板 —— 模板题 AcWing 787.",
  "keywords": [
    
  ],
  "articleBody": "acwing算法学习 [TOC]\n第一章 课上：学思想\n课下：背代码\n题目，一道题写好几遍\n理解没有任何意义，体力活+脑力活\n记忆力 毅力/自制力\n沉下心背东西\n快速排序算法模板 —— 模板题 AcWing 785. 快速排序 分治\n1、确定分界点，l、r、（l+r)/2 随机\n2、调整区间，分为两边，左边小于等于x,右边大于等于x\n3、递归处理左右两段\nvoid quick_sort(int q[], int l, int r) { if (l \u003e= r) return; int i = l - 1, j = r + 1, x = q[l + r \u003e\u003e 1]; while (i \u003c j) { do i ++ ; while (q[i] \u003c x); do j -- ; while (q[j] \u003e x); if (i \u003c j) swap(q[i], q[j]); } quick_sort(q, l, j), quick_sort(q, j + 1, r); } -std=c++11 归并排序算法模板 —— 模板题 AcWing 787. 归并排序 排序稳定：序列中相同的值排序后的相对位置是否发生改变\n时间复杂度有 （nlogn)\n1）确定分界点mid\n2）递归排序两边\n2）归并，合并为一个有序数组\nvoid merge_sort(int q[], int l, int r) { if (l \u003e= r) return; int mid = l + r \u003e\u003e 1; merge_sort(q, l, mid); merge_sort(q, mid + 1, r); int k = 0, i = l, j = mid + 1; while (i \u003c= mid \u0026\u0026 j \u003c= r) if (q[i] \u003c q[j]) tmp[k ++ ] = q[i ++ ]; else tmp[k ++ ] = q[j ++ ]; while (i \u003c= mid) tmp[k ++ ] = q[i ++ ]; while (j \u003c= r) tmp[k ++ ] = q[j ++ ]; for (i = l, j = 0; i \u003c= r; i ++, j ++ ) q[i] = tmp[j]; } 整数二分算法模板 —— 模板题 AcWing 789. 数的范围 边界问题\n本质：区间内一半满足一半不满足\nl=mid时加一\nbool check(int x) {/* ... */} // 检查x是否满足某种性质 // 区间[l, r]被划分成[l, mid]和[mid + 1, r]时使用： int bsearch_1(int l, int r) { while (l \u003c r) { int mid = l + r \u003e\u003e 1; if (check(mid)) r = mid; // check()判断mid是否满足性质 else l = mid + 1; } return l; } // 区间[l, r]被划分成[l, mid - 1]和[mid, r]时使用： int bsearch_2(int l, int r) { while (l \u003c r) { int mid = l + r + 1 \u003e\u003e 1; if (check(mid)) l = mid; else r = mid - 1; } return l; } 浮点数二分算法模板 —— 模板题 AcWing 790. 数的三次方根 浮点数二分，比较对应整数二分\nbool check(double x) {/* ... */} // 检查x是否满足某种性质 double bsearch_3(double l, double r) { const double eps = 1e-6; // eps 表示精度，取决于题目对精度的要求 while (r - l \u003e eps) { double mid = (l + r) / 2; if (check(mid)) r = mid; else l = mid; } return l; } 高精度加法 —— 模板题 AcWing 791. 高精度加法 // C = A + B, A \u003e= 0, B \u003e= 0 vector\u003cint\u003e add(vector\u003cint\u003e \u0026A, vector\u003cint\u003e \u0026B) { if (A.size() \u003c B.size()) return add(B, A); vector\u003cint\u003e C; int t = 0; for (int i = 0; i \u003c A.size(); i ++ ) { t += A[i]; if (i \u003c B.size()) t += B[i]; C.push_back(t % 10); t /= 10; } if (t) C.push_back(t); return C; } 高精度减法 —— 模板题 AcWing 792. 高精度减法 // C = A - B, 满足A \u003e= B, A \u003e= 0, B \u003e= 0 vector\u003cint\u003e sub(vector\u003cint\u003e \u0026A, vector\u003cint\u003e \u0026B) { vector\u003cint\u003e C; for (int i = 0, t = 0; i \u003c A.size(); i ++ ) { t = A[i] - t; if (i \u003c B.size()) t -= B[i]; C.push_back((t + 10) % 10); if (t \u003c 0) t = 1; else t = 0; } while (C.size() \u003e 1 \u0026\u0026 C.back() == 0) C.pop_back(); return C; } 高精度乘低精度 —— 模板题 AcWing 793. 高精度乘法 // C = A * b, A \u003e= 0, b \u003e 0 vector\u003cint\u003e mul(vector\u003cint\u003e \u0026A, int b) { vector\u003cint\u003e C; int t = 0; for (int i = 0; i \u003c A.size() || t; i ++ ) { if (i \u003c A.size()) t += A[i] * b; C.push_back(t % 10); t /= 10; } return C; } 高精度除以低精度 —— 模板题 AcWing 794. 高精度除法 // A / b = C ... r, A \u003e= 0, b \u003e 0 vector\u003cint\u003e div(vector\u003cint\u003e \u0026A, int b, int \u0026r) { vector\u003cint\u003e C; r = 0; for (int i = A.size() - 1; i \u003e= 0; i -- ) { r = r * 10 + A[i]; C.push_back(r / b); r %= b; } reverse(C.begin(), C.end()); while (C.size() \u003e 1 \u0026\u0026 C.back() == 0) C.pop_back(); return C; } 一维前缀和 —— 模板题 AcWing 795. 前缀和 快速求区间和\nS[i] = a[1] + a[2] + ... a[i] a[l] + ... + a[r] = S[r] - S[l - 1] 从1开始，便于处理边界 二维前缀和 —— 模板题 AcWing 796. 子矩阵的和 S[i, j] = 第i行j列格子左上部分所有元素的和 以(x1, y1)为左上角，(x2, y2)为右下角的子矩阵的和为： S[x2, y2] - S[x1 - 1, y2] - S[x2, y1 - 1] + S[x1 - 1, y1 - 1] 一维差分 —— 模板题 AcWing 797. 差分 给区间[l, r]中的每个数加上c： B[l] += c, B[r + 1] -= c 二维差分 —— 模板题 AcWing 798. 差分矩阵/二维差分 给以(x1, y1)为左上角，(x2, y2)为右下角的子矩阵中的所有元素加上c： S[x1, y1] += c, S[x2 + 1, y1] -= c, S[x1, y2 + 1] -= c, S[x2 + 1, y2 + 1] += c 双指针算法 —— 模板题 AcWIng 799. 最长连续不重复子序列, AcWing 800. 数组元素的目标和 __滑动窗口？ 核心：把O(n^2)算法优化为O(n)\nfor (int i = 0, j = 0; i \u003c n; i ++ ) { while (j \u003c i \u0026\u0026 check(j, i)) j ++ ; // 具体问题的逻辑 } 常见问题分类： (1) 对于一个序列，用两个指针维护一段区间 (2) 对于两个序列，维护某种次序，比如归并排序中合并两个有序序列的操作 位运算 —— 模板题 AcWing 801. 二进制中1的个数 原码，反码，补码 求n二进制表示中第k位数字: n \u003e\u003e k \u0026 1 返回n的最后一位1：lowbit(n) = n \u0026 -n 树状数组基本操作 整数离散化 —— 模板题 AcWing 802. 区间和 vector\u003cint\u003e alls; // 存储所有待离散化的值 sort(alls.begin(), alls.end()); // 将所有值排序 alls.erase(unique(alls.begin(), alls.end())返回去重后数组末尾端点, alls.end()); // 去掉重复元素 // 二分求出x对应的离散化的值 int find(int x) // 找到第一个大于等于x的位置 { int l = 0, r = alls.size() - 1; while (l \u003c r) { int mid = l + r \u003e\u003e 1; if (alls[mid] \u003e= x) r = mid; else l = mid + 1; } return r + 1; // 映射到1, 2, ...n } 区间合并 —— 模板题 AcWing 803. 区间合并 // 将所有存在交集的区间合并 贪心 void merge(vector\u003cPII\u003e \u0026segs) { vector\u003cPII\u003e res; sort(segs.begin(), segs.end()); //区间左端点排序 int st = -2e9, ed = -2e9; for (auto seg : segs) if (ed \u003c seg.first) { if (st != -2e9) res.push_back({st, ed}); st = seg.first, ed = seg.second; } else ed = max(ed, seg.second); if (st != -2e9) res.push_back({st, ed}); segs = res; } 作者：yxc 链接：https://www.acwing.com/blog/content/277/ 来源：AcWing 著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。\n第二章 数据结构，以数组模拟的形式\n指针+结构体 ： 面试题\n单链表 —— 模板题 AcWing 826. 单链表 邻接表-存储树和图 静态链表\n下标从0开始\n// head存储链表头，e[]存储节点的值，ne[]存储节点的next指针，idx表示当前用到了哪个节点 int head, e[N], ne[N], idx; // 初始化 void init() { head = -1; idx = 0; } // 在链表头插入一个数a void insert(int a) { e[idx] = a, ne[idx] = head, head = idx ++ ; } // 插入下标k后面 void add(int k,int x) { e[idx]= x, ne[idx] = ne[k], ne[k] = idx++ ; } // 将头结点删除，需要保证头结点存在 void remove() { head = ne[head]; } // 将k后面的点删掉 void remove(int k) { ne[k] = ne[ne[k]]; } 双链表 —— 模板题 AcWing 827. 双链表 优化某些问题\n// e[]表示节点的值，l[]表示节点的左指针，r[]表示节点的右指针，idx表示当前用到了哪个节点 int e[N], l[N], r[N], idx; // 初始化 void init() { //0是左端点，1是右端点 r[0] = 1, l[1] = 0; idx = 2; } // 在节点a的右边插入一个数x void insert(int a, int x) { e[idx] = x; l[idx] = a, r[idx] = r[a]; l[r[a]] = idx, r[a] = idx ++ ; } // 删除节点a void remove(int a) { l[r[a]] = l[a]; r[l[a]] = r[a]; } 栈 —— 模板题 AcWing 828. 模拟栈 // tt表示栈顶 int stk[N], tt = 0; // 向栈顶插入一个数 stk[ ++ tt] = x; // 从栈顶弹出一个数 tt -- ; // 栈顶的值 stk[tt]; // 判断栈是否为空 if (tt \u003e 0) { } 队列 —— 模板题 AcWing 829. 模拟队列 普通队列\n// hh 表示队头，tt表示队尾 int q[N], hh = 0, tt = -1; // 向队尾插入一个数 q[ ++ tt] = x; // 从队头弹出一个数 hh ++ ; // 队头的值 q[hh]; // 判断队列是否为空 if (hh \u003c= tt) { //不空 } 循环队列\n// hh 表示队头，tt表示队尾的后一个位置 int q[N], hh = 0, tt = 0; // 向队尾插入一个数 q[tt ++ ] = x; if (tt == N) tt = 0; // 从队头弹出一个数 hh ++ ; if (hh == N) hh = 0; // 队头的值 q[hh]; // 判断队列是否为空 if (hh != tt) { } 单调栈 —— 模板题 AcWing 830. 单调栈 常见模型：找出每个数左边离它最近的比它大/小的数 int tt = 0; for (int i = 1; i \u003c= n; i ++ ) { while (tt \u0026\u0026 check(stk[tt], i)) tt -- ; stk[ ++ tt] = i; } 单调队列 —— 模板题 AcWing 154. 滑动窗口 常见模型：找出滑动窗口中的最大值/最小值 int hh = 0, tt = -1; for (int i = 0; i \u003c n; i ++ ) { while (hh \u003c= tt \u0026\u0026 check_out(q[hh])) hh ++ ; // 判断队头是否滑出窗口 while (hh \u003c= tt \u0026\u0026 check(q[tt], i)) tt -- ; q[ ++ tt] = i; } KMP —— 模板题 AcWing 831. KMP字符串 用模板串来匹配模式串，找到模式串\ns的真前缀以及真后缀是指不等于s的前缀以及后缀，即至少是s[1~n-2]或s[0~n-1]\nne[i] : 以i结尾的串中 最长真前缀与真后缀相等的串 的长度，如果没有则为0。\n//前缀h vector\u003cint\u003e prefix_function(string s) { int n = (int)s.length(); vector\u003cint\u003e pi(n); for (int i = 1; i \u003c n; i++) { int j = pi[i - 1]; while (j \u003e 0 \u0026\u0026 s[i] != s[j]) j = pi[j - 1]; if (s[i] == s[j]) j++; pi[i] = j; } return pi; } 实际使用范例（下面这个例子字符串从1开始）\n// 求Next数组： // ne[i] 存储真前缀和真后缀相等的长度，所以至少从2开始： //abcab,从b开始才有真前缀 // s[]是模式串，p[]是模板串, n是s的长度，m是p的长度 for (int i = 2, j = 0; i \u003c= m; i ++ ) { while (j \u0026\u0026 p[i] != p[j + 1]) j = ne[j]; if (p[i] == p[j + 1]) j ++ ; ne[i] = j; } // 匹配 for (int i = 1, j = 0; i \u003c= n; i ++ ) { while (j \u0026\u0026 s[i] != p[j + 1]) j = ne[j]; if (s[i] == p[j + 1]) j ++ ; if (j == m) { j = ne[j]; // 匹配成功后的逻辑 } } Trie树 —— 模板题 AcWing 835. Trie字符串统计 int son[N][26], cnt[N], idx; // 0号点既是根节点，又是空节点 // son[][]存储树中每个节点的子节点 // cnt[]存储以每个节点结尾的单词数量 // 插入一个字符串 void insert(char *str) { int p = 0; for (int i = 0; str[i]; i ++ ) { int u = str[i] - 'a'; if (!son[p][u]) son[p][u] = ++ idx; p = son[p][u]; } cnt[p] ++ ; } // 查询字符串出现的次数 int query(char *str) { int p = 0; for (int i = 0; str[i]; i ++ ) { int u = str[i] - 'a'; if (!son[p][u]) return 0; p = son[p][u]; } return cnt[p]; } 并查集 —— 模板题 AcWing 836. 合并集合, AcWing 837. 连通块中点的数量 按秩合并\n字符按字符串读入\n(1)朴素并查集：\nint p[N]; //存储每个点的祖宗节点 // 返回x的祖宗节点 int find(int x) { if (p[x] != x) p[x] = find(p[x]); return p[x]; } // 初始化，假定节点编号是1~n for (int i = 1; i \u003c= n; i ++ ) p[i] = i; // 合并a和b所在的两个集合： p[find(a)] = find(b); (2)维护size的并查集：\nint p[N], size[N]; //p[]存储每个点的祖宗节点, size[]只有祖宗节点的有意义，表示祖宗节点所在集合中的点的数量 // 返回x的祖宗节点 int find(int x) { if (p[x] != x) p[x] = find(p[x]); return p[x]; } // 初始化，假定节点编号是1~n for (int i = 1; i \u003c= n; i ++ ) { p[i] = i; size[i] = 1; } // 合并a和b所在的两个集合： p[find(a)] = find(b); size[b] += size[a]; (3)维护到祖宗节点距离的并查集：\nint p[N], d[N]; //p[]存储每个点的祖宗节点, d[x]存储x到p[x]的距离 // 返回x的祖宗节点 int find(int x) { if (p[x] != x) { int u = find(p[x]); d[x] += d[p[x]]; p[x] = u; } return p[x]; } // 初始化，假定节点编号是1~n for (int i = 1; i \u003c= n; i ++ ) { p[i] = i; d[i] = 0; } // 合并a和b所在的两个集合： p[find(a)] = find(b); d[find(a)] = distance; // 根据具体问题，初始化find(a)的偏移量 堆 —— 模板题 AcWing 838. 堆排序, AcWing 839. 模拟堆 维护集合的数据结构 （大根堆，父节点值不小于子节点值）\n// h[N]存储堆中的值, h[1]是堆顶，x的左儿子是2x, 右儿子是2x + 1 // pos[k]存储第k个插入的点在堆中的位置 // ord[k]存储堆中下标是k的点是第几个插入的 int h[N], ph[N], hp[N], size; // 交换两个点，及其映射关系 void heap_swap(int a, int b) { //swap(ph[hp[a]],ph[hp[b]]); 根据题意 //swap(hp[a], hp[b]); swap(h[a], h[b]); } void down(int u) { int t = u; if (u * 2 \u003c= size \u0026\u0026 h[u * 2] \u003c h[t]) t = u * 2; if (u * 2 + 1 \u003c= size \u0026\u0026 h[u * 2 + 1] \u003c h[t]) t = u * 2 + 1; if (u != t) { heap_swap(u, t); down(t); } } void up(int u) { while (u / 2 \u0026\u0026 h[u] \u003c h[u / 2]) { heap_swap(u, u / 2); u \u003e\u003e= 1; } } // O(n)建堆 for (int i = n / 2; i; i -- ) down(i); heap[++size] = x; up(size); //添加元素 heap[1]; //堆顶元素 heap[1]=heap[size]; size--; down(1);//删除第size个结点 heap[k]=heap[size]; size---; down(k);up(k);//删除第k个结点 heap[k]=x; down(k); up(k); //将第k个元素赋值为x 一般哈希 —— 模板题 AcWing 840. 模拟散列表 (1) 拉链法 int h[N], e[N], ne[N], idx; // 向哈希表中插入一个数 void insert(int x) { int k = (x % N + N) % N; e[idx] = x; ne[idx] = h[k]; h[k] = idx ++ ; } // 在哈希表中查询某个数是否存在 bool find(int x) { int k = (x % N + N) % N; for (int i = h[k]; i != -1; i = ne[i]) if (e[i] == x) return true; return false; } (2) 开放寻址法 int h[N]; // 如果x在哈希表中，返回x的下标；如果x不在哈希表中，返回x应该插入的位置 int find(int x) { int t = (x % N + N) % N; while (h[t] != null \u0026\u0026 h[t] != x) { t ++ ; if (t == N) t = 0; } return t; } 字符串哈希 —— 模板题 AcWing 841. 字符串哈希 核心思想：将字符串看成P进制数，P的经验值是131或13331，取这两个值的冲突概率低 小技巧：取模的数用2^64，这样直接用unsigned long long存储，溢出的结果就是取模的结果。\ntypedef unsigned long long ULL; const int P = 131 or 13331 ; ULL h[N], p[N]; // h[k]存储字符串前k个字母的哈希值, p[k]存储 P^k mod 2^64 // 初始化 p[0] = 1; for (int i = 1; i \u003c= n; i ++ ) { h[i] = h[i - 1] * P + str[i]; p[i] = p[i - 1] * P; } // 计算子串 str[l ~ r] 的哈希值 ULL get(int l, int r) { return h[r] - h[l - 1] * p[r - l + 1]; } C++ STL简介 所有容器都有size() empty() vector, 变长数组，倍增的思想 size() 返回元素个数 empty() 返回是否为空 clear() 清空 front()/back() push_back()/pop_back() begin()/end() [] 支持比较运算，按字典序 vector\u003cint\u003e a(10,2); a.empty(); pair\u003cint, int\u003e first, 第一个元素 second, 第二个元素 支持比较运算，以first为第一关键字，以second为第二关键字（字典序） pair\u003cint,int\u003e p; p=make_pair(1,1); p={1,1}; string，字符串 size()/length() 返回字符串长度 empty() clear() substr(起始下标，(子串长度)) 返回子串 c_str() 返回字符串所在字符数组的起始地址 strcpy(c,s.c_str());//c_str()的使用方法 queue, 队列 没有clear函数 清空用新建queue size() empty() push() 向队尾插入一个元素 front() 返回队头元素 back() 返回队尾元素 pop() 弹出队头元素 priority_queue, 优先队列，默认是大根堆 push() 插入一个元素 top() 返回堆顶元素 pop() 弹出堆顶元素 定义成小根堆的方式：priority_queue\u003cint, vector\u003cint\u003e, greater\u003cint\u003e\u003e q; stack, 栈 size() empty() push() 向栈顶插入一个元素 top() 返回栈顶元素 pop() 弹出栈顶元素 deque, 双端队列 size() empty() clear() front()/back() push_back()/pop_back() push_front()/pop_front() begin()/end() [] set, map, multiset, multimap, 基于平衡二叉树（红黑树），动态维护有序序列 size() empty() clear() begin()/end() ++, -- 返回前驱和后继，时间复杂度 O(logn) set/multiset insert() 插入一个数 find() 查找一个数 count() 返回某一个数的个数 erase() (1) 输入是一个数x，删除所有x O(k + logn) (2) 输入一个迭代器，删除这个迭代器 lower_bound()/upper_bound() lower_bound(x) 返回大于等于x的最小的数的迭代器 upper_bound(x) 返回大于x的最小的数的迭代器 map/multimap insert() 插入的数是一个pair erase() 输入的参数是pair或者迭代器 find() [] 注意multimap不支持此操作。 时间复杂度是 O(logn) lower_bound()/upper_bound() unordered_set, unordered_map, unordered_multiset, unordered_multimap, 哈希表 和上面类似，增删改查的时间复杂度是 O(1) 不支持 lower_bound()/upper_bound()， 迭代器的++，-- bitset, 圧位 bitset\u003c10000\u003e s; ~, \u0026, |, ^ \u003e\u003e, \u003c\u003c ==, != [] count() 返回有多少个1 none() 判断是否全为0 any() 判断是否至少有一个1 set() 把所有位置成1 set(k, v) 将第k位变成v reset() 把所有位变成0 flip() 等价于~ flip(k) 把第k位取反 作者：yxc 链接：https://www.acwing.com/blog/content/404/ 来源：AcWing 著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。\n第三章 树与图的存储 树是一种特殊的图: 无环连通图，与图的存储方式相同。 对于无向图中的边ab，存储两条有向边a-\u003eb, b-\u003ea。 因此我们可以只考虑有向图的存储。\n(1) 邻接矩阵：g[a][b] 存储边a-\u003eb (2) 邻接表： // 对于每个点k，开一个单链表，存储k所有可以走到的点。h[k]存储这个单链表的头结点 int h[N], e[N], ne[N], idx; // 添加一条边a-\u003eb void add(int a, int b) { e[idx] = b, ne[idx] = h[a], h[a] = idx ++ ; } // 初始化 idx = 0; memset(h, -1, sizeof h); 树与图的遍历 时间复杂度 O(n+m)O(n+m), nn 表示点数，mm 表示边数\n(1) 深度优先遍历 —— 模板题 AcWing 846. 树的重心 int dfs(int u) { st[u] = true; // st[u] 表示点u已经被遍历过 for (int i = h[u]; i != -1; i = ne[i]) { int j = e[i]; if (!st[j]) dfs(j); } } (2) 宽度优先遍历 —— 模板题 AcWing 847. 图中点的层次 queue\u003cint\u003e q; st[1] = true; // 表示1号点已经被遍历过 q.push(1); while (q.size()) { int t = q.front(); q.pop(); for (int i = h[t]; i != -1; i = ne[i]) { int j = e[i]; if (!st[j]) { st[j] = true; // 表示点j已经被遍历过 q.push(j); } } } 拓扑排序 —— 模板题 AcWing 848. 有向图的拓扑序列 时间复杂度 O(n+m)O(n+m), nn 表示点数，mm 表示边数\nbool topsort() { int hh = 0, tt = -1; // d[i] 存储点i的入度 for (int i = 1; i \u003c= n; i ++ ) if (!d[i]) q[ ++ tt] = i; while (hh \u003c= tt) { int t = q[hh ++ ]; for (int i = h[t]; i != -1; i = ne[i]) { int j = e[i]; if (-- d[j] == 0) q[ ++ tt] = j; } } // 如果所有点都入队了，说明存在拓扑序列；否则不存在拓扑序列。 return tt == n - 1; } 最短路 单源最短路\n所有边权均为正：朴素Dijkstra O(n^2)；堆优化版的Dijkstra(mlogn)\n存在负权变：Bellman-Ford O(nm) ； SPFA（队列优化Bellman-Ford) 一般：O(m) 最坏 O(nm)\n多元汇最短路：Floyed算法 O(n^3)\n朴素dijkstra算法 —— 模板题 AcWing 849. Dijkstra求最短路 I 基于贪心 时间复杂是 O(n^2+m), n 表示点数，m 表示边数\nint g[N][N]; // 存储每条边， int dist[N]; // 存储1号点到每个点的最短距离 bool st[N]; // 存储每个点的最短路是否已经确定 // 求1号点到n号点的最短路，如果不存在则返回-1 int dijkstra() { memset(dist, 0x3f, sizeof dist); dist[1] = 0; for (int i = 0; i \u003c n - 1; i ++ ) { int t = -1; // 在还未确定最短路的点中，寻找距离最小的点 for (int j = 1; j \u003c= n; j ++ ) if (!st[j] \u0026\u0026 (t == -1 || dist[t] \u003e dist[j])) t = j; // 用t更新其他点的距离 for (int j = 1; j \u003c= n; j ++ ) dist[j] = min(dist[j], dist[t] + g[t][j]); st[t] = true; } if (dist[n] == 0x3f3f3f3f) return -1; return dist[n]; } 堆优化版dijkstra —— 模板题 AcWing 850. Dijkstra求最短路 II 时间复杂度 O(mlogn), n 表示点数，m 表示边数\ntypedef pair\u003cint, int\u003e PII; int n; // 点的数量 int h[N], w[N], e[N], ne[N], idx; // 邻接表存储所有边 int dist[N]; // 存储所有点到1号点的距离 bool st[N]; // 存储每个点的最短距离是否已确定 // 求1号点到n号点的最短距离，如果不存在，则返回-1 int dijkstra() { memset(dist, 0x3f, sizeof dist); dist[1] = 0; priority_queue\u003cPII, vector\u003cPII\u003e, greater\u003cPII\u003e\u003e heap; heap.push({0, 1}); // first存储距离，second存储节点编号 while (heap.size()) { auto t = heap.top(); heap.pop(); int ver = t.second, distance = t.first; if (st[ver]) continue; st[ver] = true; for (int i = h[ver]; i != -1; i = ne[i]) { int j = e[i]; if (dist[j] \u003e distance + w[i]) { dist[j] = distance + w[i]; heap.push({dist[j], j}); } } } if (dist[n] == 0x3f3f3f3f) return -1; return dist[n]; } Bellman-Ford算法 —— 模板题 AcWing 853. 有边数限制的最短路 时间复杂度 O(nm), n 表示点数，m表示边数 注意在模板题中需要对下面的模板稍作修改，加上备份数组，详情见模板题。\nint n, m; // n表示点数，m表示边数 int dist[N]; // dist[x]存储1到x的最短路距离 struct Edge // 边，a表示出点，b表示入点，w表示边的权重 { int a, b, w; }edges[M]; // 求1到n的最短路距离，如果无法从1走到n，则返回-1。 int bellman_ford() { memset(dist, 0x3f, sizeof dist); dist[1] = 0; // 如果第n次迭代仍然会松弛三角不等式，就说明存在一条长度是n+1的最短路径，由抽屉原理，路径中至少存在两个相同的点，说明图中存在负权回路。 for (int i = 0; i \u003c n; i ++ ) { for (int j = 0; j \u003c m; j ++ ) { int a = edges[j].a, b = edges[j].b, w = edges[j].w; if (dist[b] \u003e dist[a] + w) dist[b] = dist[a] + w; } } if (dist[n] \u003e 0x3f3f3f3f / 2) return -1; return dist[n]; } spfa 算法（队列优化的Bellman-Ford算法） —— 模板题 AcWing 851. spfa求最短路 时间复杂度 平均情况下 O(m)，最坏情况下 O(nm), n 表示点数，m 表示边数\nint n; // 总点数 int h[N], w[N], e[N], ne[N], idx; // 邻接表存储所有边 int dist[N]; // 存储每个点到1号点的最短距离 bool st[N]; // 存储每个点是否在队列中 // 求1号点到n号点的最短路距离，如果从1号点无法走到n号点则返回-1 int spfa() { memset(dist, 0x3f, sizeof dist); dist[1] = 0; queue\u003cint\u003e q; q.push(1); st[1] = true; while (q.size()) { auto t = q.front(); q.pop(); st[t] = false; for (int i = h[t]; i != -1; i = ne[i]) { int j = e[i]; if (dist[j] \u003e dist[t] + w[i]) { dist[j] = dist[t] + w[i]; if (!st[j]) // 如果队列中已存在j，则不需要将j重复插入 { q.push(j); st[j] = true; } } } } if (dist[n] == 0x3f3f3f3f) return -1; return dist[n]; } spfa判断图中是否存在负环 —— 模板题 AcWing 852. spfa判断负环 时间复杂度是 O(nm), n 表示点数，m 表示边数\nint n; // 总点数 int h[N], w[N], e[N], ne[N], idx; // 邻接表存储所有边 int dist[N], cnt[N]; // dist[x]存储1号点到x的最短距离，cnt[x]存储1到x的最短路中经过的点数 bool st[N]; // 存储每个点是否在队列中 // 如果存在负环，则返回true，否则返回false。 bool spfa() { // 不需要初始化dist数组 // 原理：如果某条最短路径上有n个点（除了自己），那么加上自己之后一共有n+1个点，由抽屉原理一定有两个点相同，所以存在环。 queue\u003cint\u003e q; for (int i = 1; i \u003c= n; i ++ ) { q.push(i); st[i] = true; } while (q.size()) { auto t = q.front(); q.pop(); st[t] = false; for (int i = h[t]; i != -1; i = ne[i]) { int j = e[i]; if (dist[j] \u003e dist[t] + w[i]) { dist[j] = dist[t] + w[i]; cnt[j] = cnt[t] + 1; if (cnt[j] \u003e= n) return true; // 如果从1号点到x的最短路中包含至少n个点（不包括自己），则说明存在环 if (!st[j]) { q.push(j); st[j] = true; } } } } return false; } floyd算法 —— 模板题 AcWing 854. Floyd求最短路 时间复杂度是 O(n3)O(n3), nn 表示点数 初始化： for (int i = 1; i \u003c= n; i ++ ) for (int j = 1; j \u003c= n; j ++ ) if (i == j) d[i][j] = 0; else d[i][j] = INF; // 算法结束后，d[a][b]表示a到b的最短距离 void floyd() { for (int k = 1; k \u003c= n; k ++ ) for (int i = 1; i \u003c= n; i ++ ) for (int j = 1; j \u003c= n; j ++ ) d[i][j] = min(d[i][j], d[i][k] + d[k][j]); } 最小生成树（无向图） Prim : 朴素版Prim O(n^2)(稠密图) ; 堆优化版Prim O(mlogn)(一般不会用)\nKruskal : O(mlogm)(稀疏图)\n朴素版prim算法 —— 模板题 AcWing 858. Prim算法求最小生成树 时间复杂度是 O(n^2+m), n 表示点数，m 表示边数\n初始化距离为正无穷，迭代所有点，找到集合中最近的点，更新它到集合的距离，把t加到集合中。\nint n; // n表示点数 int g[N][N]; // 邻接矩阵，存储所有边 int dist[N]; // 存储其他点到当前最小生成树的距离 bool st[N]; // 存储每个点是否已经在生成树中 // 如果图不连通，则返回INF(值是0x3f3f3f3f), 否则返回最小生成树的树边权重之和 int prim() { memset(dist, 0x3f, sizeof dist); int res = 0; for (int i = 0; i \u003c n; i ++ ) { int t = -1; for (int j = 1; j \u003c= n; j ++ ) if (!st[j] \u0026\u0026 (t == -1 || dist[t] \u003e dist[j])) t = j; if (i \u0026\u0026 dist[t] == INF) return INF; if (i) res += dist[t]; st[t] = true; for (int j = 1; j \u003c= n; j ++ ) dist[j] = min(dist[j], g[t][j]); } return res; } Kruskal算法 —— 模板题 AcWing 859. Kruskal算法求最小生成树 时间复杂度是 O(mlogm), n 表示点数，m 表示边数\nint n, m; // n是点数，m是边数 int p[N]; // 并查集的父节点数组 struct Edge // 存储边 { int a, b, w; // 重载小于号运算符 // 用于比较两个Edge对象的大小关系 bool operator \u003c (const Edge \u0026W) const { return w \u003c W.w; // 如果当前对象的边权小于W对象的边权，返回true，否则返回false } }edges[M]; int find(int x) // 并查集核心操作 { if (p[x] != x) p[x] = find(p[x]); return p[x]; } int kruskal() { sort(edges, edges + m); for (int i = 1; i \u003c= n; i ++ ) p[i] = i; // 初始化并查集 int res = 0, cnt = 0; for (int i = 0; i \u003c m; i ++ ) { int a = edges[i].a, b = edges[i].b, w = edges[i].w; a = find(a), b = find(b); if (a != b) // 如果两个连通块不连通，则将这两个连通块合并 { p[a] = b; res += w; cnt ++ ; } } if (cnt \u003c n - 1) return INF; return res; } 染色法（本质dfs)判别二分图 —— 模板题 AcWing 860. 染色法判定二分图 给定一个 n 个点m条边的无向图，图中可能存在重边和自环。请你判断这个图是否是二分图。\n时间复杂度是 O(n+m), n 表示点数，m 表示边数\nint n; // n表示点数 int h[N], e[M], ne[M], idx; // 邻接表存储图 int color[N]; // 表示每个点的颜色，-1表示为染色，0表示白色，1表示黑色 // 参数：u表示当前节点，c表示当前点的颜色 bool dfs(int u, int c) { color[u] = c; for (int i = h[u]; i != -1; i = ne[i]) { int j = e[i]; if (color[j] == -1) { if (!dfs(j, !c)) return false; } else if (color[j] == c) return false; } return true; } bool check() { memset(color, -1, sizeof color); bool flag = true; for (int i = 1; i \u003c= n; i ++ ) if (color[i] == -1) if (!dfs(i, 0)) { flag = false; break; } return flag; } 匈牙利算法 —— 模板题 AcWing 861. 二分图的最大匹配 时间复杂度最坏是 O(nm)，实际运行时间一般远小于O(nm)， n 表示点数，m 表示边数\n做错一件事，错过一件事\nint n1, n2; // n1表示第一个集合中的点数，n2表示第二个集合中的点数 int h[N], e[M], ne[M], idx; // 邻接表存储所有边，匈牙利算法中只会用到从第二个集合指向第一个集合的边，所以这里只用存一个方向的边 int match[N]; // 存储第二个集合中的每个点当前匹配的第一个集合中的点是哪个 bool st[N]; // 表示第二个集合中的每个点是否已经被遍历过 bool find(int x) { for (int i = h[x]; i != -1; i = ne[i]) { int j = e[i]; if (!st[j]) { st[j] = true; if (match[j] == 0 || find(match[j])) { match[j] = x; return true; } } } return false; } // 求最大匹配数，依次枚举第一个集合中的每个点能否匹配第二个集合中的点 int res = 0; for (int i = 1; i \u003c= n1; i ++ ) { memset(st, false, sizeof st); if (find(i)) res ++ ; } 作者：yxc 链接：https://www.acwing.com/blog/content/405/ 来源：AcWing 著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。\n第四章 试除法判定质数 —— 模板题 AcWing 866. 试除法判定质数 质数：大于1的整数中，如果只包含1和本身两个约束，称为质数（素数）\n（1）判定，试除法\n（2）分解质因数\nbool is_prime(int x) { if (x \u003c 2) return false; for (int i = 2; i \u003c= x / i; i ++ ) if (x % i == 0) return false; return true; } 试除法分解质因数 —— 模板题 AcWing 867. 分解质因数 void divide(int x) { for (int i = 2; i \u003c= x / i; i ++ ) if (x % i == 0) { int s = 0; while (x % i == 0) x /= i, s ++ ; cout \u003c\u003c i \u003c\u003c ' ' \u003c\u003c s \u003c\u003c endl; } if (x \u003e 1) cout \u003c\u003c x \u003c\u003c ' ' \u003c\u003c 1 \u003c\u003c endl; cout \u003c\u003c endl; } 朴素筛法求素数 —— 模板题 AcWing 868. 筛质数 int primes[N], cnt; // primes[]存储所有素数 bool st[N]; // st[x]存储x是否被筛掉 void get_primes(int n) { for (int i = 2; i \u003c= n; i ++ ) { if (st[i]) continue; primes[cnt ++ ] = i; for (int j = i; j \u003c= n; j += i) st[j] = true; } } 线性筛法求素数 —— 模板题 AcWing 868. 筛质数 被最小质因子筛掉\nint primes[N], cnt; // primes[]存储所有素数 bool st[N]; // st[x]存储x是否被筛掉 void get_primes(int n) { for (int i = 2; i \u003c= n; i ++ ) { if (!st[i]) primes[cnt ++ ] = i; for (int j = 0; primes[j] \u003c= n / i; j ++ ) { st[primes[j] * i] = true; if (i % primes[j] == 0) break; } } } 试除法求所有约数 —— 模板题 AcWing 869. 试除法求约数 int范围内约数个数最多为1500个左右\nvector\u003cint\u003e get_divisors(int x) { vector\u003cint\u003e res; for (int i = 1; i \u003c= x / i; i ++ ) if (x % i == 0) { res.push_back(i); if (i != x / i) res.push_back(x / i); } sort(res.begin(), res.end()); return res; } 约数个数和约数之和 —— 模板题 AcWing 870. 约数个数, AcWing 871. 约数之和 如果 N = p1^c1 * p2^c2 * ... *pk^ck 约数个数： (c1 + 1) * (c2 + 1) * ... * (ck + 1) 约数之和： (p1^0 + p1^1 + ... + p1^c1) * ... * (pk^0 + pk^1 + ... + pk^ck) 欧几里得算法 —— 模板题 AcWing 872. 最大公约数 int gcd(int a, int b) { return b ? gcd(b, a % b) : a; } 求欧拉函数 —— 模板题 AcWing 873. 欧拉函数 欧拉函数公式（容斥原理) : n*(1-p1)*(1-p2)…(1-pk)\nint phi(int x) { int res = x; for (int i = 2; i \u003c= x / i; i ++ ) if (x % i == 0) { res = res / i * (i - 1); while (x % i == 0) x /= i; } if (x \u003e 1) res = res / x * (x - 1); return res; } 筛法求欧拉函数 —— 模板题 AcWing 874. 筛法求欧拉函数 O(n) 线性求所有数的欧拉函数\n应用：欧拉定理：a与n互质 a^φ(n)=1(mod n)\nint primes[N], cnt; // primes[]存储所有素数 int euler[N]; // 存储每个数的欧拉函数 bool st[N]; // st[x]存储x是否被筛掉 void get_eulers(int n) { euler[1] = 1; for (int i = 2; i \u003c= n; i ++ ) { if (!st[i]) { primes[cnt ++ ] = i; euler[i] = i - 1; } for (int j = 0; primes[j] \u003c= n / i; j ++ ) { int t = primes[j] * i; st[t] = true; if (i % primes[j] == 0) { euler[t] = euler[i] * primes[j]; break; } euler[t] = euler[i] * (primes[j] - 1); } } } 快速幂 —— 模板题 AcWing 875. 快速幂 求 m^k mod p，时间复杂度 O(logk)。\nint qmi(int m, int k, int p) { int res = 1 % p, t = m; while (k) { if (k\u00261) res = res * t % p; t = t * t % p; k \u003e\u003e= 1; } return res; } 扩展欧几里得算法 —— 模板题 AcWing 877. 扩展欧几里得算法 // 求x, y，使得ax + by = gcd(a, b) int exgcd(int a, int b, int \u0026x, int \u0026y) { if (!b) { x = 1; y = 0; return a; } int d = exgcd(b, a % b, y, x); y -= (a/b) * x; return d; } 高斯消元 —— 模板题 AcWing 883. 高斯消元解线性方程组 O(n^3)时间内解n个方程n个未知数的解。\n解：无解 ； 无穷多组解 ； 唯一解 ；\n完美阶梯型：唯一解 *0=*非零 ： *无解 0=0 ： 无穷多组解 高斯消元：\n枚举每一列c：\n找到绝对值最大的一行 将该行换到最上面 将该行第一个数变成1 将下面所有行的第c列消成0 // a[N][N]是增广矩阵 int gauss() { int c, r; for (c = 0, r = 0; c \u003c n; c ++ ) { int t = r; for (int i = r; i \u003c n; i ++ ) // 找到绝对值最大的行 if (fabs(a[i][c]) \u003e fabs(a[t][c])) t = i; if (fabs(a[t][c]) \u003c eps) continue; for (int i = c; i \u003c= n; i ++ ) swap(a[t][i], a[r][i]); // 将绝对值最大的行换到最顶端 for (int i = n; i \u003e= c; i -- ) a[r][i] /= a[r][c]; // 将当前上的首位变成1 for (int i = r + 1; i \u003c n; i ++ ) // 用当前行将下面所有的列消成0 if (fabs(a[i][c]) \u003e eps) for (int j = n; j \u003e= c; j -- ) a[i][j] -= a[r][j] * a[i][c]; r ++ ; } if (r \u003c n) { for (int i = r; i \u003c n; i ++ ) if (fabs(a[i][n]) \u003e eps) return 2; // 无解 return 1; // 有无穷多组解 } for (int i = n - 1; i \u003e= 0; i -- ) for (int j = i + 1; j \u003c n; j ++ ) a[i][n] -= a[i][j] * a[j][n]; return 0; // 有唯一解 } 递归法求组合数 —— 模板题 AcWing 885. 求组合数 I 十万 1",
  "wordCount" : "5712",
  "inLanguage": "en",
  "datePublished": "0001-01-01T00:00:00Z",
  "dateModified": "0001-01-01T00:00:00Z",
  "mainEntityOfPage": {
    "@type": "WebPage",
    "@id": "https://showguan.github.io/posts/acwing/"
  },
  "publisher": {
    "@type": "Organization",
    "name": "Guan",
    "logo": {
      "@type": "ImageObject",
      "url": "https://showguan.github.io/favicon.ico"
    }
  }
}
</script>
</head>

<body class="" id="top">
<script>
    if (localStorage.getItem("pref-theme") === "dark") {
        document.body.classList.add('dark');
    } else if (localStorage.getItem("pref-theme") === "light") {
        document.body.classList.remove('dark')
    } else if (window.matchMedia('(prefers-color-scheme: dark)').matches) {
        document.body.classList.add('dark');
    }

</script>

<header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="https://showguan.github.io/" accesskey="h" title="Guan (Alt + H)">Guan</a>
            <div class="logo-switches">
                <button id="theme-toggle" accesskey="t" title="(Alt + T)">
                    <svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
                    </svg>
                    <svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <circle cx="12" cy="12" r="5"></circle>
                        <line x1="12" y1="1" x2="12" y2="3"></line>
                        <line x1="12" y1="21" x2="12" y2="23"></line>
                        <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                        <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                        <line x1="1" y1="12" x2="3" y2="12"></line>
                        <line x1="21" y1="12" x2="23" y2="12"></line>
                        <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                        <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
                    </svg>
                </button>
            </div>
        </div>
        <ul id="menu">
        </ul>
    </nav>
</header>
<main class="main">

<article class="post-single">
  <header class="post-header">
    
    <h1 class="post-title entry-hint-parent">
      
    </h1>
    <div class="post-meta">

</div>
  </header> 
  <div class="post-content"><h1 id="acwing算法学习">acwing算法学习<a hidden class="anchor" aria-hidden="true" href="#acwing算法学习">#</a></h1>
<p>[TOC]</p>
<h2 id="第一章">第一章<a hidden class="anchor" aria-hidden="true" href="#第一章">#</a></h2>
<p>课上：学思想</p>
<p>课下：背代码</p>
<p>题目，一道题写好几遍</p>
<p>理解没有任何意义，体力活+脑力活</p>
<p><strong>记忆力 毅力/自制力</strong></p>
<p>沉下心背东西</p>
<h3 id="快速排序算法模板--模板题-acwing-785-快速排序">快速排序算法模板 —— 模板题 AcWing 785. 快速排序<a hidden class="anchor" aria-hidden="true" href="#快速排序算法模板--模板题-acwing-785-快速排序">#</a></h3>
<p><strong>分治</strong></p>
<p>1、确定分界点，l、r、（l+r)/2 随机</p>
<p>2、调整区间，分为两边，左边小于等于x,右边大于等于x</p>
<p>3、递归处理左右两段</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c++" data-lang="c++"><span style="display:flex;"><span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">quick_sort</span>(<span style="color:#66d9ef">int</span> q[], <span style="color:#66d9ef">int</span> l, <span style="color:#66d9ef">int</span> r)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> (l <span style="color:#f92672">&gt;=</span> r) <span style="color:#66d9ef">return</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> l <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>, j <span style="color:#f92672">=</span> r <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>, x <span style="color:#f92672">=</span> q[l <span style="color:#f92672">+</span> r <span style="color:#f92672">&gt;&gt;</span> <span style="color:#ae81ff">1</span>];
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">while</span> (i <span style="color:#f92672">&lt;</span> j)
</span></span><span style="display:flex;"><span>    {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">do</span> i <span style="color:#f92672">++</span> ; <span style="color:#66d9ef">while</span> (q[i] <span style="color:#f92672">&lt;</span> x);
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">do</span> j <span style="color:#f92672">--</span> ; <span style="color:#66d9ef">while</span> (q[j] <span style="color:#f92672">&gt;</span> x);
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> (i <span style="color:#f92672">&lt;</span> j) swap(q[i], q[j]); 
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    quick_sort(q, l, j), quick_sort(q, j <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>, r);
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span><span style="color:#f92672">-</span>std<span style="color:#f92672">=</span>c<span style="color:#f92672">++</span><span style="color:#ae81ff">11</span>
</span></span></code></pre></div><h3 id="归并排序算法模板--模板题-acwing-787-归并排序">归并排序算法模板 —— 模板题 AcWing 787. 归并排序<a hidden class="anchor" aria-hidden="true" href="#归并排序算法模板--模板题-acwing-787-归并排序">#</a></h3>
<p>排序稳定：序列中相同的值排序后的相对位置是否发生改变</p>
<p>时间复杂度有 （nlogn)</p>
<p>1）确定分界点mid</p>
<p>2）递归排序两边</p>
<p>2）归并，合并为一个有序数组</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c++" data-lang="c++"><span style="display:flex;"><span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">merge_sort</span>(<span style="color:#66d9ef">int</span> q[], <span style="color:#66d9ef">int</span> l, <span style="color:#66d9ef">int</span> r)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> (l <span style="color:#f92672">&gt;=</span> r) <span style="color:#66d9ef">return</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> mid <span style="color:#f92672">=</span> l <span style="color:#f92672">+</span> r <span style="color:#f92672">&gt;&gt;</span> <span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span>    merge_sort(q, l, mid); merge_sort(q, mid <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>, r);
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> k <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>, i <span style="color:#f92672">=</span> l, j <span style="color:#f92672">=</span> mid <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">while</span> (i <span style="color:#f92672">&lt;=</span> mid <span style="color:#f92672">&amp;&amp;</span> j <span style="color:#f92672">&lt;=</span> r)
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> (q[i] <span style="color:#f92672">&lt;</span> q[j]) tmp[k <span style="color:#f92672">++</span> ] <span style="color:#f92672">=</span> q[i <span style="color:#f92672">++</span> ];
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">else</span> tmp[k <span style="color:#f92672">++</span> ] <span style="color:#f92672">=</span> q[j <span style="color:#f92672">++</span> ];
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">while</span> (i <span style="color:#f92672">&lt;=</span> mid) tmp[k <span style="color:#f92672">++</span> ] <span style="color:#f92672">=</span> q[i <span style="color:#f92672">++</span> ];
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">while</span> (j <span style="color:#f92672">&lt;=</span> r) tmp[k <span style="color:#f92672">++</span> ] <span style="color:#f92672">=</span> q[j <span style="color:#f92672">++</span> ];
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span> (i <span style="color:#f92672">=</span> l, j <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; i <span style="color:#f92672">&lt;=</span> r; i <span style="color:#f92672">++</span>, j <span style="color:#f92672">++</span> ) q[i] <span style="color:#f92672">=</span> tmp[j];
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h3 id="整数二分算法模板--模板题-acwing-789-数的范围">整数二分算法模板 —— 模板题 AcWing 789. 数的范围<a hidden class="anchor" aria-hidden="true" href="#整数二分算法模板--模板题-acwing-789-数的范围">#</a></h3>
<p>边界问题</p>
<p>本质：区间内一半满足一半不满足</p>
<p>l=mid时加一</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c++" data-lang="c++"><span style="display:flex;"><span><span style="color:#66d9ef">bool</span> <span style="color:#a6e22e">check</span>(<span style="color:#66d9ef">int</span> x) {<span style="color:#75715e">/* ... */</span>} <span style="color:#75715e">// 检查x是否满足某种性质
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">// 区间[l, r]被划分成[l, mid]和[mid + 1, r]时使用：
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">bsearch_1</span>(<span style="color:#66d9ef">int</span> l, <span style="color:#66d9ef">int</span> r)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">while</span> (l <span style="color:#f92672">&lt;</span> r)
</span></span><span style="display:flex;"><span>    {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">int</span> mid <span style="color:#f92672">=</span> l <span style="color:#f92672">+</span> r <span style="color:#f92672">&gt;&gt;</span> <span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> (check(mid)) r <span style="color:#f92672">=</span> mid;    <span style="color:#75715e">// check()判断mid是否满足性质
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#66d9ef">else</span> l <span style="color:#f92672">=</span> mid <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> l;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 区间[l, r]被划分成[l, mid - 1]和[mid, r]时使用：
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">bsearch_2</span>(<span style="color:#66d9ef">int</span> l, <span style="color:#66d9ef">int</span> r)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">while</span> (l <span style="color:#f92672">&lt;</span> r)
</span></span><span style="display:flex;"><span>    {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">int</span> mid <span style="color:#f92672">=</span> l <span style="color:#f92672">+</span> r <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span> <span style="color:#f92672">&gt;&gt;</span> <span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> (check(mid)) l <span style="color:#f92672">=</span> mid;
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">else</span> r <span style="color:#f92672">=</span> mid <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> l;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h3 id="浮点数二分算法模板--模板题-acwing-790-数的三次方根">浮点数二分算法模板 —— 模板题 AcWing 790. 数的三次方根<a hidden class="anchor" aria-hidden="true" href="#浮点数二分算法模板--模板题-acwing-790-数的三次方根">#</a></h3>
<p>浮点数二分，比较对应整数二分</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c++" data-lang="c++"><span style="display:flex;"><span><span style="color:#66d9ef">bool</span> <span style="color:#a6e22e">check</span>(<span style="color:#66d9ef">double</span> x) {<span style="color:#75715e">/* ... */</span>} <span style="color:#75715e">// 检查x是否满足某种性质
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">double</span> <span style="color:#a6e22e">bsearch_3</span>(<span style="color:#66d9ef">double</span> l, <span style="color:#66d9ef">double</span> r)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">const</span> <span style="color:#66d9ef">double</span> eps <span style="color:#f92672">=</span> <span style="color:#ae81ff">1e-6</span>;   <span style="color:#75715e">// eps 表示精度，取决于题目对精度的要求
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">while</span> (r <span style="color:#f92672">-</span> l <span style="color:#f92672">&gt;</span> eps)
</span></span><span style="display:flex;"><span>    {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">double</span> mid <span style="color:#f92672">=</span> (l <span style="color:#f92672">+</span> r) <span style="color:#f92672">/</span> <span style="color:#ae81ff">2</span>;
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> (check(mid)) r <span style="color:#f92672">=</span> mid;
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">else</span> l <span style="color:#f92672">=</span> mid;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> l;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h3 id="高精度加法--模板题-acwing-791-高精度加法">高精度加法 —— 模板题 AcWing 791. 高精度加法<a hidden class="anchor" aria-hidden="true" href="#高精度加法--模板题-acwing-791-高精度加法">#</a></h3>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c++" data-lang="c++"><span style="display:flex;"><span><span style="color:#75715e">// C = A + B, A &gt;= 0, B &gt;= 0
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>vector<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;</span> add(vector<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;</span> <span style="color:#f92672">&amp;</span>A, vector<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;</span> <span style="color:#f92672">&amp;</span>B)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> (A.size() <span style="color:#f92672">&lt;</span> B.size()) <span style="color:#66d9ef">return</span> add(B, A);
</span></span><span style="display:flex;"><span>    vector<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;</span> C;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> t <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; i <span style="color:#f92672">&lt;</span> A.size(); i <span style="color:#f92672">++</span> )
</span></span><span style="display:flex;"><span>    {
</span></span><span style="display:flex;"><span>        t <span style="color:#f92672">+=</span> A[i];
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> (i <span style="color:#f92672">&lt;</span> B.size()) t <span style="color:#f92672">+=</span> B[i];
</span></span><span style="display:flex;"><span>        C.push_back(t <span style="color:#f92672">%</span> <span style="color:#ae81ff">10</span>);
</span></span><span style="display:flex;"><span>        t <span style="color:#f92672">/=</span> <span style="color:#ae81ff">10</span>;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> (t) C.push_back(t);
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> C;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h3 id="高精度减法--模板题-acwing-792-高精度减法">高精度减法 —— 模板题 AcWing 792. 高精度减法<a hidden class="anchor" aria-hidden="true" href="#高精度减法--模板题-acwing-792-高精度减法">#</a></h3>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c++" data-lang="c++"><span style="display:flex;"><span><span style="color:#75715e">// C = A - B, 满足A &gt;= B, A &gt;= 0, B &gt;= 0
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>vector<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;</span> sub(vector<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;</span> <span style="color:#f92672">&amp;</span>A, vector<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;</span> <span style="color:#f92672">&amp;</span>B)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    vector<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;</span> C;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>, t <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; i <span style="color:#f92672">&lt;</span> A.size(); i <span style="color:#f92672">++</span> )
</span></span><span style="display:flex;"><span>    {
</span></span><span style="display:flex;"><span>        t <span style="color:#f92672">=</span> A[i] <span style="color:#f92672">-</span> t;
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> (i <span style="color:#f92672">&lt;</span> B.size()) t <span style="color:#f92672">-=</span> B[i];
</span></span><span style="display:flex;"><span>        C.push_back((t <span style="color:#f92672">+</span> <span style="color:#ae81ff">10</span>) <span style="color:#f92672">%</span> <span style="color:#ae81ff">10</span>);
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> (t <span style="color:#f92672">&lt;</span> <span style="color:#ae81ff">0</span>) t <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">else</span> t <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">while</span> (C.size() <span style="color:#f92672">&gt;</span> <span style="color:#ae81ff">1</span> <span style="color:#f92672">&amp;&amp;</span> C.back() <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span>) C.pop_back();
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> C;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h3 id="高精度乘低精度--模板题-acwing-793-高精度乘法">高精度乘低精度 —— 模板题 AcWing 793. 高精度乘法<a hidden class="anchor" aria-hidden="true" href="#高精度乘低精度--模板题-acwing-793-高精度乘法">#</a></h3>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c++" data-lang="c++"><span style="display:flex;"><span><span style="color:#75715e">// C = A * b, A &gt;= 0, b &gt; 0
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>vector<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;</span> mul(vector<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;</span> <span style="color:#f92672">&amp;</span>A, <span style="color:#66d9ef">int</span> b)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    vector<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;</span> C;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> t <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; i <span style="color:#f92672">&lt;</span> A.size() <span style="color:#f92672">||</span> t; i <span style="color:#f92672">++</span> )
</span></span><span style="display:flex;"><span>    {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> (i <span style="color:#f92672">&lt;</span> A.size()) t <span style="color:#f92672">+=</span> A[i] <span style="color:#f92672">*</span> b;
</span></span><span style="display:flex;"><span>        C.push_back(t <span style="color:#f92672">%</span> <span style="color:#ae81ff">10</span>);
</span></span><span style="display:flex;"><span>        t <span style="color:#f92672">/=</span> <span style="color:#ae81ff">10</span>;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> C;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h3 id="高精度除以低精度--模板题-acwing-794-高精度除法">高精度除以低精度 —— 模板题 AcWing 794. 高精度除法<a hidden class="anchor" aria-hidden="true" href="#高精度除以低精度--模板题-acwing-794-高精度除法">#</a></h3>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c++" data-lang="c++"><span style="display:flex;"><span><span style="color:#75715e">// A / b = C ... r, A &gt;= 0, b &gt; 0
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>vector<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;</span> div(vector<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;</span> <span style="color:#f92672">&amp;</span>A, <span style="color:#66d9ef">int</span> b, <span style="color:#66d9ef">int</span> <span style="color:#f92672">&amp;</span>r)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    vector<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;</span> C;
</span></span><span style="display:flex;"><span>    r <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> A.size() <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>; i <span style="color:#f92672">&gt;=</span> <span style="color:#ae81ff">0</span>; i <span style="color:#f92672">--</span> )
</span></span><span style="display:flex;"><span>    {
</span></span><span style="display:flex;"><span>        r <span style="color:#f92672">=</span> r <span style="color:#f92672">*</span> <span style="color:#ae81ff">10</span> <span style="color:#f92672">+</span> A[i];
</span></span><span style="display:flex;"><span>        C.push_back(r <span style="color:#f92672">/</span> b);
</span></span><span style="display:flex;"><span>        r <span style="color:#f92672">%=</span> b;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    reverse(C.begin(), C.end());
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">while</span> (C.size() <span style="color:#f92672">&gt;</span> <span style="color:#ae81ff">1</span> <span style="color:#f92672">&amp;&amp;</span> C.back() <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span>) C.pop_back();
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> C;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h3 id="一维前缀和--模板题-acwing-795-前缀和">一维前缀和 —— 模板题 AcWing 795. 前缀和<a hidden class="anchor" aria-hidden="true" href="#一维前缀和--模板题-acwing-795-前缀和">#</a></h3>
<p>快速求区间和</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c++" data-lang="c++"><span style="display:flex;"><span>S[i] <span style="color:#f92672">=</span> a[<span style="color:#ae81ff">1</span>] <span style="color:#f92672">+</span> a[<span style="color:#ae81ff">2</span>] <span style="color:#f92672">+</span> ... a[i]
</span></span><span style="display:flex;"><span>a[l] <span style="color:#f92672">+</span> ... <span style="color:#f92672">+</span> a[r] <span style="color:#f92672">=</span> S[r] <span style="color:#f92672">-</span> S[l <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>] <span style="color:#960050;background-color:#1e0010">从</span><span style="color:#ae81ff">1</span><span style="color:#960050;background-color:#1e0010">开始，便于处理边界</span>
</span></span></code></pre></div><h3 id="二维前缀和--模板题-acwing-796-子矩阵的和">二维前缀和 —— 模板题 AcWing 796. 子矩阵的和<a hidden class="anchor" aria-hidden="true" href="#二维前缀和--模板题-acwing-796-子矩阵的和">#</a></h3>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c++" data-lang="c++"><span style="display:flex;"><span>S[i, j] <span style="color:#f92672">=</span> <span style="color:#960050;background-color:#1e0010">第</span>i行j列格子左上部分所有元素的和
</span></span><span style="display:flex;"><span><span style="color:#960050;background-color:#1e0010">以</span>(x1, y1)<span style="color:#960050;background-color:#1e0010">为左上角，</span>(x2, y2)<span style="color:#960050;background-color:#1e0010">为右下角的子矩阵的和为：</span>
</span></span><span style="display:flex;"><span>S[x2, y2] <span style="color:#f92672">-</span> S[x1 <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>, y2] <span style="color:#f92672">-</span> S[x2, y1 <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>] <span style="color:#f92672">+</span> S[x1 <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>, y1 <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>]
</span></span></code></pre></div><h3 id="一维差分--模板题-acwing-797-差分">一维差分 —— 模板题 AcWing 797. 差分<a hidden class="anchor" aria-hidden="true" href="#一维差分--模板题-acwing-797-差分">#</a></h3>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c++" data-lang="c++"><span style="display:flex;"><span><span style="color:#960050;background-color:#1e0010">给区间</span>[l, r]<span style="color:#960050;background-color:#1e0010">中的每个数加上</span>c<span style="color:#960050;background-color:#1e0010">：</span>
</span></span><span style="display:flex;"><span>B[l] <span style="color:#f92672">+=</span> c, 
</span></span><span style="display:flex;"><span>B[r <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>] <span style="color:#f92672">-=</span> c
</span></span></code></pre></div><h3 id="二维差分--模板题-acwing-798-差分矩阵二维差分">二维差分 —— 模板题 AcWing 798. 差分矩阵/二维差分<a hidden class="anchor" aria-hidden="true" href="#二维差分--模板题-acwing-798-差分矩阵二维差分">#</a></h3>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c++" data-lang="c++"><span style="display:flex;"><span><span style="color:#960050;background-color:#1e0010">给以</span>(x1, y1)<span style="color:#960050;background-color:#1e0010">为左上角，</span>(x2, y2)<span style="color:#960050;background-color:#1e0010">为右下角的子矩阵中的所有元素加上</span>c<span style="color:#960050;background-color:#1e0010">：</span>
</span></span><span style="display:flex;"><span>S[x1, y1] <span style="color:#f92672">+=</span> c, 
</span></span><span style="display:flex;"><span>S[x2 <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>, y1] <span style="color:#f92672">-=</span> c, 
</span></span><span style="display:flex;"><span>S[x1, y2 <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>] <span style="color:#f92672">-=</span> c, 
</span></span><span style="display:flex;"><span>S[x2 <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>, y2 <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>] <span style="color:#f92672">+=</span> c
</span></span></code></pre></div><h3 id="双指针算法--模板题-acwing-799-最长连续不重复子序列-acwing-800-数组元素的目标和-__滑动窗口">双指针算法 —— 模板题 AcWIng 799. 最长连续不重复子序列, AcWing 800. 数组元素的目标和 __滑动窗口？<a hidden class="anchor" aria-hidden="true" href="#双指针算法--模板题-acwing-799-最长连续不重复子序列-acwing-800-数组元素的目标和-__滑动窗口">#</a></h3>
<p>核心：把O(n^2)算法优化为O(n)</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c++" data-lang="c++"><span style="display:flex;"><span><span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>, j <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; i <span style="color:#f92672">&lt;</span> n; i <span style="color:#f92672">++</span> )
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">while</span> (j <span style="color:#f92672">&lt;</span> i <span style="color:#f92672">&amp;&amp;</span> check(j, i)) j <span style="color:#f92672">++</span> ;
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 具体问题的逻辑
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>}
</span></span><span style="display:flex;"><span><span style="color:#960050;background-color:#1e0010">常见问题分类：</span> 
</span></span><span style="display:flex;"><span>    (<span style="color:#ae81ff">1</span>) <span style="color:#960050;background-color:#1e0010">对于一个序列，用两个指针维护一段区间</span>
</span></span><span style="display:flex;"><span>    (<span style="color:#ae81ff">2</span>) <span style="color:#960050;background-color:#1e0010">对于两个序列，维护某种次序，比如归并排序中合并两个有序序列的操作</span>
</span></span></code></pre></div><h3 id="位运算--模板题-acwing-801-二进制中1的个数">位运算 —— 模板题 AcWing 801. 二进制中1的个数<a hidden class="anchor" aria-hidden="true" href="#位运算--模板题-acwing-801-二进制中1的个数">#</a></h3>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c++" data-lang="c++"><span style="display:flex;"><span><span style="color:#960050;background-color:#1e0010">原码，反码，补码</span>
</span></span><span style="display:flex;"><span><span style="color:#960050;background-color:#1e0010">求</span>n二进制表示中第k位数字: n <span style="color:#f92672">&gt;&gt;</span> k <span style="color:#f92672">&amp;</span> <span style="color:#ae81ff">1</span> 
</span></span><span style="display:flex;"><span><span style="color:#960050;background-color:#1e0010">返回</span>n的最后一位1<span style="color:#960050;background-color:#1e0010">：</span>lowbit(n) <span style="color:#f92672">=</span> n <span style="color:#f92672">&amp;</span> <span style="color:#f92672">-</span>n <span style="color:#960050;background-color:#1e0010">树状数组基本操作</span>
</span></span></code></pre></div><h3 id="整数离散化--模板题-acwing-802-区间和">整数离散化 —— 模板题 AcWing 802. 区间和<a hidden class="anchor" aria-hidden="true" href="#整数离散化--模板题-acwing-802-区间和">#</a></h3>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c++" data-lang="c++"><span style="display:flex;"><span>vector<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;</span> alls; <span style="color:#75715e">// 存储所有待离散化的值
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>sort(alls.begin(), alls.end()); <span style="color:#75715e">// 将所有值排序
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>alls.erase(unique(alls.begin(), alls.end())<span style="color:#960050;background-color:#1e0010">返回去重后数组末尾端点</span>, alls.end());   <span style="color:#75715e">// 去掉重复元素
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">// 二分求出x对应的离散化的值
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">find</span>(<span style="color:#66d9ef">int</span> x) <span style="color:#75715e">// 找到第一个大于等于x的位置
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>{
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> l <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>, r <span style="color:#f92672">=</span> alls.size() <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">while</span> (l <span style="color:#f92672">&lt;</span> r)
</span></span><span style="display:flex;"><span>    {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">int</span> mid <span style="color:#f92672">=</span> l <span style="color:#f92672">+</span> r <span style="color:#f92672">&gt;&gt;</span> <span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> (alls[mid] <span style="color:#f92672">&gt;=</span> x) r <span style="color:#f92672">=</span> mid;
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">else</span> l <span style="color:#f92672">=</span> mid <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> r <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>; <span style="color:#75715e">// 映射到1, 2, ...n
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>}
</span></span></code></pre></div><h3 id="区间合并--模板题-acwing-803-区间合并">区间合并 —— 模板题 AcWing 803. 区间合并<a hidden class="anchor" aria-hidden="true" href="#区间合并--模板题-acwing-803-区间合并">#</a></h3>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c++" data-lang="c++"><span style="display:flex;"><span><span style="color:#75715e">// 将所有存在交集的区间合并 贪心
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">merge</span>(vector<span style="color:#f92672">&lt;</span>PII<span style="color:#f92672">&gt;</span> <span style="color:#f92672">&amp;</span>segs)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    vector<span style="color:#f92672">&lt;</span>PII<span style="color:#f92672">&gt;</span> res;
</span></span><span style="display:flex;"><span>    sort(segs.begin(), segs.end()); <span style="color:#75715e">//区间左端点排序
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">int</span> st <span style="color:#f92672">=</span> <span style="color:#f92672">-</span><span style="color:#ae81ff">2e9</span>, ed <span style="color:#f92672">=</span> <span style="color:#f92672">-</span><span style="color:#ae81ff">2e9</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">auto</span> seg : segs)
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> (ed <span style="color:#f92672">&lt;</span> seg.first)
</span></span><span style="display:flex;"><span>        {
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">if</span> (st <span style="color:#f92672">!=</span> <span style="color:#f92672">-</span><span style="color:#ae81ff">2e9</span>) res.push_back({st, ed});
</span></span><span style="display:flex;"><span>            st <span style="color:#f92672">=</span> seg.first, ed <span style="color:#f92672">=</span> seg.second;
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">else</span> ed <span style="color:#f92672">=</span> max(ed, seg.second);
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> (st <span style="color:#f92672">!=</span> <span style="color:#f92672">-</span><span style="color:#ae81ff">2e9</span>) res.push_back({st, ed});
</span></span><span style="display:flex;"><span>    segs <span style="color:#f92672">=</span> res;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>作者：yxc
链接：https://www.acwing.com/blog/content/277/
来源：AcWing
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p>
<h2 id="第二章">第二章<a hidden class="anchor" aria-hidden="true" href="#第二章">#</a></h2>
<p>数据结构，以数组模拟的形式</p>
<p>指针+结构体 ： 面试题</p>
<h3 id="单链表--模板题-acwing-826-单链表">单链表 —— 模板题 AcWing 826. 单链表<a hidden class="anchor" aria-hidden="true" href="#单链表--模板题-acwing-826-单链表">#</a></h3>
<p>邻接表-存储树和图  静态链表</p>
<p>下标从0开始</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c++" data-lang="c++"><span style="display:flex;"><span><span style="color:#75715e">// head存储链表头，e[]存储节点的值，ne[]存储节点的next指针，idx表示当前用到了哪个节点
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">int</span> head, e[N], ne[N], idx;
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 初始化
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">init</span>()
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    head <span style="color:#f92672">=</span> <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span>    idx <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 在链表头插入一个数a
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">insert</span>(<span style="color:#66d9ef">int</span> a)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    e[idx] <span style="color:#f92672">=</span> a, ne[idx] <span style="color:#f92672">=</span> head, head <span style="color:#f92672">=</span> idx <span style="color:#f92672">++</span> ;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 插入下标k后面
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">add</span>(<span style="color:#66d9ef">int</span> k,<span style="color:#66d9ef">int</span> x)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    e[idx]<span style="color:#f92672">=</span> x, ne[idx] <span style="color:#f92672">=</span> ne[k], ne[k] <span style="color:#f92672">=</span> idx<span style="color:#f92672">++</span> ;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 将头结点删除，需要保证头结点存在
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">remove</span>()
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    head <span style="color:#f92672">=</span> ne[head];
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 将k后面的点删掉
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">remove</span>(<span style="color:#66d9ef">int</span> k)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    ne[k] <span style="color:#f92672">=</span> ne[ne[k]];
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h3 id="双链表--模板题-acwing-827-双链表">双链表 —— 模板题 AcWing 827. 双链表<a hidden class="anchor" aria-hidden="true" href="#双链表--模板题-acwing-827-双链表">#</a></h3>
<p>优化某些问题</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c++" data-lang="c++"><span style="display:flex;"><span><span style="color:#75715e">// e[]表示节点的值，l[]表示节点的左指针，r[]表示节点的右指针，idx表示当前用到了哪个节点
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">int</span> e[N], l[N], r[N], idx;
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 初始化
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">init</span>()
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">//0是左端点，1是右端点
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    r[<span style="color:#ae81ff">0</span>] <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>, l[<span style="color:#ae81ff">1</span>] <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>    idx <span style="color:#f92672">=</span> <span style="color:#ae81ff">2</span>;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 在节点a的右边插入一个数x
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">insert</span>(<span style="color:#66d9ef">int</span> a, <span style="color:#66d9ef">int</span> x)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    e[idx] <span style="color:#f92672">=</span> x;
</span></span><span style="display:flex;"><span>    l[idx] <span style="color:#f92672">=</span> a, r[idx] <span style="color:#f92672">=</span> r[a];
</span></span><span style="display:flex;"><span>    l[r[a]] <span style="color:#f92672">=</span> idx, r[a] <span style="color:#f92672">=</span> idx <span style="color:#f92672">++</span> ;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 删除节点a
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">remove</span>(<span style="color:#66d9ef">int</span> a)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    l[r[a]] <span style="color:#f92672">=</span> l[a];
</span></span><span style="display:flex;"><span>    r[l[a]] <span style="color:#f92672">=</span> r[a];
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h3 id="栈--模板题-acwing-828-模拟栈">栈 —— 模板题 AcWing 828. 模拟栈<a hidden class="anchor" aria-hidden="true" href="#栈--模板题-acwing-828-模拟栈">#</a></h3>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c++" data-lang="c++"><span style="display:flex;"><span><span style="color:#75715e">// tt表示栈顶
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">int</span> stk[N], tt <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 向栈顶插入一个数
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>stk[ <span style="color:#f92672">++</span> tt] <span style="color:#f92672">=</span> x;
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 从栈顶弹出一个数
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>tt <span style="color:#f92672">--</span> ;
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 栈顶的值
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>stk[tt];
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 判断栈是否为空
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">if</span> (tt <span style="color:#f92672">&gt;</span> <span style="color:#ae81ff">0</span>)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h3 id="队列--模板题-acwing-829-模拟队列">队列 —— 模板题 AcWing 829. 模拟队列<a hidden class="anchor" aria-hidden="true" href="#队列--模板题-acwing-829-模拟队列">#</a></h3>
<p>普通队列</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c++" data-lang="c++"><span style="display:flex;"><span><span style="color:#75715e">// hh 表示队头，tt表示队尾
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">int</span> q[N], hh <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>, tt <span style="color:#f92672">=</span> <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 向队尾插入一个数
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>q[ <span style="color:#f92672">++</span> tt] <span style="color:#f92672">=</span> x;
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 从队头弹出一个数
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>hh <span style="color:#f92672">++</span> ;
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 队头的值
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>q[hh];
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 判断队列是否为空
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">if</span> (hh <span style="color:#f92672">&lt;=</span> tt)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">//不空
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>}
</span></span></code></pre></div><p><strong>循环队列</strong></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#75715e">// hh 表示队头，tt表示队尾的后一个位置
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">int</span> q[N], hh <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>, tt <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 向队尾插入一个数
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>q[tt <span style="color:#f92672">++</span> ] <span style="color:#f92672">=</span> x;
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">if</span> (tt <span style="color:#f92672">==</span> N) tt <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 从队头弹出一个数
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>hh <span style="color:#f92672">++</span> ;
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">if</span> (hh <span style="color:#f92672">==</span> N) hh <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 队头的值
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>q[hh];
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 判断队列是否为空
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">if</span> (hh <span style="color:#f92672">!=</span> tt)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h3 id="单调栈--模板题-acwing-830-单调栈">单调栈 —— 模板题 AcWing 830. 单调栈<a hidden class="anchor" aria-hidden="true" href="#单调栈--模板题-acwing-830-单调栈">#</a></h3>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c++" data-lang="c++"><span style="display:flex;"><span><span style="color:#960050;background-color:#1e0010">常见模型：找出每个数左边离它最近的比它大</span><span style="color:#f92672">/</span><span style="color:#960050;background-color:#1e0010">小的数</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> tt <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>; i <span style="color:#f92672">&lt;=</span> n; i <span style="color:#f92672">++</span> )
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">while</span> (tt <span style="color:#f92672">&amp;&amp;</span> check(stk[tt], i)) tt <span style="color:#f92672">--</span> ;
</span></span><span style="display:flex;"><span>    stk[ <span style="color:#f92672">++</span> tt] <span style="color:#f92672">=</span> i;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h3 id="单调队列--模板题-acwing-154-滑动窗口">单调队列 —— 模板题 AcWing 154. 滑动窗口<a hidden class="anchor" aria-hidden="true" href="#单调队列--模板题-acwing-154-滑动窗口">#</a></h3>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c++" data-lang="c++"><span style="display:flex;"><span><span style="color:#960050;background-color:#1e0010">常见模型：找出滑动窗口中的最大值</span><span style="color:#f92672">/</span><span style="color:#960050;background-color:#1e0010">最小值</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> hh <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>, tt <span style="color:#f92672">=</span> <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; i <span style="color:#f92672">&lt;</span> n; i <span style="color:#f92672">++</span> )
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">while</span> (hh <span style="color:#f92672">&lt;=</span> tt <span style="color:#f92672">&amp;&amp;</span> check_out(q[hh])) hh <span style="color:#f92672">++</span> ;  <span style="color:#75715e">// 判断队头是否滑出窗口
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">while</span> (hh <span style="color:#f92672">&lt;=</span> tt <span style="color:#f92672">&amp;&amp;</span> check(q[tt], i)) tt <span style="color:#f92672">--</span> ;
</span></span><span style="display:flex;"><span>    q[ <span style="color:#f92672">++</span> tt] <span style="color:#f92672">=</span> i;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h3 id="kmp--模板题-acwing-831-kmp字符串">KMP —— 模板题 AcWing 831. KMP字符串<a hidden class="anchor" aria-hidden="true" href="#kmp--模板题-acwing-831-kmp字符串">#</a></h3>
<p>用<strong>模板</strong>串来匹配<strong>模式</strong>串，找到模式串</p>
<p>s的真前缀以及真后缀是指不等于s的前缀以及后缀，即至少是<strong>s[1~n-2]<strong>或</strong>s[0~n-1]</strong></p>
<p>ne[i] : 以<strong>i</strong>结尾的串中 <strong>最长真前缀与真后缀相等的串</strong> 的长度，如果没有则为0。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c++" data-lang="c++"><span style="display:flex;"><span><span style="color:#75715e">//前缀h
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>vector<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;</span> prefix_function(string s) {
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">int</span> n <span style="color:#f92672">=</span> (<span style="color:#66d9ef">int</span>)s.length();
</span></span><span style="display:flex;"><span>  vector<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;</span> pi(n);
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>; i <span style="color:#f92672">&lt;</span> n; i<span style="color:#f92672">++</span>) {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> j <span style="color:#f92672">=</span> pi[i <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>];
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">while</span> (j <span style="color:#f92672">&gt;</span> <span style="color:#ae81ff">0</span> <span style="color:#f92672">&amp;&amp;</span> s[i] <span style="color:#f92672">!=</span> s[j]) j <span style="color:#f92672">=</span> pi[j <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>];
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> (s[i] <span style="color:#f92672">==</span> s[j]) j<span style="color:#f92672">++</span>;
</span></span><span style="display:flex;"><span>    pi[i] <span style="color:#f92672">=</span> j;
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">return</span> pi;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p><strong>实际使用范例（下面这个例子字符串从1开始）</strong></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c++" data-lang="c++"><span style="display:flex;"><span><span style="color:#75715e">// 求Next数组：
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">// ne[i] 存储真前缀和真后缀相等的长度，所以至少从2开始：
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">//abcab,从b开始才有真前缀
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">// s[]是模式串，p[]是模板串, n是s的长度，m是p的长度
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">2</span>, j <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; i <span style="color:#f92672">&lt;=</span> m; i <span style="color:#f92672">++</span> )
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">while</span> (j <span style="color:#f92672">&amp;&amp;</span> p[i] <span style="color:#f92672">!=</span> p[j <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>]) j <span style="color:#f92672">=</span> ne[j];
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> (p[i] <span style="color:#f92672">==</span> p[j <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>]) j <span style="color:#f92672">++</span> ;
</span></span><span style="display:flex;"><span>    ne[i] <span style="color:#f92672">=</span> j;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 匹配
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>, j <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; i <span style="color:#f92672">&lt;=</span> n; i <span style="color:#f92672">++</span> )
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">while</span> (j <span style="color:#f92672">&amp;&amp;</span> s[i] <span style="color:#f92672">!=</span> p[j <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>]) j <span style="color:#f92672">=</span> ne[j];
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> (s[i] <span style="color:#f92672">==</span> p[j <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>]) j <span style="color:#f92672">++</span> ;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> (j <span style="color:#f92672">==</span> m)
</span></span><span style="display:flex;"><span>    {
</span></span><span style="display:flex;"><span>        j <span style="color:#f92672">=</span> ne[j];
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// 匹配成功后的逻辑
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h3 id="trie树--模板题-acwing-835-trie字符串统计">Trie树 —— 模板题 AcWing 835. Trie字符串统计<a hidden class="anchor" aria-hidden="true" href="#trie树--模板题-acwing-835-trie字符串统计">#</a></h3>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c++" data-lang="c++"><span style="display:flex;"><span><span style="color:#66d9ef">int</span> son[N][<span style="color:#ae81ff">26</span>], cnt[N], idx;
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 0号点既是根节点，又是空节点
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">// son[][]存储树中每个节点的子节点
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">// cnt[]存储以每个节点结尾的单词数量
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">// 插入一个字符串
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">insert</span>(<span style="color:#66d9ef">char</span> <span style="color:#f92672">*</span>str)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> p <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; str[i]; i <span style="color:#f92672">++</span> )
</span></span><span style="display:flex;"><span>    {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">int</span> u <span style="color:#f92672">=</span> str[i] <span style="color:#f92672">-</span> <span style="color:#e6db74">&#39;a&#39;</span>;
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> (<span style="color:#f92672">!</span>son[p][u]) son[p][u] <span style="color:#f92672">=</span> <span style="color:#f92672">++</span> idx;
</span></span><span style="display:flex;"><span>        p <span style="color:#f92672">=</span> son[p][u];
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    cnt[p] <span style="color:#f92672">++</span> ;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 查询字符串出现的次数
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">query</span>(<span style="color:#66d9ef">char</span> <span style="color:#f92672">*</span>str)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> p <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; str[i]; i <span style="color:#f92672">++</span> )
</span></span><span style="display:flex;"><span>    {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">int</span> u <span style="color:#f92672">=</span> str[i] <span style="color:#f92672">-</span> <span style="color:#e6db74">&#39;a&#39;</span>;
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> (<span style="color:#f92672">!</span>son[p][u]) <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>        p <span style="color:#f92672">=</span> son[p][u];
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> cnt[p];
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h3 id="并查集--模板题-acwing-836-合并集合-acwing-837-连通块中点的数量">并查集 —— 模板题 AcWing 836. 合并集合, AcWing 837. 连通块中点的数量<a hidden class="anchor" aria-hidden="true" href="#并查集--模板题-acwing-836-合并集合-acwing-837-连通块中点的数量">#</a></h3>
<p>按秩合并</p>
<p>字符按字符串读入</p>
<p>(1)朴素并查集：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c++" data-lang="c++"><span style="display:flex;"><span><span style="color:#66d9ef">int</span> p[N]; <span style="color:#75715e">//存储每个点的祖宗节点
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">// 返回x的祖宗节点
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">find</span>(<span style="color:#66d9ef">int</span> x)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> (p[x] <span style="color:#f92672">!=</span> x) p[x] <span style="color:#f92672">=</span> find(p[x]);
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> p[x];
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 初始化，假定节点编号是1~n
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>; i <span style="color:#f92672">&lt;=</span> n; i <span style="color:#f92672">++</span> ) p[i] <span style="color:#f92672">=</span> i;
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 合并a和b所在的两个集合：
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>p[find(a)] <span style="color:#f92672">=</span> find(b);
</span></span></code></pre></div><p>(2)维护size的并查集：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c++" data-lang="c++"><span style="display:flex;"><span><span style="color:#66d9ef">int</span> p[N], size[N];
</span></span><span style="display:flex;"><span><span style="color:#75715e">//p[]存储每个点的祖宗节点, size[]只有祖宗节点的有意义，表示祖宗节点所在集合中的点的数量
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">// 返回x的祖宗节点
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">find</span>(<span style="color:#66d9ef">int</span> x)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> (p[x] <span style="color:#f92672">!=</span> x) p[x] <span style="color:#f92672">=</span> find(p[x]);
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> p[x];
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 初始化，假定节点编号是1~n
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>; i <span style="color:#f92672">&lt;=</span> n; i <span style="color:#f92672">++</span> )
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    p[i] <span style="color:#f92672">=</span> i;
</span></span><span style="display:flex;"><span>    size[i] <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 合并a和b所在的两个集合：
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>p[find(a)] <span style="color:#f92672">=</span> find(b);
</span></span><span style="display:flex;"><span>size[b] <span style="color:#f92672">+=</span> size[a];
</span></span></code></pre></div><p>(3)维护到祖宗节点距离的并查集：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c++" data-lang="c++"><span style="display:flex;"><span><span style="color:#66d9ef">int</span> p[N], d[N];
</span></span><span style="display:flex;"><span><span style="color:#75715e">//p[]存储每个点的祖宗节点, d[x]存储x到p[x]的距离
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">// 返回x的祖宗节点
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">find</span>(<span style="color:#66d9ef">int</span> x)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> (p[x] <span style="color:#f92672">!=</span> x)
</span></span><span style="display:flex;"><span>    {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">int</span> u <span style="color:#f92672">=</span> find(p[x]);
</span></span><span style="display:flex;"><span>        d[x] <span style="color:#f92672">+=</span> d[p[x]];
</span></span><span style="display:flex;"><span>        p[x] <span style="color:#f92672">=</span> u;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> p[x];
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 初始化，假定节点编号是1~n
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>; i <span style="color:#f92672">&lt;=</span> n; i <span style="color:#f92672">++</span> )
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    p[i] <span style="color:#f92672">=</span> i;
</span></span><span style="display:flex;"><span>    d[i] <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 合并a和b所在的两个集合：
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>p[find(a)] <span style="color:#f92672">=</span> find(b);
</span></span><span style="display:flex;"><span>d[find(a)] <span style="color:#f92672">=</span> distance; <span style="color:#75715e">// 根据具体问题，初始化find(a)的偏移量
</span></span></span></code></pre></div><h3 id="堆--模板题-acwing-838-堆排序-acwing-839-模拟堆">堆 —— 模板题 AcWing 838. 堆排序, AcWing 839. 模拟堆<a hidden class="anchor" aria-hidden="true" href="#堆--模板题-acwing-838-堆排序-acwing-839-模拟堆">#</a></h3>
<p>维护集合的数据结构 （大根堆，父节点值不小于子节点值）</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c++" data-lang="c++"><span style="display:flex;"><span><span style="color:#75715e">// h[N]存储堆中的值, h[1]是堆顶，x的左儿子是2x, 右儿子是2x + 1
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">// pos[k]存储第k个插入的点在堆中的位置
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">// ord[k]存储堆中下标是k的点是第几个插入的
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> h[N], ph[N], hp[N], size;
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 交换两个点，及其映射关系
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">heap_swap</span>(<span style="color:#66d9ef">int</span> a, <span style="color:#66d9ef">int</span> b)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">//swap(ph[hp[a]],ph[hp[b]]); 根据题意
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#75715e">//swap(hp[a], hp[b]);
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    swap(h[a], h[b]);
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">down</span>(<span style="color:#66d9ef">int</span> u)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> t <span style="color:#f92672">=</span> u;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> (u <span style="color:#f92672">*</span> <span style="color:#ae81ff">2</span> <span style="color:#f92672">&lt;=</span> size <span style="color:#f92672">&amp;&amp;</span> h[u <span style="color:#f92672">*</span> <span style="color:#ae81ff">2</span>] <span style="color:#f92672">&lt;</span> h[t]) t <span style="color:#f92672">=</span> u <span style="color:#f92672">*</span> <span style="color:#ae81ff">2</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> (u <span style="color:#f92672">*</span> <span style="color:#ae81ff">2</span> <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span> <span style="color:#f92672">&lt;=</span> size <span style="color:#f92672">&amp;&amp;</span> h[u <span style="color:#f92672">*</span> <span style="color:#ae81ff">2</span> <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>] <span style="color:#f92672">&lt;</span> h[t]) t <span style="color:#f92672">=</span> u <span style="color:#f92672">*</span> <span style="color:#ae81ff">2</span> <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> (u <span style="color:#f92672">!=</span> t)
</span></span><span style="display:flex;"><span>    {
</span></span><span style="display:flex;"><span>        heap_swap(u, t);
</span></span><span style="display:flex;"><span>        down(t);
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">up</span>(<span style="color:#66d9ef">int</span> u)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">while</span> (u <span style="color:#f92672">/</span> <span style="color:#ae81ff">2</span> <span style="color:#f92672">&amp;&amp;</span> h[u] <span style="color:#f92672">&lt;</span> h[u <span style="color:#f92672">/</span> <span style="color:#ae81ff">2</span>])
</span></span><span style="display:flex;"><span>    {
</span></span><span style="display:flex;"><span>        heap_swap(u, u <span style="color:#f92672">/</span> <span style="color:#ae81ff">2</span>);
</span></span><span style="display:flex;"><span>        u <span style="color:#f92672">&gt;&gt;=</span> <span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span><span style="color:#75715e">// O(n)建堆
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> n <span style="color:#f92672">/</span> <span style="color:#ae81ff">2</span>; i; i <span style="color:#f92672">--</span> ) down(i);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>heap[<span style="color:#f92672">++</span>size] <span style="color:#f92672">=</span> x; up(size); <span style="color:#75715e">//添加元素
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>heap[<span style="color:#ae81ff">1</span>]; <span style="color:#75715e">//堆顶元素
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>heap[<span style="color:#ae81ff">1</span>]<span style="color:#f92672">=</span>heap[size]; size<span style="color:#f92672">--</span>; down(<span style="color:#ae81ff">1</span>);<span style="color:#75715e">//删除第size个结点
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>heap[k]<span style="color:#f92672">=</span>heap[size]; size<span style="color:#f92672">---</span>; down(k);up(k);<span style="color:#75715e">//删除第k个结点
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>heap[k]<span style="color:#f92672">=</span>x; down(k); up(k); <span style="color:#75715e">//将第k个元素赋值为x
</span></span></span></code></pre></div><h3 id="一般哈希--模板题-acwing-840-模拟散列表">一般哈希 —— 模板题 AcWing 840. 模拟散列表<a hidden class="anchor" aria-hidden="true" href="#一般哈希--模板题-acwing-840-模拟散列表">#</a></h3>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c++" data-lang="c++"><span style="display:flex;"><span>(<span style="color:#ae81ff">1</span>) <span style="color:#960050;background-color:#1e0010">拉链法</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> h[N], e[N], ne[N], idx;
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 向哈希表中插入一个数
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">insert</span>(<span style="color:#66d9ef">int</span> x)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> k <span style="color:#f92672">=</span> (x <span style="color:#f92672">%</span> N <span style="color:#f92672">+</span> N) <span style="color:#f92672">%</span> N;
</span></span><span style="display:flex;"><span>    e[idx] <span style="color:#f92672">=</span> x;
</span></span><span style="display:flex;"><span>    ne[idx] <span style="color:#f92672">=</span> h[k];
</span></span><span style="display:flex;"><span>    h[k] <span style="color:#f92672">=</span> idx <span style="color:#f92672">++</span> ;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 在哈希表中查询某个数是否存在
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">bool</span> <span style="color:#a6e22e">find</span>(<span style="color:#66d9ef">int</span> x)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> k <span style="color:#f92672">=</span> (x <span style="color:#f92672">%</span> N <span style="color:#f92672">+</span> N) <span style="color:#f92672">%</span> N;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> h[k]; i <span style="color:#f92672">!=</span> <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>; i <span style="color:#f92672">=</span> ne[i])
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> (e[i] <span style="color:#f92672">==</span> x)
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">return</span> true;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> false;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>(<span style="color:#ae81ff">2</span>) <span style="color:#960050;background-color:#1e0010">开放寻址法</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> h[N];
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 如果x在哈希表中，返回x的下标；如果x不在哈希表中，返回x应该插入的位置
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">find</span>(<span style="color:#66d9ef">int</span> x)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> t <span style="color:#f92672">=</span> (x <span style="color:#f92672">%</span> N <span style="color:#f92672">+</span> N) <span style="color:#f92672">%</span> N;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">while</span> (h[t] <span style="color:#f92672">!=</span> null <span style="color:#f92672">&amp;&amp;</span> h[t] <span style="color:#f92672">!=</span> x)
</span></span><span style="display:flex;"><span>    {
</span></span><span style="display:flex;"><span>        t <span style="color:#f92672">++</span> ;
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> (t <span style="color:#f92672">==</span> N) t <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> t;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h3 id="字符串哈希--模板题-acwing-841-字符串哈希">字符串哈希 —— 模板题 AcWing 841. 字符串哈希<a hidden class="anchor" aria-hidden="true" href="#字符串哈希--模板题-acwing-841-字符串哈希">#</a></h3>
<p>核心思想：将字符串看成P进制数，P的经验值是131或13331，取这两个值的冲突概率低
小技巧：取模的数用2^64，这样直接用unsigned long long存储，溢出的结果就是取模的结果。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c++" data-lang="c++"><span style="display:flex;"><span><span style="color:#66d9ef">typedef</span> <span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">long</span> <span style="color:#66d9ef">long</span> ULL;
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">const</span> <span style="color:#66d9ef">int</span> P <span style="color:#f92672">=</span> <span style="color:#ae81ff">131</span> or <span style="color:#ae81ff">13331</span> ;
</span></span><span style="display:flex;"><span>ULL h[N], p[N]; <span style="color:#75715e">// h[k]存储字符串前k个字母的哈希值, p[k]存储 P^k mod 2^64
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">// 初始化
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>p[<span style="color:#ae81ff">0</span>] <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>; i <span style="color:#f92672">&lt;=</span> n; i <span style="color:#f92672">++</span> )
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    h[i] <span style="color:#f92672">=</span> h[i <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>] <span style="color:#f92672">*</span> P <span style="color:#f92672">+</span> str[i];
</span></span><span style="display:flex;"><span>    p[i] <span style="color:#f92672">=</span> p[i <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>] <span style="color:#f92672">*</span> P;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 计算子串 str[l ~ r] 的哈希值
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>ULL <span style="color:#a6e22e">get</span>(<span style="color:#66d9ef">int</span> l, <span style="color:#66d9ef">int</span> r)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> h[r] <span style="color:#f92672">-</span> h[l <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>] <span style="color:#f92672">*</span> p[r <span style="color:#f92672">-</span> l <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>];
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h2 id="c-stl简介">C++ STL简介<a hidden class="anchor" aria-hidden="true" href="#c-stl简介">#</a></h2>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c++" data-lang="c++"><span style="display:flex;"><span><span style="color:#960050;background-color:#1e0010">所有容器都有</span>size() empty()
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>vector, <span style="color:#960050;background-color:#1e0010">变长数组，倍增的思想</span>
</span></span><span style="display:flex;"><span>    size()  <span style="color:#960050;background-color:#1e0010">返回元素个数</span>
</span></span><span style="display:flex;"><span>    empty()  <span style="color:#960050;background-color:#1e0010">返回是否为空</span>
</span></span><span style="display:flex;"><span>    clear()  <span style="color:#960050;background-color:#1e0010">清空</span>
</span></span><span style="display:flex;"><span>    front()<span style="color:#f92672">/</span>back()
</span></span><span style="display:flex;"><span>    push_back()<span style="color:#f92672">/</span>pop_back()
</span></span><span style="display:flex;"><span>    begin()<span style="color:#f92672">/</span>end()
</span></span><span style="display:flex;"><span>    []
</span></span><span style="display:flex;"><span>    <span style="color:#960050;background-color:#1e0010">支持比较运算，按字典序</span>
</span></span><span style="display:flex;"><span>    vector<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;</span> a(<span style="color:#ae81ff">10</span>,<span style="color:#ae81ff">2</span>);
</span></span><span style="display:flex;"><span>	a.empty();
</span></span><span style="display:flex;"><span>pair<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span>, <span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;</span>
</span></span><span style="display:flex;"><span>    first, <span style="color:#960050;background-color:#1e0010">第一个元素</span>
</span></span><span style="display:flex;"><span>    second, <span style="color:#960050;background-color:#1e0010">第二个元素</span>
</span></span><span style="display:flex;"><span>    <span style="color:#960050;background-color:#1e0010">支持比较运算，以</span>first为第一关键字<span style="color:#960050;background-color:#1e0010">，以</span>second为第二关键字<span style="color:#960050;background-color:#1e0010">（字典序）</span>
</span></span><span style="display:flex;"><span>	pair<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span>,<span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;</span> p;
</span></span><span style="display:flex;"><span>	p<span style="color:#f92672">=</span>make_pair(<span style="color:#ae81ff">1</span>,<span style="color:#ae81ff">1</span>);
</span></span><span style="display:flex;"><span>	p<span style="color:#f92672">=</span>{<span style="color:#ae81ff">1</span>,<span style="color:#ae81ff">1</span>};
</span></span><span style="display:flex;"><span>string<span style="color:#960050;background-color:#1e0010">，字符串</span>
</span></span><span style="display:flex;"><span>    size()<span style="color:#f92672">/</span>length()  <span style="color:#960050;background-color:#1e0010">返回字符串长度</span>
</span></span><span style="display:flex;"><span>    empty()
</span></span><span style="display:flex;"><span>    clear()
</span></span><span style="display:flex;"><span>    substr(<span style="color:#960050;background-color:#1e0010">起始下标，</span>(<span style="color:#960050;background-color:#1e0010">子串长度</span>))  <span style="color:#960050;background-color:#1e0010">返回子串</span>
</span></span><span style="display:flex;"><span>    c_str()  <span style="color:#960050;background-color:#1e0010">返回字符串所在字符数组的起始地址</span>
</span></span><span style="display:flex;"><span>        strcpy(c,s.c_str());<span style="color:#75715e">//c_str()的使用方法
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span>queue, <span style="color:#960050;background-color:#1e0010">队列</span>
</span></span><span style="display:flex;"><span>    <span style="color:#960050;background-color:#1e0010">没有</span>clear函数
</span></span><span style="display:flex;"><span>    <span style="color:#960050;background-color:#1e0010">清空用新建</span>queue
</span></span><span style="display:flex;"><span>    size()
</span></span><span style="display:flex;"><span>    empty()
</span></span><span style="display:flex;"><span>    push()  <span style="color:#960050;background-color:#1e0010">向队尾插入一个元素</span>
</span></span><span style="display:flex;"><span>    front()  <span style="color:#960050;background-color:#1e0010">返回队头元素</span>
</span></span><span style="display:flex;"><span>    back()  <span style="color:#960050;background-color:#1e0010">返回队尾元素</span>
</span></span><span style="display:flex;"><span>    pop()  <span style="color:#960050;background-color:#1e0010">弹出队头元素</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>priority_queue, <span style="color:#960050;background-color:#1e0010">优先队列，默认是大根堆</span>
</span></span><span style="display:flex;"><span>    push()  <span style="color:#960050;background-color:#1e0010">插入一个元素</span>
</span></span><span style="display:flex;"><span>    top()  <span style="color:#960050;background-color:#1e0010">返回堆顶元素</span>
</span></span><span style="display:flex;"><span>    pop()  <span style="color:#960050;background-color:#1e0010">弹出堆顶元素</span>
</span></span><span style="display:flex;"><span>    <span style="color:#960050;background-color:#1e0010">定义成小根堆的方式：</span>priority_queue<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span>, vector<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;</span>, greater<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;&gt;</span> q;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>stack, <span style="color:#960050;background-color:#1e0010">栈</span>
</span></span><span style="display:flex;"><span>    size()
</span></span><span style="display:flex;"><span>    empty()
</span></span><span style="display:flex;"><span>    push()  <span style="color:#960050;background-color:#1e0010">向栈顶插入一个元素</span>
</span></span><span style="display:flex;"><span>    top()  <span style="color:#960050;background-color:#1e0010">返回栈顶元素</span>
</span></span><span style="display:flex;"><span>    pop()  <span style="color:#960050;background-color:#1e0010">弹出栈顶元素</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>deque, <span style="color:#960050;background-color:#1e0010">双端队列</span>
</span></span><span style="display:flex;"><span>    size()
</span></span><span style="display:flex;"><span>    empty()
</span></span><span style="display:flex;"><span>    clear()
</span></span><span style="display:flex;"><span>    front()<span style="color:#f92672">/</span>back()
</span></span><span style="display:flex;"><span>    push_back()<span style="color:#f92672">/</span>pop_back()
</span></span><span style="display:flex;"><span>    push_front()<span style="color:#f92672">/</span>pop_front()
</span></span><span style="display:flex;"><span>    begin()<span style="color:#f92672">/</span>end()
</span></span><span style="display:flex;"><span>    []
</span></span></code></pre></div><div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>set, map, multiset, multimap, <span style="color:#960050;background-color:#1e0010">基于平衡二叉树（红黑树），动态维护有序序列</span>
</span></span><span style="display:flex;"><span>    size()
</span></span><span style="display:flex;"><span>    empty()
</span></span><span style="display:flex;"><span>    clear()
</span></span><span style="display:flex;"><span>    begin()<span style="color:#f92672">/</span>end()
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">++</span>, <span style="color:#f92672">--</span> <span style="color:#960050;background-color:#1e0010">返回前驱和后继，时间复杂度</span> O(logn)
</span></span><span style="display:flex;"><span>set<span style="color:#f92672">/</span>multiset
</span></span><span style="display:flex;"><span>    insert()  <span style="color:#960050;background-color:#1e0010">插入一个数</span>
</span></span><span style="display:flex;"><span>    find()  <span style="color:#960050;background-color:#1e0010">查找一个数</span>
</span></span><span style="display:flex;"><span>    count()  <span style="color:#960050;background-color:#1e0010">返回某一个数的个数</span>
</span></span><span style="display:flex;"><span>    erase()
</span></span><span style="display:flex;"><span>        (<span style="color:#ae81ff">1</span>) <span style="color:#960050;background-color:#1e0010">输入是一个数</span>x<span style="color:#960050;background-color:#1e0010">，删除所有</span>x   O(k <span style="color:#f92672">+</span> logn)
</span></span><span style="display:flex;"><span>        (<span style="color:#ae81ff">2</span>) <span style="color:#960050;background-color:#1e0010">输入一个迭代器，删除这个迭代器</span>
</span></span><span style="display:flex;"><span>    lower_bound()<span style="color:#f92672">/</span>upper_bound()
</span></span><span style="display:flex;"><span>        lower_bound(x)  <span style="color:#960050;background-color:#1e0010">返回大于等于</span>x的最小的数的迭代器
</span></span><span style="display:flex;"><span>        upper_bound(x)  <span style="color:#960050;background-color:#1e0010">返回大于</span>x的最小的数的迭代器
</span></span><span style="display:flex;"><span>map<span style="color:#f92672">/</span>multimap
</span></span><span style="display:flex;"><span>    insert()  <span style="color:#960050;background-color:#1e0010">插入的数是一个</span>pair
</span></span><span style="display:flex;"><span>    erase()  <span style="color:#960050;background-color:#1e0010">输入的参数是</span>pair或者迭代器
</span></span><span style="display:flex;"><span>    find()
</span></span><span style="display:flex;"><span>    []  <span style="color:#960050;background-color:#1e0010">注意</span>multimap不支持此操作<span style="color:#960050;background-color:#1e0010">。</span> <span style="color:#960050;background-color:#1e0010">时间复杂度是</span> O(logn)
</span></span><span style="display:flex;"><span>    lower_bound()<span style="color:#f92672">/</span>upper_bound()
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>unordered_set, unordered_map, unordered_multiset, unordered_multimap, <span style="color:#960050;background-color:#1e0010">哈希表</span>
</span></span><span style="display:flex;"><span>    <span style="color:#960050;background-color:#1e0010">和上面类似，增删改查的时间复杂度是</span> O(<span style="color:#ae81ff">1</span>)
</span></span><span style="display:flex;"><span>    <span style="color:#960050;background-color:#1e0010">不支持</span> lower_bound()<span style="color:#f92672">/</span>upper_bound()<span style="color:#960050;background-color:#1e0010">，</span> <span style="color:#960050;background-color:#1e0010">迭代器的</span><span style="color:#f92672">++</span><span style="color:#960050;background-color:#1e0010">，</span><span style="color:#f92672">--</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>bitset, <span style="color:#960050;background-color:#1e0010">圧位</span>
</span></span><span style="display:flex;"><span>    bitset<span style="color:#f92672">&lt;</span><span style="color:#ae81ff">10000</span><span style="color:#f92672">&gt;</span> s;
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">~</span>, <span style="color:#f92672">&amp;</span>, <span style="color:#f92672">|</span>, <span style="color:#f92672">^</span>
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">&gt;&gt;</span>, <span style="color:#f92672">&lt;&lt;</span>
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">==</span>, <span style="color:#f92672">!=</span>
</span></span><span style="display:flex;"><span>    []
</span></span><span style="display:flex;"><span>    count()  <span style="color:#960050;background-color:#1e0010">返回有多少个</span><span style="color:#ae81ff">1</span>
</span></span><span style="display:flex;"><span>    none()  <span style="color:#960050;background-color:#1e0010">判断是否全为</span><span style="color:#ae81ff">0</span>     any()  <span style="color:#960050;background-color:#1e0010">判断是否至少有一个</span><span style="color:#ae81ff">1</span>
</span></span><span style="display:flex;"><span>    set()  <span style="color:#960050;background-color:#1e0010">把所有位置成</span><span style="color:#ae81ff">1</span>
</span></span><span style="display:flex;"><span>    set(k, v)  <span style="color:#960050;background-color:#1e0010">将第</span>k位变成v
</span></span><span style="display:flex;"><span>    reset()  <span style="color:#960050;background-color:#1e0010">把所有位变成</span><span style="color:#ae81ff">0</span>
</span></span><span style="display:flex;"><span>    flip()  <span style="color:#960050;background-color:#1e0010">等价于</span><span style="color:#f92672">~</span>
</span></span><span style="display:flex;"><span>    flip(k) <span style="color:#960050;background-color:#1e0010">把第</span>k位取反
</span></span></code></pre></div><p>作者：yxc
链接：https://www.acwing.com/blog/content/404/
来源：AcWing
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p>
<h2 id="第三章">第三章<a hidden class="anchor" aria-hidden="true" href="#第三章">#</a></h2>
<h3 id="树与图的存储">树与图的存储<a hidden class="anchor" aria-hidden="true" href="#树与图的存储">#</a></h3>
<p><strong>树是一种特殊的图: 无环连通图</strong>，与图的存储方式相同。
对于无向图中的边ab，存储两条有向边a-&gt;b, b-&gt;a。
因此我们可以只考虑有向图的存储。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c++" data-lang="c++"><span style="display:flex;"><span>(<span style="color:#ae81ff">1</span>) <span style="color:#960050;background-color:#1e0010">邻接矩阵：</span>g[a][b] <span style="color:#960050;background-color:#1e0010">存储边</span>a<span style="color:#f92672">-&gt;</span>b
</span></span><span style="display:flex;"><span>(<span style="color:#ae81ff">2</span>) <span style="color:#960050;background-color:#1e0010">邻接表：</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 对于每个点k，开一个单链表，存储k所有可以走到的点。h[k]存储这个单链表的头结点
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">int</span> h[N], e[N], ne[N], idx;
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 添加一条边a-&gt;b
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">add</span>(<span style="color:#66d9ef">int</span> a, <span style="color:#66d9ef">int</span> b)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    e[idx] <span style="color:#f92672">=</span> b, ne[idx] <span style="color:#f92672">=</span> h[a], h[a] <span style="color:#f92672">=</span> idx <span style="color:#f92672">++</span> ;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 初始化
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>idx <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>memset(h, <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>, <span style="color:#66d9ef">sizeof</span> h); 
</span></span></code></pre></div><h3 id="树与图的遍历">树与图的遍历<a hidden class="anchor" aria-hidden="true" href="#树与图的遍历">#</a></h3>
<p>时间复杂度 O(n+m)O(n+m), nn 表示点数，mm 表示边数</p>
<h4 id="1-深度优先遍历--模板题-acwing-846-树的重心">(1) 深度优先遍历 —— 模板题 AcWing 846. 树的重心<a hidden class="anchor" aria-hidden="true" href="#1-深度优先遍历--模板题-acwing-846-树的重心">#</a></h4>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c++" data-lang="c++"><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">dfs</span>(<span style="color:#66d9ef">int</span> u)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    st[u] <span style="color:#f92672">=</span> true; <span style="color:#75715e">// st[u] 表示点u已经被遍历过
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> h[u]; i <span style="color:#f92672">!=</span> <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>; i <span style="color:#f92672">=</span> ne[i])
</span></span><span style="display:flex;"><span>    {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">int</span> j <span style="color:#f92672">=</span> e[i];
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> (<span style="color:#f92672">!</span>st[j]) dfs(j);
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h4 id="2-宽度优先遍历--模板题-acwing-847-图中点的层次">(2) 宽度优先遍历 —— 模板题 AcWing 847. 图中点的层次<a hidden class="anchor" aria-hidden="true" href="#2-宽度优先遍历--模板题-acwing-847-图中点的层次">#</a></h4>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c++" data-lang="c++"><span style="display:flex;"><span>queue<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;</span> q;
</span></span><span style="display:flex;"><span>st[<span style="color:#ae81ff">1</span>] <span style="color:#f92672">=</span> true; <span style="color:#75715e">// 表示1号点已经被遍历过
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>q.push(<span style="color:#ae81ff">1</span>);
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">while</span> (q.size())
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> t <span style="color:#f92672">=</span> q.front();
</span></span><span style="display:flex;"><span>    q.pop();
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> h[t]; i <span style="color:#f92672">!=</span> <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>; i <span style="color:#f92672">=</span> ne[i])
</span></span><span style="display:flex;"><span>    {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">int</span> j <span style="color:#f92672">=</span> e[i];
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> (<span style="color:#f92672">!</span>st[j])
</span></span><span style="display:flex;"><span>        {
</span></span><span style="display:flex;"><span>            st[j] <span style="color:#f92672">=</span> true; <span style="color:#75715e">// 表示点j已经被遍历过
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>            q.push(j);
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h3 id="拓扑排序--模板题-acwing-848-有向图的拓扑序列">拓扑排序 —— 模板题 AcWing 848. 有向图的拓扑序列<a hidden class="anchor" aria-hidden="true" href="#拓扑排序--模板题-acwing-848-有向图的拓扑序列">#</a></h3>
<p>时间复杂度 O(n+m)O(n+m), nn 表示点数，mm 表示边数</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c++" data-lang="c++"><span style="display:flex;"><span><span style="color:#66d9ef">bool</span> <span style="color:#a6e22e">topsort</span>()
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> hh <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>, tt <span style="color:#f92672">=</span> <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// d[i] 存储点i的入度
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>; i <span style="color:#f92672">&lt;=</span> n; i <span style="color:#f92672">++</span> )
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> (<span style="color:#f92672">!</span>d[i])
</span></span><span style="display:flex;"><span>            q[ <span style="color:#f92672">++</span> tt] <span style="color:#f92672">=</span> i;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">while</span> (hh <span style="color:#f92672">&lt;=</span> tt)
</span></span><span style="display:flex;"><span>    {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">int</span> t <span style="color:#f92672">=</span> q[hh <span style="color:#f92672">++</span> ];
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> h[t]; i <span style="color:#f92672">!=</span> <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>; i <span style="color:#f92672">=</span> ne[i])
</span></span><span style="display:flex;"><span>        {
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">int</span> j <span style="color:#f92672">=</span> e[i];
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">if</span> (<span style="color:#f92672">--</span> d[j] <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span>)
</span></span><span style="display:flex;"><span>                q[ <span style="color:#f92672">++</span> tt] <span style="color:#f92672">=</span> j;
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// 如果所有点都入队了，说明存在拓扑序列；否则不存在拓扑序列。
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">return</span> tt <span style="color:#f92672">==</span> n <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h3 id="最短路">最短路<a hidden class="anchor" aria-hidden="true" href="#最短路">#</a></h3>
<p>单源最短路</p>
<p>所有边权均为正：朴素Dijkstra O(n^2)；堆优化版的Dijkstra(mlogn)</p>
<p>存在负权变：Bellman-Ford O(nm) ； SPFA（队列优化Bellman-Ford) 一般：O(m) 最坏 O(nm)</p>
<p>多元汇最短路：Floyed算法 O(n^3)</p>
<h3 id="朴素dijkstra算法--模板题-acwing-849-dijkstra求最短路-i-基于贪心">朴素dijkstra算法 —— 模板题 AcWing 849. Dijkstra求最短路 I 基于贪心<a hidden class="anchor" aria-hidden="true" href="#朴素dijkstra算法--模板题-acwing-849-dijkstra求最短路-i-基于贪心">#</a></h3>
<p>时间复杂是 O(n^2+m), n 表示点数，m 表示边数</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c++" data-lang="c++"><span style="display:flex;"><span><span style="color:#66d9ef">int</span> g[N][N];  <span style="color:#75715e">// 存储每条边，
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">int</span> dist[N];  <span style="color:#75715e">// 存储1号点到每个点的最短距离
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">bool</span> st[N];   <span style="color:#75715e">// 存储每个点的最短路是否已经确定
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">// 求1号点到n号点的最短路，如果不存在则返回-1
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">dijkstra</span>()
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    memset(dist, <span style="color:#ae81ff">0x3f</span>, <span style="color:#66d9ef">sizeof</span> dist);
</span></span><span style="display:flex;"><span>    dist[<span style="color:#ae81ff">1</span>] <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; i <span style="color:#f92672">&lt;</span> n <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>; i <span style="color:#f92672">++</span> )
</span></span><span style="display:flex;"><span>    {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">int</span> t <span style="color:#f92672">=</span> <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>;     <span style="color:#75715e">// 在还未确定最短路的点中，寻找距离最小的点
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> j <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>; j <span style="color:#f92672">&lt;=</span> n; j <span style="color:#f92672">++</span> )
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">if</span> (<span style="color:#f92672">!</span>st[j] <span style="color:#f92672">&amp;&amp;</span> (t <span style="color:#f92672">==</span> <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span> <span style="color:#f92672">||</span> dist[t] <span style="color:#f92672">&gt;</span> dist[j]))
</span></span><span style="display:flex;"><span>                t <span style="color:#f92672">=</span> j;
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// 用t更新其他点的距离
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> j <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>; j <span style="color:#f92672">&lt;=</span> n; j <span style="color:#f92672">++</span> )
</span></span><span style="display:flex;"><span>            dist[j] <span style="color:#f92672">=</span> min(dist[j], dist[t] <span style="color:#f92672">+</span> g[t][j]);
</span></span><span style="display:flex;"><span>        st[t] <span style="color:#f92672">=</span> true;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> (dist[n] <span style="color:#f92672">==</span> <span style="color:#ae81ff">0x3f3f3f3f</span>) <span style="color:#66d9ef">return</span> <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> dist[n];
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h3 id="堆优化版dijkstra--模板题-acwing-850-dijkstra求最短路-ii">堆优化版dijkstra —— 模板题 AcWing 850. Dijkstra求最短路 II<a hidden class="anchor" aria-hidden="true" href="#堆优化版dijkstra--模板题-acwing-850-dijkstra求最短路-ii">#</a></h3>
<p>时间复杂度 O(mlogn), n 表示点数，m 表示边数</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c++" data-lang="c++"><span style="display:flex;"><span><span style="color:#66d9ef">typedef</span> pair<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span>, <span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;</span> PII;
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> n;      <span style="color:#75715e">// 点的数量
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">int</span> h[N], w[N], e[N], ne[N], idx;       <span style="color:#75715e">// 邻接表存储所有边
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">int</span> dist[N];        <span style="color:#75715e">// 存储所有点到1号点的距离
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">bool</span> st[N];     <span style="color:#75715e">// 存储每个点的最短距离是否已确定
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">// 求1号点到n号点的最短距离，如果不存在，则返回-1
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">dijkstra</span>()
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    memset(dist, <span style="color:#ae81ff">0x3f</span>, <span style="color:#66d9ef">sizeof</span> dist);
</span></span><span style="display:flex;"><span>    dist[<span style="color:#ae81ff">1</span>] <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>    priority_queue<span style="color:#f92672">&lt;</span>PII, vector<span style="color:#f92672">&lt;</span>PII<span style="color:#f92672">&gt;</span>, greater<span style="color:#f92672">&lt;</span>PII<span style="color:#f92672">&gt;&gt;</span> heap;
</span></span><span style="display:flex;"><span>    heap.push({<span style="color:#ae81ff">0</span>, <span style="color:#ae81ff">1</span>});      <span style="color:#75715e">// first存储距离，second存储节点编号
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">while</span> (heap.size())
</span></span><span style="display:flex;"><span>    {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">auto</span> t <span style="color:#f92672">=</span> heap.top();
</span></span><span style="display:flex;"><span>        heap.pop();
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">int</span> ver <span style="color:#f92672">=</span> t.second, distance <span style="color:#f92672">=</span> t.first;
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> (st[ver]) <span style="color:#66d9ef">continue</span>;
</span></span><span style="display:flex;"><span>        st[ver] <span style="color:#f92672">=</span> true;
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> h[ver]; i <span style="color:#f92672">!=</span> <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>; i <span style="color:#f92672">=</span> ne[i])
</span></span><span style="display:flex;"><span>        {
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">int</span> j <span style="color:#f92672">=</span> e[i];
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">if</span> (dist[j] <span style="color:#f92672">&gt;</span> distance <span style="color:#f92672">+</span> w[i])
</span></span><span style="display:flex;"><span>            {
</span></span><span style="display:flex;"><span>                dist[j] <span style="color:#f92672">=</span> distance <span style="color:#f92672">+</span> w[i];
</span></span><span style="display:flex;"><span>                heap.push({dist[j], j});
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> (dist[n] <span style="color:#f92672">==</span> <span style="color:#ae81ff">0x3f3f3f3f</span>) <span style="color:#66d9ef">return</span> <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> dist[n];
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h3 id="bellman-ford算法--模板题-acwing-853-有边数限制的最短路">Bellman-Ford算法 —— 模板题 AcWing 853. 有边数限制的最短路<a hidden class="anchor" aria-hidden="true" href="#bellman-ford算法--模板题-acwing-853-有边数限制的最短路">#</a></h3>
<p>时间复杂度 O(nm), n 表示点数，m表示边数
注意在模板题中需要对下面的模板稍作修改，加上备份数组，详情见模板题。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c++" data-lang="c++"><span style="display:flex;"><span><span style="color:#66d9ef">int</span> n, m;       <span style="color:#75715e">// n表示点数，m表示边数
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">int</span> dist[N];        <span style="color:#75715e">// dist[x]存储1到x的最短路距离
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">Edge</span>     <span style="color:#75715e">// 边，a表示出点，b表示入点，w表示边的权重
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>{
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> a, b, w;
</span></span><span style="display:flex;"><span>}edges[M];
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 求1到n的最短路距离，如果无法从1走到n，则返回-1。
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">bellman_ford</span>()
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    memset(dist, <span style="color:#ae81ff">0x3f</span>, <span style="color:#66d9ef">sizeof</span> dist);
</span></span><span style="display:flex;"><span>    dist[<span style="color:#ae81ff">1</span>] <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// 如果第n次迭代仍然会松弛三角不等式，就说明存在一条长度是n+1的最短路径，由抽屉原理，路径中至少存在两个相同的点，说明图中存在负权回路。
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; i <span style="color:#f92672">&lt;</span> n; i <span style="color:#f92672">++</span> )
</span></span><span style="display:flex;"><span>    {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> j <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; j <span style="color:#f92672">&lt;</span> m; j <span style="color:#f92672">++</span> )
</span></span><span style="display:flex;"><span>        {
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">int</span> a <span style="color:#f92672">=</span> edges[j].a, b <span style="color:#f92672">=</span> edges[j].b, w <span style="color:#f92672">=</span> edges[j].w;
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">if</span> (dist[b] <span style="color:#f92672">&gt;</span> dist[a] <span style="color:#f92672">+</span> w)
</span></span><span style="display:flex;"><span>                dist[b] <span style="color:#f92672">=</span> dist[a] <span style="color:#f92672">+</span> w;
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> (dist[n] <span style="color:#f92672">&gt;</span> <span style="color:#ae81ff">0x3f3f3f3f</span> <span style="color:#f92672">/</span> <span style="color:#ae81ff">2</span>) <span style="color:#66d9ef">return</span> <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> dist[n];
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h3 id="spfa-算法队列优化的bellman-ford算法--模板题-acwing-851-spfa求最短路">spfa 算法（队列优化的Bellman-Ford算法） —— 模板题 AcWing 851. spfa求最短路<a hidden class="anchor" aria-hidden="true" href="#spfa-算法队列优化的bellman-ford算法--模板题-acwing-851-spfa求最短路">#</a></h3>
<p>时间复杂度 平均情况下 O(m)，最坏情况下 O(nm), n 表示点数，m 表示边数</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c++" data-lang="c++"><span style="display:flex;"><span><span style="color:#66d9ef">int</span> n;      <span style="color:#75715e">// 总点数
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">int</span> h[N], w[N], e[N], ne[N], idx;       <span style="color:#75715e">// 邻接表存储所有边
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">int</span> dist[N];        <span style="color:#75715e">// 存储每个点到1号点的最短距离
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">bool</span> st[N];     <span style="color:#75715e">// 存储每个点是否在队列中
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">// 求1号点到n号点的最短路距离，如果从1号点无法走到n号点则返回-1
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">spfa</span>()
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    memset(dist, <span style="color:#ae81ff">0x3f</span>, <span style="color:#66d9ef">sizeof</span> dist);
</span></span><span style="display:flex;"><span>    dist[<span style="color:#ae81ff">1</span>] <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>    queue<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;</span> q;
</span></span><span style="display:flex;"><span>    q.push(<span style="color:#ae81ff">1</span>);
</span></span><span style="display:flex;"><span>    st[<span style="color:#ae81ff">1</span>] <span style="color:#f92672">=</span> true;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">while</span> (q.size())
</span></span><span style="display:flex;"><span>    {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">auto</span> t <span style="color:#f92672">=</span> q.front();
</span></span><span style="display:flex;"><span>        q.pop(); st[t] <span style="color:#f92672">=</span> false;
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> h[t]; i <span style="color:#f92672">!=</span> <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>; i <span style="color:#f92672">=</span> ne[i])
</span></span><span style="display:flex;"><span>        {
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">int</span> j <span style="color:#f92672">=</span> e[i];
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">if</span> (dist[j] <span style="color:#f92672">&gt;</span> dist[t] <span style="color:#f92672">+</span> w[i])
</span></span><span style="display:flex;"><span>            {
</span></span><span style="display:flex;"><span>                dist[j] <span style="color:#f92672">=</span> dist[t] <span style="color:#f92672">+</span> w[i];
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">if</span> (<span style="color:#f92672">!</span>st[j])     <span style="color:#75715e">// 如果队列中已存在j，则不需要将j重复插入
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>                {
</span></span><span style="display:flex;"><span>                    q.push(j); st[j] <span style="color:#f92672">=</span> true;
</span></span><span style="display:flex;"><span>                }
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> (dist[n] <span style="color:#f92672">==</span> <span style="color:#ae81ff">0x3f3f3f3f</span>) <span style="color:#66d9ef">return</span> <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> dist[n];
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h3 id="spfa判断图中是否存在负环--模板题-acwing-852-spfa判断负环">spfa判断图中是否存在负环 —— 模板题 AcWing 852. spfa判断负环<a hidden class="anchor" aria-hidden="true" href="#spfa判断图中是否存在负环--模板题-acwing-852-spfa判断负环">#</a></h3>
<p>时间复杂度是 O(nm), n 表示点数，m 表示边数</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c++" data-lang="c++"><span style="display:flex;"><span><span style="color:#66d9ef">int</span> n;      <span style="color:#75715e">// 总点数
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">int</span> h[N], w[N], e[N], ne[N], idx;       <span style="color:#75715e">// 邻接表存储所有边
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">int</span> dist[N], cnt[N];        <span style="color:#75715e">// dist[x]存储1号点到x的最短距离，cnt[x]存储1到x的最短路中经过的点数
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">bool</span> st[N];     <span style="color:#75715e">// 存储每个点是否在队列中
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">// 如果存在负环，则返回true，否则返回false。
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">bool</span> <span style="color:#a6e22e">spfa</span>()
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// 不需要初始化dist数组
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#75715e">// 原理：如果某条最短路径上有n个点（除了自己），那么加上自己之后一共有n+1个点，由抽屉原理一定有两个点相同，所以存在环。
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    queue<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;</span> q;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>; i <span style="color:#f92672">&lt;=</span> n; i <span style="color:#f92672">++</span> )
</span></span><span style="display:flex;"><span>    {
</span></span><span style="display:flex;"><span>        q.push(i);
</span></span><span style="display:flex;"><span>        st[i] <span style="color:#f92672">=</span> true;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">while</span> (q.size())
</span></span><span style="display:flex;"><span>    {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">auto</span> t <span style="color:#f92672">=</span> q.front();
</span></span><span style="display:flex;"><span>        q.pop();
</span></span><span style="display:flex;"><span>        st[t] <span style="color:#f92672">=</span> false;
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> h[t]; i <span style="color:#f92672">!=</span> <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>; i <span style="color:#f92672">=</span> ne[i])
</span></span><span style="display:flex;"><span>        {
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">int</span> j <span style="color:#f92672">=</span> e[i];
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">if</span> (dist[j] <span style="color:#f92672">&gt;</span> dist[t] <span style="color:#f92672">+</span> w[i])
</span></span><span style="display:flex;"><span>            {
</span></span><span style="display:flex;"><span>                dist[j] <span style="color:#f92672">=</span> dist[t] <span style="color:#f92672">+</span> w[i];
</span></span><span style="display:flex;"><span>                cnt[j] <span style="color:#f92672">=</span> cnt[t] <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">if</span> (cnt[j] <span style="color:#f92672">&gt;=</span> n) <span style="color:#66d9ef">return</span> true;       <span style="color:#75715e">// 如果从1号点到x的最短路中包含至少n个点（不包括自己），则说明存在环
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>                <span style="color:#66d9ef">if</span> (<span style="color:#f92672">!</span>st[j])
</span></span><span style="display:flex;"><span>                {
</span></span><span style="display:flex;"><span>                    q.push(j);
</span></span><span style="display:flex;"><span>                    st[j] <span style="color:#f92672">=</span> true;
</span></span><span style="display:flex;"><span>                }
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> false;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h3 id="floyd算法--模板题-acwing-854-floyd求最短路">floyd算法 —— 模板题 AcWing 854. Floyd求最短路<a hidden class="anchor" aria-hidden="true" href="#floyd算法--模板题-acwing-854-floyd求最短路">#</a></h3>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c++" data-lang="c++"><span style="display:flex;"><span><span style="color:#960050;background-color:#1e0010">时间复杂度是</span> <span style="color:#a6e22e">O</span>(n3)O(n3), nn <span style="color:#960050;background-color:#1e0010">表示点数</span>
</span></span><span style="display:flex;"><span><span style="color:#960050;background-color:#1e0010">初始化：</span> 
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>; i <span style="color:#f92672">&lt;=</span> n; i <span style="color:#f92672">++</span> )
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> j <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>; j <span style="color:#f92672">&lt;=</span> n; j <span style="color:#f92672">++</span> )
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">if</span> (i <span style="color:#f92672">==</span> j) d[i][j] <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">else</span> d[i][j] <span style="color:#f92672">=</span> INF;
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 算法结束后，d[a][b]表示a到b的最短距离
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">floyd</span>()
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> k <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>; k <span style="color:#f92672">&lt;=</span> n; k <span style="color:#f92672">++</span> )
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>; i <span style="color:#f92672">&lt;=</span> n; i <span style="color:#f92672">++</span> )
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> j <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>; j <span style="color:#f92672">&lt;=</span> n; j <span style="color:#f92672">++</span> )
</span></span><span style="display:flex;"><span>                d[i][j] <span style="color:#f92672">=</span> min(d[i][j], d[i][k] <span style="color:#f92672">+</span> d[k][j]);
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h3 id="最小生成树无向图">最小生成树（无向图）<a hidden class="anchor" aria-hidden="true" href="#最小生成树无向图">#</a></h3>
<p>Prim : 朴素版Prim O(n^2)(稠密图) ; 堆优化版Prim O(mlogn)(一般不会用)</p>
<p>Kruskal  : O(mlogm)(稀疏图)</p>
<h3 id="朴素版prim算法--模板题-acwing-858-prim算法求最小生成树">朴素版prim算法 —— 模板题 AcWing 858. Prim算法求最小生成树<a hidden class="anchor" aria-hidden="true" href="#朴素版prim算法--模板题-acwing-858-prim算法求最小生成树">#</a></h3>
<p>时间复杂度是 O(n^2+m), n 表示点数，m 表示边数</p>
<p>初始化距离为正无穷，迭代所有点，找到集合中最近的点，更新它到<strong>集合</strong>的距离，把t加到集合中。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c++" data-lang="c++"><span style="display:flex;"><span><span style="color:#66d9ef">int</span> n;      <span style="color:#75715e">// n表示点数
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">int</span> g[N][N];        <span style="color:#75715e">// 邻接矩阵，存储所有边
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">int</span> dist[N];        <span style="color:#75715e">// 存储其他点到当前最小生成树的距离
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">bool</span> st[N];     <span style="color:#75715e">// 存储每个点是否已经在生成树中
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">// 如果图不连通，则返回INF(值是0x3f3f3f3f), 否则返回最小生成树的树边权重之和
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">prim</span>()
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    memset(dist, <span style="color:#ae81ff">0x3f</span>, <span style="color:#66d9ef">sizeof</span> dist);
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> res <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; i <span style="color:#f92672">&lt;</span> n; i <span style="color:#f92672">++</span> )
</span></span><span style="display:flex;"><span>    {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">int</span> t <span style="color:#f92672">=</span> <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> j <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>; j <span style="color:#f92672">&lt;=</span> n; j <span style="color:#f92672">++</span> )
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">if</span> (<span style="color:#f92672">!</span>st[j] <span style="color:#f92672">&amp;&amp;</span> (t <span style="color:#f92672">==</span> <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span> <span style="color:#f92672">||</span> dist[t] <span style="color:#f92672">&gt;</span> dist[j]))
</span></span><span style="display:flex;"><span>                t <span style="color:#f92672">=</span> j;
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> (i <span style="color:#f92672">&amp;&amp;</span> dist[t] <span style="color:#f92672">==</span> INF) <span style="color:#66d9ef">return</span> INF;
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> (i) res <span style="color:#f92672">+=</span> dist[t];
</span></span><span style="display:flex;"><span>        st[t] <span style="color:#f92672">=</span> true;
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> j <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>; j <span style="color:#f92672">&lt;=</span> n; j <span style="color:#f92672">++</span> ) dist[j] <span style="color:#f92672">=</span> min(dist[j], g[t][j]);
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> res;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h3 id="kruskal算法--模板题-acwing-859-kruskal算法求最小生成树">Kruskal算法 —— 模板题 AcWing 859. Kruskal算法求最小生成树<a hidden class="anchor" aria-hidden="true" href="#kruskal算法--模板题-acwing-859-kruskal算法求最小生成树">#</a></h3>
<p>时间复杂度是 O(mlogm), n 表示点数，m 表示边数</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c++" data-lang="c++"><span style="display:flex;"><span><span style="color:#66d9ef">int</span> n, m;       <span style="color:#75715e">// n是点数，m是边数
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">int</span> p[N];       <span style="color:#75715e">// 并查集的父节点数组
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">Edge</span>     <span style="color:#75715e">// 存储边
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>{
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> a, b, w;
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// 重载小于号运算符
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#75715e">// 用于比较两个Edge对象的大小关系
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">bool</span> <span style="color:#66d9ef">operator</span> <span style="color:#f92672">&lt;</span> (<span style="color:#66d9ef">const</span> Edge <span style="color:#f92672">&amp;</span>W) <span style="color:#66d9ef">const</span>
</span></span><span style="display:flex;"><span>    {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> w <span style="color:#f92672">&lt;</span> W.w; <span style="color:#75715e">// 如果当前对象的边权小于W对象的边权，返回true，否则返回false
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    }
</span></span><span style="display:flex;"><span>}edges[M];
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">find</span>(<span style="color:#66d9ef">int</span> x)     <span style="color:#75715e">// 并查集核心操作
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>{
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> (p[x] <span style="color:#f92672">!=</span> x) p[x] <span style="color:#f92672">=</span> find(p[x]);
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> p[x];
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">kruskal</span>()
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    sort(edges, edges <span style="color:#f92672">+</span> m);
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>; i <span style="color:#f92672">&lt;=</span> n; i <span style="color:#f92672">++</span> ) p[i] <span style="color:#f92672">=</span> i;    <span style="color:#75715e">// 初始化并查集
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">int</span> res <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>, cnt <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; i <span style="color:#f92672">&lt;</span> m; i <span style="color:#f92672">++</span> )
</span></span><span style="display:flex;"><span>    {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">int</span> a <span style="color:#f92672">=</span> edges[i].a, b <span style="color:#f92672">=</span> edges[i].b, w <span style="color:#f92672">=</span> edges[i].w;
</span></span><span style="display:flex;"><span>        a <span style="color:#f92672">=</span> find(a), b <span style="color:#f92672">=</span> find(b);
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> (a <span style="color:#f92672">!=</span> b)     <span style="color:#75715e">// 如果两个连通块不连通，则将这两个连通块合并
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        {
</span></span><span style="display:flex;"><span>            p[a] <span style="color:#f92672">=</span> b;
</span></span><span style="display:flex;"><span>            res <span style="color:#f92672">+=</span> w;
</span></span><span style="display:flex;"><span>            cnt <span style="color:#f92672">++</span> ;
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> (cnt <span style="color:#f92672">&lt;</span> n <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>) <span style="color:#66d9ef">return</span> INF;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> res;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h3 id="染色法本质dfs判别二分图--模板题-acwing-860-染色法判定二分图">染色法（本质dfs)判别二分图 —— 模板题 AcWing 860. 染色法判定二分图<a hidden class="anchor" aria-hidden="true" href="#染色法本质dfs判别二分图--模板题-acwing-860-染色法判定二分图">#</a></h3>
<p><strong>给定一个 n 个点m条边的无向图，图中可能存在重边和自环。请你判断这个图是否是二分图。</strong></p>
<p>时间复杂度是 O(n+m), n 表示点数，m 表示边数</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c++" data-lang="c++"><span style="display:flex;"><span><span style="color:#66d9ef">int</span> n;      <span style="color:#75715e">// n表示点数
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">int</span> h[N], e[M], ne[M], idx;     <span style="color:#75715e">// 邻接表存储图
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">int</span> color[N];       <span style="color:#75715e">// 表示每个点的颜色，-1表示为染色，0表示白色，1表示黑色
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">// 参数：u表示当前节点，c表示当前点的颜色
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">bool</span> <span style="color:#a6e22e">dfs</span>(<span style="color:#66d9ef">int</span> u, <span style="color:#66d9ef">int</span> c)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    color[u] <span style="color:#f92672">=</span> c;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> h[u]; i <span style="color:#f92672">!=</span> <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>; i <span style="color:#f92672">=</span> ne[i])
</span></span><span style="display:flex;"><span>    {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">int</span> j <span style="color:#f92672">=</span> e[i];
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> (color[j] <span style="color:#f92672">==</span> <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>)
</span></span><span style="display:flex;"><span>        {
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">if</span> (<span style="color:#f92672">!</span>dfs(j, <span style="color:#f92672">!</span>c)) <span style="color:#66d9ef">return</span> false;
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">else</span> <span style="color:#66d9ef">if</span> (color[j] <span style="color:#f92672">==</span> c) <span style="color:#66d9ef">return</span> false;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> true;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">bool</span> <span style="color:#a6e22e">check</span>()
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    memset(color, <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>, <span style="color:#66d9ef">sizeof</span> color);
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">bool</span> flag <span style="color:#f92672">=</span> true;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>; i <span style="color:#f92672">&lt;=</span> n; i <span style="color:#f92672">++</span> )
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> (color[i] <span style="color:#f92672">==</span> <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>)
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">if</span> (<span style="color:#f92672">!</span>dfs(i, <span style="color:#ae81ff">0</span>))
</span></span><span style="display:flex;"><span>            {
</span></span><span style="display:flex;"><span>                flag <span style="color:#f92672">=</span> false;
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">break</span>;
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> flag;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h3 id="匈牙利算法--模板题-acwing-861-二分图的最大匹配">匈牙利算法 —— 模板题 AcWing 861. 二分图的最大匹配<a hidden class="anchor" aria-hidden="true" href="#匈牙利算法--模板题-acwing-861-二分图的最大匹配">#</a></h3>
<p>时间复杂度最坏是 O(nm)，实际运行时间一般远小于O(nm)， n 表示点数，m 表示边数</p>
<p>做错一件事，错过一件事</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c++" data-lang="c++"><span style="display:flex;"><span><span style="color:#66d9ef">int</span> n1, n2;     <span style="color:#75715e">// n1表示第一个集合中的点数，n2表示第二个集合中的点数
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">int</span> h[N], e[M], ne[M], idx;     <span style="color:#75715e">// 邻接表存储所有边，匈牙利算法中只会用到从第二个集合指向第一个集合的边，所以这里只用存一个方向的边
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">int</span> match[N];       <span style="color:#75715e">// 存储第二个集合中的每个点当前匹配的第一个集合中的点是哪个
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">bool</span> st[N];     <span style="color:#75715e">// 表示第二个集合中的每个点是否已经被遍历过
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">bool</span> <span style="color:#a6e22e">find</span>(<span style="color:#66d9ef">int</span> x)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> h[x]; i <span style="color:#f92672">!=</span> <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>; i <span style="color:#f92672">=</span> ne[i])
</span></span><span style="display:flex;"><span>    {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">int</span> j <span style="color:#f92672">=</span> e[i];
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> (<span style="color:#f92672">!</span>st[j])
</span></span><span style="display:flex;"><span>        {
</span></span><span style="display:flex;"><span>            st[j] <span style="color:#f92672">=</span> true;
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">if</span> (match[j] <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span> <span style="color:#f92672">||</span> find(match[j]))
</span></span><span style="display:flex;"><span>            {
</span></span><span style="display:flex;"><span>                match[j] <span style="color:#f92672">=</span> x;
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">return</span> true;
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> false;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 求最大匹配数，依次枚举第一个集合中的每个点能否匹配第二个集合中的点
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">int</span> res <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>; i <span style="color:#f92672">&lt;=</span> n1; i <span style="color:#f92672">++</span> )
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    memset(st, false, <span style="color:#66d9ef">sizeof</span> st);
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> (find(i)) res <span style="color:#f92672">++</span> ;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>作者：yxc
链接：https://www.acwing.com/blog/content/405/
来源：AcWing
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p>
<h2 id="第四章">第四章<a hidden class="anchor" aria-hidden="true" href="#第四章">#</a></h2>
<h3 id="试除法判定质数--模板题-acwing-866-试除法判定质数">试除法判定质数 —— 模板题 AcWing 866. 试除法判定质数<a hidden class="anchor" aria-hidden="true" href="#试除法判定质数--模板题-acwing-866-试除法判定质数">#</a></h3>
<p>质数：大于1的整数中，如果只包含1和本身两个约束，称为质数（素数）</p>
<p>（1）判定，试除法</p>
<p>（2）分解质因数</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c++" data-lang="c++"><span style="display:flex;"><span><span style="color:#66d9ef">bool</span> <span style="color:#a6e22e">is_prime</span>(<span style="color:#66d9ef">int</span> x)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> (x <span style="color:#f92672">&lt;</span> <span style="color:#ae81ff">2</span>) <span style="color:#66d9ef">return</span> false;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">2</span>; i <span style="color:#f92672">&lt;=</span> x <span style="color:#f92672">/</span> i; i <span style="color:#f92672">++</span> )
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> (x <span style="color:#f92672">%</span> i <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span>)
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">return</span> false;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> true;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h3 id="试除法分解质因数--模板题-acwing-867-分解质因数">试除法分解质因数 —— 模板题 AcWing 867. 分解质因数<a hidden class="anchor" aria-hidden="true" href="#试除法分解质因数--模板题-acwing-867-分解质因数">#</a></h3>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c++" data-lang="c++"><span style="display:flex;"><span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">divide</span>(<span style="color:#66d9ef">int</span> x)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">2</span>; i <span style="color:#f92672">&lt;=</span> x <span style="color:#f92672">/</span> i; i <span style="color:#f92672">++</span> )
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> (x <span style="color:#f92672">%</span> i <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span>)
</span></span><span style="display:flex;"><span>        {
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">int</span> s <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">while</span> (x <span style="color:#f92672">%</span> i <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span>) x <span style="color:#f92672">/=</span> i, s <span style="color:#f92672">++</span> ;
</span></span><span style="display:flex;"><span>            cout <span style="color:#f92672">&lt;&lt;</span> i <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#39; &#39;</span> <span style="color:#f92672">&lt;&lt;</span> s <span style="color:#f92672">&lt;&lt;</span> endl;
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> (x <span style="color:#f92672">&gt;</span> <span style="color:#ae81ff">1</span>) cout <span style="color:#f92672">&lt;&lt;</span> x <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#39; &#39;</span> <span style="color:#f92672">&lt;&lt;</span> <span style="color:#ae81ff">1</span> <span style="color:#f92672">&lt;&lt;</span> endl;
</span></span><span style="display:flex;"><span>    cout <span style="color:#f92672">&lt;&lt;</span> endl;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h3 id="朴素筛法求素数--模板题-acwing-868-筛质数">朴素筛法求素数 —— 模板题 AcWing 868. 筛质数<a hidden class="anchor" aria-hidden="true" href="#朴素筛法求素数--模板题-acwing-868-筛质数">#</a></h3>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c++" data-lang="c++"><span style="display:flex;"><span><span style="color:#66d9ef">int</span> primes[N], cnt;     <span style="color:#75715e">// primes[]存储所有素数
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">bool</span> st[N];         <span style="color:#75715e">// st[x]存储x是否被筛掉
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">get_primes</span>(<span style="color:#66d9ef">int</span> n)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">2</span>; i <span style="color:#f92672">&lt;=</span> n; i <span style="color:#f92672">++</span> )
</span></span><span style="display:flex;"><span>    {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> (st[i]) <span style="color:#66d9ef">continue</span>;
</span></span><span style="display:flex;"><span>        primes[cnt <span style="color:#f92672">++</span> ] <span style="color:#f92672">=</span> i;
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> j <span style="color:#f92672">=</span> i; j <span style="color:#f92672">&lt;=</span> n; j <span style="color:#f92672">+=</span> i)
</span></span><span style="display:flex;"><span>            st[j] <span style="color:#f92672">=</span> true;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h3 id="线性筛法求素数--模板题-acwing-868-筛质数">线性筛法求素数 —— 模板题 AcWing 868. 筛质数<a hidden class="anchor" aria-hidden="true" href="#线性筛法求素数--模板题-acwing-868-筛质数">#</a></h3>
<p>被最小质因子筛掉</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c++" data-lang="c++"><span style="display:flex;"><span><span style="color:#66d9ef">int</span> primes[N], cnt;     <span style="color:#75715e">// primes[]存储所有素数
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">bool</span> st[N];         <span style="color:#75715e">// st[x]存储x是否被筛掉
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">get_primes</span>(<span style="color:#66d9ef">int</span> n)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">2</span>; i <span style="color:#f92672">&lt;=</span> n; i <span style="color:#f92672">++</span> )
</span></span><span style="display:flex;"><span>    {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> (<span style="color:#f92672">!</span>st[i]) primes[cnt <span style="color:#f92672">++</span> ] <span style="color:#f92672">=</span> i;
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> j <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; primes[j] <span style="color:#f92672">&lt;=</span> n <span style="color:#f92672">/</span> i; j <span style="color:#f92672">++</span> )
</span></span><span style="display:flex;"><span>        {
</span></span><span style="display:flex;"><span>            st[primes[j] <span style="color:#f92672">*</span> i] <span style="color:#f92672">=</span> true;
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">if</span> (i <span style="color:#f92672">%</span> primes[j] <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span>) <span style="color:#66d9ef">break</span>;
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h3 id="试除法求所有约数--模板题-acwing-869-试除法求约数">试除法求所有约数 —— 模板题 AcWing 869. 试除法求约数<a hidden class="anchor" aria-hidden="true" href="#试除法求所有约数--模板题-acwing-869-试除法求约数">#</a></h3>
<p>int范围内约数个数最多为1500个左右</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c++" data-lang="c++"><span style="display:flex;"><span>vector<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;</span> get_divisors(<span style="color:#66d9ef">int</span> x)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    vector<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;</span> res;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>; i <span style="color:#f92672">&lt;=</span> x <span style="color:#f92672">/</span> i; i <span style="color:#f92672">++</span> )
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> (x <span style="color:#f92672">%</span> i <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span>)
</span></span><span style="display:flex;"><span>        {
</span></span><span style="display:flex;"><span>            res.push_back(i);
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">if</span> (i <span style="color:#f92672">!=</span> x <span style="color:#f92672">/</span> i) res.push_back(x <span style="color:#f92672">/</span> i);
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    sort(res.begin(), res.end());
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> res;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h3 id="约数个数和约数之和--模板题-acwing-870-约数个数-acwing-871-约数之和">约数个数和约数之和 —— 模板题 AcWing 870. 约数个数, AcWing 871. 约数之和<a hidden class="anchor" aria-hidden="true" href="#约数个数和约数之和--模板题-acwing-870-约数个数-acwing-871-约数之和">#</a></h3>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c++" data-lang="c++"><span style="display:flex;"><span><span style="color:#960050;background-color:#1e0010">如果</span> N <span style="color:#f92672">=</span> p1<span style="color:#f92672">^</span>c1 <span style="color:#f92672">*</span> p2<span style="color:#f92672">^</span>c2 <span style="color:#f92672">*</span> ... <span style="color:#f92672">*</span>pk<span style="color:#f92672">^</span>ck
</span></span><span style="display:flex;"><span><span style="color:#960050;background-color:#1e0010">约数个数：</span> (c1 <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>) <span style="color:#f92672">*</span> (c2 <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>) <span style="color:#f92672">*</span> ... <span style="color:#f92672">*</span> (ck <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>)
</span></span><span style="display:flex;"><span><span style="color:#960050;background-color:#1e0010">约数之和：</span> (p1<span style="color:#f92672">^</span><span style="color:#ae81ff">0</span> <span style="color:#f92672">+</span> p1<span style="color:#f92672">^</span><span style="color:#ae81ff">1</span> <span style="color:#f92672">+</span> ... <span style="color:#f92672">+</span> p1<span style="color:#f92672">^</span>c1) <span style="color:#f92672">*</span> ... <span style="color:#f92672">*</span> (pk<span style="color:#f92672">^</span><span style="color:#ae81ff">0</span> <span style="color:#f92672">+</span> pk<span style="color:#f92672">^</span><span style="color:#ae81ff">1</span> <span style="color:#f92672">+</span> ... <span style="color:#f92672">+</span> pk<span style="color:#f92672">^</span>ck)
</span></span></code></pre></div><h3 id="欧几里得算法--模板题-acwing-872-最大公约数">欧几里得算法 —— 模板题 AcWing 872. 最大公约数<a hidden class="anchor" aria-hidden="true" href="#欧几里得算法--模板题-acwing-872-最大公约数">#</a></h3>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c++" data-lang="c++"><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">gcd</span>(<span style="color:#66d9ef">int</span> a, <span style="color:#66d9ef">int</span> b)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> b <span style="color:#f92672">?</span> gcd(b, a <span style="color:#f92672">%</span> b) <span style="color:#f92672">:</span> a;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h3 id="求欧拉函数--模板题-acwing-873-欧拉函数">求欧拉函数 —— 模板题 AcWing 873. 欧拉函数<a hidden class="anchor" aria-hidden="true" href="#求欧拉函数--模板题-acwing-873-欧拉函数">#</a></h3>
<p>欧拉函数公式（容斥原理) : n*(1-p1)*(1-p2)&hellip;(1-pk)</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c++" data-lang="c++"><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">phi</span>(<span style="color:#66d9ef">int</span> x)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> res <span style="color:#f92672">=</span> x;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">2</span>; i <span style="color:#f92672">&lt;=</span> x <span style="color:#f92672">/</span> i; i <span style="color:#f92672">++</span> )
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> (x <span style="color:#f92672">%</span> i <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span>)
</span></span><span style="display:flex;"><span>        {
</span></span><span style="display:flex;"><span>            res <span style="color:#f92672">=</span> res <span style="color:#f92672">/</span> i <span style="color:#f92672">*</span> (i <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>);
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">while</span> (x <span style="color:#f92672">%</span> i <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span>) x <span style="color:#f92672">/=</span> i;
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> (x <span style="color:#f92672">&gt;</span> <span style="color:#ae81ff">1</span>) res <span style="color:#f92672">=</span> res <span style="color:#f92672">/</span> x <span style="color:#f92672">*</span> (x <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>);
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> res;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h3 id="筛法求欧拉函数--模板题-acwing-874-筛法求欧拉函数">筛法求欧拉函数 —— 模板题 AcWing 874. 筛法求欧拉函数<a hidden class="anchor" aria-hidden="true" href="#筛法求欧拉函数--模板题-acwing-874-筛法求欧拉函数">#</a></h3>
<p>O(n) 线性求所有数的欧拉函数</p>
<p>应用：欧拉定理：a与n互质   a^φ(n)=1(mod n)</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c++" data-lang="c++"><span style="display:flex;"><span><span style="color:#66d9ef">int</span> primes[N], cnt;     <span style="color:#75715e">// primes[]存储所有素数
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">int</span> euler[N];           <span style="color:#75715e">// 存储每个数的欧拉函数
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">bool</span> st[N];         <span style="color:#75715e">// st[x]存储x是否被筛掉
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">get_eulers</span>(<span style="color:#66d9ef">int</span> n)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    euler[<span style="color:#ae81ff">1</span>] <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">2</span>; i <span style="color:#f92672">&lt;=</span> n; i <span style="color:#f92672">++</span> )
</span></span><span style="display:flex;"><span>    {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> (<span style="color:#f92672">!</span>st[i])
</span></span><span style="display:flex;"><span>        {
</span></span><span style="display:flex;"><span>            primes[cnt <span style="color:#f92672">++</span> ] <span style="color:#f92672">=</span> i;
</span></span><span style="display:flex;"><span>            euler[i] <span style="color:#f92672">=</span> i <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> j <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; primes[j] <span style="color:#f92672">&lt;=</span> n <span style="color:#f92672">/</span> i; j <span style="color:#f92672">++</span> )
</span></span><span style="display:flex;"><span>        {
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">int</span> t <span style="color:#f92672">=</span> primes[j] <span style="color:#f92672">*</span> i;
</span></span><span style="display:flex;"><span>            st[t] <span style="color:#f92672">=</span> true;
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">if</span> (i <span style="color:#f92672">%</span> primes[j] <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span>)
</span></span><span style="display:flex;"><span>            {
</span></span><span style="display:flex;"><span>                euler[t] <span style="color:#f92672">=</span> euler[i] <span style="color:#f92672">*</span> primes[j];
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">break</span>;
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>            euler[t] <span style="color:#f92672">=</span> euler[i] <span style="color:#f92672">*</span> (primes[j] <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>);
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h3 id="快速幂--模板题-acwing-875-快速幂">快速幂 —— 模板题 AcWing 875. 快速幂<a hidden class="anchor" aria-hidden="true" href="#快速幂--模板题-acwing-875-快速幂">#</a></h3>
<p>求 m^k mod p，时间复杂度 O(logk)。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c++" data-lang="c++"><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">qmi</span>(<span style="color:#66d9ef">int</span> m, <span style="color:#66d9ef">int</span> k, <span style="color:#66d9ef">int</span> p)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> res <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span> <span style="color:#f92672">%</span> p, t <span style="color:#f92672">=</span> m;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">while</span> (k)
</span></span><span style="display:flex;"><span>    {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> (k<span style="color:#f92672">&amp;</span><span style="color:#ae81ff">1</span>) res <span style="color:#f92672">=</span> res <span style="color:#f92672">*</span> t <span style="color:#f92672">%</span> p;
</span></span><span style="display:flex;"><span>        t <span style="color:#f92672">=</span> t <span style="color:#f92672">*</span> t <span style="color:#f92672">%</span> p;
</span></span><span style="display:flex;"><span>        k <span style="color:#f92672">&gt;&gt;=</span> <span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> res;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h3 id="扩展欧几里得算法--模板题-acwing-877-扩展欧几里得算法">扩展欧几里得算法 —— 模板题 AcWing 877. 扩展欧几里得算法<a hidden class="anchor" aria-hidden="true" href="#扩展欧几里得算法--模板题-acwing-877-扩展欧几里得算法">#</a></h3>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c++" data-lang="c++"><span style="display:flex;"><span><span style="color:#75715e">// 求x, y，使得ax + by = gcd(a, b)
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">exgcd</span>(<span style="color:#66d9ef">int</span> a, <span style="color:#66d9ef">int</span> b, <span style="color:#66d9ef">int</span> <span style="color:#f92672">&amp;</span>x, <span style="color:#66d9ef">int</span> <span style="color:#f92672">&amp;</span>y)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> (<span style="color:#f92672">!</span>b)
</span></span><span style="display:flex;"><span>    {
</span></span><span style="display:flex;"><span>        x <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>; y <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> a;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> d <span style="color:#f92672">=</span> exgcd(b, a <span style="color:#f92672">%</span> b, y, x);
</span></span><span style="display:flex;"><span>    y <span style="color:#f92672">-=</span> (a<span style="color:#f92672">/</span>b) <span style="color:#f92672">*</span> x;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> d;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h3 id="高斯消元--模板题-acwing-883-高斯消元解线性方程组">高斯消元 —— 模板题 AcWing 883. 高斯消元解线性方程组<a hidden class="anchor" aria-hidden="true" href="#高斯消元--模板题-acwing-883-高斯消元解线性方程组">#</a></h3>
<p>O(n^3)时间内解n个方程n个未知数的解。</p>
<p>解：无解 ； 无穷多组解 ； 唯一解 ；</p>
<ul>
<li>完美阶梯型：唯一解</li>
<li>*0=*非零 ： *<em>无解</em></li>
<li>0=0 ： 无穷多组解</li>
</ul>
<p>高斯消元：</p>
<p>枚举每一列c：</p>
<ol>
<li>找到绝对值最大的一行</li>
<li>将该行换到最上面</li>
<li>将该行第一个数变成1</li>
<li>将下面所有行的第c列消成0</li>
</ol>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c++" data-lang="c++"><span style="display:flex;"><span><span style="color:#75715e">// a[N][N]是增广矩阵
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">gauss</span>()
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> c, r;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span> (c <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>, r <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; c <span style="color:#f92672">&lt;</span> n; c <span style="color:#f92672">++</span> )
</span></span><span style="display:flex;"><span>    {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">int</span> t <span style="color:#f92672">=</span> r;
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> r; i <span style="color:#f92672">&lt;</span> n; i <span style="color:#f92672">++</span> )   <span style="color:#75715e">// 找到绝对值最大的行
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>            <span style="color:#66d9ef">if</span> (fabs(a[i][c]) <span style="color:#f92672">&gt;</span> fabs(a[t][c]))
</span></span><span style="display:flex;"><span>                t <span style="color:#f92672">=</span> i;
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> (fabs(a[t][c]) <span style="color:#f92672">&lt;</span> eps) <span style="color:#66d9ef">continue</span>;
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> c; i <span style="color:#f92672">&lt;=</span> n; i <span style="color:#f92672">++</span> ) swap(a[t][i], a[r][i]);      <span style="color:#75715e">// 将绝对值最大的行换到最顶端
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> n; i <span style="color:#f92672">&gt;=</span> c; i <span style="color:#f92672">--</span> ) a[r][i] <span style="color:#f92672">/=</span> a[r][c];      <span style="color:#75715e">// 将当前上的首位变成1
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> r <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>; i <span style="color:#f92672">&lt;</span> n; i <span style="color:#f92672">++</span> )       <span style="color:#75715e">// 用当前行将下面所有的列消成0
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>            <span style="color:#66d9ef">if</span> (fabs(a[i][c]) <span style="color:#f92672">&gt;</span> eps)
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> j <span style="color:#f92672">=</span> n; j <span style="color:#f92672">&gt;=</span> c; j <span style="color:#f92672">--</span> )
</span></span><span style="display:flex;"><span>                    a[i][j] <span style="color:#f92672">-=</span> a[r][j] <span style="color:#f92672">*</span> a[i][c];
</span></span><span style="display:flex;"><span>        r <span style="color:#f92672">++</span> ;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> (r <span style="color:#f92672">&lt;</span> n)
</span></span><span style="display:flex;"><span>    {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> r; i <span style="color:#f92672">&lt;</span> n; i <span style="color:#f92672">++</span> )
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">if</span> (fabs(a[i][n]) <span style="color:#f92672">&gt;</span> eps)
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">2</span>; <span style="color:#75715e">// 无解
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">1</span>; <span style="color:#75715e">// 有无穷多组解
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> n <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>; i <span style="color:#f92672">&gt;=</span> <span style="color:#ae81ff">0</span>; i <span style="color:#f92672">--</span> )
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> j <span style="color:#f92672">=</span> i <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>; j <span style="color:#f92672">&lt;</span> n; j <span style="color:#f92672">++</span> )
</span></span><span style="display:flex;"><span>            a[i][n] <span style="color:#f92672">-=</span> a[i][j] <span style="color:#f92672">*</span> a[j][n];
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>; <span style="color:#75715e">// 有唯一解
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>}
</span></span></code></pre></div><h3 id="递归法求组合数--模板题-acwing-885-求组合数-i">递归法求组合数 —— 模板题 <em>AcWing</em> 885. 求组合数 I<a hidden class="anchor" aria-hidden="true" href="#递归法求组合数--模板题-acwing-885-求组合数-i">#</a></h3>
<p>十万 1&lt;b&lt;a&lt;2000 O(n^2)</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c++" data-lang="c++"><span style="display:flex;"><span><span style="color:#75715e">// c[a][b] 表示从a个苹果中选b个的方案数
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; i <span style="color:#f92672">&lt;</span> N; i <span style="color:#f92672">++</span> )
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> j <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; j <span style="color:#f92672">&lt;=</span> i; j <span style="color:#f92672">++</span> )
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> (<span style="color:#f92672">!</span>j) c[i][j] <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">else</span> c[i][j] <span style="color:#f92672">=</span> (c[i <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>][j] <span style="color:#f92672">+</span> c[i <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>][j <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>]) <span style="color:#f92672">%</span> mod;
</span></span></code></pre></div><h3 id="通过预处理逆元的方式求组合数--模板题-acwing-886-求组合数-ii">通过预处理逆元的方式求组合数 —— 模板题 AcWing 886. 求组合数 II<a hidden class="anchor" aria-hidden="true" href="#通过预处理逆元的方式求组合数--模板题-acwing-886-求组合数-ii">#</a></h3>
<p>一万 1&lt;b&lt;a&lt;10^5 O(logn)</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c++" data-lang="c++"><span style="display:flex;"><span><span style="color:#960050;background-color:#1e0010">首先预处理出所有阶乘取模的余数</span>fact[N]<span style="color:#960050;background-color:#1e0010">，以及所有阶乘取模的逆元</span>infact[N]
</span></span><span style="display:flex;"><span><span style="color:#960050;background-color:#1e0010">如果取模的数是质数，可以用费马小定理求逆元</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> qmi(<span style="color:#66d9ef">int</span> a, <span style="color:#66d9ef">int</span> k, <span style="color:#66d9ef">int</span> p)    <span style="color:#75715e">// 快速幂模板
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>{
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> res <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">while</span> (k)
</span></span><span style="display:flex;"><span>    {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> (k <span style="color:#f92672">&amp;</span> <span style="color:#ae81ff">1</span>) res <span style="color:#f92672">=</span> (LL)res <span style="color:#f92672">*</span> a <span style="color:#f92672">%</span> p;
</span></span><span style="display:flex;"><span>        a <span style="color:#f92672">=</span> (LL)a <span style="color:#f92672">*</span> a <span style="color:#f92672">%</span> p;
</span></span><span style="display:flex;"><span>        k <span style="color:#f92672">&gt;&gt;=</span> <span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> res;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 预处理阶乘的余数和阶乘逆元的余数
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>fact[<span style="color:#ae81ff">0</span>] <span style="color:#f92672">=</span> infact[<span style="color:#ae81ff">0</span>] <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>; i <span style="color:#f92672">&lt;</span> N; i <span style="color:#f92672">++</span> )
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    fact[i] <span style="color:#f92672">=</span> (LL)fact[i <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>] <span style="color:#f92672">*</span> i <span style="color:#f92672">%</span> mod;
</span></span><span style="display:flex;"><span>    infact[i] <span style="color:#f92672">=</span> (LL)infact[i <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>] <span style="color:#f92672">*</span> qmi(i, mod <span style="color:#f92672">-</span> <span style="color:#ae81ff">2</span>, mod) <span style="color:#f92672">%</span> mod;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>ll <span style="color:#a6e22e">C</span>(ll n,ll m){
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span>(m<span style="color:#f92672">&gt;</span>n) <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0ll</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> fact[n]<span style="color:#f92672">*</span>infact[m]<span style="color:#f92672">%</span>mod<span style="color:#f92672">*</span>infact[n<span style="color:#f92672">-</span>m]<span style="color:#f92672">%</span>mod;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h3 id="lucas定理--模板题-acwing-887-求组合数-iii"><em>Lucas</em>定理 —— 模板题 AcWing 887. 求组合数 III<a hidden class="anchor" aria-hidden="true" href="#lucas定理--模板题-acwing-887-求组合数-iii">#</a></h3>
<p>组合数，1&lt;b&lt;a</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c++" data-lang="c++"><span style="display:flex;"><span><span style="color:#960050;background-color:#1e0010">若</span>p是质数<span style="color:#960050;background-color:#1e0010">，则对于任意整数</span> <span style="color:#ae81ff">1</span> <span style="color:#f92672">&lt;=</span> m <span style="color:#f92672">&lt;=</span> n<span style="color:#960050;background-color:#1e0010">，有：</span>
</span></span><span style="display:flex;"><span>    C(n, m) <span style="color:#f92672">=</span> C(n <span style="color:#f92672">%</span> p, m <span style="color:#f92672">%</span> p) <span style="color:#f92672">*</span> C(n <span style="color:#f92672">/</span> p, m <span style="color:#f92672">/</span> p) (mod p)
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> qmi(<span style="color:#66d9ef">int</span> a, <span style="color:#66d9ef">int</span> k)       <span style="color:#75715e">// 快速幂模板
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>{
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> res <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">while</span> (k)
</span></span><span style="display:flex;"><span>    {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> (k <span style="color:#f92672">&amp;</span> <span style="color:#ae81ff">1</span>) res <span style="color:#f92672">=</span> (LL)res <span style="color:#f92672">*</span> a <span style="color:#f92672">%</span> p;
</span></span><span style="display:flex;"><span>        a <span style="color:#f92672">=</span> (LL)a <span style="color:#f92672">*</span> a <span style="color:#f92672">%</span> p;
</span></span><span style="display:flex;"><span>        k <span style="color:#f92672">&gt;&gt;=</span> <span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> res;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">C</span>(<span style="color:#66d9ef">int</span> a, <span style="color:#66d9ef">int</span> b)     <span style="color:#75715e">// 通过定理求组合数C(a, b)
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>{
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> res <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>, j <span style="color:#f92672">=</span> a; i <span style="color:#f92672">&lt;=</span> b; i <span style="color:#f92672">++</span>, j <span style="color:#f92672">--</span> )
</span></span><span style="display:flex;"><span>    {
</span></span><span style="display:flex;"><span>        res <span style="color:#f92672">=</span> (LL)res <span style="color:#f92672">*</span> j <span style="color:#f92672">%</span> p;
</span></span><span style="display:flex;"><span>        res <span style="color:#f92672">=</span> (LL)res <span style="color:#f92672">*</span> qmi(i, p <span style="color:#f92672">-</span> <span style="color:#ae81ff">2</span>) <span style="color:#f92672">%</span> p;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> res;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">lucas</span>(LL a, LL b)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> (a <span style="color:#f92672">&lt;</span> p <span style="color:#f92672">&amp;&amp;</span> b <span style="color:#f92672">&lt;</span> p) <span style="color:#66d9ef">return</span> C(a, b);
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> (LL)C(a <span style="color:#f92672">%</span> p, b <span style="color:#f92672">%</span> p) <span style="color:#f92672">*</span> lucas(a <span style="color:#f92672">/</span> p, b <span style="color:#f92672">/</span> p) <span style="color:#f92672">%</span> p;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h3 id="分解质因数法求组合数--模板题-acwing-888-求组合数-iv">分解质因数法求组合数 —— 模板题 AcWing 888. 求组合数 IV<a hidden class="anchor" aria-hidden="true" href="#分解质因数法求组合数--模板题-acwing-888-求组合数-iv">#</a></h3>
<p>当我们需要求出组合数的真实值，而非对某个数的余数时，分解质因数的方式比较好用：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c++" data-lang="c++"><span style="display:flex;"><span><span style="color:#ae81ff">1.</span> <span style="color:#960050;background-color:#1e0010">筛法求出范围内的所有质数</span>
</span></span><span style="display:flex;"><span><span style="color:#ae81ff">2.</span> <span style="color:#960050;background-color:#1e0010">通过</span> C(a, b) <span style="color:#f92672">=</span> a<span style="color:#f92672">!</span> <span style="color:#f92672">/</span> b<span style="color:#f92672">!</span> <span style="color:#f92672">/</span> (a <span style="color:#f92672">-</span> b)<span style="color:#f92672">!</span> <span style="color:#960050;background-color:#1e0010">这个公式求出每个质因子的次数。</span> n<span style="color:#f92672">!</span> <span style="color:#960050;background-color:#1e0010">中</span>p的次数是 n <span style="color:#f92672">/</span> p <span style="color:#f92672">+</span> n <span style="color:#f92672">/</span> p<span style="color:#f92672">^</span><span style="color:#ae81ff">2</span> <span style="color:#f92672">+</span> n <span style="color:#f92672">/</span> p<span style="color:#f92672">^</span><span style="color:#ae81ff">3</span> <span style="color:#f92672">+</span> ...
</span></span><span style="display:flex;"><span><span style="color:#ae81ff">3.</span> <span style="color:#960050;background-color:#1e0010">用高精度乘法将所有质因子相乘</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> primes[N], cnt;     <span style="color:#75715e">// 存储所有质数
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">int</span> sum[N];     <span style="color:#75715e">// 存储每个质数的次数
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">bool</span> st[N];     <span style="color:#75715e">// 存储每个数是否已被筛掉
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">get_primes</span>(<span style="color:#66d9ef">int</span> n)      <span style="color:#75715e">// 线性筛法求素数
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>{
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">2</span>; i <span style="color:#f92672">&lt;=</span> n; i <span style="color:#f92672">++</span> )
</span></span><span style="display:flex;"><span>    {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> (<span style="color:#f92672">!</span>st[i]) primes[cnt <span style="color:#f92672">++</span> ] <span style="color:#f92672">=</span> i;
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> j <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; primes[j] <span style="color:#f92672">&lt;=</span> n <span style="color:#f92672">/</span> i; j <span style="color:#f92672">++</span> )
</span></span><span style="display:flex;"><span>        {
</span></span><span style="display:flex;"><span>            st[primes[j] <span style="color:#f92672">*</span> i] <span style="color:#f92672">=</span> true;
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">if</span> (i <span style="color:#f92672">%</span> primes[j] <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span>) <span style="color:#66d9ef">break</span>;
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">get</span>(<span style="color:#66d9ef">int</span> n, <span style="color:#66d9ef">int</span> p)       <span style="color:#75715e">// 求n！中的次数
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>{
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> res <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">while</span> (n)
</span></span><span style="display:flex;"><span>    {
</span></span><span style="display:flex;"><span>        res <span style="color:#f92672">+=</span> n <span style="color:#f92672">/</span> p;
</span></span><span style="display:flex;"><span>        n <span style="color:#f92672">/=</span> p;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> res;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>vector<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;</span> mul(vector<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;</span> a, <span style="color:#66d9ef">int</span> b)       <span style="color:#75715e">// 高精度乘低精度模板
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>{
</span></span><span style="display:flex;"><span>    vector<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;</span> c;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> t <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; i <span style="color:#f92672">&lt;</span> a.size(); i <span style="color:#f92672">++</span> )
</span></span><span style="display:flex;"><span>    {
</span></span><span style="display:flex;"><span>        t <span style="color:#f92672">+=</span> a[i] <span style="color:#f92672">*</span> b;
</span></span><span style="display:flex;"><span>        c.push_back(t <span style="color:#f92672">%</span> <span style="color:#ae81ff">10</span>);
</span></span><span style="display:flex;"><span>        t <span style="color:#f92672">/=</span> <span style="color:#ae81ff">10</span>;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">while</span> (t)
</span></span><span style="display:flex;"><span>    {
</span></span><span style="display:flex;"><span>        c.push_back(t <span style="color:#f92672">%</span> <span style="color:#ae81ff">10</span>);
</span></span><span style="display:flex;"><span>        t <span style="color:#f92672">/=</span> <span style="color:#ae81ff">10</span>;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> c;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>get_primes(a);  <span style="color:#75715e">// 预处理范围内的所有质数
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; i <span style="color:#f92672">&lt;</span> cnt; i <span style="color:#f92672">++</span> )     <span style="color:#75715e">// 求每个质因数的次数
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>{
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> p <span style="color:#f92672">=</span> primes[i];
</span></span><span style="display:flex;"><span>    sum[i] <span style="color:#f92672">=</span> get(a, p) <span style="color:#f92672">-</span> get(b, p) <span style="color:#f92672">-</span> get(a <span style="color:#f92672">-</span> b, p);
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>vector<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;</span> res;
</span></span><span style="display:flex;"><span>res.push_back(<span style="color:#ae81ff">1</span>);
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; i <span style="color:#f92672">&lt;</span> cnt; i <span style="color:#f92672">++</span> )     <span style="color:#75715e">// 用高精度乘法将所有质因子相乘
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> j <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; j <span style="color:#f92672">&lt;</span> sum[i]; j <span style="color:#f92672">++</span> )
</span></span><span style="display:flex;"><span>        res <span style="color:#f92672">=</span> mul(res, primes[i]);
</span></span></code></pre></div><h3 id="卡特兰数--模板题-acwing-889-满足条件的01序列">卡特兰数 —— 模板题 AcWing 889. 满足条件的01序列<a hidden class="anchor" aria-hidden="true" href="#卡特兰数--模板题-acwing-889-满足条件的01序列">#</a></h3>
<p>给定n个0和n个1，它们按照某种顺序排成长度为2n的序列，满足任意前缀中0的个数都不少于1的个数的序列的数量为：
$$
Cat(n) = C(2n, n) / (n + 1)
$$</p>
<h3 id="容斥原理">容斥原理<a hidden class="anchor" aria-hidden="true" href="#容斥原理">#</a></h3>
<p>找1~n中能至少被素数p1,p2,&hellip;,pn一个整除的整数有多少个。</p>
<p>位运算对应容斥原理集合，1~n中能被x整除的个数为n/x，奇数加上，偶数减去</p>
<h3 id="nim尼姆游戏--模板题-acwing-891-nim游戏">NIM(尼姆)游戏 —— 模板题 AcWing 891. Nim游戏<a hidden class="anchor" aria-hidden="true" href="#nim尼姆游戏--模板题-acwing-891-nim游戏">#</a></h3>
<p>给定<strong>N</strong>堆物品，第<strong>i</strong>堆物品有<strong>Ai</strong>个。两名玩家轮流行动，每次可以任选一堆，取走任意多个物品，可把一堆取光，但不能不取。取走最后一件物品者获胜。两人都采取最优策略，问先手是否必胜。</p>
<p>我们把这种游戏称为<strong>NIM</strong>博弈。把游戏过程中面临的状态称为局面。整局游戏第一个行动的称为先手，第二个行动的称为后手。若在某一局面下无论采取何种行动，都会输掉游戏，则称该局面必败。
所谓采取最优策略是指，若在某一局面下存在某种行动，使得行动后对面面临必败局面，则优先采取该行动。同时，这样的局面被称为必胜。我们讨论的博弈问题一般都只考虑理想情况，即两人均无失误，都采取最优策略行动时游戏的结果。
<strong>NIM</strong>博弈不存在平局，只有<strong>先手必胜</strong>和<strong>先手必败</strong>两种情况。</p>
<p><strong>定理</strong>： <strong>NIM</strong>博弈<strong>先手必胜</strong>，当且仅当 A1 ^ A2 ^ … ^ An != 0</p>
<p>公平组合游戏ICG
若一个游戏满足：</p>
<p>由两名玩家交替行动；
在游戏进程的任意时刻，可以执行的合法行动与轮到哪名玩家无关；
不能行动的玩家判负；
则称该游戏为一个公平组合游戏。
NIM博弈属于公平组合游戏，但城建的棋类游戏，比如围棋，就不是公平组合游戏。因为围棋交战双方分别只能落黑子和白子，胜负判定也比较复杂，不满足条件2和条件3。</p>
<p><strong>有向图游戏</strong>
给定一个有向无环图，图中有一个唯一的起点，在起点上放有一枚棋子。两名玩家交替地把这枚棋子沿有向边进行移动，每次可以移动一步，无法移动者判负。该游戏被称为有向图游戏。
任何一个公平组合游戏都可以转化为有向图游戏。具体方法是，把每个局面看成图中的一个节点，并且从每个局面向沿着合法行动能够到达的下一个局面连有向边。</p>
<p><strong>Mex运算</strong>
设S表示一个非负整数集合。定义mex(S)为求出不属于集合S的最小非负整数的运算，即：
mex(S) = min{x}, x属于自然数，且x不属于S</p>
<p><strong>SG函数</strong>
在有向图游戏中，对于每个节点x，设从x出发共有k条有向边，分别到达节点y1, y2, …, yk，定义SG(x)为x的后继节点y1, y2, …, yk 的SG函数值构成的集合再执行**mex(S)**运算的结果，即：
SG(x) = mex({SG(y1), SG(y2), …, SG(yk)})
特别地，整个有向图游戏G的SG函数值被定义为有向图游戏起点s的SG函数值，即SG(G) = SG(s)。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c++" data-lang="c++"><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">sg</span>(<span style="color:#66d9ef">int</span> x){
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">if</span> (f[x] <span style="color:#f92672">!=</span> <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>) <span style="color:#66d9ef">return</span> f[x];
</span></span><span style="display:flex;"><span>    unordered_set<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;</span> S;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span>(<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; i <span style="color:#f92672">&lt;</span> m; i<span style="color:#f92672">++</span> ) {
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">int</span> sum <span style="color:#f92672">=</span> s[i];
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> (x <span style="color:#f92672">&gt;=</span> sum) S.insert(sg(x <span style="color:#f92672">-</span> sum));
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i<span style="color:#f92672">=</span><span style="color:#ae81ff">0</span>; ; i<span style="color:#f92672">++</span> )
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> (<span style="color:#f92672">!</span>S.count(i))
</span></span><span style="display:flex;"><span>            	<span style="color:#66d9ef">return</span> f[x] <span style="color:#f92672">=</span> i;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h3 id="有向图游戏的和--模板题-acwing-893-集合-nim游戏">有向图游戏的和 —— 模板题 AcWing 893. 集合-Nim游戏<a hidden class="anchor" aria-hidden="true" href="#有向图游戏的和--模板题-acwing-893-集合-nim游戏">#</a></h3>
<p>设G1, G2, …, Gm 是<strong>m个有向图游戏</strong>。定义有向图游戏G，它的行动规则是任选某个有向图游戏Gi，并在Gi上行动一步。G被称为有向图游戏G1, G2, …, Gm的和。
有向图游戏的<strong>和的SG函数值</strong>等于它包含的各个子游戏SG函数值的异或和，即：
SG(G) = SG(G1) ^ SG(G2) ^ … ^ SG(Gm)</p>
<p>定理
有向图游戏的某个局面必胜，当且仅当该局面对应节点的SG函数值大于0。
有向图游戏的某个局面必败，当且仅当该局面对应节点的SG函数值等于0。</p>
<p>作者：yxc
链接：https://www.acwing.com/blog/content/406/
来源：AcWing
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p>
<h2 id="时空复杂度分析">时空复杂度分析<a hidden class="anchor" aria-hidden="true" href="#时空复杂度分析">#</a></h2>
<p>当处理ACM或笔试题时，通常时间限制为1秒或2秒。在这种情况下，C++代码中的操作次数应控制在10^7 到 10^8之间，这是最佳范围。</p>
<p>以下是在不同数据规模下，代码的时间复杂度和算法选择的指导：</p>
<ol>
<li><strong>n ≤ 30</strong>：指数级别，使用DFS+剪枝，状态压缩DP。</li>
<li><strong>n ≤ 100</strong>：O(n^3)，适用于Floyd、DP、高斯消元。</li>
<li><strong>n ≤ 1000</strong>：O(n^2)或O(n^2*logn)，适用于DP、分治、高斯消元、朴素版Dijkstra、朴素版Prim、Bellman-Ford。</li>
<li><strong>n ≤ 10000</strong>：O(n * √n)，适用于块状链表、分块、莫队。</li>
<li><strong>n ≤ 100000</strong>：O(nlogn)，适用于各种排序、线段树、树状数组、集合/映射、堆、拓扑排序、Dijkstra+堆、Prim、Kruskal、SPFA、求凸包、求半平面交、二分、CDQ分治、整体二分、后缀数组、树链剖分、动态树。</li>
<li><strong>n &lt; 1000000</strong>：O(n)或常数较小的O(nlogn)，适用于单调队列、哈希映射、双指针扫描、BFS、并查集、KMP、AC自动机、常数较小的O(nlogn)的做法（如排序、树状数组、堆、Dijkstra、SPFA）。</li>
<li><strong>n &lt; 10000000</strong>：O(n)，适用于双指针扫描、KMP、AC自动机、线性筛素数。</li>
<li><strong>n ≤ 10^9</strong>：O(n√n)，适用于判断质数。</li>
<li><strong>n ≤ 10^18</strong>：O(logn)，适用于最大公约数、快速幂、数位DP。</li>
<li><strong>n ≤ 10^1000</strong>：O((logn)^2)，适用于高精度加减乘除。</li>
<li><strong>n ≤ 10^100000</strong>：O(logk × loglogk)，其中k表示位数，适用于高精度加减、FFT/NTT。</li>
</ol>
<p>动态规划计算量 ： 状态数 * 状态转移数量</p>
<p>1 Byte = 8 bit</p>
<p>1KB = 1024 Byte</p>
<p>1MB = 1024<em>1024</em>1024 Byte</p>
<p>1GB = 1024 * 1024 * 1024 Byte</p>
<p>int 4 Byte</p>
<p>char 1 Byte</p>
<p>double, long long 8 Byte</p>
<h1 id="动态规划">动态规划<a hidden class="anchor" aria-hidden="true" href="#动态规划">#</a></h1>
<p>常见模型</p>
<h2 id="背包-九讲">背包 九讲<a hidden class="anchor" aria-hidden="true" href="#背包-九讲">#</a></h2>
<h3 id="01背包">01背包<a hidden class="anchor" aria-hidden="true" href="#01背包">#</a></h3>
<p><strong>每件物品最多可以用一次</strong></p>
<p>体积从大到小的原因 ： 如果从小到大，则<code>f[j-w[i]]+v[i]</code>实际是<code>f[i-1][j-w[i]]+v[i]</code>，需要的是上一维度f[i-1]维度，所以从大到小可以使用上一维度的，因为这一维度的还没有被计算到。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c++" data-lang="c++"><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span>(<span style="color:#66d9ef">int</span> i<span style="color:#f92672">=</span><span style="color:#ae81ff">1</span>;i<span style="color:#f92672">&lt;=</span>N;i<span style="color:#f92672">++</span>){
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">for</span>(<span style="color:#66d9ef">int</span> j<span style="color:#f92672">=</span>V;j<span style="color:#f92672">&gt;=</span>w[i];j<span style="color:#f92672">--</span>){
</span></span><span style="display:flex;"><span>            f[j]<span style="color:#f92672">=</span>max(f[j],f[j<span style="color:#f92672">-</span>w[i]]<span style="color:#f92672">+</span>v[i]);
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    }
</span></span></code></pre></div><h3 id="完全背包">完全背包<a hidden class="anchor" aria-hidden="true" href="#完全背包">#</a></h3>
<p>每件物品可以用无限次</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c++" data-lang="c++"><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span>(<span style="color:#66d9ef">int</span> i<span style="color:#f92672">=</span><span style="color:#ae81ff">1</span>;i<span style="color:#f92672">&lt;=</span>N;i<span style="color:#f92672">++</span>){
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">for</span>(<span style="color:#66d9ef">int</span> j<span style="color:#f92672">=</span>w[i];j<span style="color:#f92672">&lt;=</span>V;j<span style="color:#f92672">++</span>){
</span></span><span style="display:flex;"><span>            f[j]<span style="color:#f92672">=</span>max(f[j],f[j<span style="color:#f92672">-</span>w[i]]<span style="color:#f92672">+</span>v[i]);
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    }
</span></span></code></pre></div><h3 id="多重背包">多重背包<a hidden class="anchor" aria-hidden="true" href="#多重背包">#</a></h3>
<p>每件物品特定数量</p>
<h4 id="二进制优化">二进制优化<a hidden class="anchor" aria-hidden="true" href="#二进制优化">#</a></h4>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c++" data-lang="c++"><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span>(<span style="color:#66d9ef">int</span> i<span style="color:#f92672">=</span><span style="color:#ae81ff">1</span>;i<span style="color:#f92672">&lt;=</span>N;i<span style="color:#f92672">++</span>){
</span></span><span style="display:flex;"><span>        cin<span style="color:#f92672">&gt;&gt;</span>a<span style="color:#f92672">&gt;&gt;</span>b<span style="color:#f92672">&gt;&gt;</span>c; <span style="color:#75715e">//权重a,价值b，数量c
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#66d9ef">int</span> k<span style="color:#f92672">=</span><span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">while</span>(k<span style="color:#f92672">&lt;=</span>c){
</span></span><span style="display:flex;"><span>            cnt<span style="color:#f92672">++</span>; c<span style="color:#f92672">-=</span>k;
</span></span><span style="display:flex;"><span>            w[cnt]<span style="color:#f92672">=</span>k<span style="color:#f92672">*</span>a;
</span></span><span style="display:flex;"><span>            v[cnt]<span style="color:#f92672">=</span>k<span style="color:#f92672">*</span>b;
</span></span><span style="display:flex;"><span>            k<span style="color:#f92672">*=</span><span style="color:#ae81ff">2</span>;
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span>(c){
</span></span><span style="display:flex;"><span>            cnt<span style="color:#f92672">++</span>;
</span></span><span style="display:flex;"><span>            w[cnt]<span style="color:#f92672">=</span>c<span style="color:#f92672">*</span>a;
</span></span><span style="display:flex;"><span>            v[cnt]<span style="color:#f92672">=</span>c<span style="color:#f92672">*</span>b;
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    } <span style="color:#75715e">//之后用01背包
</span></span></span></code></pre></div><h4 id="单调队列优化">单调队列优化<a hidden class="anchor" aria-hidden="true" href="#单调队列优化">#</a></h4>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span>(<span style="color:#66d9ef">int</span> i<span style="color:#f92672">=</span><span style="color:#ae81ff">1</span>;i<span style="color:#f92672">&lt;=</span>N;i<span style="color:#f92672">++</span>){ <span style="color:#75715e">// 遍历每件物品
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        memcpy(g, f, <span style="color:#66d9ef">sizeof</span> g); <span style="color:#75715e">// 将上一轮的最优解拷贝给g数组
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#66d9ef">for</span>(<span style="color:#66d9ef">int</span> r<span style="color:#f92672">=</span><span style="color:#ae81ff">0</span>;r<span style="color:#f92672">&lt;</span>v[i];r<span style="color:#f92672">++</span>){ <span style="color:#75715e">// 遍历余数r（用于优化循环）
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>            <span style="color:#66d9ef">int</span> h<span style="color:#f92672">=</span><span style="color:#ae81ff">0</span>,t<span style="color:#f92672">=-</span><span style="color:#ae81ff">1</span>; <span style="color:#75715e">// 滑动窗口的起始索引和结束索引
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>            <span style="color:#66d9ef">for</span>(<span style="color:#66d9ef">int</span> l<span style="color:#f92672">=</span>r;l<span style="color:#f92672">&lt;=</span>V;l<span style="color:#f92672">+=</span>v[i]){ <span style="color:#75715e">// 遍历背包容量，间隔为当前物品体积
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>                <span style="color:#66d9ef">while</span>(h<span style="color:#f92672">&lt;=</span>t <span style="color:#f92672">&amp;&amp;</span> l<span style="color:#f92672">-</span>q[h]<span style="color:#f92672">&gt;</span>s[i]<span style="color:#f92672">*</span>v[i]) h<span style="color:#f92672">++</span>; <span style="color:#75715e">// 如果窗口左边界超出限制，则左边界右移
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>                <span style="color:#66d9ef">while</span>(h<span style="color:#f92672">&lt;=</span>t <span style="color:#f92672">&amp;&amp;</span> g[q[t]] <span style="color:#f92672">+</span> (l<span style="color:#f92672">-</span>q[t])<span style="color:#f92672">/</span>v[i]<span style="color:#f92672">*</span>w[i]<span style="color:#f92672">&lt;=</span>g[l]) t<span style="color:#f92672">--</span>; <span style="color:#75715e">// 保持窗口单调性，将窗口内不符合条件的解移除
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>                q[<span style="color:#f92672">++</span>t] <span style="color:#f92672">=</span> l; <span style="color:#75715e">// 将当前状态的背包容量加入窗口
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>                f[l] <span style="color:#f92672">=</span> g[q[h]] <span style="color:#f92672">+</span> (l<span style="color:#f92672">-</span>q[h])<span style="color:#f92672">/</span>v[i]<span style="color:#f92672">*</span>w[i]; <span style="color:#75715e">// 更新当前状态的最优解
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>            }
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    }
</span></span></code></pre></div><h3 id="分组背包">分组背包<a hidden class="anchor" aria-hidden="true" href="#分组背包">#</a></h3>
<p>若干组，一组只能选一个</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c++" data-lang="c++"><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span>(<span style="color:#66d9ef">int</span> i<span style="color:#f92672">=</span><span style="color:#ae81ff">1</span>;i<span style="color:#f92672">&lt;=</span>N;i<span style="color:#f92672">++</span>){
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">for</span>(<span style="color:#66d9ef">int</span> j<span style="color:#f92672">=</span>V;j<span style="color:#f92672">&gt;=</span><span style="color:#ae81ff">0</span>;j<span style="color:#f92672">--</span>){
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">for</span>(<span style="color:#66d9ef">int</span> k<span style="color:#f92672">=</span><span style="color:#ae81ff">1</span>;k<span style="color:#f92672">&lt;=</span>s[i];k<span style="color:#f92672">++</span>){
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">if</span>(w[i][k]<span style="color:#f92672">&lt;=</span>j){
</span></span><span style="display:flex;"><span>                    f[j]<span style="color:#f92672">=</span>max(f[j],f[j<span style="color:#f92672">-</span> w[i][k] ]<span style="color:#f92672">+</span>v[i][k]);
</span></span><span style="display:flex;"><span>                }
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    }
</span></span></code></pre></div><h3 id="混合背包">混合背包<a hidden class="anchor" aria-hidden="true" href="#混合背包">#</a></h3>
<p>转换成01背包问题</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span>(<span style="color:#66d9ef">int</span> i<span style="color:#f92672">=</span><span style="color:#ae81ff">1</span>;i<span style="color:#f92672">&lt;=</span>N;i<span style="color:#f92672">++</span>){
</span></span><span style="display:flex;"><span>        cin<span style="color:#f92672">&gt;&gt;</span>a<span style="color:#f92672">&gt;&gt;</span>b<span style="color:#f92672">&gt;&gt;</span>s;
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span>(s<span style="color:#f92672">==-</span><span style="color:#ae81ff">1</span>) s<span style="color:#f92672">=</span><span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">else</span> <span style="color:#a6e22e">if</span>(s<span style="color:#f92672">==</span><span style="color:#ae81ff">0</span>) s<span style="color:#f92672">=</span>V<span style="color:#f92672">/</span>a;
</span></span><span style="display:flex;"><span>        k<span style="color:#f92672">=</span><span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">while</span>(k<span style="color:#f92672">&lt;=</span>s){
</span></span><span style="display:flex;"><span>            s<span style="color:#f92672">-=</span>k; cnt<span style="color:#f92672">++</span>;
</span></span><span style="display:flex;"><span>            v[cnt] <span style="color:#f92672">=</span> k<span style="color:#f92672">*</span>a; w[cnt] <span style="color:#f92672">=</span> k<span style="color:#f92672">*</span>b;
</span></span><span style="display:flex;"><span>            k<span style="color:#f92672">*=</span><span style="color:#ae81ff">2</span>;
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span>(s){
</span></span><span style="display:flex;"><span>            cnt<span style="color:#f92672">++</span>;
</span></span><span style="display:flex;"><span>            v[cnt] <span style="color:#f92672">=</span> s<span style="color:#f92672">*</span>a; w[cnt] <span style="color:#f92672">=</span> s<span style="color:#f92672">*</span>b;
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span>(<span style="color:#66d9ef">int</span> i<span style="color:#f92672">=</span><span style="color:#ae81ff">1</span>;i<span style="color:#f92672">&lt;=</span>cnt;i<span style="color:#f92672">++</span>){
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">for</span>(<span style="color:#66d9ef">int</span> j<span style="color:#f92672">=</span>V;j<span style="color:#f92672">&gt;=</span>v[i];j<span style="color:#f92672">--</span>){
</span></span><span style="display:flex;"><span>            f[j] <span style="color:#f92672">=</span> max(f[j], f[j<span style="color:#f92672">-</span>v[i]]<span style="color:#f92672">+</span>w[i]);
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    }
</span></span></code></pre></div><h3 id="二维费用的背包问题">二维费用的背包问题<a hidden class="anchor" aria-hidden="true" href="#二维费用的背包问题">#</a></h3>
<p>采用两层循环</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>    cin<span style="color:#f92672">&gt;&gt;</span>N<span style="color:#f92672">&gt;&gt;</span>V<span style="color:#f92672">&gt;&gt;</span>W;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span>(<span style="color:#66d9ef">int</span> i<span style="color:#f92672">=</span><span style="color:#ae81ff">1</span>;i<span style="color:#f92672">&lt;=</span>N;i<span style="color:#f92672">++</span>){
</span></span><span style="display:flex;"><span>        cin<span style="color:#f92672">&gt;&gt;</span>v<span style="color:#f92672">&gt;&gt;</span>m<span style="color:#f92672">&gt;&gt;</span>w;
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">for</span>(<span style="color:#66d9ef">int</span> j<span style="color:#f92672">=</span>V;j<span style="color:#f92672">&gt;=</span>v;j<span style="color:#f92672">--</span>){
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">for</span>(<span style="color:#66d9ef">int</span> k<span style="color:#f92672">=</span>W;k<span style="color:#f92672">&gt;=</span>m;k<span style="color:#f92672">--</span>){
</span></span><span style="display:flex;"><span>                f[j][k] <span style="color:#f92672">=</span> max(f[j][k], f[j<span style="color:#f92672">-</span>v][k<span style="color:#f92672">-</span>m] <span style="color:#f92672">+</span> w);
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    cout<span style="color:#f92672">&lt;&lt;</span>f[V][W]<span style="color:#f92672">&lt;&lt;</span>endl;
</span></span></code></pre></div><h2 id="线性dp">线性dp<a hidden class="anchor" aria-hidden="true" href="#线性dp">#</a></h2>
<h4 id="数字三角形">数字三角形<a hidden class="anchor" aria-hidden="true" href="#数字三角形">#</a></h4>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c++" data-lang="c++"><span style="display:flex;"><span>	<span style="color:#66d9ef">for</span>(<span style="color:#66d9ef">int</span> i<span style="color:#f92672">=</span><span style="color:#ae81ff">1</span>;i<span style="color:#f92672">&lt;=</span>n;i<span style="color:#f92672">++</span>){
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">for</span>(<span style="color:#66d9ef">int</span> j<span style="color:#f92672">=</span><span style="color:#ae81ff">1</span>;j<span style="color:#f92672">&lt;=</span>i;j<span style="color:#f92672">++</span>){
</span></span><span style="display:flex;"><span>			a[i][j]<span style="color:#f92672">+=</span>max(a[i<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>][j],a[i<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>][j<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>]);
</span></span><span style="display:flex;"><span>		}
</span></span><span style="display:flex;"><span>	}
</span></span></code></pre></div><h4 id="lis">LIS<a hidden class="anchor" aria-hidden="true" href="#lis">#</a></h4>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c++" data-lang="c++"><span style="display:flex;"><span>	<span style="color:#66d9ef">for</span>(<span style="color:#66d9ef">int</span> i<span style="color:#f92672">=</span><span style="color:#ae81ff">1</span>;i<span style="color:#f92672">&lt;=</span>n;i<span style="color:#f92672">++</span>){
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">for</span>(<span style="color:#66d9ef">int</span> j<span style="color:#f92672">=</span><span style="color:#ae81ff">1</span>;j<span style="color:#f92672">&lt;</span>i;j<span style="color:#f92672">++</span>){
</span></span><span style="display:flex;"><span>			<span style="color:#66d9ef">if</span>(a[j]<span style="color:#f92672">&lt;</span>a[i]) f[i]<span style="color:#f92672">=</span>max(f[j]<span style="color:#f92672">+</span><span style="color:#ae81ff">1</span>,f[i]);
</span></span><span style="display:flex;"><span>		}
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">for</span>(<span style="color:#66d9ef">int</span> i<span style="color:#f92672">=</span><span style="color:#ae81ff">1</span>;i<span style="color:#f92672">&lt;=</span>n;i<span style="color:#f92672">++</span>){
</span></span><span style="display:flex;"><span>		ma<span style="color:#f92672">=</span>max(f[i],ma);
</span></span><span style="display:flex;"><span>	}
</span></span></code></pre></div><h4 id="lcs">LCS<a hidden class="anchor" aria-hidden="true" href="#lcs">#</a></h4>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c++" data-lang="c++"><span style="display:flex;"><span>	<span style="color:#66d9ef">for</span>(<span style="color:#66d9ef">int</span> i<span style="color:#f92672">=</span><span style="color:#ae81ff">1</span>;i<span style="color:#f92672">&lt;=</span>n;i<span style="color:#f92672">++</span>){
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">for</span>(<span style="color:#66d9ef">int</span> j<span style="color:#f92672">=</span><span style="color:#ae81ff">1</span>;j<span style="color:#f92672">&lt;=</span>m;j<span style="color:#f92672">++</span>){
</span></span><span style="display:flex;"><span>			f[i][j]<span style="color:#f92672">=</span>max(f[i<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>][j],f[i][j<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>]);
</span></span><span style="display:flex;"><span>			<span style="color:#66d9ef">if</span>(a[i]<span style="color:#f92672">==</span>b[j]) f[i][j]<span style="color:#f92672">=</span>f[i<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>][j<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>]<span style="color:#f92672">+</span><span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span>		}
</span></span><span style="display:flex;"><span>	}
</span></span></code></pre></div><h3 id="区间dp">区间dp<a hidden class="anchor" aria-hidden="true" href="#区间dp">#</a></h3>
<h4 id="石子合并">石子合并<a hidden class="anchor" aria-hidden="true" href="#石子合并">#</a></h4>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c++" data-lang="c++"><span style="display:flex;"><span>	memset(f, <span style="color:#ae81ff">0x3f</span>, <span style="color:#66d9ef">sizeof</span> f);
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">for</span>(<span style="color:#66d9ef">int</span> len<span style="color:#f92672">=</span><span style="color:#ae81ff">2</span>;len<span style="color:#f92672">&lt;=</span>n;len<span style="color:#f92672">++</span>){
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">for</span>(<span style="color:#66d9ef">int</span> i<span style="color:#f92672">=</span><span style="color:#ae81ff">1</span>;i<span style="color:#f92672">+</span>len<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span><span style="color:#f92672">&lt;=</span>n;i<span style="color:#f92672">++</span>){
</span></span><span style="display:flex;"><span>			<span style="color:#66d9ef">int</span> j<span style="color:#f92672">=</span>i<span style="color:#f92672">+</span>len<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">if</span> (len <span style="color:#f92672">==</span> <span style="color:#ae81ff">1</span>) {
</span></span><span style="display:flex;"><span>             	f[i][j] <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;  <span style="color:#75715e">// 边界初始化
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>                <span style="color:#66d9ef">continue</span>;
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>			<span style="color:#66d9ef">for</span>(<span style="color:#66d9ef">int</span> k<span style="color:#f92672">=</span>i;k<span style="color:#f92672">&lt;</span>j;k<span style="color:#f92672">++</span>){
</span></span><span style="display:flex;"><span>				f[l][r]<span style="color:#f92672">=</span>min(f[l][r],f[l][k]<span style="color:#f92672">+</span>f[k<span style="color:#f92672">+</span><span style="color:#ae81ff">1</span>][r]<span style="color:#f92672">+</span>s[r]<span style="color:#f92672">-</span>s[l<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>]);
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>		}
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>	cout<span style="color:#f92672">&lt;&lt;</span>f[<span style="color:#ae81ff">1</span>][n];
</span></span></code></pre></div><h2 id="数位统计dp">数位统计dp<a hidden class="anchor" aria-hidden="true" href="#数位统计dp">#</a></h2>
<p>状态表示</p>
<p>分情况讨论</p>
<h2 id="状态压缩-dp">状态压缩 dp<a hidden class="anchor" aria-hidden="true" href="#状态压缩-dp">#</a></h2>
<p>蒙德里安的梦想</p>
<p>最短Hamilton距离</p>
<h2 id="树形dp">树形dp<a hidden class="anchor" aria-hidden="true" href="#树形dp">#</a></h2>
<p>没有上司的舞会</p>
<h3 id="记忆化">记忆化<a hidden class="anchor" aria-hidden="true" href="#记忆化">#</a></h3>
<p>滑雪</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#75715e">#include&lt;bits/stdc++.h&gt;
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">using</span> <span style="color:#66d9ef">namespace</span> std;
</span></span><span style="display:flex;"><span><span style="color:#75715e">#define ll long long
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">const</span> <span style="color:#66d9ef">int</span> maxn<span style="color:#f92672">=</span><span style="color:#ae81ff">1e4</span>;
</span></span><span style="display:flex;"><span>ll f[maxn][maxn],g[maxn][maxn]; <span style="color:#75715e">//distance
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">node</span>{
</span></span><span style="display:flex;"><span>    ll i,j,num;
</span></span><span style="display:flex;"><span>}a[maxn];
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">cmp</span>
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">bool</span> <span style="color:#a6e22e">operator</span> () (node x,node y){
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> x.num<span style="color:#f92672">&gt;</span>y.num;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>};
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>()
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    ios<span style="color:#f92672">::</span>sync_with_stdio(false);
</span></span><span style="display:flex;"><span>    cin.tie(<span style="color:#ae81ff">0</span>);
</span></span><span style="display:flex;"><span>    cout.tie(<span style="color:#ae81ff">0</span>);
</span></span><span style="display:flex;"><span>    ll n,m,ma<span style="color:#f92672">=-</span><span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span>    cin<span style="color:#f92672">&gt;&gt;</span>n<span style="color:#f92672">&gt;&gt;</span>m;
</span></span><span style="display:flex;"><span>    priority_queue<span style="color:#f92672">&lt;</span>node, vector<span style="color:#f92672">&lt;</span>node<span style="color:#f92672">&gt;</span>,cmp<span style="color:#f92672">&gt;</span>pq;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span>(ll i<span style="color:#f92672">=</span><span style="color:#ae81ff">1</span>;i<span style="color:#f92672">&lt;=</span>n;i<span style="color:#f92672">++</span>){
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">for</span>(ll j<span style="color:#f92672">=</span><span style="color:#ae81ff">1</span>;j<span style="color:#f92672">&lt;=</span>m;j<span style="color:#f92672">++</span>){
</span></span><span style="display:flex;"><span>            f[i][j]<span style="color:#f92672">=</span><span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span>            node a;
</span></span><span style="display:flex;"><span>            a.i<span style="color:#f92672">=</span>i;
</span></span><span style="display:flex;"><span>            a.j<span style="color:#f92672">=</span>j;
</span></span><span style="display:flex;"><span>            cin<span style="color:#f92672">&gt;&gt;</span>a.num;
</span></span><span style="display:flex;"><span>            g[i][j]<span style="color:#f92672">=</span>a.num;
</span></span><span style="display:flex;"><span>            pq.push(a);
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">while</span>(<span style="color:#f92672">!</span>pq.empty()){
</span></span><span style="display:flex;"><span>        node t<span style="color:#f92672">=</span>pq.top();
</span></span><span style="display:flex;"><span>        pq.pop();
</span></span><span style="display:flex;"><span>        ll i<span style="color:#f92672">=</span>t.i;
</span></span><span style="display:flex;"><span>        ll j<span style="color:#f92672">=</span>t.j;
</span></span><span style="display:flex;"><span>        ll nu<span style="color:#f92672">=</span>t.num;
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span>(g[i<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>][j]<span style="color:#f92672">&lt;</span>nu) f[i][j]<span style="color:#f92672">=</span>max(f[i][j],f[i<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>][j]<span style="color:#f92672">+</span><span style="color:#ae81ff">1</span>);
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span>(g[i<span style="color:#f92672">+</span><span style="color:#ae81ff">1</span>][j]<span style="color:#f92672">&lt;</span>nu) f[i][j]<span style="color:#f92672">=</span>max(f[i][j],f[i<span style="color:#f92672">+</span><span style="color:#ae81ff">1</span>][j]<span style="color:#f92672">+</span><span style="color:#ae81ff">1</span>);
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span>(g[i][j<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>]<span style="color:#f92672">&lt;</span>nu) f[i][j]<span style="color:#f92672">=</span>max(f[i][j],f[i][j<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>]<span style="color:#f92672">+</span><span style="color:#ae81ff">1</span>);
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span>(g[i][j<span style="color:#f92672">+</span><span style="color:#ae81ff">1</span>]<span style="color:#f92672">&lt;</span>nu) f[i][j]<span style="color:#f92672">=</span>max(f[i][j],f[i][j<span style="color:#f92672">+</span><span style="color:#ae81ff">1</span>]<span style="color:#f92672">+</span><span style="color:#ae81ff">1</span>);
</span></span><span style="display:flex;"><span>        ma<span style="color:#f92672">=</span>max(ma,f[i][j]);
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    cout<span style="color:#f92672">&lt;&lt;</span>ma<span style="color:#f92672">&lt;&lt;</span>endl;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h1 id="习题课">习题课<a hidden class="anchor" aria-hidden="true" href="#习题课">#</a></h1>


  </div>

  <footer class="post-footer">
    <ul class="post-tags">
    </ul>
  </footer>
</article>
    </main>
    
<footer class="footer">
    <span>&copy; 2024 <a href="https://showguan.github.io/">Guan</a></span>
    <span>
        Powered by
        <a href="https://gohugo.io/" rel="noopener noreferrer" target="_blank">Hugo</a> &
        <a href="https://github.com/adityatelange/hugo-PaperMod/" rel="noopener" target="_blank">PaperMod</a>
    </span>
</footer>
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)" class="top-link" id="top-link" accesskey="g">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
        <path d="M12 6H0l6-6z" />
    </svg>
</a>

<script>
    let menu = document.getElementById('menu')
    if (menu) {
        menu.scrollLeft = localStorage.getItem("menu-scroll-position");
        menu.onscroll = function () {
            localStorage.setItem("menu-scroll-position", menu.scrollLeft);
        }
    }

    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.pushState(null, null, `#${id}`);
            }
        });
    });

</script>
<script>
    var mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };

</script>
<script>
    document.getElementById("theme-toggle").addEventListener("click", () => {
        if (document.body.className.includes("dark")) {
            document.body.classList.remove('dark');
            localStorage.setItem("pref-theme", 'light');
        } else {
            document.body.classList.add('dark');
            localStorage.setItem("pref-theme", 'dark');
        }
    })

</script>
</body>

</html>
