[{"content":"第一天作业 作业内容 1 程序搭建完成AndroidStudio环境，项目能够正常运行展示hello world 新建工程的hello world 简单修改页面后的hello world 2 代码上传到自己的gitlab仓库 上传截图\n3 请大家用adb命令配置到环境变量里用adb命令安装课上编译好的apk到手机中 安装（Install） 卸载（Uninstall） 第一天学习笔记 老师：唐鸿程\nAndroid按照运行方式分为3阶段 JIT\tAOT AOT+JIT\nAndroid系统可以分5层 kernel 层 ，硬件抽象层 ， art c++层 ， java framework层 ， app层\n字节码对齐（Bytecode Alignment）：在 Android 应用开发中是一个优化步骤，旨在提高应用程序的启动速度和运行效率。它主要用于优化 DEX 文件的加载过程。\ngit 项目管理工具 git使用\ngit配置多个ssh账号\n1、账号密码登陆 ： git config --global user.name “xx” git config --global user.email \u0026#34;[fangqi@xiaomi.com](mailto:fangqi@xiaomi.com)\u0026#34; 需要和你的登录的账户邮箱一致 2、配置ssh方式：生成本地的指纹 ： ssh-keygen -t rsa cat /Users/{tournament}/.ssh/id_rsa.pub 将文档全部字符串复制到 gitlab 的 sshkey 3、将代码推到新仓库： git init git remote add origin [git@partner-gitlab.mioffice.cn](mailto:git@partner-gitlab.mioffice.cn):nj-trainingcollege/miclassroom240108/{yourproject}.git git add * git commit -m \u0026#34;Initial commit\u0026#34; git push -u origin master 4、拉以后仓库代码并更新 git clone [git@partner-gitlab.mioffice.cn](mailto:git@partner-gitlab.mioffice.cn):nj-trainingcollege/miclassroom240108/hello.git git status git add * git commit -m \u0026#34;Initial commit\u0026#34; git push -u origin master 5、Android studio 使用 下载 2020-2022版本的 android studio\n配置 java_home\n配置 android_home\n配置 adb_home {androidsdk} /platform-tools\n新建项目 hello\n在app目录下 找打res文件夹 新建layout文件夹 ，新建文件 activity_hello.xml\n添加代码\n\u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;utf-8\u0026#34;?\u0026gt; \u0026lt;LinearLayout xmlns:android=\u0026#34;http://schemas.android.com/apk/res/android\u0026#34; android:layout_width=\u0026#34;match_parent\u0026#34; android:layout_height=\u0026#34;match_parent\u0026#34; android:orientation=\u0026#34;vertical\u0026#34;\u0026gt; \u0026lt;TextView android:layout_width=\u0026#34;wrap_content\u0026#34; android:layout_height=\u0026#34;wrap_content\u0026#34; android:layout_margin=\u0026#34;50dp\u0026#34; android:layout_gravity=\u0026#34;center\u0026#34; android:text=\u0026#34;hello world\u0026#34;/\u0026gt; \u0026lt;/LinearLayout\u0026gt; 切换到文件mainactivity.java 文件（如果是kt文件，请删掉，新建mainactivity.java ） 改成如下代码\npackage com.example.hello; import android.app.Activity; import android.os.Bundle; public class MainActivity extends Activity { @Override protected void onCreate( Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.activity_hello); } } gradle 构建项目 ./gradlew build 如果build失败提示 java 版本问题 ，请切换到相应版本\nadb 安装 apk 手机\n找到根目录下已经编译好的 release 文件 release/app-release.apk\nadb install {rootdir}/release/app-release.apk 新建项目 签名打包 创建一个keystore。\nApplication中不要做一些耗时的操作\nADB\n其他资源 Android官方文档：https://developer.android.google.cn/docs?hl=zh-cn 各种开源代码：https://github.com/ kotlin https://kotlinlang.org/docs/home.html java： https://www.oracle.com/java/technologies/downloads/ 系统源码 https://cs.android.com/ gradle https://developer.android.google.cn/studio/build/building-cmdline?hl=zh-cn\n","permalink":"https://kennems.github.io/zh/posts/tech/%E7%AC%AC%E4%B8%80%E5%A4%A9%E7%AC%94%E8%AE%B0/","summary":"第一天作业 作业内容 1 程序搭建完成AndroidStudio环境，项目能够正常运行展示hello world 新建工程的hello world 简单修改页面后的hel","title":"训练营第一天学习笔记"},{"content":"Android内存管理知识点 问题 1: 什么是垃圾回收机制？ 解答： 垃圾回收（GC）是由Java虚拟机（JVM）垃圾回收器提供的一种对内存回收的机制。它会在内存空间不足或者内存占用过高的时候，自动回收那些没有引用的对象，以释放内存资源。垃圾回收的主要目标是自动管理内存，避免内存泄漏和内存溢出。\n问题 2: JVM的内存模型有哪些部分组成？ 解答： JVM内存模型主要分为以下几部分：\n程序计数器（Program Counter Register）：记录当前线程执行的字节码指令地址。 本地方法栈（Native Method Stacks）：用于执行本地方法。 JVM栈（JVM Stacks）：每个线程一个栈，存储局部变量、操作数栈、动态链接和方法出口等。 堆（Heap）：所有线程共享的内存区域，用于存储所有对象实例和数组。堆又分为年轻代（Young Generation）和老年代（Old Generation），其中年轻代又划分为Eden区、S0区和S1区。 方法区（Method Area）：存储已被虚拟机加载的类信息、常量、静态变量和即时编译后的代码等。 运行时常量池（Runtime Constant Pool）：方法区的一部分，用于存储编译期生成的各种字面量和符号引用。 直接内存（Direct Memory）：并不是JVM规范的一部分，但被广泛使用，主要用于NIO（New Input/Output）中的缓冲区。 问题 3: 什么是引用计数算法？ 解答： 引用计数算法是一种判断对象是否是垃圾的算法。对象被创建后，系统会给该对象初始化一个引用计数器，当该对象被引用时，计数器+1；当引用失效时，计数器-1。当计数器为0时，表示该对象不再被使用，可以进行回收。\n问题 4: 引用计数算法的优缺点是什么？ 解答：\n优点：判定比较简单，效率高。 缺点：无法避免循环引用。例如，当对象A和对象B相互引用时，即使它们都不再被其他对象引用，其引用计数器也不会变为0，导致内存泄漏。 问题 5: 如何处理引用计数算法的循环引用问题？ 解答： 引用计数算法无法直接解决循环引用问题。通常需要结合其他算法，如标记-清除算法（Mark-Sweep），来处理循环引用。标记-清除算法通过从根对象出发，遍历所有可达对象并进行标记，然后回收未被标记的对象。\n补充问题 6: 常见的垃圾回收器有哪些？ 解答：\nSerial 收集器：单线程收集，适用于单核处理器和内存较小的场景。 ParNew 收集器：Serial 收集器的多线程版本，常用于多处理器系统。 Parallel Scavenge 收集器：关注吞吐量，适用于后台运算而不要求高响应速度的场景。 CMS（Concurrent Mark-Sweep）收集器：关注低延迟，适用于需要较快响应的应用。 G1（Garbage First）收集器：适用于多核处理器和大内存场景，能够提供高吞吐量和低延迟。 补充问题 7: 如何检测和解决内存泄漏？ 解答：\n工具：使用MAT（Memory Analyzer Tool）、VisualVM、JProfiler等工具。 方法：通过分析内存快照，找到长时间存在的对象，检查它们的引用链，找出可能的内存泄漏点。 编码规范：及时释放不再使用的资源，避免长时间持有对象引用，使用弱引用（WeakReference）、软引用（SoftReference）和虚引用（PhantomReference）来辅助垃圾回收。 面试提示 面试官可能会深入探讨垃圾回收器的具体实现，如Serial、Parallel、CMS、G1等不同类型的垃圾回收器。 可能会涉及内存泄漏的具体场景及排查工具和方法，如MAT（Memory Analyzer Tool）。 了解其他垃圾回收算法及其优缺点，如标记-清除算法、标记-压缩算法、分代收集算法等。 熟悉各种垃圾回收调优参数及其配置方法，如-Xms、-Xmx、-XX、-XX 等。 可达性分析法 问题 1: 什么是可达性分析法？\n解答： 可达性分析法是一种垃圾回收算法，通过从根对象（GC Roots）开始，沿着引用链遍历整个对象图。如果一个对象到GC Roots没有任何引用链相连，则认为该对象不可达，可以被垃圾回收。\n问题 2: GC Roots包含哪些对象？\n解答： GC Roots包含以下几类对象：\n虚拟机栈（Java线程栈）中引用的对象：例如栈帧中的本地变量表。 方法区中类静态属性引用的对象：例如静态变量引用的对象。 方法区中常量引用的对象：例如常量池中的引用。 本地方法栈中JNI（Native方法）引用的对象。 问题 3: 在可达性分析中，如果一个对象不可达，是否立即被回收？\n解答： 不一定。即使一个对象在可达性分析中被判定为不可达，它也不会立即被回收。它将首先进入一个“缓冲阶段”（如在Java中会经历两次标记过程），以防止对象在缓冲阶段中被错误地回收。只有在缓冲阶段结束后，且对象仍然不可达时，才会被标记为真正的垃圾，进行回收。\nJava 中的对象引用 问题 4: Java中的对象引用有几种类型？\n解答： Java中的对象引用有四种类型：\n强引用（Strong Reference）： 示例：Object obj = new Object(); 特点：最常见的引用类型，垃圾回收器不会回收这类对象，即使内存不足，也会抛出OutOfMemoryError错误。 软引用（Soft Reference）： 特点：比强引用弱一些，当内存不足时，垃圾回收器会回收软引用指向的对象，以避免内存溢出。常用于实现缓存。 示例：SoftReference\u0026lt;Object\u0026gt; softRef = new SoftReference\u0026lt;\u0026gt;(new Object()); 弱引用（Weak Reference）： 特点：比软引用更弱，只要垃圾回收器运行，不论内存是否充足，都会回收弱引用指向的对象。常用于防止内存泄漏。 示例：WeakReference\u0026lt;Object\u0026gt; weakRef = new WeakReference\u0026lt;\u0026gt;(new Object()); 虚引用（Phantom Reference）： 特点：最弱的引用，不能通过虚引用来访问对象，唯一的作用是在对象被回收时收到一个系统通知，通常用来实现一些清理机制。 示例：PhantomReference\u0026lt;Object\u0026gt; phantomRef = new PhantomReference\u0026lt;\u0026gt;(new Object(), new ReferenceQueue\u0026lt;\u0026gt;()); 问题 5: 软引用和弱引用的区别是什么？\n解答：\n软引用： 在内存不足时，垃圾回收器会回收软引用指向的对象，以避免内存溢出。 适用于实现缓存，当内存足够时，保留对象；当内存不足时，回收对象。 弱引用： 只要垃圾回收器运行，不论内存是否充足，都会回收弱引用指向的对象。 适用于防止内存泄漏，如避免长生命周期对象引用短生命周期对象。 问题 6: 什么是虚引用，有什么用处？\n解答：\n虚引用（Phantom Reference）： 也称为幽灵引用或幻影引用，是最弱的一种引用关系。 作用：不能通过虚引用访问对象，主要用于在对象被垃圾回收时收到一个系统通知，从而进行相关清理操作。它为对象设置一个虚引用关联，这样对象被收集器回收时，会收到通知。 面试提示 面试官可能会深入探讨可达性分析法的具体实现和优化策略。 了解如何在实际项目中应用不同类型的引用，特别是软引用和弱引用的应用场景。 可以准备一些实际案例，说明如何使用这些引用类型来优化内存管理和防止内存泄漏。 Java中的对象引用 问题 1: Java中的对象引用有几种类型？请解释它们的特点。\n解答： Java中的对象引用有四种类型：\n强引用（Strong Reference）： 示例：Object obj = new Object(); 特点：最常见的引用类型，垃圾回收器不会回收这类对象，即使内存不足，也会抛出OutOfMemoryError错误。 软引用（Soft Reference）： 特点：比强引用弱一些，当内存不足时，垃圾回收器会回收软引用指向的对象，以避免内存溢出。常用于实现缓存。 示例：SoftReference\u0026lt;Object\u0026gt; softRef = new SoftReference\u0026lt;\u0026gt;(new Object()); 弱引用（Weak Reference）： 特点：比软引用更弱，只要垃圾回收器运行，不论内存是否充足，都会回收弱引用指向的对象。常用于防止内存泄漏。 示例：WeakReference\u0026lt;Object\u0026gt; weakRef = new WeakReference\u0026lt;\u0026gt;(new Object()); 虚引用（Phantom Reference）： 特点：最弱的引用，不能通过虚引用来访问对象，唯一的作用是在对象被回收时收到一个系统通知，通常用来实现一些清理机制。 示例：PhantomReference\u0026lt;Object\u0026gt; phantomRef = new PhantomReference\u0026lt;\u0026gt;(new Object(), new ReferenceQueue\u0026lt;\u0026gt;()); 问题 2: 软引用和弱引用的区别是什么？\n解答：\n软引用： 在内存不足时，垃圾回收器会回收软引用指向的对象，以避免内存溢出。 适用于实现缓存，当内存足够时，保留对象；当内存不足时，回收对象。 弱引用： 只要垃圾回收器运行，不论内存是否充足，都会回收弱引用指向的对象。 适用于防止内存泄漏，如避免长生命周期对象引用短生命周期对象。 问题 3: 什么是虚引用，有什么用处？\n解答：\n**虚引用（Phantom Reference）**也称为幽灵引用或幻影引用，是最弱的一种引用关系。 作用：不能通过虚引用访问对象，主要用于在对象被垃圾回收时收到一个系统通知，从而进行相关清理操作。虚引用与一个引用队列（ReferenceQueue）一起使用，当垃圾回收器准备回收一个对象时，如果发现它有虚引用，会在回收对象之前把这个虚引用加入到引用队列中。 Android内存泄漏 问题 1: 什么是内存泄漏？内存泄漏的原因是什么？\n解答： 内存泄漏是指程序中已分配的内存无法被释放或回收，导致内存资源逐渐耗尽的问题。内存泄漏的主要原因是短生命周期的对象被长生命周期的对象持有，导致短生命周期的对象无法回收。例如，Activity、Fragment、View或Service持有了一个短生命周期的对象并且未及时释放。\n问题 2: Android中哪些对象被长生命周期对象持有会导致内存泄漏？\n解答： 在Android中，以下对象被长生命周期对象持有会导致内存泄漏：\nActivity Fragment View Service 问题 3: 如何检测和解决内存泄漏问题？\n解答： 可以使用工具如LeakCanary来检测和解决内存泄漏问题。LeakCanary是Square公司为Android开发者提供的一个自动检测内存泄漏的工具。它基于MAT进行Android应用程序内存泄漏的自动化检测。通过集成LeakCanary提供的jar包到自己的工程中，一旦检测到内存泄漏，LeakCanary会dump Memory信息，并通过另一个进程分析内存泄漏的信息并展示出来，帮助开发者及时发现和定位内存泄漏问题。\n面试提示 面试官可能会深入探讨引用类型的具体实现和使用场景，特别是软引用和弱引用在实际项目中的应用。 对于内存泄漏部分，准备一些实际案例说明如何检测和解决内存泄漏问题，以及如何使用LeakCanary等工具进行内存管理优化。 了解内存泄漏的常见场景，如静态持有Activity、匿名内部类或非静态内部类、未取消的Handler或AsyncTask等。 ANR（Application Not Responding） 问题 1: 什么是ANR？\n解答： ANR的全称是Application Not Responding，即应用程序无响应。它指的是在Android应用的UI线程（主线程）中，有特定的消息（例如按键、触摸事件、广播、服务等）没有在规定时间内处理完毕，从而触发了ANR异常。\nAndroid系统通过消息处理机制，确保在规定的时间间隔内处理消息，如果超过这个时间，系统将认为应用程序无响应，并触发ANR异常。\n问题 2: ANR有哪几种类型？请详细解释每种类型。\n解答： ANR有三种类型：\nKeyDispatchTimeout： 描述：当按键或触摸事件没有在特定时间内无响应时触发。 默认时间：一般Android平台默认超时时间是5秒，但有些平台会修改这个时间，例如MTK平台超时时间为8秒。 BroadcastTimeout： 描述：当BroadcastReceiver在规定时间内无法处理完广播消息时触发。 默认时间：前台广播超时时间是10秒，后台广播超时时间是60秒。 ServiceTimeout： 描述：当Service在规定时间内无法处理完操作时触发。 默认时间：前台Service超时时间是20秒，后台Service超时时间是200秒。 问题 3: 如何检测ANR问题？\n解答： ANR发生时，系统会在日志中输出错误信息，并生成一个/data/anr/traces.txt的文件。这个文件中包含当前应用进程和系统进程的函数堆栈信息，是分析ANR原因的关键文件。通过检查这个文件，可以看到当前的CPU使用率等信息，这些都是重要的线索。\n问题 4: 主线程执行耗时操作会导致ANR，请解释并举例说明。\n解答： 主线程（UI线程）执行耗时操作，例如大量计算、循环、递归、I/O操作等，会占用主线程的时间，导致无法及时处理UI更新和用户输入，从而引发ANR。\n示例代码：\njavaCopy codemBind.textView.setOnClickListener(new View.OnClickListener() {\r@Override\rpublic void onClick(View v) {\rwhile (true) {\rLog.i(\u0026#34;TAG\u0026#34;, \u0026#34;主线程执行耗时操作\u0026#34;);\rtry {\rThread.sleep(500);\r} catch (Exception e) {\re.printStackTrace();\r}\r}\r}\r}); 问题 5: 死锁会导致ANR，请解释并举例说明。\n解答： 死锁是指两个或多个线程互相等待对方释放资源，导致线程永久阻塞。主线程长时间无法获取到所需的资源锁，导致无法响应用户操作，从而引发ANR。\n示例代码：\njavaCopy codepublic class MainThreadAnrActivity extends BaseActivity\u0026lt;ActivityHandlerBinding\u0026gt; { private final Object object = new Object(); private final String TAG = MainThreadAnrActivity.class.getSimpleName(); private boolean taskComplete = false; @Override protected void bindListener() { super.bindListener(); mBind.textView.setOnClickListener(new View.OnClickListener() { @Override public void onClick(View v) { synchronized (object) { Log.i(TAG, \u0026#34;死锁导致ANR \u0026#34; + taskComplete); } } }); new Thread(new Runnable() { @Override public void run() { synchronized (object) { try { Thread.sleep(30 * 1000); taskComplete = true; } catch (Exception e) { e.printStackTrace(); } } } }).start(); } } 面试提示 面试官可能会深入探讨ANR的具体类型和触发条件，了解如何分析和解决ANR问题。 准备一些实际项目中的ANR案例，说明如何检测、分析和解决这些问题。 熟悉ANR相关的日志文件（如traces.txt）的结构和内容，能够根据日志进行问题定位和分析。 ","permalink":"https://kennems.github.io/zh/posts/tech/android%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E7%9F%A5%E8%AF%86%E7%82%B9/","summary":"Android内存管理知识点 问题 1: 什么是垃圾回收机制？ 解答： 垃圾回收（GC）是由Java虚拟机（JVM）垃圾回收器提供的一种对内存回收的机制","title":"Android内存管理知识点"},{"content":"Android（5） 高级控件 SpinnerDialog + ArrayAdapter XML \u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;utf-8\u0026#34;?\u0026gt; \u0026lt;LinearLayout xmlns:android=\u0026#34;http://schemas.android.com/apk/res/android\u0026#34; xmlns:app=\u0026#34;http://schemas.android.com/apk/res-auto\u0026#34; xmlns:tools=\u0026#34;http://schemas.android.com/tools\u0026#34; android:id=\u0026#34;@+id/main\u0026#34; android:layout_width=\u0026#34;match_parent\u0026#34; android:layout_height=\u0026#34;match_parent\u0026#34; tools:context=\u0026#34;.SpinnerDropdownActivity\u0026#34; android:orientation=\u0026#34;vertical\u0026#34;\u0026gt; \u0026lt;TextView android:layout_width=\u0026#34;match_parent\u0026#34; android:layout_height=\u0026#34;wrap_content\u0026#34; android:text=\u0026#34;下拉模式的列表框\u0026#34; android:textSize=\u0026#34;17sp\u0026#34;/\u0026gt; \u0026lt;Spinner android:id=\u0026#34;@id/sp_dialog\u0026#34; android:layout_width=\u0026#34;match_parent\u0026#34; android:layout_height=\u0026#34;wrap_content\u0026#34; android:spinnerMode=\u0026#34;dialog\u0026#34;/\u0026gt; \u0026lt;/LinearLayout\u0026gt; item_select.xml \u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;utf-8\u0026#34;?\u0026gt; \u0026lt;TextView xmlns:android=\u0026#34;http://schemas.android.com/apk/res/android\u0026#34; xmlns:tools=\u0026#34;http://schemas.android.com/tools\u0026#34; android:layout_width=\u0026#34;match_parent\u0026#34; android:layout_height=\u0026#34;50dp\u0026#34; android:gravity=\u0026#34;center\u0026#34; android:textColor=\u0026#34;#0000ff\u0026#34; android:textSize=\u0026#34;17sp\u0026#34; tools:text=\u0026#34;火星\u0026#34;\u0026gt; \u0026lt;/TextView\u0026gt; Java package com.showguan.chapter08; import android.os.Bundle; import android.view.View; import android.widget.AdapterView; import android.widget.ArrayAdapter; import android.widget.Spinner; import androidx.appcompat.app.AppCompatActivity; import com.showguan.chapter08.util.ToastUtil; public class SpinnerDialogActivity extends AppCompatActivity implements AdapterView.OnItemSelectedListener { private Spinner sp_dialog; private static final String[] starArray = new String[]{ \u0026#34;水星\u0026#34;, \u0026#34;金星\u0026#34;, \u0026#34;地球\u0026#34;, \u0026#34;火星\u0026#34;, \u0026#34;木星\u0026#34;, \u0026#34;土星\u0026#34;, \u0026#34;天王星\u0026#34;, \u0026#34;海王星\u0026#34; }; @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.activity_spinner_dialog); sp_dialog = findViewById(R.id.sp_dialog); ArrayAdapter\u0026lt;String\u0026gt; starAdapter = new ArrayAdapter\u0026lt;\u0026gt;(this, R.layout.item_select, starArray); sp_dialog.setPrompt(\u0026#34;🌤选择行星\u0026#34;); sp_dialog.setAdapter(starAdapter); sp_dialog.setSelection(0); sp_dialog.setOnItemSelectedListener(this); } @Override public void onItemSelected(AdapterView\u0026lt;?\u0026gt; parent, View view, int position, long id) { ToastUtil.show(this, \u0026#34;您选择了： \u0026#34; + starArray[position]); } @Override public void onNothingSelected(AdapterView\u0026lt;?\u0026gt; parent) { } } SpinnerDropdown XML \u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;utf-8\u0026#34;?\u0026gt; \u0026lt;LinearLayout xmlns:android=\u0026#34;http://schemas.android.com/apk/res/android\u0026#34; xmlns:app=\u0026#34;http://schemas.android.com/apk/res-auto\u0026#34; xmlns:tools=\u0026#34;http://schemas.android.com/tools\u0026#34; android:id=\u0026#34;@+id/main\u0026#34; android:layout_width=\u0026#34;match_parent\u0026#34; android:layout_height=\u0026#34;match_parent\u0026#34; tools:context=\u0026#34;.SpinnerDropdownActivity\u0026#34; android:orientation=\u0026#34;vertical\u0026#34;\u0026gt; \u0026lt;TextView android:layout_width=\u0026#34;match_parent\u0026#34; android:layout_height=\u0026#34;wrap_content\u0026#34; android:text=\u0026#34;下拉模式的列表框\u0026#34; android:textSize=\u0026#34;17sp\u0026#34;/\u0026gt; \u0026lt;Spinner android:id=\u0026#34;@id/sp_dropdown\u0026#34; android:layout_width=\u0026#34;match_parent\u0026#34; android:layout_height=\u0026#34;wrap_content\u0026#34; android:spinnerMode=\u0026#34;dropdown\u0026#34;/\u0026gt; \u0026lt;/LinearLayout\u0026gt; Java package com.showguan.chapter08; import android.os.Bundle; import android.view.View; import android.widget.AdapterView; import android.widget.ArrayAdapter; import android.widget.Spinner; import androidx.activity.EdgeToEdge; import androidx.appcompat.app.AppCompatActivity; import androidx.core.graphics.Insets; import androidx.core.view.ViewCompat; import androidx.core.view.WindowInsetsCompat; import com.showguan.chapter08.util.ToastUtil; public class SpinnerDropdownActivity extends AppCompatActivity implements AdapterView.OnItemSelectedListener { private Spinner sp_dropdown; private static final String[] starArray = new String[]{ \u0026#34;水星\u0026#34;, \u0026#34;金星\u0026#34;, \u0026#34;地球\u0026#34;, \u0026#34;火星\u0026#34;, \u0026#34;木星\u0026#34;, \u0026#34;土星\u0026#34;, \u0026#34;天王星\u0026#34;, \u0026#34;海王星\u0026#34; }; @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.activity_spinner_dropdown); sp_dropdown = findViewById(R.id.sp_dropdown); ArrayAdapter\u0026lt;String\u0026gt; starAdapter = new ArrayAdapter\u0026lt;\u0026gt;(this, R.layout.item_select, starArray); sp_dropdown.setAdapter(starAdapter); sp_dropdown.setSelection(0); sp_dropdown.setOnItemSelectedListener(this); } @Override public void onItemSelected(AdapterView\u0026lt;?\u0026gt; parent, View view, int position, long id) { ToastUtil.show(this, \u0026#34;您选择了： \u0026#34; + starArray[position]); } @Override public void onNothingSelected(AdapterView\u0026lt;?\u0026gt; parent) { } } SimpleAdapter简单适配器 XML \u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;utf-8\u0026#34;?\u0026gt; \u0026lt;LinearLayout xmlns:android=\u0026#34;http://schemas.android.com/apk/res/android\u0026#34; xmlns:app=\u0026#34;http://schemas.android.com/apk/res-auto\u0026#34; xmlns:tools=\u0026#34;http://schemas.android.com/tools\u0026#34; android:id=\u0026#34;@+id/main\u0026#34; android:layout_width=\u0026#34;match_parent\u0026#34; android:layout_height=\u0026#34;match_parent\u0026#34; android:orientation=\u0026#34;vertical\u0026#34; tools:context=\u0026#34;.SpinnerDropdownActivity\u0026#34;\u0026gt; \u0026lt;TextView android:layout_width=\u0026#34;match_parent\u0026#34; android:layout_height=\u0026#34;wrap_content\u0026#34; android:gravity=\u0026#34;center\u0026#34; android:text=\u0026#34;行星的简单适配器\u0026#34; android:textSize=\u0026#34;17sp\u0026#34; /\u0026gt; \u0026lt;Spinner android:id=\u0026#34;@id/sp_icon\u0026#34; android:layout_width=\u0026#34;match_parent\u0026#34; android:layout_height=\u0026#34;wrap_content\u0026#34; android:spinnerMode=\u0026#34;dropdown\u0026#34; /\u0026gt; \u0026lt;/LinearLayout\u0026gt; Java package com.showguan.chapter08; // 包名 public class SpinnerIconActivity extends AppCompatActivity implements AdapterView.OnItemSelectedListener { // 定义一个整型数组，存储星球图标的资源ID private static final int[] iconArray = { R.drawable.shuixing, R.drawable.jinxing, R.drawable.diqiu, R.drawable.huoxing, R.drawable.muxing, R.drawable.tuxing, }; // 定义一个字符串数组，存储星球的名称 private static final String[] starArray = new String[]{ \u0026#34;水星\u0026#34;, \u0026#34;金星\u0026#34;, \u0026#34;地球\u0026#34;, \u0026#34;火星\u0026#34;, \u0026#34;木星\u0026#34;, \u0026#34;土星\u0026#34;, \u0026#34;天王星\u0026#34;, \u0026#34;海王星\u0026#34; }; @Override protected void onCreate(Bundle savedInstanceState) { // onCreate方法，活动启动时调用 super.onCreate(savedInstanceState); // 调用父类的onCreate方法 setContentView(R.layout.activity_spinner_icon); // 设置活动的布局文件 List\u0026lt;Map\u0026lt;String, Object\u0026gt;\u0026gt; list = new ArrayList\u0026lt;\u0026gt;(); // 创建一个列表，用于存储图标和名称 for (int i = 0; i \u0026lt; iconArray.length; i++) { // 遍历图标数组 Map\u0026lt;String, Object\u0026gt; item = new HashMap\u0026lt;\u0026gt;(); // 创建一个HashMap对象 item.put(\u0026#34;icon\u0026#34;, iconArray[i]); // 将图标资源ID放入Map中 item.put(\u0026#34;name\u0026#34;, starArray[i]); // 将名称放入Map中 list.add(item); // 将Map添加到列表中 } // 创建一个SimpleAdapter，连接数据和布局 SimpleAdapter startAdapter = new SimpleAdapter(this, list, // 数据源 R.layout.item_simple, // 列表项布局 new String[]{\u0026#34;icon\u0026#34;, \u0026#34;name\u0026#34;}, // Map中的键 new int[]{R.id.iv_icon, R.id.tv_name}); // 布局中的视图ID Spinner sp_icon = findViewById(R.id.sp_icon); // 获取Spinner控件 sp_icon.setAdapter(startAdapter); // 为Spinner设置适配器 sp_icon.setSelection(0); // 默认选中第0项 sp_icon.setOnItemSelectedListener(this); // 设置选项选中监听器 } @Override public void onItemSelected(AdapterView\u0026lt;?\u0026gt; parent, View view, int position, long id) { // 当选择一个选项时调用 ToastUtil.show(this, \u0026#34;你选择的是：\u0026#34; + starArray[position]); // 显示选择的星球名称 } @Override public void onNothingSelected(AdapterView\u0026lt;?\u0026gt; parent) { // 当没有选项被选择时调用 } } BaseAdapter基本适配器 BaseAdapter是一个抽象类，所以需要重写\nPlanetBaseAdapter.java package com.showguan.chapter08.adapter; // 包名 import android.content.Context; // 导入Context类 import android.view.LayoutInflater; // 导入LayoutInflater类 import android.view.View; // 导入View类 import android.view.ViewGroup; // 导入ViewGroup类 import android.widget.BaseAdapter; // 导入BaseAdapter类 import android.widget.ImageView; // 导入ImageView类 import android.widget.TextView; // 导入TextView类 import com.showguan.chapter08.R; // 导入项目的R类 import com.showguan.chapter08.bean.Planet; // 导入自定义的Planet类 import java.util.List; // 导入List接口 public class PlanetBaseAdapter extends BaseAdapter { // 定义PlanetBaseAdapter类，继承自BaseAdapter private Context mContext; // 上下文对象 private List\u0026lt;Planet\u0026gt; mPlanetList; // 存储Planet对象的列表 // 构造方法，初始化上下文和列表 public PlanetBaseAdapter(Context mContext, List\u0026lt;Planet\u0026gt; mPlanetList) { this.mContext = mContext; // 初始化上下文 this.mPlanetList = mPlanetList; // 初始化星球列表 } @Override public int getCount() { // 返回列表项的数量 return mPlanetList.size(); // 返回星球列表的大小 } @Override public Object getItem(int position) { // 获取指定位置的列表项 return mPlanetList.get(position); // 返回指定位置的Planet对象 } @Override public long getItemId(int position) { // 获取指定位置项的ID return position; // 返回位置作为项的ID } @Override public View getView(int position, View convertView, ViewGroup parent) { // 获取每个列表项的视图 // 根据布局文件item_base.xml生成转换视图对象 View view = LayoutInflater.from(mContext).inflate(R.layout.item_base, null); ImageView iv_icon = view.findViewById(R.id.iv_icon); // 获取图标视图 TextView tv_name = view.findViewById(R.id.tv_name); // 获取名称视图 TextView tv_desc = view.findViewById(R.id.tv_desc); // 获取描述视图 // 给控件设置数据 Planet planet = mPlanetList.get(position); // 获取当前星球对象 iv_icon.setImageResource(planet.image); // 设置图标资源 tv_name.setText(planet.name); // 设置星球名称 tv_desc.setText(planet.desc); // 设置星球描述 return view; // 返回生成的视图 } } item_base.xml \u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;utf-8\u0026#34;?\u0026gt; \u0026lt;LinearLayout xmlns:android=\u0026#34;http://schemas.android.com/apk/res/android\u0026#34; xmlns:tools=\u0026#34;http://schemas.android.com/tools\u0026#34; android:layout_width=\u0026#34;match_parent\u0026#34; android:layout_height=\u0026#34;wrap_content\u0026#34; android:orientation=\u0026#34;horizontal\u0026#34;\u0026gt; \u0026lt;ImageView android:id=\u0026#34;@+id/iv_icon\u0026#34; android:layout_width=\u0026#34;0dp\u0026#34; android:layout_height=\u0026#34;60dp\u0026#34; android:layout_weight=\u0026#34;1\u0026#34; tools:src=\u0026#34;@drawable/diqiu\u0026#34; /\u0026gt; \u0026lt;LinearLayout android:layout_width=\u0026#34;0dp\u0026#34; android:layout_height=\u0026#34;match_parent\u0026#34; android:layout_weight=\u0026#34;3\u0026#34; android:orientation=\u0026#34;vertical\u0026#34;\u0026gt; \u0026lt;TextView android:id=\u0026#34;@+id/tv_name\u0026#34; android:layout_width=\u0026#34;match_parent\u0026#34; android:layout_height=\u0026#34;wrap_content\u0026#34; android:text=\u0026#34;地球\u0026#34; android:textColor=\u0026#34;@color/black\u0026#34; android:textSize=\u0026#34;20sp\u0026#34; /\u0026gt; \u0026lt;TextView android:id=\u0026#34;@+id/tv_desc\u0026#34; android:layout_width=\u0026#34;match_parent\u0026#34; android:layout_height=\u0026#34;match_parent\u0026#34; android:text=\u0026#34;地球\u0026#34; android:textColor=\u0026#34;@color/black\u0026#34; android:textSize=\u0026#34;12sp\u0026#34; tools:text=\u0026#34;地球快一点毁灭吧！地球快一点毁灭吧！地球快一点毁灭吧！地球快一点毁灭吧！地球快一点毁灭吧！地球快一点毁灭吧！\u0026#34;/\u0026gt; \u0026lt;/LinearLayout\u0026gt; \u0026lt;/LinearLayout\u0026gt; BaseAdapterActivity.java package com.showguan.chapter08; // 包名 public class BaseAdapterActivity extends AppCompatActivity implements AdapterView.OnItemSelectedListener { // 定义活动类，实现选项选择监听器 private static final String[] starArray = new String[]{ // 定义星球名称数组 \u0026#34;水星\u0026#34;, \u0026#34;金星\u0026#34;, \u0026#34;地球\u0026#34;, \u0026#34;火星\u0026#34;, \u0026#34;木星\u0026#34;, \u0026#34;土星\u0026#34;, \u0026#34;天王星\u0026#34;, \u0026#34;海王星\u0026#34; }; private List\u0026lt;Planet\u0026gt; planetList; // 存储Planet对象的列表 @Override protected void onCreate(Bundle savedInstanceState) { // 活动创建时调用 super.onCreate(savedInstanceState); // 调用父类的onCreate方法 setContentView(R.layout.activity_base_adapter); // 设置活动的布局文件 Spinner sp_planet = findViewById(R.id.sp_planet); // 获取Spinner控件 planetList = Planet.getDefaultList(); // 获取默认的星球列表 PlanetBaseAdapter adapter = new PlanetBaseAdapter(this, planetList); // 创建适配器 sp_planet.setAdapter(adapter); // 为Spinner设置适配器 sp_planet.setSelection(0); // 默认选中第0项 sp_planet.setOnItemSelectedListener(this); // 设置选项选中监听器 } @Override public void onItemSelected(AdapterView\u0026lt;?\u0026gt; parent, View view, int position, long id) { // 当选择一个选项时调用 ToastUtil.show(this, \u0026#34;您选择的是\u0026#34; + planetList.get(position).name); // 显示选择的星球名称 } @Override public void onNothingSelected(AdapterView\u0026lt;?\u0026gt; parent) { // 当没有选项被选择时调用 } } BaseAdapter优化 @Override public View getView(int position, View convertView, ViewGroup parent) { // 获取每个列表项的视图 ViewHolder holder = null; if (convertView == null) { convertView = LayoutInflater.from(mContext).inflate(R.layout.item_base, null); holder = new ViewHolder(); holder.iv_icon = convertView.findViewById(R.id.iv_icon); // 获取图标视图 holder.tv_name = convertView.findViewById(R.id.tv_name); // 获取名称视图 holder.tv_desc = convertView.findViewById(R.id.tv_desc); // 获取描述视图 // 将视图持有者保存到转换视图当中 convertView.setTag(holder); } else { holder = (ViewHolder) convertView.getTag(); } Planet planet = mPlanetList.get(position); holder.iv_icon.setImageResource(planet.image); holder.tv_name.setText(planet.name); holder.tv_desc.setText(planet.desc); return convertView; } 列表视图ListView XML \u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;utf-8\u0026#34;?\u0026gt; \u0026lt;LinearLayout xmlns:android=\u0026#34;http://schemas.android.com/apk/res/android\u0026#34; xmlns:app=\u0026#34;http://schemas.android.com/apk/res-auto\u0026#34; xmlns:tools=\u0026#34;http://schemas.android.com/tools\u0026#34; android:id=\u0026#34;@+id/main\u0026#34; android:layout_width=\u0026#34;match_parent\u0026#34; android:layout_height=\u0026#34;match_parent\u0026#34; android:orientation=\u0026#34;vertical\u0026#34; tools:context=\u0026#34;.ListViewActivity\u0026#34;\u0026gt; \u0026lt;LinearLayout android:layout_width=\u0026#34;match_parent\u0026#34; android:layout_height=\u0026#34;wrap_content\u0026#34; android:orientation=\u0026#34;horizontal\u0026#34;\u0026gt; \u0026lt;CheckBox android:id=\u0026#34;@+id/ck_divider\u0026#34; android:layout_width=\u0026#34;0dp\u0026#34; android:layout_height=\u0026#34;40dp\u0026#34; android:layout_weight=\u0026#34;1\u0026#34; android:gravity=\u0026#34;start|center\u0026#34; android:text=\u0026#34;显示分割线\u0026#34; android:textSize=\u0026#34;17sp\u0026#34; /\u0026gt; \u0026lt;CheckBox android:id=\u0026#34;@+id/ck_bgc\u0026#34; android:layout_width=\u0026#34;0dp\u0026#34; android:layout_height=\u0026#34;40dp\u0026#34; android:layout_weight=\u0026#34;1\u0026#34; android:gravity=\u0026#34;start|center\u0026#34; android:text=\u0026#34;显示按压背景\u0026#34; android:textSize=\u0026#34;17sp\u0026#34; /\u0026gt; \u0026lt;/LinearLayout\u0026gt; \u0026lt;ListView android:id=\u0026#34;@+id/lv_planet\u0026#34; android:layout_width=\u0026#34;match_parent\u0026#34; android:layout_height=\u0026#34;wrap_content\u0026#34; android:divider=\u0026#34;@null\u0026#34; android:dividerHeight=\u0026#34;0dp\u0026#34; android:listSelector=\u0026#34;@color/transparent\u0026#34; /\u0026gt; \u0026lt;/LinearLayout\u0026gt; Java package com.showguan.chapter08; public class ListViewActivity extends AppCompatActivity implements AdapterView.OnItemClickListener, View.OnClickListener, CompoundButton.OnCheckedChangeListener { // 星球列表 private List\u0026lt;Planet\u0026gt; planetList; // 分割线复选框 private CheckBox ck_divider; // 背景色复选框 private CheckBox ck_bgc; // 列表视图 private ListView lv_planet; @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.activity_list_view); // 初始化列表视图 lv_planet = findViewById(R.id.lv_planet); // 初始化分割线复选框并设置监听器 ck_divider = findViewById(R.id.ck_divider); ck_divider.setOnCheckedChangeListener(this); // 初始化背景色复选框并设置监听器 ck_bgc = findViewById(R.id.ck_bgc); ck_bgc.setOnCheckedChangeListener(this); // 获取默认星球列表 planetList = Planet.getDefaultList(); // 创建适配器并设置给列表视图 PlanetBaseAdapter adapter = new PlanetBaseAdapter(this, planetList); lv_planet.setAdapter(adapter); // 设置列表项点击监听器 lv_planet.setOnItemClickListener(this); } @Override public void onItemClick(AdapterView\u0026lt;?\u0026gt; parent, View view, int position, long id) { // 当列表项被点击时，显示对应星球名称的 Toast 消息 ToastUtil.show(this, \u0026#34;您选择的是\u0026#34; + planetList.get(position).name); } @Override public void onClick(View v) { // 空实现，暂时没有需要处理的点击事件 } @Override public void onCheckedChanged(CompoundButton buttonView, boolean isChecked) { // 当复选框状态改变时调用 if (buttonView.getId() == R.id.ck_divider) { // 处理分割线复选框的状态改变 if (ck_divider.isChecked()) { // 如果复选框被选中，设置黑色分割线和高度 Drawable black = getResources().getDrawable(R.color.black, getTheme()); lv_planet.setDivider(black); lv_planet.setDividerHeight(Utils.dip2px(this, 1)); } else { // 如果复选框未选中，移除分割线 lv_planet.setDivider(null); lv_planet.setDividerHeight(Utils.dip2px(this, 0)); } } else if (buttonView.getId() == R.id.ck_bgc) { // 处理背景色复选框的状态改变 if (ck_bgc.isChecked()) { // 如果复选框被选中，设置列表项的选择器背景 lv_planet.setSelector(R.drawable.list_selector); } else { // 如果复选框未选中，设置透明背景 Drawable transparent = getResources().getDrawable(R.color.transparent, getTheme()); lv_planet.setSelector(transparent); } } } } ListView注意点 在ListView中添加按钮并设置监听时， 会导致原来的ListView中onItemClick无效，此时需要在XML文件中设置android:descendantFocusability=\u0026quot;blocksDescendants才能同时生效。\nandroid:descendantFocusability=\u0026#34;blocksDescendants\u0026#34; 网格视图GridView XML \u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;utf-8\u0026#34;?\u0026gt; \u0026lt;LinearLayout xmlns:android=\u0026#34;http://schemas.android.com/apk/res/android\u0026#34; xmlns:app=\u0026#34;http://schemas.android.com/apk/res-auto\u0026#34; xmlns:tools=\u0026#34;http://schemas.android.com/tools\u0026#34; android:id=\u0026#34;@+id/main\u0026#34; android:layout_width=\u0026#34;match_parent\u0026#34; android:layout_height=\u0026#34;wrap_content\u0026#34; android:orientation=\u0026#34;vertical\u0026#34;\u0026gt; \u0026lt;GridView android:id=\u0026#34;@+id/gv_planet\u0026#34; android:layout_width=\u0026#34;match_parent\u0026#34; android:layout_height=\u0026#34;wrap_content\u0026#34; android:numColumns=\u0026#34;2\u0026#34; android:background=\u0026#34;@color/pink\u0026#34; android:columnWidth=\u0026#34;100dp\u0026#34; android:verticalSpacing=\u0026#34;10dp\u0026#34; android:stretchMode=\u0026#34;none\u0026#34;/\u0026gt; \u0026lt;/LinearLayout\u0026gt; Java package com.showguan.chapter08; import android.os.Bundle; import android.view.View; import android.widget.AdapterView; import android.widget.GridView; import androidx.appcompat.app.AppCompatActivity; import com.showguan.chapter08.adapter.PlanetGridAdapter; import com.showguan.chapter08.entity.Planet; import com.showguan.chapter08.util.ToastUtil; import java.util.List; // GridViewActivity 类实现了 AdapterView.OnItemClickListener 接口 public class GridViewActivity extends AppCompatActivity implements AdapterView.OnItemClickListener { // 声明一个 Planet 对象的 List，用于存储行星数据 private List\u0026lt;Planet\u0026gt; planetList; @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); // 设置活动的布局文件 setContentView(R.layout.activity_grid_view); // 获取 GridView 控件 GridView gv_planet = findViewById(R.id.gv_planet); // 获取默认的行星列表 planetList = Planet.getDefaultList(); // 创建一个适配器，将行星列表传递给适配器 PlanetGridAdapter adapter = new PlanetGridAdapter(this, planetList); // 设置 GridView 的适配器 gv_planet.setAdapter(adapter); // 设置 GridView 的 item 点击事件监听器 gv_planet.setOnItemClickListener(this); // 设置 GridView 的拉伸模式 gv_planet.setStretchMode(GridView.STRETCH_COLUMN_WIDTH); } // 当 GridView 的 item 被点击时调用此方法 @Override public void onItemClick(AdapterView\u0026lt;?\u0026gt; parent, View view, int position, long id) { // 显示一个 Toast，提示用户选择了哪个行星 ToastUtil.show(this, \u0026#34;你选择了\u0026#34; + planetList.get(position).name); } } 使用GridView重构购物车 XML \u0026lt;LinearLayout xmlns:android=\u0026#34;http://schemas.android.com/apk/res/android\u0026#34; android:layout_width=\u0026#34;match_parent\u0026#34; android:layout_height=\u0026#34;match_parent\u0026#34; android:background=\u0026#34;@color/AntiqueWhite1\u0026#34; android:orientation=\u0026#34;vertical\u0026#34;\u0026gt; \u0026lt;include layout=\u0026#34;@layout/title_shopping\u0026#34; /\u0026gt; \u0026lt;GridView android:id=\u0026#34;@+id/gv_channel\u0026#34; android:layout_width=\u0026#34;match_parent\u0026#34; android:layout_height=\u0026#34;wrap_content\u0026#34; android:numColumns=\u0026#34;2\u0026#34; /\u0026gt; \u0026lt;/LinearLayout\u0026gt; Java GoodsGridAdapter.java package com.showguan.chapter08.adapter; import android.content.Context; import android.net.Uri; import android.view.LayoutInflater; import android.view.View; import android.view.ViewGroup; import android.widget.BaseAdapter; import android.widget.Button; import android.widget.ImageView; import android.widget.TextView; import com.showguan.chapter08.R; import com.showguan.chapter08.ShoppingChannelActivity; import com.showguan.chapter08.entity.GoodsInfo; import java.util.List; public class GoodsGridAdapter extends BaseAdapter { public Context mContext; public List\u0026lt;GoodsInfo\u0026gt; mGoodsInfo; private AddCartListener mAddCartListener; public GoodsGridAdapter(Context mContext, List\u0026lt;GoodsInfo\u0026gt; mGoodsInfo, AddCartListener addCartListener) { this.mContext = mContext; this.mGoodsInfo = mGoodsInfo; this.mAddCartListener = addCartListener; } @Override public int getCount() { return mGoodsInfo.size(); } @Override public Object getItem(int position) { return mGoodsInfo.get(position); } @Override public long getItemId(int position) { return position; } @Override public View getView(int position, View convertView, ViewGroup parent) { GoodsInfo goodsInfo = mGoodsInfo.get(position); ViewHolder holder; if(convertView == null){ holder = new ViewHolder(); // 将 XML 布局文件扩展为相应的 View 对象的类 convertView = LayoutInflater.from(mContext).inflate(R.layout.item_goods, null); holder.iv_thumb = convertView.findViewById(R.id.iv_thumb); holder.tv_name = convertView.findViewById(R.id.tv_name); holder.tv_price = convertView.findViewById(R.id.tv_price); holder.btn_add = convertView.findViewById(R.id.btn_add); convertView.setTag(holder); }else{ holder = (ViewHolder) convertView.getTag(); } GoodsInfo info = mGoodsInfo.get(position); holder.iv_thumb.setImageURI(Uri.parse(info.picPath)); holder.tv_name.setText(info.name); holder.tv_price.setText(String.valueOf(info.price)); holder.btn_add.setOnClickListener(v -\u0026gt; { // ShoppingChannelActivity activity = (ShoppingChannelActivity) mContext; // activity.addToCart(info.id, info.name); mAddCartListener.addToCart(info.id, info.name); }); return convertView; } public final class ViewHolder{ public ImageView iv_thumb; public TextView tv_name; public TextView tv_price; public Button btn_add; } public interface AddCartListener{ abstract void addToCart(int goodsId, String goodsName); } } ShoppingChannelActivity.java package com.showguan.chapter08; // ShoppingChannelActivity 类实现了 GoodsGridAdapter.AddCartListener 和 View.OnClickListener 接口 public class ShoppingChannelActivity extends AppCompatActivity implements GoodsGridAdapter.AddCartListener, View.OnClickListener { private static String TAG = \u0026#34;Kennem\u0026#34;; // 日志标签 private ShoppingDBHelper mDBHelper; // 数据库助手对象 private TextView tv_title; // 显示标题的 TextView private GridView gv_channel; // 显示商品的 GridView private TextView tv_count; // 显示购物车商品数量的 TextView @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); // 设置活动的布局文件 setContentView(R.layout.activity_shopping_channel); // 初始化控件 tv_title = findViewById(R.id.tv_title); tv_title.setText(\u0026#34;手机商城\u0026#34;); tv_count = findViewById(R.id.tv_count); gv_channel = findViewById(R.id.gv_channel); // 设置点击事件监听器 findViewById(R.id.iv_back).setOnClickListener(this); findViewById(R.id.iv_cart).setOnClickListener(this); // 初始化数据库助手并打开读写链接 mDBHelper = ShoppingDBHelper.getInstance(this); mDBHelper.openWriteLink(); mDBHelper.openReadLink(); // 显示商品信息 showGoods(); } @Override protected void onResume() { super.onResume(); // 在活动恢复时，显示购物车的总信息 showCartTotalInfo(); } // 显示购物车总信息的方法 private void showCartTotalInfo() { int count = mDBHelper.countCartInfo(); MyApplication.getInstance().goodsCount = count; tv_count.setText(String.valueOf(count)); } // 显示商品信息的方法 private void showGoods() { List\u0026lt;GoodsInfo\u0026gt; list = mDBHelper.queryAllGoods(); GoodsGridAdapter adapter = new GoodsGridAdapter(this, list, this); gv_channel.setAdapter(adapter); } // 添加商品到购物车的方法 @Override public void addToCart(int goodsId, String name) { mDBHelper.insertCartInfo(goodsId); int count = ++MyApplication.getInstance().goodsCount; tv_count.setText(String.valueOf(count)); ToastUtil.show(this, \u0026#34;已添加一部 \u0026#34; + name + \u0026#34;到购物车成功！\u0026#34;); } @Override protected void onDestroy() { super.onDestroy(); // 在活动销毁时，关闭数据库链接 mDBHelper.closeLink(); } // 处理点击事件的方法 @Override public void onClick(View v) { if (v.getId() == R.id.iv_back) { // 点击返回按钮时，结束当前活动 finish(); } else if (v.getId() == R.id.iv_cart) { // 点击购物车按钮时，启动购物车活动 Intent intent = new Intent(this, ShoppingCartActivity.class); intent.setFlags(Intent.FLAG_ACTIVITY_SINGLE_TOP); startActivity(intent); } } @Override public void onPointerCaptureChanged(boolean hasCapture) { super.onPointerCaptureChanged(hasCapture); } } ViewPager XML \u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;utf-8\u0026#34;?\u0026gt; \u0026lt;LinearLayout xmlns:android=\u0026#34;http://schemas.android.com/apk/res/android\u0026#34; xmlns:app=\u0026#34;http://schemas.android.com/apk/res-auto\u0026#34; xmlns:tools=\u0026#34;http://schemas.android.com/tools\u0026#34; android:id=\u0026#34;@+id/main\u0026#34; android:layout_width=\u0026#34;match_parent\u0026#34; android:layout_height=\u0026#34;match_parent\u0026#34; android:orientation=\u0026#34;vertical\u0026#34; tools:context=\u0026#34;.ViewPageActivity\u0026#34;\u0026gt; \u0026lt;androidx.viewpager.widget.ViewPager android:id=\u0026#34;@+id/vp_content\u0026#34; android:layout_width=\u0026#34;match_parent\u0026#34; android:layout_height=\u0026#34;300dp\u0026#34; /\u0026gt; \u0026lt;/LinearLayout\u0026gt; Java package com.showguan.chapter08; import android.os.Bundle; import android.view.View; import androidx.activity.EdgeToEdge; import androidx.appcompat.app.AppCompatActivity; import androidx.core.graphics.Insets; import androidx.core.view.ViewCompat; import androidx.core.view.WindowInsetsCompat; import androidx.viewpager.widget.ViewPager; import com.showguan.chapter08.adapter.ImagePagerAdapter; import com.showguan.chapter08.entity.GoodsInfo; import com.showguan.chapter08.util.ToastUtil; import java.util.ArrayList; public class ViewPageActivity extends AppCompatActivity implements ViewPager.OnPageChangeListener { // 商品信息列表 private ArrayList\u0026lt;GoodsInfo\u0026gt; mGoodsList; @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); // 设置当前活动的布局文件 setContentView(R.layout.activity_view_page); // 获取 ViewPager 控件 ViewPager vp_content = findViewById(R.id.vp_content); // 获取默认的商品信息列表 mGoodsList = GoodsInfo.getDefaultList(); // 创建 ImagePagerAdapter 适配器 ImagePagerAdapter adapter = new ImagePagerAdapter(this, mGoodsList); // 为 ViewPager 设置适配器 vp_content.setAdapter(adapter); // 设置页面变更监听器 vp_content.addOnPageChangeListener(this); } /** * 在翻页过程中触发 * @param position 当前页面位置 * @param positionOffset 页面偏移百分比 * @param positionOffsetPixels 页面偏移像素 */ @Override public void onPageScrolled(int position, float positionOffset, int positionOffsetPixels) { // 可以在这里实现页面滚动时的相关逻辑 } /** * 页面选中时触发 * @param position 选中页面的位置 */ @Override public void onPageSelected(int position) { // 显示当前选中页面的商品名称 ToastUtil.show(this, \u0026#34;当前滑动的页面为 \u0026#34; + mGoodsList.get(position).name); } /** * 翻页状态改变时触发 * @param state 页面状态 */ @Override public void onPageScrollStateChanged(int state) { // 可以在这里实现页面滚动状态变化时的相关逻辑 } } 翻页标签栏PagerTabStrip XML \u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;utf-8\u0026#34;?\u0026gt; \u0026lt;LinearLayout xmlns:android=\u0026#34;http://schemas.android.com/apk/res/android\u0026#34; xmlns:app=\u0026#34;http://schemas.android.com/apk/res-auto\u0026#34; xmlns:tools=\u0026#34;http://schemas.android.com/tools\u0026#34; android:id=\u0026#34;@+id/main\u0026#34; android:layout_width=\u0026#34;match_parent\u0026#34; android:layout_height=\u0026#34;match_parent\u0026#34; android:orientation=\u0026#34;vertical\u0026#34; tools:context=\u0026#34;.PagerTabActivity\u0026#34;\u0026gt; \u0026lt;androidx.viewpager.widget.ViewPager android:id=\u0026#34;@+id/vp_content\u0026#34; android:layout_width=\u0026#34;match_parent\u0026#34; android:layout_height=\u0026#34;wrap_content\u0026#34;\u0026gt; \u0026lt;androidx.viewpager.widget.PagerTabStrip android:id=\u0026#34;@+id/pts_tab\u0026#34; android:layout_width=\u0026#34;wrap_content\u0026#34; android:layout_height=\u0026#34;wrap_content\u0026#34; /\u0026gt; \u0026lt;/androidx.viewpager.widget.ViewPager\u0026gt; \u0026lt;/LinearLayout\u0026gt; Java package com.showguan.chapter08; import android.graphics.Color; import android.os.Bundle; import android.util.TypedValue; import android.view.View; import androidx.activity.EdgeToEdge; import androidx.appcompat.app.AppCompatActivity; import androidx.core.graphics.Insets; import androidx.core.view.ViewCompat; import androidx.core.view.WindowInsetsCompat; import androidx.viewpager.widget.PagerTabStrip; import androidx.viewpager.widget.ViewPager; import com.showguan.chapter08.adapter.ImagePagerAdapter; import com.showguan.chapter08.entity.GoodsInfo; import com.showguan.chapter08.util.ToastUtil; import java.util.ArrayList; public class PagerTabActivity extends AppCompatActivity implements ViewPager.OnPageChangeListener { // 商品信息列表 private ArrayList\u0026lt;GoodsInfo\u0026gt; mGoodsList; @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.activity_pager_tab); initPagerStrip(); initViewPager(); } // 初始化翻页标签栏 private void initPagerStrip() { PagerTabStrip pts_tab = findViewById(R.id.pts_tab); pts_tab.setTextSize(TypedValue.COMPLEX_UNIT_SP, 20); pts_tab.setTextColor(Color.GRAY); } private void initViewPager() { // 获取 ViewPager 控件 ViewPager vp_content = findViewById(R.id.vp_content); // 获取默认的商品信息列表 mGoodsList = GoodsInfo.getDefaultList(); // 创建 ImagePagerAdapter 适配器 ImagePagerAdapter adapter = new ImagePagerAdapter(this, mGoodsList); // 为 ViewPager 设置适配器 vp_content.setAdapter(adapter); // 设置页面变更监听器 vp_content.addOnPageChangeListener(this); vp_content.setCurrentItem(2); } @Override public void onPageScrolled(int position, float positionOffset, int positionOffsetPixels) { } @Override public void onPageSelected(int position) { ToastUtil.show(this, \u0026#34;当前滑动的页面为 \u0026#34; + mGoodsList.get(position).name); } @Override public void onPageScrollStateChanged(int state) { } } 简单的启动引导页 碎片Fragment ⭐⭐⭐⭐⭐ 传统的Activity并不能很好的处理大屏问题，所以急需一个碎片化的东西能够划区域的展示内容，并且有属于自己的独立可操作空间，所以就出现了Fragment。\nFragment注册 静态注册在布局文件中直接指定Fragment，而动态注册直到代码中才动态添加Fragment。\nFragment声明周期 ","permalink":"https://kennems.github.io/zh/posts/tech/android5/","summary":"Android（5） 高级控件 SpinnerDialog + ArrayAdapter XML \u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;utf-8\u0026#34;?\u0026gt; \u0026lt;LinearLayout xmlns:android=\u0026#34;http://schemas.android.com/apk/res/android\u0026#34; xmlns:app=\u0026#34;http://schemas.android.com/apk/res-auto\u0026#34; xmlns:tools=\u0026#34;http://schemas.android.com/tools\u0026#34; android:id=\u0026#34;@+id/main\u0026#34; android:layout_width=\u0026#34;match_parent\u0026#34; android:layout_height=\u0026#34;match_parent\u0026#34; tools:context=\u0026#34;.SpinnerDropdownActivity\u0026#34; android:orientation=\u0026#34;vertical\u0026#34;\u0026gt; \u0026lt;TextView android:layout_width=\u0026#34;match_parent\u0026#34; android:layout_height=\u0026#34;wrap_content\u0026#34; android:text=\u0026#34;下拉模式的列表框\u0026#34; android:textSize=\u0026#34;17sp\u0026#34;/\u0026gt; \u0026lt;Spinner android:id=\u0026#34;@id/sp_dialog\u0026#34; android:layout_width=\u0026#34;match_parent\u0026#34; android:layout_height=\u0026#34;wrap_content\u0026#34; android:spinnerMode=\u0026#34;dialog\u0026#34;/\u0026gt;","title":"Android（5）"},{"content":"《数字图像处理》课程综合项目——基于多种滤波器的图像去噪算法比较与分析 GUI界面： 本项目源代码和报告均已开源：\n开源仓库：https://github.com/Kennems/Image_Processing_GUI\n项目简介 本项目旨在设计一个基于Matlab的图像去噪GUI系统，通过应用多种图像去噪算法，提高图像的质量和可用性。该系统集成了多种经典和现代的去噪方法，并提供了直观的用户界面，方便用户对图像进行去噪处理和效果评估。\n主要功能概述 1. 图像去噪方法 系统实现了多种常见的图像去噪方法，包括：\n均值滤波：通过邻域像素的平均值来替代中心像素的值，有效减少高频噪声，但可能导致图像细节丢失 。 中值滤波：采用滤波窗口内像素的中值替代中心像素的值，能够有效去除椒盐噪声和脉冲噪声，同时保留图像边缘和细节信息 。 高斯低通滤波：利用高斯函数对图像进行低通滤波，平滑图像并减少噪声 。 巴特沃斯低通滤波：一种频域滤波方法，适用于去除频率较高的噪声 。 小波变换：通过小波分解和重构来实现图像去噪，能够有效保留图像的细节和边缘 。 非局部均值去噪：基于图像中相似区域的像素值信息，对目标像素进行加权平均，保留图像细节但计算复杂度较高 。 维纳滤波：基于最小均方误差准则，恢复由噪声污染的图像，效果显著但需预估噪声性质 。 同态滤波：结合对数变换和频域滤波，增强图像对比度，去除光照变化和噪声 。 2. 图像噪声添加 系统支持多种噪声类型的添加，以模拟实际应用中的噪声环境，包括高斯噪声、椒盐噪声、泊松噪声和运动噪声等 。\n3. 去噪效果评估 提供了多种图像质量评价指标，包括峰值信噪比（PSNR）、均方误差（MSE）、信噪比（SNR）和结构相似性指数（SSIM）等，帮助用户客观比较不同去噪算法的性能 。\n4. 用户界面 系统采用Matlab GUI设计，用户可以通过界面选择去噪方法、设置相关参数、添加噪声以及查看去噪效果图，操作简便直观 。\n结论 本项目设计的数字图像处理GUI系统，通过集成多种图像去噪方法和提供直观的用户界面，方便用户进行图像去噪处理和效果评估。该系统具有重要的理论意义和实际应用价值，为推动数字图像处理技术的进步和满足实际应用需求提供了有力支持。\n","permalink":"https://kennems.github.io/zh/posts/tech/%E6%95%B0%E5%AD%97%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86%E8%AF%BE%E7%A8%8B%E7%BB%BC%E5%90%88%E9%A1%B9%E7%9B%AE%E5%9F%BA%E4%BA%8E%E5%A4%9A%E7%A7%8D%E6%BB%A4%E6%B3%A2%E5%99%A8%E7%9A%84%E5%9B%BE%E5%83%8F%E5%8E%BB%E5%99%AA%E7%AE%97%E6%B3%95%E6%AF%94%E8%BE%83%E4%B8%8E%E5%88%86%E6%9E%90/","summary":"《数字图像处理》课程综合项目——基于多种滤波器的图像去噪算法比较与分析 GUI界面： 本项目源代码和报告均已开源： 开源仓库：https://gi","title":"《数字图像处理》课程综合项目(Matlab)"},{"content":"Android（4） 就算是最低的15x15都已经不错了，以后还有时间去学，上了研究生也没人能保证你有15x15的收入\n内容提供者(ContentProvider) CountentProvider为App存取内部数据提供统一的外部接口，让不同的应用之间得以共享数据\nUri 通用资源标识符 Universal Resource Identifer， 代表数据操作的地址，每一个ContentProvider都会有唯一的地址。ContentProvider使用的Uri语法结构如下：\ncontent://authority/data_path/id content://是通用前缀，表示该Uri用于ContentProvider定位资源。 authority是授权者名称，用来确定具体由哪一个ContentProvider提供资源。因此一般anthority都由类的小写全称组成，以保证唯一性。 data_path是数据路径，用来确定请求的是哪个数据集 id是数据编号，用来请求单条数据。如果是多条这个字段忽略。 server内容提供程序 UserInfoProvider.java package com.showguan.chapter07_server.provider; import android.content.ContentProvider; import android.content.ContentValues; import android.content.UriMatcher; import android.database.Cursor; import android.database.sqlite.SQLiteDatabase; import android.net.Uri; import android.util.Log; import com.showguan.chapter07_server.database.UserDBHelper; public class UserInfoProvider extends ContentProvider { private static String TAG = \u0026#34;Kennem\u0026#34;; private UserDBHelper dbHelper; private static final int USER = 1; private static final int USERS = 2; private static final UriMatcher URI_MATCHER = new UriMatcher(UriMatcher.NO_MATCH); static { URI_MATCHER.addURI(UserInfoContent.AUTHORITIES, \u0026#34;/user/#\u0026#34;, USER); URI_MATCHER.addURI(UserInfoContent.AUTHORITIES, \u0026#34;/user\u0026#34;, USERS); } @Override public boolean onCreate() { // TODO: Implement this to initialize your content provider on startup. Log.d(TAG, \u0026#34;ContentProvider onCreate: \u0026#34;); dbHelper = UserDBHelper.getInstance(getContext()); return true; } @Override public Uri insert(Uri uri, ContentValues values) { if (URI_MATCHER.match(uri) == USERS) { SQLiteDatabase db = dbHelper.getWritableDatabase(); db.insert(UserDBHelper.TABLE_NAME, null, values); } return uri; } @Override public Cursor query(Uri uri, String[] projection, String selection, String[] selectionArgs, String sortOrder) { if (URI_MATCHER.match(uri) == USERS) { Log.d(TAG, \u0026#34;UserInfoProvider query: \u0026#34;); SQLiteDatabase db = dbHelper.getReadableDatabase(); Cursor cursor = db.query(UserDBHelper.TABLE_NAME, projection, selection, selectionArgs, null, null, null); return cursor; } return null; } @Override public int delete(Uri uri, String selection, String[] selectionArgs) { int count = 0; switch (URI_MATCHER.match(uri)) { case USER: String id = uri.getLastPathSegment(); SQLiteDatabase db1 = dbHelper.getWritableDatabase(); count = db1.delete(UserDBHelper.TABLE_NAME, \u0026#34;_id = ?\u0026#34;, new String[]{id}); db1.close(); break; case USERS: SQLiteDatabase db2 = dbHelper.getWritableDatabase(); count = db2.delete(UserDBHelper.TABLE_NAME, selection, selectionArgs); db2.close(); break; } return count; } @Override public String getType(Uri uri) { // TODO: Implement this to handle requests for the MIME type of the data // at the given URI. throw new UnsupportedOperationException(\u0026#34;Not yet implemented\u0026#34;); } @Override public int update(Uri uri, ContentValues values, String selection, String[] selectionArgs) { // TODO: Implement this to handle requests to update one or more rows. throw new UnsupportedOperationException(\u0026#34;Not yet implemented\u0026#34;); } } UserInfoContent.java 定义常量 package com.showguan.chapter07_server.provider; import android.net.Uri; import android.provider.BaseColumns; public class UserInfoContent implements BaseColumns { public static final String AUTHORITIES = \u0026#34;com.showguan.chapter07_server.provider.UserInfoProvider\u0026#34;; public static final Uri CONTENT_URI = Uri.parse(\u0026#34;content://\u0026#34; + AUTHORITIES + \u0026#34;/user\u0026#34;); public static final String USER_NAME = \u0026#34;name\u0026#34;; public static final String USER_AGE = \u0026#34;age\u0026#34;; public static final String USER_HEIGHT = \u0026#34;height\u0026#34;; public static final String USER_WEIGHT = \u0026#34;weight\u0026#34;; public static final String USER_MARRIED = \u0026#34;married\u0026#34;; } UserDBHelper.java创建表 package com.showguan.chapter07_server.database; import android.content.ContentValues; import android.content.Context; import android.database.Cursor; import android.database.sqlite.SQLiteDatabase; import android.database.sqlite.SQLiteOpenHelper; import androidx.annotation.Nullable; import java.util.ArrayList; import java.util.List; public class UserDBHelper extends SQLiteOpenHelper { public static final String DB_NAME = \u0026#34;user.db\u0026#34;; public static final String TABLE_NAME = \u0026#34;user_info\u0026#34;; private static final int DB_VERSION = 2; private static UserDBHelper mHelper = null; private SQLiteDatabase mRDB = null; private SQLiteDatabase mWDB = null; private UserDBHelper(@Nullable Context context) { super(context, DB_NAME, null, DB_VERSION); } public static UserDBHelper getInstance(Context context) { if (mHelper == null) { mHelper = new UserDBHelper(context); } return mHelper; } @Override public void onCreate(SQLiteDatabase db) { String sql = \u0026#34;CREATE TABLE IF NOT EXISTS \u0026#34; + TABLE_NAME + \u0026#34; (\u0026#34; + \u0026#34;_id INTEGER PRIMARY KEY AUTOINCREMENT NOT NULL,\u0026#34; + \u0026#34; name VARCHAR NOT NULL,\u0026#34; + \u0026#34; age INTEGER NOT NULL,\u0026#34; + \u0026#34; height LONG NOT NULL,\u0026#34; + \u0026#34; weight FLOAT NOT NULL,\u0026#34; + \u0026#34; married INTEGER NOT NULL);\u0026#34;; db.execSQL(sql); } @Override public void onUpgrade(SQLiteDatabase db, int oldVersion, int newVersion) { } } client接受数据端 首先在Manifest中添加如下，表示需要访问的内容提供者的包\nContentWriteActivity.java package com.showguan.chapter07_client; public class ContentWriteActivity extends AppCompatActivity implements View.OnClickListener { private static String TAG = \u0026#34;Kennem\u0026#34;; private EditText et_name; private EditText et_age; private EditText et_height; private EditText et_weight; private CheckBox ck_isMarried; @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.activity_content_write); et_name = findViewById(R.id.et_name); et_age = findViewById(R.id.et_age); et_height = findViewById(R.id.et_height); et_weight = findViewById(R.id.et_weight); ck_isMarried = findViewById(R.id.ck_isMarried); findViewById(R.id.btn_read).setOnClickListener(this); findViewById(R.id.btn_write).setOnClickListener(this); findViewById(R.id.btn_delete).setOnClickListener(this); } @SuppressLint(\u0026#34;Range\u0026#34;) @Override public void onClick(View v) { if(v.getId() == R.id.btn_write){ ContentValues values = new ContentValues(); values.put(UserInfoContent.USER_NAME, et_name.getText().toString()); values.put(UserInfoContent.USER_AGE, et_age.getText().toString()); values.put(UserInfoContent.USER_HEIGHT, et_height.getText().toString()); values.put(UserInfoContent.USER_WEIGHT, et_weight.getText().toString()); values.put(UserInfoContent.USER_MARRIED, ck_isMarried.isChecked()); getContentResolver().insert(UserInfoContent.CONTENT_URI, values); ToastUtil.show(this, \u0026#34;保存成功！\u0026#34;); } else if (v.getId() == R.id.btn_read) { Cursor cursor = getContentResolver().query(UserInfoContent.CONTENT_URI, null, null, null, null); if (cursor != null) { while(cursor.moveToNext()){ User info = new User(); info.setId(cursor.getInt(cursor.getColumnIndex(UserInfoContent._ID))); info.setAge(cursor.getInt(cursor.getColumnIndex(UserInfoContent.USER_AGE))); info.setName(cursor.getString(cursor.getColumnIndex(UserInfoContent.USER_NAME))); info.setHeight(cursor.getFloat(cursor.getColumnIndex(UserInfoContent.USER_HEIGHT))); info.setWeight(cursor.getFloat(cursor.getColumnIndex(UserInfoContent.USER_WEIGHT))); info.setMarried(cursor.getInt(cursor.getColumnIndex(UserInfoContent.USER_MARRIED)) == 1); Log.d(TAG, info.toString()); } cursor.close(); } } else if (v.getId() == R.id.btn_delete) { // 根据id删除单条 // Uri uri = ContentUris.withAppendedId(UserInfoContent.CONTENT_URI, 1); // int count = getContentResolver().delete(uri, null, null); //根据名称删除多条 int count = getContentResolver().delete(UserInfoContent.CONTENT_URI, \u0026#34;name = ?\u0026#34;, new String[]{et_name.getText().toString()}); if(count \u0026gt; 0){ ToastUtil.show(this, \u0026#34;删除成功\u0026#34;); }else{ ToastUtil.show(this, \u0026#34;删除失败，不存在名为\u0026#34; + et_name.getText().toString() + \u0026#34;的用户！\u0026#34;); } } } } 通过Uri格式删除一个用户 // 根据id删除单条 Uri uri = ContentUris.withAppendedId(UserInfoContent.CONTENT_URI, 1); int count = getContentResolver().delete(uri, null, null); 动态申请权限 步骤：\n检查App是否开启了指定权限 调用ContextCompat的checkSelfPermission方法 请求系统弹窗，以便用户选择是否开启权限 调用ActivityCompat的requestPermission方法，即可命令系统自动弹出权限申请窗口。 判断用户的权限选择结果 重写活动页面的权限请求回调方法onRequestPermissionResult， 在该方法内部处理用户的权限选择结果。 懒汉式获取权限 首先添加按钮事件监听： @Override public void onClick(View v) { if (v.getId() == R.id.btn_contacts) { PermissionUtil.checkPermission(this, PERMISSIONS_CONTACTS, REQUEST_CODE_CONTACTS); } else if (v.getId() == R.id.btn_sms) { PermissionUtil.checkPermission(this, PERMISSIONS_SMS, REQUEST_CODE_SMS); } } 在工具类中判断是否有没有获取到的权限，申请获取 public static boolean checkPermission(Activity act, String[] permissions, int requestCode){ if(Build.VERSION.SDK_INT \u0026gt;= Build.VERSION_CODES.M){ int check = PackageManager.PERMISSION_GRANTED; for (String permission : permissions) { check = ContextCompat.checkSelfPermission(act, permission); if(check != PackageManager.PERMISSION_GRANTED){ break; } } if(check != PackageManager.PERMISSION_GRANTED){ ActivityCompat.requestPermissions(act, permissions, requestCode); return false; } } return true; } 其中ActivityCompat.requestPermissions方法的参数在onRequestPermissionsResult中返回 @Override public void onRequestPermissionsResult(int requestCode, @NonNull String[] permissions, @NonNull int[] grantResults) { super.onRequestPermissionsResult(requestCode, permissions, grantResults); switch (requestCode) { case REQUEST_CODE_CONTACTS: for (int grantResult : grantResults) { Log.d(TAG, String.valueOf(grantResult)); } if (PermissionUtil.checkGranted(grantResults)) { Log.d(TAG, \u0026#34;通讯录权限获取成功\u0026#34;); } else { ToastUtil.show(this, \u0026#34;获取权限失败!\u0026#34;); jumpToSettings(); } break; case REQUEST_CODE_SMS: if (PermissionUtil.checkGranted(grantResults)) { Log.d(TAG, \u0026#34;短信收发权限获取成功\u0026#34;); } else { ToastUtil.show(this, \u0026#34;获取权限失败!\u0026#34;); jumpToSettings(); } break; } } PermissionLazyActivity.java package com.showguan.chapter07_client; import android.Manifest; import android.content.Intent; import android.net.Uri; import android.os.Bundle; import android.provider.Settings; import android.util.Log; import android.view.View; import androidx.activity.EdgeToEdge; import androidx.annotation.NonNull; import androidx.appcompat.app.AppCompatActivity; import androidx.core.graphics.Insets; import androidx.core.view.ViewCompat; import androidx.core.view.WindowInsetsCompat; import com.showguan.chapter07_client.util.PermissionUtil; import com.showguan.chapter07_client.util.ToastUtil; public class PermissionLazyActivity extends AppCompatActivity implements View.OnClickListener { private static String TAG = \u0026#34;Kennem\u0026#34;; private static final String[] PERMISSIONS_CONTACTS = new String[]{ android.Manifest.permission.READ_CONTACTS, android.Manifest.permission.WRITE_CONTACTS }; private static final String[] PERMISSIONS_SMS = new String[]{ Manifest.permission.SEND_SMS, Manifest.permission.READ_SMS }; private static final int REQUEST_CODE_CONTACTS = 1; private static final int REQUEST_CODE_SMS = 2; @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.activity_permission_lazy); findViewById(R.id.btn_contacts).setOnClickListener(this); findViewById(R.id.btn_sms).setOnClickListener(this); } @Override public void onClick(View v) { if (v.getId() == R.id.btn_contacts) { PermissionUtil.checkPermission(this, PERMISSIONS_CONTACTS, REQUEST_CODE_CONTACTS); } else if (v.getId() == R.id.btn_sms) { PermissionUtil.checkPermission(this, PERMISSIONS_SMS, REQUEST_CODE_SMS); } } @Override public void onRequestPermissionsResult(int requestCode, @NonNull String[] permissions, @NonNull int[] grantResults) { super.onRequestPermissionsResult(requestCode, permissions, grantResults); switch (requestCode) { case REQUEST_CODE_CONTACTS: for (int grantResult : grantResults) { Log.d(TAG, String.valueOf(grantResult)); } if (PermissionUtil.checkGranted(grantResults)) { Log.d(TAG, \u0026#34;通讯录权限获取成功\u0026#34;); } else { ToastUtil.show(this, \u0026#34;获取权限失败!\u0026#34;); jumpToSettings(); } break; case REQUEST_CODE_SMS: if (PermissionUtil.checkGranted(grantResults)) { Log.d(TAG, \u0026#34;短信收发权限获取成功\u0026#34;); } else { ToastUtil.show(this, \u0026#34;获取权限失败!\u0026#34;); jumpToSettings(); } break; } } private void jumpToSettings() { Intent intent = new Intent(); intent.setAction(Settings.ACTION_APPLICATION_DETAILS_SETTINGS); intent.setData(Uri.fromParts(\u0026#34;package\u0026#34;, getPackageName(), null)); intent.setFlags(Intent.FLAG_ACTIVITY_NEW_TASK); startActivity(intent); } } 跳转到系统权限设计界面： private void jumpToSettings() { Intent intent = new Intent(); intent.setAction(Settings.ACTION_APPLICATION_DETAILS_SETTINGS); intent.setData(Uri.fromParts(\u0026#34;package\u0026#34;, getPackageName(), null)); intent.setFlags(Intent.FLAG_ACTIVITY_NEW_TASK); startActivity(intent); } 饿汉式获取权限 PermissionHungryActivity.java 不同于懒汉式，创建时即申请全部权限\npackage com.showguan.chapter07_client; import android.Manifest; import android.content.Intent; import android.content.pm.PackageManager; import android.net.Uri; import android.os.Bundle; import android.provider.Settings; import android.util.Log; import android.view.View; import androidx.activity.EdgeToEdge; import androidx.annotation.NonNull; import androidx.appcompat.app.AppCompatActivity; import androidx.core.graphics.Insets; import androidx.core.view.ViewCompat; import androidx.core.view.WindowInsetsCompat; import com.showguan.chapter07_client.util.PermissionUtil; import com.showguan.chapter07_client.util.ToastUtil; public class PermissionHungryActivity extends AppCompatActivity implements View.OnClickListener { private static String TAG = \u0026#34;Kennem\u0026#34;; private static final String[] PERMISSIONS_ALL = new String[]{ android.Manifest.permission.READ_CONTACTS, android.Manifest.permission.WRITE_CONTACTS, android.Manifest.permission.SEND_SMS, Manifest.permission.READ_SMS }; private static final int REQUEST_CODE_ALL = 1; private static final int REQUEST_CODE_CONTACTS = 2; private static final int REQUEST_CODE_SMS = 3; @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.activity_permission_lazy); findViewById(R.id.btn_contacts).setOnClickListener(this); findViewById(R.id.btn_sms).setOnClickListener(this); PermissionUtil.checkPermission(this, PERMISSIONS_ALL, REQUEST_CODE_ALL); } @Override public void onClick(View v) { if (v.getId() == R.id.btn_contacts) { PermissionUtil.checkPermission(this, new String[]{PERMISSIONS_ALL[0], PERMISSIONS_ALL[1]}, REQUEST_CODE_CONTACTS); } else if (v.getId() == R.id.btn_sms) { PermissionUtil.checkPermission(this, new String[]{PERMISSIONS_ALL[2], PERMISSIONS_ALL[3]}, REQUEST_CODE_SMS); } } @Override public void onRequestPermissionsResult(int requestCode, @NonNull String[] permissions, @NonNull int[] grantResults) { super.onRequestPermissionsResult(requestCode, permissions, grantResults); switch (requestCode) { case REQUEST_CODE_ALL: if (PermissionUtil.checkGranted(grantResults)) { Log.d(TAG, \u0026#34;所有权限获取成功！\u0026#34;); } else { for (int i = 0; i \u0026lt; grantResults.length; i++) { if (grantResults[i] != PackageManager.PERMISSION_GRANTED) { switch (permissions[i]) { case Manifest.permission.READ_CONTACTS: case Manifest.permission.WRITE_CONTACTS: ToastUtil.show(this, \u0026#34;获取通讯录读写权限失败\u0026#34;); jumpToSettings(); return; case Manifest.permission.SEND_SMS: case Manifest.permission.READ_SMS: ToastUtil.show(this, \u0026#34;获取短信读写权限失败\u0026#34;); jumpToSettings(); return; } } } } break; case REQUEST_CODE_CONTACTS: for (int grantResult : grantResults) { Log.d(TAG, String.valueOf(grantResult)); } if (PermissionUtil.checkGranted(grantResults)) { Log.d(TAG, \u0026#34;通讯录权限获取成功\u0026#34;); } else { ToastUtil.show(this, \u0026#34;获取权限失败!\u0026#34;); jumpToSettings(); } break; case REQUEST_CODE_SMS: if (PermissionUtil.checkGranted(grantResults)) { Log.d(TAG, \u0026#34;短信收发权限获取成功\u0026#34;); } else { ToastUtil.show(this, \u0026#34;获取权限失败!\u0026#34;); jumpToSettings(); } break; } } private void jumpToSettings() { Intent intent = new Intent(); intent.setAction(Settings.ACTION_APPLICATION_DETAILS_SETTINGS); intent.setData(Uri.fromParts(\u0026#34;package\u0026#34;, getPackageName(), null)); intent.setFlags(Intent.FLAG_ACTIVITY_NEW_TASK); startActivity(intent); } } 添加联系人 添加用户到通讯录，读取所有联系人信息到logcat中。\npackage com.showguan.chapter07_client; public class ContactAddActivity extends AppCompatActivity implements View.OnClickListener { private static String TAG = \u0026#34;Kennem\u0026#34;; private TextView et_name; private TextView et_phone; private TextView et_email; @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.activity_contact_add); et_name = findViewById(R.id.et_name); et_phone = findViewById(R.id.et_phone); et_email = findViewById(R.id.et_email); findViewById(R.id.btn_read).setOnClickListener(this); findViewById(R.id.btn_write).setOnClickListener(this); } @Override public void onClick(View v) { if (v.getId() == R.id.btn_write) { // 创建一个联系人对象 Contact contact = new Contact(); contact.name = et_name.getText().toString(); contact.phone = et_phone.getText().toString(); contact.email = et_email.getText().toString(); //addContacts(getContentResolver(), contact); //批处理方式，每一次操作都是一个ContentProviderOperation， 构建一个操作集合，然后一次性执行 // 好处：要么全部成功，要么全部失败，保证了事务的一致性 addFullContacts(getContentResolver(), contact); } else if (v.getId() == R.id.btn_read) { readPhoneContact(getContentResolver()); } } @SuppressLint(\u0026#34;Range\u0026#34;) // 禁用范围警告，因为我们手动处理列索引 private void readPhoneContact(ContentResolver resolver) { // 查询RawContacts表，获取所有联系人的_raw_contact_id Cursor cursor = resolver.query( ContactsContract.RawContacts.CONTENT_URI, new String[]{ContactsContract.RawContacts._ID}, // 只查询_raw_contact_id列 null, // 无筛选条件 null, // 无筛选条件参数 null // 无排序 ); // 遍历查询结果 while (cursor.moveToNext()) { // 获取当前记录的raw_contact_id int rawContactId = cursor.getInt(0); // 构建用于查询联系人的Data URI Uri uri = Uri.parse(\u0026#34;content://com.android.contacts/contacts/\u0026#34; + rawContactId + \u0026#34;/data\u0026#34;); // 查询Data表，获取与当前联系人相关的所有数据 Cursor dataCursor = resolver.query( uri, new String[]{Contacts.Data.MIMETYPE, Contacts.Data.DATA1, Contacts.Data.DATA2}, // 查询MIME类型和数据列 null, // 无筛选条件 null, // 无筛选条件参数 null // 无排序 ); // 创建一个Contact对象用于存储查询结果 Contact contact = new Contact(); // 遍历查询结果 while (dataCursor.moveToNext()) { // 获取当前记录的DATA1列的值 String data1 = dataCursor.getString(dataCursor.getColumnIndex(Contacts.Data.DATA1)); // 获取当前记录的MIMETYPE列的值 String mimeType = dataCursor.getString(dataCursor.getColumnIndex(Contacts.Data.MIMETYPE)); // 根据MIME类型，将数据存储到相应的Contact属性中 switch (mimeType) { case CommonDataKinds.StructuredName.CONTENT_ITEM_TYPE: // 如果MIME类型是StructuredName，则将data1赋值给contact的name属性 contact.name = data1; break; case CommonDataKinds.Phone.CONTENT_ITEM_TYPE: // 如果MIME类型是Phone，则将data1赋值给contact的phone属性 contact.phone = data1; break; case CommonDataKinds.Email.CONTENT_ITEM_TYPE: // 如果MIME类型是Email，则将data1赋值给contact的email属性 contact.email = data1; break; } } // 关闭Data表的查询结果游标 dataCursor.close(); // 如果contact的name属性不为空，则输出联系人姓名到日志 if (contact.name != null) { Log.d(TAG, contact.name); } } // 关闭RawContacts表的查询结果游标 cursor.close(); } // 往手机通讯录一次性添加一个联系人信息（包括主记录，姓名，电话号码，电子邮箱） // 事务性，要么全部成功，要么全部失败 private void addFullContacts(ContentResolver contentResolver, Contact contact) { // 创建一个插入联系人主记录的内容操作器 ContentProviderOperation op_main = ContentProviderOperation // 设置操作类型为插入 .newInsert(ContactsContract.RawContacts.CONTENT_URI) // 设置插入的ACCOUNT_NAME为null，表示使用默认账户 .withValue(ContactsContract.RawContacts.ACCOUNT_NAME, null) // 构建操作 .build(); // 创建一个插入联系人姓名的内容操作器 ContentProviderOperation op_name = ContentProviderOperation // 设置操作类型为插入 .newInsert(ContactsContract.Data.CONTENT_URI) // 设置引用的RAW_CONTACT_ID为前一个操作生成的ID .withValueBackReference(Contacts.Data.RAW_CONTACT_ID, 0) // 设置数据的MIME类型为StructuredName（联系人的名字） .withValue(Contacts.Data.MIMETYPE, CommonDataKinds.StructuredName.CONTENT_ITEM_TYPE) // 设置联系人的名字 .withValue(Contacts.Data.DATA1, contact.name) // 构建操作 .build(); // 创建一个插入联系人电话号码的内容操作器 ContentProviderOperation op_phone = ContentProviderOperation // 设置操作类型为插入 .newInsert(ContactsContract.Data.CONTENT_URI) // 设置引用的RAW_CONTACT_ID为前一个操作生成的ID .withValueBackReference(Contacts.Data.RAW_CONTACT_ID, 0) // 设置数据的MIME类型为Phone（联系人的电话） .withValue(Contacts.Data.MIMETYPE, CommonDataKinds.Phone.CONTENT_ITEM_TYPE) // 设置联系人的电话号码 .withValue(Contacts.Data.DATA1, contact.phone) // 设置电话号码的类型为Mobile（手机） .withValue(Contacts.Data.DATA2, CommonDataKinds.Phone.TYPE_MOBILE) // 构建操作 .build(); // 创建一个插入联系人电子邮箱的内容操作器 ContentProviderOperation op_email = ContentProviderOperation // 设置操作类型为插入 .newInsert(ContactsContract.Data.CONTENT_URI) // 设置引用的RAW_CONTACT_ID为前一个操作生成的ID .withValueBackReference(Contacts.Data.RAW_CONTACT_ID, 0) // 设置数据的MIME类型为Email（联系人的邮箱） .withValue(Contacts.Data.MIMETYPE, CommonDataKinds.Email.CONTENT_ITEM_TYPE) // 设置联系人的电子邮箱地址 .withValue(Contacts.Data.DATA1, contact.email) // 设置电子邮箱的类型为Mobile（手机邮箱） .withValue(Contacts.Data.DATA2, CommonDataKinds.Email.TYPE_MOBILE) // 构建操作 .build(); // 创建一个操作列表，用于批量执行所有操作 ArrayList\u0026lt;ContentProviderOperation\u0026gt; operations = new ArrayList\u0026lt;\u0026gt;(); // 将插入主记录的操作添加到操作列表 operations.add(op_main); // 将插入姓名的操作添加到操作列表 operations.add(op_name); // 将插入电话号码的操作添加到操作列表 operations.add(op_phone); // 将插入电子邮箱的操作添加到操作列表 operations.add(op_email); try { // 执行批量操作，将所有数据插入联系人数据库 contentResolver.applyBatch(ContactsContract.AUTHORITY, operations); } catch (OperationApplicationException e) { // 捕获OperationApplicationException异常并抛出RuntimeException throw new RuntimeException(e); } catch (RemoteException e) { // 捕获RemoteException异常并抛出RuntimeException throw new RuntimeException(e); } } private void addContacts(ContentResolver resolver, Contact contact) { // 创建一个ContentValues对象，用于存储新联系人数据 ContentValues values = new ContentValues(); // 插入一个空的RawContact记录，返回该记录的URI Uri uri = resolver.insert(ContactsContract.RawContacts.CONTENT_URI, values); // 解析出新插入记录的ID long rawContactId = ContentUris.parseId(uri); // 创建一个ContentValues对象，用于存储联系人的名字数据 ContentValues name = new ContentValues(); // 设置RAW_CONTACT_ID，表示该数据属于哪个联系人 name.put(Contacts.Data.RAW_CONTACT_ID, rawContactId); // 设置数据的MIME类型为StructuredName（联系人的名字） name.put(Contacts.Data.MIMETYPE, CommonDataKinds.StructuredName.CONTENT_ITEM_TYPE); // 设置联系人的名字 name.put(Contacts.Data.DATA1, contact.name); // 将联系人的名字数据插入到Data表中 resolver.insert(ContactsContract.Data.CONTENT_URI, name); // 创建一个ContentValues对象，用于存储联系人的电话号码数据 ContentValues phone = new ContentValues(); // 设置RAW_CONTACT_ID，表示该数据属于哪个联系人 phone.put(Contacts.Data.RAW_CONTACT_ID, rawContactId); // 设置数据的MIME类型为Phone（联系人的电话） phone.put(Contacts.Data.MIMETYPE, CommonDataKinds.Phone.CONTENT_ITEM_TYPE); // 设置联系人的电话号码 phone.put(Contacts.Data.DATA1, contact.phone); // 设置电话号码的类型为Mobile（手机） phone.put(Contacts.Data.DATA2, CommonDataKinds.Phone.TYPE_MOBILE); // 将联系人的电话号码数据插入到Data表中 resolver.insert(ContactsContract.Data.CONTENT_URI, phone); // 创建一个ContentValues对象，用于存储联系人的邮箱数据 ContentValues email = new ContentValues(); // 设置RAW_CONTACT_ID，表示该数据属于哪个联系人 email.put(Contacts.Data.RAW_CONTACT_ID, rawContactId); // 设置数据的MIME类型为Email（联系人的邮箱） email.put(Contacts.Data.MIMETYPE, CommonDataKinds.Email.CONTENT_ITEM_TYPE); // 设置联系人的邮箱地址（此处错误，应该是contact.email，而不是contact.phone） email.put(Contacts.Data.DATA1, contact.email); // 纠正了原来的错误 // 设置邮箱地址的类型为Work（工作邮箱） email.put(Contacts.Data.DATA2, CommonDataKinds.Email.TYPE_WORK); // 将联系人的邮箱数据插入到Data表中 resolver.insert(ContactsContract.Data.CONTENT_URI, email); } private void addContact(ContentResolver resolver, Contact contact) { ContentValues values = new ContentValues(); Uri uri = resolver.insert(ContactsContract.RawContacts.CONTENT_URI, values); long rawDataId = ContentUris.parseId(uri); } } 发送短信 Java package com.showguan.chapter07_client; // 定义包名 public class SentMmsActivity extends AppCompatActivity implements View.OnClickListener { // 定义SentMmsActivity类，继承AppCompatActivity，实现View.OnClickListener接口 private static String TAG = \u0026#34;Kennem\u0026#34;; // 定义TAG用于日志 private ActivityResultLauncher\u0026lt;Intent\u0026gt; mResultLauncher; // 定义ActivityResultLauncher变量 private EditText et_phone_number; // 定义EditText变量用于电话号码输入 private EditText et_title; // 定义EditText变量用于标题输入 private EditText et_desc; // 定义EditText变量用于描述输入 private Uri picUri; // 定义Uri变量用于存储图片URI @Override protected void onCreate(Bundle savedInstanceState) { // onCreate方法，Activity创建时调用 super.onCreate(savedInstanceState); // 调用父类onCreate方法 setContentView(R.layout.activity_sent_mms); // 设置布局文件 ImageView iv_add_pic = findViewById(R.id.iv_add_pic); // 获取ImageView用于添加图片 findViewById(R.id.btn_send).setOnClickListener(this); // 设置发送按钮的点击监听 iv_add_pic.setOnClickListener(this); // 设置添加图片按钮的点击监听 et_phone_number = findViewById(R.id.et_phone_number); // 获取EditText用于电话号码输入 et_title = findViewById(R.id.et_title); // 获取EditText用于标题输入 et_desc = findViewById(R.id.et_desc); // 获取EditText用于描述输入 mResultLauncher = registerForActivityResult(new ActivityResultContracts.StartActivityForResult(), result -\u0026gt; { // 注册Activity结果启动器 if(result.getResultCode() == RESULT_OK){ // 检查结果码是否为RESULT_OK Intent intent = result.getData(); // 获取结果数据 picUri = intent.getData(); // 获取图片URI if(picUri != null){ // 如果URI不为空 iv_add_pic.setImageURI(picUri); // 设置ImageView显示图片 Log.d(TAG, picUri.toString()); // 打印图片URI到日志 } } }); } @Override public void onClick(View v) { // onClick方法，处理点击事件 if(v.getId() == R.id.iv_add_pic){ // 如果点击的是添加图片按钮 Intent intent = new Intent(Intent.ACTION_GET_CONTENT); // 创建Intent用于选择内容 intent.setType(\u0026#34;image/*\u0026#34;); // 设置选择类型为图片 mResultLauncher.launch(intent); // 启动选择图片的Activity } else if (v.getId() == R.id.btn_send) { // 如果点击的是发送按钮 sendMms(et_phone_number.getText().toString(), // 调用sendMms方法发送MMS et_title.getText().toString(), // 获取标题文本 et_desc.getText().toString()); // 获取描述文本 } } private void sendMms(String phone, String title, String desc) { // sendMms方法，用于发送MMS Intent intent = new Intent(Intent.ACTION_SEND); // 创建发送Intent intent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK); // 添加新任务标志 intent.addFlags(Intent.FLAG_GRANT_READ_URI_PERMISSION); // 添加URI读权限标志 intent.putExtra(\u0026#34;address\u0026#34;, phone); // 设置电话号码 intent.putExtra(\u0026#34;subject\u0026#34;, title); // 设置标题 intent.putExtra(\u0026#34;sms_body\u0026#34;, desc); // 设置描述 intent.putExtra(Intent.EXTRA_STREAM, picUri); // 添加图片URI intent.setType(\u0026#34;image/*\u0026#34;); // 设置类型为图片 startActivity(intent); // 启动发送MMS的Activity ToastUtil.show(this, \u0026#34;从在弹窗中选择信息或短信应用\u0026#34;); // 显示提示信息 } } FileProvider指定获取图片路径并发送短信 package com.showguan.chapter07_client; // 定义包名 public class ProvideMmsActivity extends AppCompatActivity { // 定义ProvideMmsActivity类，继承AppCompatActivity private static String TAG = \u0026#34;Kennem\u0026#34;; // 定义TAG用于日志 private List\u0026lt;ImageInfo\u0026gt; mImageList = new ArrayList\u0026lt;\u0026gt;(); // 定义用于存储图片信息的列表 private GridLayout gl_appendix; // 定义GridLayout用于显示图片 private static final String[] PERMISSION_STORAGE = new String[]{ // 定义存储权限数组 Manifest.permission.READ_EXTERNAL_STORAGE, }; private static final int PERMISSION_STORAGE_CODE = 1; // 定义存储权限请求码 private EditText et_phone_number; // 定义EditText用于输入电话号码 private EditText et_message; // 定义EditText用于输入消息 private EditText et_title; // 定义EditText用于输入标题 @Override protected void onCreate(Bundle savedInstanceState) { // onCreate方法，Activity创建时调用 super.onCreate(savedInstanceState); // 调用父类onCreate方法 setContentView(R.layout.activity_provide_mms); // 设置布局文件 gl_appendix = findViewById(R.id.gl_appendix); // 获取GridLayout用于显示图片 et_title = findViewById(R.id.et_title); // 获取EditText用于输入标题 et_message = findViewById(R.id.et_message); // 获取EditText用于输入消息 et_phone_number = findViewById(R.id.et_phone_number); // 获取EditText用于输入电话号码 MediaScannerConnection.scanFile( // 调用MediaScannerConnection扫描文件 this, new String[]{Environment.getExternalStoragePublicDirectory(Environment.DIRECTORY_DOWNLOADS).toString()}, // 扫描下载目录 null, null ); if (PermissionUtil.checkPermission(this, PERMISSION_STORAGE, PERMISSION_STORAGE_CODE)) { // 检查存储权限 loadImageList(); // 加载图片列表 showImageGrid(); // 显示图片网格 } } @Override public void onRequestPermissionsResult(int requestCode, @NonNull String[] permissions, @NonNull int[] grantResults) { // 权限请求结果回调 super.onRequestPermissionsResult(requestCode, permissions, grantResults); // 调用父类方法 if (requestCode == PERMISSION_STORAGE_CODE) { // 判断请求码是否为存储权限 if (PermissionUtil.checkGranted(grantResults)) { // 检查权限是否被授予 loadImageList(); // 加载图片列表 showImageGrid(); // 显示图片网格 } } } private void showImageGrid() { // 显示图片网格的方法 gl_appendix.removeAllViews(); // 移除所有视图 for (ImageInfo image : mImageList) { // 遍历图片列表 ImageView imageView = new ImageView(this); // 创建ImageView Bitmap bitmap = BitmapFactory.decodeFile(image.path); // 解码图片文件 imageView.setImageBitmap(bitmap); // 设置图片 imageView.setScaleType(ImageView.ScaleType.FIT_CENTER); // 设置缩放类型 int px = Utils.dip2px(this, 110); // 将110dp转换为px ViewGroup.LayoutParams params = new ViewGroup.LayoutParams(px, px); // 创建布局参数 imageView.setLayoutParams(params); // 设置布局参数 int padding = Utils.dip2px(this, 5); // 将5dp转换为px imageView.setPadding(padding, padding, padding, padding); // 设置内边距 imageView.setOnClickListener(v -\u0026gt; { // 设置点击监听器 sendMms(et_phone_number.getText().toString(), // 获取输入的电话号码 et_title.getText().toString(), // 获取输入的标题 et_message.getText().toString(), // 获取输入的消息 image.path); // 获取图片路径 }); gl_appendix.addView(imageView); // 将ImageView添加到GridLayout } } private void sendMms(String phone, String title, String desc, String path) { // 发送MMS的方法 Uri uri = Uri.parse(path); // 将路径解析为Uri // 兼容Android 7.0 把访问文件的Uri方式改为FileProvider if (Build.VERSION.SDK_INT \u0026gt;= Build.VERSION_CODES.N) { // 判断是否为Android 7.0及以上 uri = FileProvider.getUriForFile(this, getString(R.string.file_Provider), new File(path)); // 使用FileProvider获取Uri Log.d(TAG, String.format(\u0026#34;FileProvider Uri : %s\u0026#34;, uri.toString())); // 打印FileProvider的Uri } Intent intent = new Intent(Intent.ACTION_SEND); // 创建发送Intent intent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK); // 添加新任务标志 intent.addFlags(Intent.FLAG_GRANT_READ_URI_PERMISSION); // 添加读取URI权限标志 intent.putExtra(\u0026#34;address\u0026#34;, phone); // 设置电话号码 intent.putExtra(\u0026#34;subject\u0026#34;, title); // 设置标题 intent.putExtra(\u0026#34;sms_body\u0026#34;, desc); // 设置消息内容 intent.putExtra(Intent.EXTRA_STREAM, uri); // 添加图片Uri intent.setType(\u0026#34;image/*\u0026#34;); // 设置类型为图片 startActivity(intent); // 启动Activity ToastUtil.show(this, \u0026#34;从在弹窗中选择信息或短信应用\u0026#34;); // 显示提示信息 } @SuppressLint(\u0026#34;Range\u0026#34;) private void loadImageList() { // 加载图片列表的方法 String[] columns = new String[]{ // 定义要查询的列 MediaStore.Images.Media._ID, MediaStore.Images.Media.TITLE, MediaStore.Images.Media.SIZE, MediaStore.Images.Media.DATA }; Cursor cursor = getContentResolver().query( // 查询图片媒体库 MediaStore.Images.Media.EXTERNAL_CONTENT_URI, // 查询外部图片URI columns, // 查询的列 \u0026#34;_size \u0026lt; 307200\u0026#34;, // 查询条件：大小小于300KB null, // 查询参数 \u0026#34;_size DESC\u0026#34;); // 排序方式：按大小降序 int count = 0; // 定义计数器 if (cursor != null) { // 如果游标不为空 while (cursor.moveToNext() \u0026amp;\u0026amp; count \u0026lt; 6) { // 遍历查询结果，最多6个 ImageInfo image = new ImageInfo(); // 创建ImageInfo对象 image.id = cursor.getLong(cursor.getColumnIndex(MediaStore.Images.Media._ID)); // 获取图片ID image.name = cursor.getString(cursor.getColumnIndex(MediaStore.Images.Media.TITLE)); // 获取图片标题 image.size = cursor.getLong(cursor.getColumnIndex(MediaStore.Images.Media.SIZE)); // 获取图片大小 image.path = cursor.getString(cursor.getColumnIndex(MediaStore.Images.Media.DATA)); // 获取图片路径 if (FileUtil.checkFileUri(this, image.path)) { // 检查文件URI是否有效 count += 1; // 增加计数 mImageList.add(image); // 将图片信息添加到列表 } Log.d(TAG, image.toString()); // 打印图片信息 } } } } xml \u0026lt;LinearLayout xmlns:android=\u0026#34;http://schemas.android.com/apk/res/android\u0026#34; android:layout_width=\u0026#34;match_parent\u0026#34; android:layout_height=\u0026#34;match_parent\u0026#34; android:orientation=\u0026#34;vertical\u0026#34; android:padding=\u0026#34;5dp\u0026#34;\u0026gt; \u0026lt;LinearLayout android:layout_width=\u0026#34;match_parent\u0026#34; android:layout_height=\u0026#34;40dp\u0026#34; android:orientation=\u0026#34;horizontal\u0026#34;\u0026gt; \u0026lt;TextView android:layout_width=\u0026#34;wrap_content\u0026#34; android:layout_height=\u0026#34;match_parent\u0026#34; android:gravity=\u0026#34;center\u0026#34; android:text=\u0026#34;对方号码：\u0026#34; android:textColor=\u0026#34;@color/black\u0026#34; android:textSize=\u0026#34;17sp\u0026#34; /\u0026gt; \u0026lt;EditText android:id=\u0026#34;@+id/et_phone_number\u0026#34; android:layout_width=\u0026#34;0dp\u0026#34; android:layout_height=\u0026#34;match_parent\u0026#34; android:layout_margin=\u0026#34;3dp\u0026#34; android:layout_weight=\u0026#34;1\u0026#34; android:background=\u0026#34;@drawable/edittext_selector\u0026#34; android:inputType=\u0026#34;number\u0026#34; android:textColor=\u0026#34;@color/black\u0026#34; android:textSize=\u0026#34;17sp\u0026#34; android:text=\u0026#34;10086\u0026#34;/\u0026gt; \u0026lt;/LinearLayout\u0026gt; \u0026lt;LinearLayout android:layout_width=\u0026#34;match_parent\u0026#34; android:layout_height=\u0026#34;40dp\u0026#34; android:orientation=\u0026#34;horizontal\u0026#34;\u0026gt; \u0026lt;TextView android:layout_width=\u0026#34;wrap_content\u0026#34; android:layout_height=\u0026#34;match_parent\u0026#34; android:gravity=\u0026#34;center\u0026#34; android:text=\u0026#34;彩信标题：\u0026#34; android:textColor=\u0026#34;@color/black\u0026#34; android:textSize=\u0026#34;17sp\u0026#34; /\u0026gt; \u0026lt;EditText android:id=\u0026#34;@+id/et_title\u0026#34; android:layout_width=\u0026#34;0dp\u0026#34; android:layout_height=\u0026#34;match_parent\u0026#34; android:layout_margin=\u0026#34;3dp\u0026#34; android:layout_weight=\u0026#34;1\u0026#34; android:background=\u0026#34;@drawable/edittext_selector\u0026#34; android:textColor=\u0026#34;@color/black\u0026#34; android:textSize=\u0026#34;17sp\u0026#34; android:text=\u0026#34;Hallo\u0026#34;/\u0026gt; \u0026lt;/LinearLayout\u0026gt; \u0026lt;LinearLayout android:layout_width=\u0026#34;match_parent\u0026#34; android:layout_height=\u0026#34;100dp\u0026#34; android:orientation=\u0026#34;horizontal\u0026#34;\u0026gt; \u0026lt;TextView android:layout_width=\u0026#34;wrap_content\u0026#34; android:layout_height=\u0026#34;match_parent\u0026#34; android:gravity=\u0026#34;center\u0026#34; android:text=\u0026#34;彩信内容：\u0026#34; android:textColor=\u0026#34;@color/black\u0026#34; android:textSize=\u0026#34;17sp\u0026#34; /\u0026gt; \u0026lt;EditText android:id=\u0026#34;@+id/et_message\u0026#34; android:layout_width=\u0026#34;0dp\u0026#34; android:layout_height=\u0026#34;match_parent\u0026#34; android:layout_margin=\u0026#34;3dp\u0026#34; android:layout_weight=\u0026#34;1\u0026#34; android:background=\u0026#34;@drawable/edittext_selector\u0026#34; android:gravity=\u0026#34;left|top\u0026#34; android:textColor=\u0026#34;@color/black\u0026#34; android:textSize=\u0026#34;17sp\u0026#34; android:text=\u0026#34;test\u0026#34;/\u0026gt; \u0026lt;/LinearLayout\u0026gt; \u0026lt;TextView android:layout_width=\u0026#34;match_parent\u0026#34; android:layout_height=\u0026#34;30dp\u0026#34; android:text=\u0026#34;点击下方图片开始发送彩信\u0026#34; android:textColor=\u0026#34;@color/black\u0026#34; android:textSize=\u0026#34;17sp\u0026#34; /\u0026gt; \u0026lt;GridLayout andddroid:id=\u0026#34;@+id/gl_appendix\u0026#34; android:layout_width=\u0026#34;match_parent\u0026#34; android:layout_height=\u0026#34;wrap_content\u0026#34; android:columnCount=\u0026#34;3\u0026#34; /\u0026gt; \u0026lt;/LinearLayout\u0026gt; FileProvider 安装apk Java package com.showguan.chapter07_client; public class ProviderApkActivity extends AppCompatActivity implements View.OnClickListener { private static final String TAG = \u0026#34;Kennem\u0026#34;; // 所需权限列表 private static final String[] PERMISSIONS = new String[]{ Manifest.permission.REQUEST_INSTALL_PACKAGES, Manifest.permission.READ_EXTERNAL_STORAGE, Manifest.permission.WRITE_EXTERNAL_STORAGE }; // 请求码，用于权限请求回调标识 private static final int REQUEST_CODE = 1; @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.activity_provider_apk); // 设置按钮点击监听 findViewById(R.id.btn_install).setOnClickListener(this); } @Override public void onClick(View v) { // 检查权限并安装APK checkAndInstall(); } /** * 检查权限并安装APK */ private void checkAndInstall() { if (Build.VERSION.SDK_INT \u0026gt;= Build.VERSION_CODES.R) { Log.d(TAG, \u0026#34;android 11 + \u0026#34;); // 检查是否具有管理所有文件的权限 if (!Environment.isExternalStorageManager()) { Log.d(TAG, \u0026#34;checkisExternalStorageManager\u0026#34;); // 跳转到设置页面请求权限 Intent intent = new Intent(Settings.ACTION_MANAGE_APP_ALL_FILES_ACCESS_PERMISSION); intent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK); intent.setData(Uri.fromParts(\u0026#34;package\u0026#34;, getPackageName(), null)); startActivity(intent); } else { // 权限已授予， // 安装APK installApk(); } } else { // 检查所需权限是否已全部授予 if (PermissionUtil.checkPermission(this, PERMISSIONS, REQUEST_CODE)) { // 权限已授予，安装APK installApk(); } } } /** * 安装APK文件 */ private void installApk() { // 获取APK文件的路径 String apkPath = Environment.getExternalStoragePublicDirectory(Environment.DIRECTORY_DOWNLOADS).toString() + \u0026#34;/chapter06-release.apk\u0026#34;; Log.d(TAG, \u0026#34;apkPath:\u0026#34; + apkPath); // 获取应用包管理器 PackageManager pm = getPackageManager(); // 获取APK文件的包信息 PackageInfo pi = pm.getPackageArchiveInfo(apkPath, PackageManager.GET_ACTIVITIES); if (pi == null) { // 如果包信息为空，显示文件损坏提示 ToastUtil.show(this, \u0026#34;安装文件已经损坏!\u0026#34;); return; } // 获取APK文件的Uri Uri uri = Uri.parse(apkPath); // 兼容Android 7.0及以上版本，通过FileProvider获取Uri if (Build.VERSION.SDK_INT \u0026gt;= Build.VERSION_CODES.N) { // 通过FileProvider获取文件的Uri uri = FileProvider.getUriForFile(this, getString(R.string.file_provider), new File(apkPath)); Log.d(\u0026#34;Kennem\u0026#34;, String.format(\u0026#34;new uri:%s\u0026#34;, uri.toString())); } // 创建Intent以启动APK安装程序 Intent intent = new Intent(Intent.ACTION_VIEW); intent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK); intent.addFlags(Intent.FLAG_GRANT_READ_URI_PERMISSION); // 设置Uri的数据类型为APK文件 intent.setDataAndType(uri, \u0026#34;application/vnd.android.package-archive\u0026#34;); // 启动系统自带的应用安装程序 startActivity(intent); } @Override public void onRequestPermissionsResult(int requestCode, @NonNull String[] permissions, @NonNull int[] grantResults) { super.onRequestPermissionsResult(requestCode, permissions, grantResults); // 检查权限请求结果 if (requestCode == REQUEST_CODE \u0026amp;\u0026amp; PermissionUtil.checkGranted(grantResults)) { // 权限已授予，安装APK installApk(); } } } ","permalink":"https://kennems.github.io/zh/posts/tech/android4/","summary":"Android（4） 就算是最低的15x15都已经不错了，以后还有时间去学，上了研究生也没人能保证你有15x15的收入 内容提供者(Conten","title":"Android（4）"},{"content":"Android（2） Activity的启动和结束 从当前页面跳转到新页面，跳转代码如下：\nstartActivity(new Intent(源页面.this， 目标页面.class)) 从当前页面回到上一个页面，相当于关闭当前页面，返回代码如下：\nfinish(); //结束当前的活动页面 Activity声明周期 onCreate ：创建活动。把页面布局加载进内存，进入了初始状态。 onStart：开始活动。把活动显示在屏幕上，进入了就绪状态 onResume：恢复活动。活动页面进入了活跃状态，能够与用户正常交互，例如允许响应用户的点击动作，允许用户输入文字等等。动画开启 onPause：暂停活动。页面进入暂停状态，无法与用户正常交互。动画暂停 onStop：停止活动。页面不在屏幕上显示。 onDestroy：销毁活动。回收活动占用的系统资源，把页面从内存中清除。 onRestart：重启活动。重新加载内存中的页面数据。 onNewIntent：重用已有的活动实例 Activity的启动模式 launchMode属性值 说明 standard 标准模式，无论何时启动哪个活动，都是重新创建该页面的实例并放入栈顶。如果不指定launchMode属性，则默认为标准模式 singleTop 启动新活动时，判断如果栈顶正好就是该活动的实例，则重用该实例；否则创建新的实例并放入栈顶，也就是按照standard模式处理 singleTask 启动新活动时，判断如果栈中存在该活动的实例，则重用该实例，启动新活动时，判断如果栈中存在该活动的实例，则重用该实例，并清除位于该实例上面的所有实例；否则按照standard模式处理 singleInstance 启动新活动时，将该活动的实例放入一个新栈中，原栈的实例列表保持不变 启动标志的取值说明如下：\nIntent.FLAG_ACTIVITY_NEW_TASK：开辟一个新的任务栈\nIntent.FLAG_ACTIVITY_SINGLE_TOP：当栈顶为待跳转的活动实例之时，则重用栈顶的实例\nIntent.FLAG_ACTIVITY_CLEAR_TOP：当栈中存在待跳转的活动实例时，则重新创建一个新实例，并清除原实例上方的所有实例\nIntent.FLAG_ACTIVITY_NO_HISTORY：栈中不保存新启动的活动实例\nIntent.FLAG_ACTIVITY_CLEAR_TASK：跳转到新页面时，栈中的原有实例都被清空\n显示Intent和隐式Intent Intent是各个组件之间信息沟通的桥梁，它用于Android各组件之间的通信，主要完成下列工作：\n标明本次通信请求从哪里来，到哪里去，要怎么走。 发起方携带本次通信需要的数据内容，接收方从收到的意图中解析数据 发起方若想判断接收方的处理结果，意图就要负责让接收方传回应答的数据内容 显示Intent 显示Intent，直接指定来源活动与目标活动，属于精确匹配。三种构建方式：\n在Intent的构造函数中指定 调用意图对象的setClass方法指定 调用意图对象的setComponent方法指定 @Override public void onClick(View v) { // startActivity(new Intent(this, ActFinishActivity.class)); // Intent intent = new Intent(); // intent.setClass(this, ActFinishActivity.class) // startActivity(intent); Intent intent = new Intent(); ComponentName componentName = new ComponentName(this, ActFinishActivity.class); intent.setComponent(componentName); Log.d(TAG, \u0026#34;ActStartActivity onClick\u0026#34;); } 隐式Intent 没有明确指定要跳转的目标活动，只给出一个动作字符串让系统自动匹配。属于模糊匹配。动作名称既可以通过setAction方法指定，也可以通过构造函数Intent(String action)直接生成意图对象。常用的系统动作如下表：\nAndroidManifest.xml 指定一个需要自定义跳转的View, 将\u0026lt;action\u0026gt; 和 \u0026lt;category\u0026gt;两个标签分别修改为，自定义包名，以及android.intent.category.DEFAULT\n\u0026lt;activity android:name=\u0026#34;.LoginInputActivity\u0026#34; android:exported=\u0026#34;true\u0026#34;\u0026gt; \u0026lt;intent-filter\u0026gt; \u0026lt;action android:name=\u0026#34;android.intent.action.kennem\u0026#34; /\u0026gt; \u0026lt;category android:name=\u0026#34;android.intent.category.DEFAULT\u0026#34; /\u0026gt; \u0026lt;/intent-filter\u0026gt; \u0026lt;/activity\u0026gt; XML \u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;utf-8\u0026#34;?\u0026gt; \u0026lt;LinearLayout xmlns:android=\u0026#34;http://schemas.android.com/apk/res/android\u0026#34; android:id=\u0026#34;@+id/main\u0026#34; android:layout_width=\u0026#34;match_parent\u0026#34; android:layout_height=\u0026#34;match_parent\u0026#34; android:orientation=\u0026#34;vertical\u0026#34;\u0026gt; \u0026lt;TextView android:layout_width=\u0026#34;match_parent\u0026#34; android:layout_height=\u0026#34;wrap_content\u0026#34; android:padding=\u0026#34;5dp\u0026#34; android:text=\u0026#34;点击以下按钮对号码123321发起请求\u0026#34;/\u0026gt; \u0026lt;Button android:id=\u0026#34;@+id/btn_dial\u0026#34; android:layout_width=\u0026#34;match_parent\u0026#34; android:layout_height=\u0026#34;wrap_content\u0026#34; android:text=\u0026#34;跳转到拨号页面\u0026#34;/\u0026gt; \u0026lt;Button android:id=\u0026#34;@+id/btn_sms\u0026#34; android:layout_width=\u0026#34;match_parent\u0026#34; android:layout_height=\u0026#34;wrap_content\u0026#34; android:text=\u0026#34;跳转到发短信页面\u0026#34;/\u0026gt; \u0026lt;Button android:id=\u0026#34;@+id/btn_my\u0026#34; android:layout_width=\u0026#34;match_parent\u0026#34; android:layout_height=\u0026#34;wrap_content\u0026#34; android:text=\u0026#34;跳转到我的页面\u0026#34;/\u0026gt; \u0026lt;/LinearLayout\u0026gt; Java // 定义一个名为 ActUriActivity 的 Activity 类，继承自 AppCompatActivity 并实现 View.OnClickListener 接口 public class ActUriActivity extends AppCompatActivity implements View.OnClickListener { @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); // 设置 Activity 的布局文件 setContentView(R.layout.activity_act_uri); // 为三个按钮设置点击监听器 findViewById(R.id.btn_dial).setOnClickListener(this); findViewById(R.id.btn_sms).setOnClickListener(this); findViewById(R.id.btn_my).setOnClickListener(this); } @Override public void onClick(View v) { // 创建一个 Intent 对象，用于启动其他 Activity Intent intent = new Intent(); // 定义一个电话号码字符串 String phoneNum = \u0026#34;123654789\u0026#34;; // 根据点击的按钮 ID 执行相应的操作 if (v.getId() == R.id.btn_dial) { // 设置 Intent 的 Action 为拨号 intent.setAction(Intent.ACTION_DIAL); // 创建一个 Uri 对象，表示电话号码 Uri uri = Uri.parse(\u0026#34;tel:\u0026#34; + phoneNum); // 将 Uri 数据设置到 Intent 中 intent.setData(uri); // 启动拨号界面 startActivity(intent); } else if (v.getId() == R.id.btn_sms) { // 设置 Intent 的 Action 为发送短信 intent.setAction(Intent.ACTION_SENDTO); // 创建一个 Uri 对象，表示短信号码 Uri uri2 = Uri.parse(\u0026#34;smsto:\u0026#34; + phoneNum); // 将 Uri 数据设置到 Intent 中 intent.setData(uri2); // 启动短信界面 startActivity(intent); } else if (v.getId() == R.id.btn_my) { // 设置 Intent 的 Action 为自定义 Action intent.setAction(\u0026#34;android.intent.action.kennem\u0026#34;); // 添加默认类别 intent.addCategory(Intent.CATEGORY_DEFAULT); // 启动自定义的 Activity startActivity(intent); } } } 向下一个Activity发送数据\nIntent使用Bundle对象存放待传递的数据信息。 Bundle对象操作各种类型数据的读写方法说明： 向下一个Activity发送数据 XML send.xml \u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;utf-8\u0026#34;?\u0026gt; \u0026lt;LinearLayout xmlns:android=\u0026#34;http://schemas.android.com/apk/res/android\u0026#34; android:id=\u0026#34;@+id/main\u0026#34; android:layout_width=\u0026#34;match_parent\u0026#34; android:layout_height=\u0026#34;match_parent\u0026#34; android:orientation=\u0026#34;vertical\u0026#34;\u0026gt; \u0026lt;TextView android:id=\u0026#34;@+id/tv_send\u0026#34; android:layout_width=\u0026#34;match_parent\u0026#34; android:layout_height=\u0026#34;wrap_content\u0026#34; android:text=\u0026#34;坚持下去\u0026#34; android:textSize=\u0026#34;20sp\u0026#34;/\u0026gt; \u0026lt;Button android:id=\u0026#34;@+id/btn_send\u0026#34; android:layout_width=\u0026#34;match_parent\u0026#34; android:layout_height=\u0026#34;wrap_content\u0026#34; android:gravity=\u0026#34;center\u0026#34; android:text=\u0026#34;发送以上的文字\u0026#34; /\u0026gt; \u0026lt;/LinearLayout\u0026gt; receive.xml \u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;utf-8\u0026#34;?\u0026gt; \u0026lt;LinearLayout xmlns:android=\u0026#34;http://schemas.android.com/apk/res/android\u0026#34; android:id=\u0026#34;@+id/main\u0026#34; android:layout_width=\u0026#34;match_parent\u0026#34; android:layout_height=\u0026#34;match_parent\u0026#34; android:orientation=\u0026#34;vertical\u0026#34;\u0026gt; \u0026lt;TextView android:id=\u0026#34;@+id/tv_receive\u0026#34; android:layout_width=\u0026#34;match_parent\u0026#34; android:layout_height=\u0026#34;wrap_content\u0026#34; android:text=\u0026#34;坚持下去\u0026#34; android:textSize=\u0026#34;20sp\u0026#34;/\u0026gt; \u0026lt;/LinearLayout\u0026gt; Java ActSentActivity.java package com.showguan.chapter04; public class ActSentActivity extends AppCompatActivity implements View.OnClickListener { private TextView tv_send; @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.activity_act_sent); tv_send = findViewById(R.id.tv_send); findViewById(R.id.btn_send).setOnClickListener(this); } @Override public void onClick(View v) { Intent intent = new Intent(this, ActReceiveActivity.class); Bundle bundle = new Bundle(); bundle.putString(\u0026#34;request_time\u0026#34;, DateUtil.getNowTime()); bundle.putString(\u0026#34;request_content\u0026#34;, tv_send.getText().toString()); intent.putExtras(bundle); startActivity(intent); } } ActReceiveActivity.java package com.showguan.chapter04; public class ActReceiveActivity extends AppCompatActivity { private TextView tv_send; private TextView tv_receive; @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.activity_act_receive); tv_receive = findViewById(R.id.tv_receive); Bundle bundle = getIntent().getExtras(); String request_time = bundle.getString(\u0026#34;request_time\u0026#34;); String request_content = bundle.getString(\u0026#34;request_content\u0026#34;); String desc = String.format(\u0026#34;成功收到消息，收到时间为%s, 收到内容为%s\u0026#34;, request_time, request_content); tv_receive.setText(desc); } } 向上一个Activity返回数据 XML request.xml \u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;utf-8\u0026#34;?\u0026gt; \u0026lt;LinearLayout xmlns:android=\u0026#34;http://schemas.android.com/apk/res/android\u0026#34; android:id=\u0026#34;@+id/main\u0026#34; android:layout_width=\u0026#34;match_parent\u0026#34; android:layout_height=\u0026#34;match_parent\u0026#34; android:orientation=\u0026#34;vertical\u0026#34;\u0026gt; \u0026lt;TextView android:id=\u0026#34;@+id/tv_request\u0026#34; android:layout_margin=\u0026#34;30dp\u0026#34; android:layout_width=\u0026#34;match_parent\u0026#34; android:textSize=\u0026#34;15sp\u0026#34; android:layout_height=\u0026#34;wrap_content\u0026#34; /\u0026gt; \u0026lt;Button android:id=\u0026#34;@+id/btn_request\u0026#34; android:layout_width=\u0026#34;match_parent\u0026#34; android:layout_height=\u0026#34;wrap_content\u0026#34; android:layout_margin=\u0026#34;30dp\u0026#34; android:gravity=\u0026#34;center\u0026#34; android:text=\u0026#34;请求传送数据\u0026#34; /\u0026gt; \u0026lt;TextView android:id=\u0026#34;@+id/tv_response\u0026#34; android:layout_margin=\u0026#34;30dp\u0026#34; android:layout_width=\u0026#34;match_parent\u0026#34; android:layout_height=\u0026#34;wrap_content\u0026#34;/\u0026gt; \u0026lt;/LinearLayout\u0026gt; response.xml \u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;utf-8\u0026#34;?\u0026gt; \u0026lt;LinearLayout xmlns:android=\u0026#34;http://schemas.android.com/apk/res/android\u0026#34; xmlns:app=\u0026#34;http://schemas.android.com/apk/res-auto\u0026#34; xmlns:tools=\u0026#34;http://schemas.android.com/tools\u0026#34; android:id=\u0026#34;@+id/main\u0026#34; android:layout_width=\u0026#34;match_parent\u0026#34; android:layout_height=\u0026#34;match_parent\u0026#34; android:orientation=\u0026#34;vertical\u0026#34;\u0026gt; \u0026lt;TextView android:id=\u0026#34;@+id/tv_request\u0026#34; android:layout_width=\u0026#34;match_parent\u0026#34; android:layout_height=\u0026#34;wrap_content\u0026#34; /\u0026gt; \u0026lt;Button android:id=\u0026#34;@+id/btn_response\u0026#34; android:layout_width=\u0026#34;match_parent\u0026#34; android:layout_height=\u0026#34;wrap_content\u0026#34; android:gravity=\u0026#34;center\u0026#34; android:text=\u0026#34;请求传送数据\u0026#34; /\u0026gt; \u0026lt;TextView android:id=\u0026#34;@+id/tv_response\u0026#34; android:layout_width=\u0026#34;match_parent\u0026#34; android:layout_height=\u0026#34;wrap_content\u0026#34;/\u0026gt; \u0026lt;/LinearLayout\u0026gt; Java ActRequestActivity.java package com.showguan.chapter04; public class ActRequestActivity extends AppCompatActivity implements View.OnClickListener { // 要发送的请求内容 private final String mRequest = \u0026#34;今天是2024/06/18， 坚持就是胜利，效率就是王者\u0026#34;; // 用于启动活动并接收结果的启动器 private ActivityResultLauncher\u0026lt;Intent\u0026gt; register; // 显示响应内容的TextView private TextView tv_response; // 显示请求内容的TextView private TextView tv_request; @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); // 设置活动的布局 setContentView(R.layout.activity_act_request); // 绑定显示请求内容的TextView tv_request = findViewById(R.id.tv_request); // 绑定显示响应内容的TextView tv_response = findViewById(R.id.tv_response); // 设置待发送的文本内容 tv_request.setText(\u0026#34;待发送的文本：\u0026#34; + mRequest); // 绑定按钮点击事件 findViewById(R.id.btn_request).setOnClickListener(this); // 注册一个用于启动活动并接收结果的启动器 register = registerForActivityResult(new ActivityResultContracts.StartActivityForResult(), result -\u0026gt; { if (result != null) { // 获取返回的Intent Intent intent = result.getData(); if (intent != null \u0026amp;\u0026amp; result.getResultCode() == Activity.RESULT_OK) { // 获取Intent中的数据 Bundle bundle = intent.getExtras(); String request_time = bundle.getString(\u0026#34;response_time\u0026#34;); String request_content = bundle.getString(\u0026#34;response_content\u0026#34;); // 格式化显示响应消息 String desc = String.format(\u0026#34;收到应答消息，应答时间为%s, 应答内容为%s\u0026#34;, request_time, request_content); tv_response.setText(desc); } } }); } @Override public void onClick(View v) { // 创建一个启动ActResponseActivity的Intent Intent intent = new Intent(this, ActResponseActivity.class); // 创建一个Bundle用于传递请求数据 Bundle bundle = new Bundle(); // 将当前时间和请求内容放入Bundle bundle.putString(\u0026#34;request_time\u0026#34;, DateUtil.getNowTime()); bundle.putString(\u0026#34;request_content\u0026#34;, mRequest); // 将Bundle放入Intent intent.putExtras(bundle); // 启动活动并等待结果 register.launch(intent); } } ActResponseActivity.java package com.showguan.chapter04; public class ActResponseActivity extends AppCompatActivity implements View.OnClickListener { // 静态常量，表示响应的内容 private static final String mResponse = \u0026#34;我™一定能进小米\u0026#34;; @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); // 设置活动的布局 setContentView(R.layout.activity_act_response); // 绑定显示请求内容的TextView TextView tv_request = findViewById(R.id.tv_request); // 获取启动此活动时传递的Intent中的Extras Bundle bundle = getIntent().getExtras(); // 从Extras中获取请求的时间和内容 String request_time = bundle.getString(\u0026#34;request_time\u0026#34;); String request_content = bundle.getString(\u0026#34;request_content\u0026#34;); // 格式化显示接收到的请求消息 String desc = String.format(\u0026#34;成功收到消息，收到时间为%s, 收到内容为%s\u0026#34;, request_time, request_content); tv_request.setText(desc); // 绑定响应按钮的点击事件 findViewById(R.id.btn_response).setOnClickListener(this); // 绑定显示响应内容的TextView TextView tv_response = findViewById(R.id.tv_response); // 设置待返回的响应内容 tv_response.setText(\u0026#34;待返回的内容：\u0026#34; + mResponse); } @Override public void onClick(View v) { // 创建一个返回给ActRequestActivity的Intent Intent intent = new Intent(this, ActRequestActivity.class); // 创建一个Bundle用于传递响应数据 Bundle bundle = new Bundle(); // 将当前时间和响应内容放入Bundle bundle.putString(\u0026#34;response_time\u0026#34;, DateUtil.getNowTime()); bundle.putString(\u0026#34;response_content\u0026#34;, \u0026#34;应答内容：\u0026#34; + mResponse); // 将Bundle放入Intent intent.putExtras(bundle); // 设置结果码和返回的Intent setResult(Activity.RESULT_OK, intent); // 结束当前活动 finish(); } } 为活动补充附加信息 将string信息定义在strings.xml\n\u0026lt;resources\u0026gt; \u0026lt;string name=\u0026#34;app_name\u0026#34;\u0026gt;chapter04\u0026lt;/string\u0026gt; \u0026lt;string name=\u0026#34;weather_info\u0026#34;\u0026gt;今天是个糟糕的一天\u0026lt;/string\u0026gt; \u0026lt;/resources\u0026gt; java代码中引用即可：\nTextView tv_resource = findViewById(R.id.tv_resource); String value = getString(R.string.weather_info); tv_resource.setText(value); 在代码中获取元数据 在AndroidManifest.xml文件中指定metadata \u0026lt;activity android:name=\u0026#34;.ActStartActivity\u0026#34; android:exported=\u0026#34;true\u0026#34; android:launchMode=\u0026#34;standard\u0026#34;\u0026gt; \u0026lt;intent-filter\u0026gt; \u0026lt;action android:name=\u0026#34;android.intent.action.MAIN\u0026#34; /\u0026gt; \u0026lt;category android:name=\u0026#34;android.intent.category.LAUNCHER\u0026#34; /\u0026gt; \u0026lt;/intent-filter\u0026gt; \u0026lt;meta-data android:name=\u0026#34;android.app.shortcuts\u0026#34; android:resource=\u0026#34;@xml/shortcuts\u0026#34; /\u0026gt; \u0026lt;/activity\u0026gt; 编写shortcuts.xml， 指定显示的名称和要跳转的页面 \u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;utf-8\u0026#34;?\u0026gt; \u0026lt;shortcuts xmlns:android=\u0026#34;http://schemas.android.com/apk/res/android\u0026#34;\u0026gt; \u0026lt;shortcut android:enabled=\u0026#34;true\u0026#34; android:icon=\u0026#34;@mipmap/ic_launcher\u0026#34; android:shortcutId=\u0026#34;first\u0026#34; android:shortcutLongLabel=\u0026#34;@string/first_long\u0026#34; android:shortcutShortLabel=\u0026#34;@string/first_short\u0026#34;\u0026gt; \u0026lt;intent android:action=\u0026#34;android.intent.action.VIEW\u0026#34; android:targetClass=\u0026#34;com.showguan.chapter04.ActStartActivity\u0026#34; android:targetPackage=\u0026#34;com.showguan.chapter04\u0026#34;\u0026gt; \u0026lt;categories android:name=\u0026#34;android.shortcut.conversation\u0026#34; /\u0026gt; \u0026lt;/intent\u0026gt; \u0026lt;/shortcut\u0026gt; \u0026lt;shortcut android:enabled=\u0026#34;true\u0026#34; android:icon=\u0026#34;@mipmap/ic_launcher\u0026#34; android:shortcutId=\u0026#34;second\u0026#34; android:shortcutLongLabel=\u0026#34;@string/second_long\u0026#34; android:shortcutShortLabel=\u0026#34;@string/second_short\u0026#34;\u0026gt; \u0026lt;intent android:action=\u0026#34;android.intent.action.VIEW\u0026#34; android:targetClass=\u0026#34;com.showguan.chapter04.JumpFirstActivity\u0026#34; android:targetPackage=\u0026#34;com.showguan.chapter04\u0026#34;\u0026gt; \u0026lt;categories android:name=\u0026#34;android.shortcut.conversation\u0026#34; /\u0026gt; \u0026lt;/intent\u0026gt; \u0026lt;/shortcut\u0026gt; \u0026lt;shortcut android:enabled=\u0026#34;true\u0026#34; android:icon=\u0026#34;@mipmap/ic_launcher\u0026#34; android:shortcutId=\u0026#34;third\u0026#34; android:shortcutLongLabel=\u0026#34;@string/third_long\u0026#34; android:shortcutShortLabel=\u0026#34;@string/third_short\u0026#34;\u0026gt; \u0026lt;intent android:action=\u0026#34;android.intent.action.VIEW\u0026#34; android:targetClass=\u0026#34;com.showguan.chapter04.LoginInputActivity\u0026#34; android:targetPackage=\u0026#34;com.showguan.chapter04\u0026#34;\u0026gt; \u0026lt;categories android:name=\u0026#34;android.shortcut.conversation\u0026#34; /\u0026gt; \u0026lt;/intent\u0026gt; \u0026lt;/shortcut\u0026gt; \u0026lt;/shortcuts\u0026gt; 注意名称需要存储在strings.xml中\nAndroidManifest.xml中需要跳转的页面exported属性要设置为true 中级控件 图形Drawable Drawable类型表达了各种各样的图形，包括图片，色块，画板， 背景等\n包含图片在内的图形文件放在res目录的各个drawable目录下，其中drawable目录一般保存描述性的XML文件，而图片文件一般放在具体分辨率的drawable目录下。\ndrawable-ldpi, drawable-mdpi, drawable-hdpi, drawable-xhdpi,drawable-xxhdpi， drawable-xxhdpi表示低分辨率，中等分辨率，高分辨率，超高分辨率， 超超高分辨率 各视图的background属性，ImageView和ImageButton的src属性，TextView和Button四个方向的drawable系列属性都可以引用图形文件。\n形状图形 shape图形又称形状图形，它用来描述常见的几何形状，包括矩形，圆角矩形，圆形，椭圆等。 形状图形 drawable中xml \u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;utf-8\u0026#34;?\u0026gt; \u0026lt;shape xmlns:android=\u0026#34;http://schemas.android.com/apk/res/android\u0026#34; android:shape=\u0026#34;oval\u0026#34;\u0026gt; \u0026lt;solid android:color=\u0026#34;#ff66aa\u0026#34;/\u0026gt; \u0026lt;stroke android:width=\u0026#34;1dp\u0026#34; android:color=\u0026#34;#aaaaaa\u0026#34;/\u0026gt; \u0026lt;/shape\u0026gt; \u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;utf-8\u0026#34;?\u0026gt; \u0026lt;shape xmlns:android=\u0026#34;http://schemas.android.com/apk/res/android\u0026#34;\u0026gt; \u0026lt;!-- 填充颜色--\u0026gt; \u0026lt;solid android:color=\u0026#34;#ffdd66\u0026#34; /\u0026gt; \u0026lt;!-- 轮廓粗细与颜色--\u0026gt; \u0026lt;stroke android:width=\u0026#34;1dp\u0026#34; android:color=\u0026#34;#aaaaaa\u0026#34; /\u0026gt; \u0026lt;!-- 形状四个圆角的半径--\u0026gt; \u0026lt;corners android:radius=\u0026#34;10dp\u0026#34; /\u0026gt; \u0026lt;/shape\u0026gt; activity_draw_shape.xml \u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;utf-8\u0026#34;?\u0026gt; \u0026lt;LinearLayout xmlns:android=\u0026#34;http://schemas.android.com/apk/res/android\u0026#34; android:id=\u0026#34;@+id/main\u0026#34; android:layout_width=\u0026#34;match_parent\u0026#34; android:layout_height=\u0026#34;match_parent\u0026#34; android:orientation=\u0026#34;vertical\u0026#34;\u0026gt; \u0026lt;View android:id=\u0026#34;@+id/v_content\u0026#34; android:layout_width=\u0026#34;match_parent\u0026#34; android:layout_height=\u0026#34;200dp\u0026#34; android:layout_margin=\u0026#34;10dp\u0026#34;/\u0026gt; \u0026lt;LinearLayout android:layout_width=\u0026#34;match_parent\u0026#34; android:layout_height=\u0026#34;wrap_content\u0026#34; android:orientation=\u0026#34;horizontal\u0026#34;\u0026gt; \u0026lt;Button android:id=\u0026#34;@+id/btn_rect\u0026#34; android:layout_width=\u0026#34;0dp\u0026#34; android:layout_height=\u0026#34;wrap_content\u0026#34; android:layout_weight=\u0026#34;1\u0026#34; android:text=\u0026#34;圆角矩形按钮\u0026#34;/\u0026gt; \u0026lt;Button android:id=\u0026#34;@+id/btn_oval\u0026#34; android:layout_width=\u0026#34;0dp\u0026#34; android:layout_height=\u0026#34;wrap_content\u0026#34; android:layout_weight=\u0026#34;1\u0026#34; android:text=\u0026#34;椭圆按钮\u0026#34;/\u0026gt; \u0026lt;/LinearLayout\u0026gt; \u0026lt;/LinearLayout\u0026gt; Java package com.showguan.chapter05; public class DrawShapeActivity extends AppCompatActivity implements View.OnClickListener { private View v_content; @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.activity_draw_shape); v_content = findViewById(R.id.v_content); findViewById(R.id.btn_rect).setOnClickListener(this); findViewById(R.id.btn_oval).setOnClickListener(this); v_content.setBackgroundResource(R.drawable.shape_rect_gold); } @Override public void onClick(View v) { if(v.getId() == R.id.btn_rect){ v_content.setBackgroundResource(R.drawable.shape_rect_gold); }else if (v.getId()==R.id.btn_oval){ v_content.setBackgroundResource(R.drawable.shape_oval_rose); } } } 九宫格图片 将某张图片设置为视图背景时，如果图片尺寸太小，则系统会自动拉伸图片使之填满背景 可是一旦图片拉得过大，其画面容易变得模糊 创建.9文件 状态列表图形 btn_nice_selector.xml \u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;utf-8\u0026#34;?\u0026gt; \u0026lt;selector xmlns:android=\u0026#34;http://schemas.android.com/apk/res/android\u0026#34;\u0026gt; \u0026lt;item android:state_pressed=\u0026#34;true\u0026#34; android:drawable=\u0026#34;@drawable/button_pressed\u0026#34; /\u0026gt; \u0026lt;item android:drawable=\u0026#34;@drawable/button_normal\u0026#34; /\u0026gt; \u0026lt;/selector\u0026gt; 复选框checkbox xml \u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;utf-8\u0026#34;?\u0026gt; \u0026lt;LinearLayout xmlns:android=\u0026#34;http://schemas.android.com/apk/res/android\u0026#34; android:id=\u0026#34;@+id/main\u0026#34; android:layout_width=\u0026#34;match_parent\u0026#34; android:layout_height=\u0026#34;match_parent\u0026#34; android:orientation=\u0026#34;vertical\u0026#34;\u0026gt; \u0026lt;CheckBox android:id=\u0026#34;@+id/ck_system\u0026#34; android:layout_width=\u0026#34;match_parent\u0026#34; android:layout_height=\u0026#34;wrap_content\u0026#34; android:layout_marginTop=\u0026#34;5dp\u0026#34; android:text=\u0026#34;系统的checkbox\u0026#34;/\u0026gt; \u0026lt;CheckBox android:id=\u0026#34;@+id/ck_custom\u0026#34; android:layout_width=\u0026#34;match_parent\u0026#34; android:layout_height=\u0026#34;wrap_content\u0026#34; android:button=\u0026#34;@drawable/checkbox_selector\u0026#34; android:layout_marginTop=\u0026#34;10dp\u0026#34; android:checked=\u0026#34;true\u0026#34; android:text=\u0026#34;系统的checkbox\u0026#34;/\u0026gt; \u0026lt;/LinearLayout\u0026gt; Java package com.showguan.chapter05; import android.os.Bundle; import android.view.View; import android.widget.CheckBox; import android.widget.CompoundButton; import androidx.activity.EdgeToEdge; import androidx.appcompat.app.AppCompatActivity; import androidx.core.graphics.Insets; import androidx.core.view.ViewCompat; import androidx.core.view.WindowInsetsCompat; public class CheckBoxActivity extends AppCompatActivity implements CompoundButton.OnCheckedChangeListener { @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.activity_check_box); CheckBox ck_system = findViewById(R.id.ck_system); CheckBox ck_custom = findViewById(R.id.ck_custom); ck_system.setOnCheckedChangeListener(this); ck_custom.setOnCheckedChangeListener(this); } @Override public void onCheckedChanged(CompoundButton buttonView, boolean isChecked) { String desc = String.format(\u0026#34;您%s此按钮。\u0026#34; , isChecked ? \u0026#34;勾选了\u0026#34; : \u0026#34;取消勾选了\u0026#34;); buttonView.setText(desc); } } 开关Switch xml \u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;utf-8\u0026#34;?\u0026gt; \u0026lt;LinearLayout xmlns:android=\u0026#34;http://schemas.android.com/apk/res/android\u0026#34; android:id=\u0026#34;@+id/main\u0026#34; android:layout_width=\u0026#34;match_parent\u0026#34; android:layout_height=\u0026#34;match_parent\u0026#34; android:orientation=\u0026#34;vertical\u0026#34;\u0026gt; \u0026lt;LinearLayout android:layout_width=\u0026#34;match_parent\u0026#34; android:layout_height=\u0026#34;wrap_content\u0026#34; android:orientation=\u0026#34;horizontal\u0026#34;\u0026gt; \u0026lt;TextView android:layout_width=\u0026#34;0dp\u0026#34; android:layout_height=\u0026#34;wrap_content\u0026#34; android:layout_gravity=\u0026#34;start\u0026#34; android:layout_marginTop=\u0026#34;5dp\u0026#34; android:layout_weight=\u0026#34;1\u0026#34; android:text=\u0026#34;开关\u0026#34; android:textSize=\u0026#34;17sp\u0026#34; /\u0026gt; \u0026lt;Switch android:id=\u0026#34;@+id/sw_status\u0026#34; android:layout_width=\u0026#34;wrap_content\u0026#34; android:layout_height=\u0026#34;wrap_content\u0026#34; android:layout_gravity=\u0026#34;end\u0026#34; android:width=\u0026#34;80dp\u0026#34; android:height=\u0026#34;30dp\u0026#34; android:padding=\u0026#34;5dp\u0026#34; /\u0026gt; \u0026lt;/LinearLayout\u0026gt; \u0026lt;TextView android:id=\u0026#34;@+id/tv_result\u0026#34; android:layout_width=\u0026#34;0dp\u0026#34; android:layout_height=\u0026#34;wrap_content\u0026#34; android:layout_gravity=\u0026#34;start\u0026#34; android:layout_marginTop=\u0026#34;10dp\u0026#34; android:layout_weight=\u0026#34;1\u0026#34; android:gravity=\u0026#34;start\u0026#34; /\u0026gt; \u0026lt;/LinearLayout\u0026gt; Java package com.showguan.chapter05; public class SwitchActivity extends AppCompatActivity implements CompoundButton.OnCheckedChangeListener { private TextView tv_result; @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.activity_switch); Switch sw_status = findViewById(R.id.sw_status); tv_result = findViewById(R.id.tv_result); sw_status.setOnCheckedChangeListener(this); } @Override public void onCheckedChanged(CompoundButton buttonView, boolean isChecked) { String desc = String.format(\u0026#34;Switch按钮的状态是%s\u0026#34;, isChecked ? \u0026#34;开\u0026#34; : \u0026#34;关\u0026#34;); tv_result.setText(desc); } } 用checkbox实现switch xml \u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;utf-8\u0026#34;?\u0026gt; \u0026lt;LinearLayout xmlns:android=\u0026#34;http://schemas.android.com/apk/res/android\u0026#34; android:id=\u0026#34;@+id/main\u0026#34; android:layout_width=\u0026#34;match_parent\u0026#34; android:layout_height=\u0026#34;match_parent\u0026#34; android:orientation=\u0026#34;vertical\u0026#34;\u0026gt; \u0026lt;LinearLayout android:layout_width=\u0026#34;match_parent\u0026#34; android:layout_height=\u0026#34;wrap_content\u0026#34; android:orientation=\u0026#34;horizontal\u0026#34;\u0026gt; \u0026lt;TextView android:layout_width=\u0026#34;0dp\u0026#34; android:layout_height=\u0026#34;wrap_content\u0026#34; android:layout_gravity=\u0026#34;start\u0026#34; android:layout_marginTop=\u0026#34;5dp\u0026#34; android:layout_weight=\u0026#34;1\u0026#34; android:text=\u0026#34;开关\u0026#34; android:textSize=\u0026#34;17sp\u0026#34; /\u0026gt; \u0026lt;CheckBox android:id=\u0026#34;@+id/ck_status\u0026#34; android:layout_width=\u0026#34;60dp\u0026#34; android:layout_height=\u0026#34;30dp\u0026#34; android:layout_gravity=\u0026#34;end\u0026#34; android:width=\u0026#34;80dp\u0026#34; android:height=\u0026#34;30dp\u0026#34; android:background=\u0026#34;@drawable/switch_selector\u0026#34; android:button=\u0026#34;@null\u0026#34; /\u0026gt; \u0026lt;/LinearLayout\u0026gt; \u0026lt;TextView android:id=\u0026#34;@+id/tv_result\u0026#34; android:layout_width=\u0026#34;match_parent\u0026#34; android:layout_height=\u0026#34;wrap_content\u0026#34; android:layout_gravity=\u0026#34;start\u0026#34; android:layout_marginTop=\u0026#34;10dp\u0026#34; android:gravity=\u0026#34;start\u0026#34; /\u0026gt; \u0026lt;/LinearLayout\u0026gt; Java package com.showguan.chapter05; public class SwitchIOSActivity extends AppCompatActivity implements CompoundButton.OnCheckedChangeListener { private TextView tv_result; @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.activity_switch_iosactivity); CheckBox ck_status = findViewById(R.id.ck_status); tv_result = findViewById(R.id.tv_result); ck_status.setOnCheckedChangeListener(this); } @Override public void onCheckedChanged(CompoundButton buttonView, boolean isChecked) { String desc = String.format(\u0026#34;开关按钮的状态是%s\u0026#34;, isChecked ? \u0026#34;开\u0026#34; : \u0026#34;关\u0026#34;); tv_result.setText(desc); } } 单选按钮RadioButton XML \u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;utf-8\u0026#34;?\u0026gt; \u0026lt;LinearLayout xmlns:android=\u0026#34;http://schemas.android.com/apk/res/android\u0026#34; android:id=\u0026#34;@+id/main\u0026#34; android:layout_width=\u0026#34;match_parent\u0026#34; android:layout_height=\u0026#34;match_parent\u0026#34; android:orientation=\u0026#34;vertical\u0026#34;\u0026gt; \u0026lt;TextView android:layout_width=\u0026#34;match_parent\u0026#34; android:layout_height=\u0026#34;wrap_content\u0026#34; android:layout_gravity=\u0026#34;start\u0026#34; android:layout_marginTop=\u0026#34;5dp\u0026#34; android:text=\u0026#34;请选择你的性别\u0026#34; android:textSize=\u0026#34;17sp\u0026#34; /\u0026gt; \u0026lt;RadioGroup android:id=\u0026#34;@+id/rg_gender\u0026#34; android:layout_width=\u0026#34;match_parent\u0026#34; android:layout_height=\u0026#34;wrap_content\u0026#34; android:orientation=\u0026#34;horizontal\u0026#34;\u0026gt; \u0026lt;RadioButton android:id=\u0026#34;@+id/rb_male\u0026#34; android:layout_width=\u0026#34;0dp\u0026#34; android:layout_height=\u0026#34;wrap_content\u0026#34; android:layout_weight=\u0026#34;1\u0026#34; android:text=\u0026#34;男\u0026#34; /\u0026gt; \u0026lt;RadioButton android:id=\u0026#34;@+id/rb_female\u0026#34; android:layout_width=\u0026#34;0dp\u0026#34; android:layout_height=\u0026#34;wrap_content\u0026#34; android:layout_weight=\u0026#34;1\u0026#34; android:text=\u0026#34;女\u0026#34; /\u0026gt; \u0026lt;/RadioGroup\u0026gt; \u0026lt;TextView android:id=\u0026#34;@+id/tv_result\u0026#34; android:layout_width=\u0026#34;match_parent\u0026#34; android:layout_height=\u0026#34;wrap_content\u0026#34; android:layout_marginTop=\u0026#34;10dp\u0026#34; android:textSize=\u0026#34;17sp\u0026#34; /\u0026gt; \u0026lt;/LinearLayout\u0026gt; Java package com.showguan.chapter05; public class RadioHorizontalActivity extends AppCompatActivity implements RadioGroup.OnCheckedChangeListener { private TextView tv_result; @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.activity_radio_horizontal); RadioGroup rg_gender = findViewById(R.id.rg_gender); rg_gender.setOnCheckedChangeListener(this); tv_result = findViewById(R.id.tv_result); } @Override public void onCheckedChanged(RadioGroup group, int checkedId) { if(checkedId == R.id.rb_male){ tv_result.setText(\u0026#34;你是个帅气的男孩\u0026#34;); } else if (checkedId==R.id.rb_female) { tv_result.setText(\u0026#34;你是个漂亮的女孩\u0026#34;); } } } EditText设置外框 XML \u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;utf-8\u0026#34;?\u0026gt; \u0026lt;LinearLayout xmlns:android=\u0026#34;http://schemas.android.com/apk/res/android\u0026#34; android:id=\u0026#34;@+id/main\u0026#34; android:layout_width=\u0026#34;match_parent\u0026#34; android:layout_height=\u0026#34;match_parent\u0026#34; android:orientation=\u0026#34;vertical\u0026#34; android:padding=\u0026#34;5dp\u0026#34;\u0026gt; \u0026lt;EditText android:layout_width=\u0026#34;match_parent\u0026#34; android:layout_height=\u0026#34;wrap_content\u0026#34; android:hint=\u0026#34;这里是默认边框\u0026#34; android:inputType=\u0026#34;text\u0026#34;/\u0026gt; \u0026lt;EditText android:layout_width=\u0026#34;match_parent\u0026#34; android:layout_height=\u0026#34;wrap_content\u0026#34; android:hint=\u0026#34;这里没有边框\u0026#34; android:inputType=\u0026#34;text\u0026#34; android:layout_marginTop=\u0026#34;5dp\u0026#34; android:background=\u0026#34;@null\u0026#34;/\u0026gt; \u0026lt;EditText android:layout_width=\u0026#34;match_parent\u0026#34; android:layout_height=\u0026#34;wrap_content\u0026#34; android:hint=\u0026#34;这里是圆角边框\u0026#34; android:inputType=\u0026#34;text\u0026#34; android:layout_marginTop=\u0026#34;5dp\u0026#34; android:background=\u0026#34;@drawable/edittext_selector\u0026#34; /\u0026gt; \u0026lt;/LinearLayout\u0026gt; Java public class EditBoardActivity extends AppCompatActivity { @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.activity_edit_board); } } 对话提示框 XML \u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;utf-8\u0026#34;?\u0026gt; \u0026lt;LinearLayout xmlns:android=\u0026#34;http://schemas.android.com/apk/res/android\u0026#34; android:id=\u0026#34;@+id/main\u0026#34; android:layout_width=\u0026#34;match_parent\u0026#34; android:layout_height=\u0026#34;match_parent\u0026#34; android:orientation=\u0026#34;vertical\u0026#34; android:padding=\u0026#34;5dp\u0026#34;\u0026gt; \u0026lt;Button android:id=\u0026#34;@+id/btn_alert\u0026#34; android:layout_width=\u0026#34;match_parent\u0026#34; android:layout_height=\u0026#34;wrap_content\u0026#34; android:hint=\u0026#34;这里没有边框\u0026#34; android:text=\u0026#34;点击弹出提醒对话框\u0026#34; android:layout_marginTop=\u0026#34;5dp\u0026#34; android:background=\u0026#34;@null\u0026#34;/\u0026gt; \u0026lt;TextView android:id=\u0026#34;@+id/tv_alert\u0026#34; android:layout_width=\u0026#34;match_parent\u0026#34; android:layout_height=\u0026#34;wrap_content\u0026#34; android:layout_marginTop=\u0026#34;5dp\u0026#34; /\u0026gt; \u0026lt;/LinearLayout\u0026gt; Java package com.showguan.chapter05; import android.os.Bundle; import android.view.View; import android.widget.TextView; import androidx.appcompat.app.AlertDialog; import androidx.appcompat.app.AppCompatActivity; public class AlertDialogActivity extends AppCompatActivity implements View.OnClickListener { private TextView tv_alert; @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.activity_alert_dialog); findViewById(R.id.btn_alert).setOnClickListener(this); tv_alert = findViewById(R.id.tv_alert); } @Override public void onClick(View v) { AlertDialog.Builder builder = new AlertDialog.Builder(this); builder.setTitle(\u0026#34;尊敬的用户朋友\u0026#34;); builder.setMessage(\u0026#34;你真的确定没点错吗？\u0026#34;); builder.setPositiveButton(\u0026#34;残忍卸载\u0026#34;, (dialog, which) -\u0026gt; { tv_alert.setText(\u0026#34;虽然依依不舍，但是希望能再见面\u0026#34;); }); builder.setNegativeButton(\u0026#34;点错了哦\u0026#34;, (dialog, which) -\u0026gt; { tv_alert.setText(\u0026#34;我还要再陪你365*n个日夜\u0026#34;); }); AlertDialog dialog = builder.create(); dialog.show(); } } 文本框提示信息 XML \u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;utf-8\u0026#34;?\u0026gt; \u0026lt;LinearLayout xmlns:android=\u0026#34;http://schemas.android.com/apk/res/android\u0026#34; android:id=\u0026#34;@+id/main\u0026#34; android:layout_width=\u0026#34;match_parent\u0026#34; android:layout_height=\u0026#34;match_parent\u0026#34; android:orientation=\u0026#34;vertical\u0026#34; android:padding=\u0026#34;5dp\u0026#34;\u0026gt; \u0026lt;EditText android:id=\u0026#34;@+id/et_phone\u0026#34; android:layout_width=\u0026#34;match_parent\u0026#34; android:layout_height=\u0026#34;wrap_content\u0026#34; android:hint=\u0026#34;请输入11位手机号码\u0026#34; android:inputType=\u0026#34;number\u0026#34; android:maxLength=\u0026#34;11\u0026#34; android:layout_marginTop=\u0026#34;15dp\u0026#34; android:background=\u0026#34;@drawable/edittext_selector\u0026#34;/\u0026gt; \u0026lt;EditText android:id=\u0026#34;@+id/et_password\u0026#34; android:layout_width=\u0026#34;match_parent\u0026#34; android:layout_height=\u0026#34;wrap_content\u0026#34; android:hint=\u0026#34;请输入6位密码\u0026#34; android:inputType=\u0026#34;numberPassword\u0026#34; android:maxLength=\u0026#34;11\u0026#34; android:layout_marginTop=\u0026#34;15dp\u0026#34; android:background=\u0026#34;@drawable/edittext_selector\u0026#34;/\u0026gt; \u0026lt;Button android:layout_width=\u0026#34;match_parent\u0026#34; android:layout_marginTop=\u0026#34;15dp\u0026#34; android:layout_height=\u0026#34;wrap_content\u0026#34; android:text=\u0026#34;登录\u0026#34;/\u0026gt; \u0026lt;/LinearLayout\u0026gt; Java package com.showguan.chapter05; public class EditFocusActivity extends AppCompatActivity implements View.OnFocusChangeListener { private EditText et_phone; @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.activity_edit_focus); et_phone = findViewById(R.id.et_phone); et_phone.setOnFocusChangeListener(this); } @Override public void onFocusChange(View v, boolean hasFocus) { if(!hasFocus){ String phone = et_phone.getText().toString(); if(TextUtils.isEmpty(phone) || phone.length() \u0026lt; 11){ // et_phone.requestFocus(); Toast.makeText(this, \u0026#34;请输入11位手机号码\u0026#34;, Toast.LENGTH_SHORT).show(); } } } } 实现当文本长度符合时自动收起输入法 @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.activity_edit_hide); // 设置当前活动的布局 // 获取布局文件中的EditText控件 EditText et_phone = findViewById(R.id.et_phone); EditText et_password = findViewById(R.id.et_password); // 为EditText控件添加文本变化监听器 et_phone.addTextChangedListener(new HideTextWatcher(et_phone, 11)); et_password.addTextChangedListener(new HideTextWatcher(et_password, 6)); } // 自定义的文本监听器类，用于在文本长度达到指定值时隐藏输入法 private class HideTextWatcher implements TextWatcher { private EditText mView; // 需要监听的EditText控件 private int mMaxLength; // 文本长度的最大值 // 构造函数，初始化控件和最大长度 public HideTextWatcher(EditText et, int maxLength) { this.mView = et; this.mMaxLength = maxLength; } // 文本变化前的回调方法 @Override public void beforeTextChanged(CharSequence s, int start, int count, int after) { // 在文本变化前执行的操作，这里不需要实现 } // 文本变化中的回调方法 @Override public void onTextChanged(CharSequence s, int start, int before, int count) { // 在文本变化中执行的操作，这里不需要实现 } // 文本变化后的回调方法 @Override public void afterTextChanged(Editable s) { String str = s.toString(); // 获取当前文本内容 if(str.length() == mMaxLength) { // 如果文本长度等于最大值 // 调用自定义工具类隐藏输入法 ViewUtil.hideOneInputMethod(EditHideActivity.this, mView); } } } 日期选择器 DatePicker XML \u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;utf-8\u0026#34;?\u0026gt; \u0026lt;LinearLayout xmlns:android=\u0026#34;http://schemas.android.com/apk/res/android\u0026#34; android:id=\u0026#34;@+id/main\u0026#34; android:layout_width=\u0026#34;match_parent\u0026#34; android:layout_height=\u0026#34;match_parent\u0026#34; android:orientation=\u0026#34;vertical\u0026#34; \u0026gt; \u0026lt;Button android:id=\u0026#34;@+id/btn_calendar\u0026#34; android:layout_width=\u0026#34;match_parent\u0026#34; android:layout_height=\u0026#34;wrap_content\u0026#34; android:text=\u0026#34;请选择日期\u0026#34; android:layout_marginTop=\u0026#34;40dp\u0026#34;/\u0026gt; \u0026lt;DatePicker android:id=\u0026#34;@+id/dp_date\u0026#34; android:layout_width=\u0026#34;match_parent\u0026#34; android:layout_height=\u0026#34;wrap_content\u0026#34; android:datePickerMode=\u0026#34;spinner\u0026#34; android:calendarViewShown=\u0026#34;false\u0026#34;/\u0026gt; \u0026lt;Button android:id=\u0026#34;@+id/btn_confirm\u0026#34; android:layout_width=\u0026#34;match_parent\u0026#34; android:layout_height=\u0026#34;wrap_content\u0026#34; android:text=\u0026#34;确定\u0026#34;/\u0026gt; \u0026lt;TextView android:id=\u0026#34;@+id/tv_result\u0026#34; android:layout_width=\u0026#34;match_parent\u0026#34; android:layout_height=\u0026#34;wrap_content\u0026#34; android:background=\u0026#34;@drawable/edittext_selector\u0026#34; /\u0026gt; \u0026lt;/LinearLayout\u0026gt; Java package com.showguan.chapter05; import android.app.DatePickerDialog; import android.os.Bundle; import android.view.View; import android.widget.Button; import android.widget.DatePicker; import android.widget.TextView; import androidx.activity.EdgeToEdge; import androidx.appcompat.app.AppCompatActivity; import androidx.core.graphics.Insets; import androidx.core.view.ViewCompat; import androidx.core.view.WindowInsetsCompat; public class DatePickerActivity extends AppCompatActivity implements View.OnClickListener, DatePickerDialog.OnDateSetListener { private DatePicker dp_date; private TextView tv_result; @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); EdgeToEdge.enable(this); setContentView(R.layout.activity_date_picker); findViewById(R.id.btn_confirm).setOnClickListener(this); findViewById(R.id.btn_calendar).setOnClickListener(this); dp_date = findViewById(R.id.dp_date); tv_result = findViewById(R.id.tv_result); } @Override public void onClick(View v) { if(v.getId() == R.id.btn_confirm){ String desc = String.format(\u0026#34;您选择的日期为%s年 %s月 %s日\u0026#34;, dp_date.getYear(), dp_date.getMonth() + 1, dp_date.getDayOfMonth()); tv_result.setText(desc); } else if (v.getId() == R.id.btn_calendar) { DatePickerDialog dialog = new DatePickerDialog(this, this, 2027, 4, 13); dialog.show(); } } @Override public void onDateSet(DatePicker view, int year, int month, int dayOfMonth) { String desc = String.format(\u0026#34;您选择的日期为%s年 %s月 %s日\u0026#34;, year, month, dayOfMonth); tv_result.setText(desc); } } 时间选择器 TimePicker XML \u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;utf-8\u0026#34;?\u0026gt; \u0026lt;LinearLayout xmlns:android=\u0026#34;http://schemas.android.com/apk/res/android\u0026#34; android:id=\u0026#34;@+id/main\u0026#34; android:layout_width=\u0026#34;match_parent\u0026#34; android:layout_height=\u0026#34;match_parent\u0026#34; android:orientation=\u0026#34;vertical\u0026#34; \u0026gt; \u0026lt;Button android:id=\u0026#34;@+id/btn_time\u0026#34; android:layout_width=\u0026#34;match_parent\u0026#34; android:layout_height=\u0026#34;wrap_content\u0026#34; android:text=\u0026#34;请选择时间\u0026#34; android:layout_marginTop=\u0026#34;40dp\u0026#34;/\u0026gt; \u0026lt;TimePicker android:id=\u0026#34;@+id/tp_time\u0026#34; android:layout_width=\u0026#34;match_parent\u0026#34; android:layout_height=\u0026#34;wrap_content\u0026#34; android:timePickerMode=\u0026#34;spinner\u0026#34; android:layout_marginTop=\u0026#34;5dp\u0026#34; android:calendarViewShown=\u0026#34;false\u0026#34;/\u0026gt; \u0026lt;Button android:id=\u0026#34;@+id/btn_confirm\u0026#34; android:layout_width=\u0026#34;match_parent\u0026#34; android:layout_height=\u0026#34;wrap_content\u0026#34; android:text=\u0026#34;确定\u0026#34;/\u0026gt; \u0026lt;TextView android:id=\u0026#34;@+id/tv_result\u0026#34; android:layout_width=\u0026#34;match_parent\u0026#34; android:layout_height=\u0026#34;wrap_content\u0026#34; android:layout_marginTop=\u0026#34;5dp\u0026#34; android:background=\u0026#34;@drawable/edittext_selector\u0026#34; /\u0026gt; \u0026lt;/LinearLayout\u0026gt; Java public class TimePickerActivity extends AppCompatActivity implements View.OnClickListener, TimePickerDialog.OnTimeSetListener { private TimePicker tp_time; private TextView tv_result; @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.activity_time_picker); findViewById(R.id.btn_confirm).setOnClickListener(this); findViewById(R.id.btn_time).setOnClickListener(this); tp_time = findViewById(R.id.tp_time); tv_result = findViewById(R.id.tv_result); } @Override public void onClick(View v) { if (v.getId() == R.id.btn_confirm) { String desc = String.format(\u0026#34;您选择的时间为%s时 %s分\u0026#34;, tp_time.getHour(), tp_time.getMinute()); tv_result.setText(desc); } else if (v.getId() == R.id.btn_time) { Log.d(\u0026#34;Kennem\u0026#34;, \u0026#34;onClick: R.id.btn_time\u0026#34;); Calendar calendar = Calendar.getInstance(); TimePickerDialog dialog = new TimePickerDialog(this, AlertDialog.THEME_HOLO_DARK,this, calendar.get(Calendar.HOUR_OF_DAY), calendar.get(Calendar.MINUTE), true); dialog.show(); } } @Override public void onTimeSet(TimePicker view, int hourOfDay, int minute) { String desc = String.format(\u0026#34;您选择的时间为%s时 %s分\u0026#34;, hourOfDay, minute); tv_result.setText(desc); } } 案例 登录页面以及找回密码页面\n","permalink":"https://kennems.github.io/zh/posts/tech/android2/","summary":"Android（2） Activity的启动和结束 从当前页面跳转到新页面，跳转代码如下： startActivity(new Intent(源页面.this， 目标页面.class","title":"Android（2）"},{"content":"Android（3） 数据存储 共享参数的用法 SharedPreferences 是 Android的一个轻量级存储工具，采用的存储结构是key-value的键值对方式 共享参数的存储介质是符合XML规范的配置文件。保存路径是：/data/data/应用包名/shared_prefs/文件名.xml 共享参数主要适用的场合：\n简单且孤立的数据。若是复杂且相互间有关的数据，则要保存在数据库中。 文本形式的数据。若是二进制数据，则要保存在文件中。 需要持久化存储的数据。在App退出后再次启动时，之前保存的数据仍然有效。 实际开发中，共享参数经常存储的数据有App的个性化配置信息，用户使用App的行为信息，临时需要保存的片段信息。\nShareWriteActivity.java package com.showguan.chapter06; public class ShareWriteActivity extends AppCompatActivity implements View.OnClickListener { private EditText et_name; private EditText et_age; private EditText et_height; private EditText et_weight; private SharedPreferences preferences; private CheckBox ck_isMarried; @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.activity_share_write); et_name = findViewById(R.id.et_name); et_age = findViewById(R.id.et_age); et_height = findViewById(R.id.et_height); et_weight = findViewById(R.id.et_weight); ck_isMarried = findViewById(R.id.ck_isMarried); findViewById(R.id.btn_save).setOnClickListener(this); preferences = getSharedPreferences(\u0026#34;config\u0026#34;, Context.MODE_PRIVATE); reload(); } private void reload() { String name = preferences.getString(\u0026#34;name\u0026#34;, null); if(name != null){ et_name.setText(name); } int age = preferences.getInt(\u0026#34;age\u0026#34;, 0); if(age != 0){ et_age.setText(String.valueOf(age)); } Float height = preferences.getFloat(\u0026#34;height\u0026#34;, 0.0F); if(height != 0.0F){ et_height.setText(height.toString()); } Float weight = preferences.getFloat(\u0026#34;weight\u0026#34;, 0.0F); if(weight != 0.0F){ et_weight.setText(weight.toString()); } Boolean isMarried = preferences.getBoolean(\u0026#34;married\u0026#34;, false); ck_isMarried.setChecked(isMarried); } @Override public void onClick(View v) { String name = et_name.getText().toString(); String age = et_age.getText().toString(); String height = et_height.getText().toString(); String weight = et_weight.getText().toString(); SharedPreferences.Editor editor = preferences.edit(); editor.putString(\u0026#34;name\u0026#34;, name); editor.putInt(\u0026#34;age\u0026#34;, Integer.valueOf(age)); editor.putFloat(\u0026#34;height\u0026#34;, Float.valueOf(height)); editor.putFloat(\u0026#34;weight\u0026#34;, Float.valueOf(weight)); editor.putBoolean(\u0026#34;married\u0026#34;, ck_isMarried.isChecked()); editor.commit(); } } 实现保存密码 Java 用数据库存储\npackage com.showguan.chapter06; import java.util.Random; public class LoginSQLliteActivity extends AppCompatActivity implements RadioGroup.OnCheckedChangeListener, View.OnClickListener, View.OnFocusChangeListener { // 定义界面中的控件 private TextView login_passFun; private EditText login_input; private TextView login_input_option; private View remember_password_layout; private RadioButton rb_phonecode; private RadioButton rb_password; private CheckBox ck_save_password; private EditText et_phone; private Button login; private String mPassword = \u0026#34;123456\u0026#34;; // 默认密码 private String mVerifyCode; // 验证码 // ActivityResultLauncher用于处理从FindPasswordActivity返回的结果 private ActivityResultLauncher\u0026lt;Intent\u0026gt; register = registerForActivityResult(new ActivityResultContracts.StartActivityForResult(), new ActivityResultCallback\u0026lt;ActivityResult\u0026gt;() { @Override public void onActivityResult(ActivityResult o) { Intent intent = o.getData(); if (intent != null \u0026amp;\u0026amp; o.getResultCode() == Activity.RESULT_OK) { mPassword = intent.getStringExtra(\u0026#34;new_password\u0026#34;); // 获取新密码 } } }); private SharedPreferences preferences; private LoginDBHelper mHelper; @Override protected void onStart() { super.onStart(); mHelper = LoginDBHelper.getInstance(this); // 获取数据库帮助类实例 mHelper.openReadLink(); // 打开数据库读取连接 mHelper.openWriteLink(); // 打开数据库写入连接 reload(); // 重新加载用户信息 } @Override protected void onStop() { super.onStop(); mHelper.closeLink(); // 关闭数据库连接 } @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.activity_login_main); // 设置活动布局 // 初始化控件 RadioGroup rg_login = findViewById(R.id.rg_login); login_passFun = findViewById(R.id.login_passFun); login_input = findViewById(R.id.login_input); login_input_option = findViewById(R.id.login_input_option); remember_password_layout = findViewById(R.id.remember_password_layout); rb_password = findViewById(R.id.rb_password); rb_phonecode = findViewById(R.id.rb_phonecode); et_phone = findViewById(R.id.et_phone); ck_save_password = findViewById(R.id.ck_save_password); login = findViewById(R.id.login); // 设置监听器 rg_login.setOnCheckedChangeListener(this); et_phone.addTextChangedListener(new HideTextWatcher(et_phone, 11)); login_input.addTextChangedListener(new HideTextWatcher(login_input, 6)); login_input.setOnFocusChangeListener(this); login_input_option.setOnClickListener(this); login.setOnClickListener(this); // 获取SharedPreferences对象 preferences = getSharedPreferences(\u0026#34;config\u0026#34;, Context.MODE_PRIVATE); } // 重新加载用户信息 private void reload() { LoginInfo info = mHelper.queryTop(); // 查询最新的用户信息 if (info != null \u0026amp;\u0026amp; info.isRemember()) { et_phone.setText(info.getPhone()); login_input.setText(info.getPassword()); ck_save_password.setChecked(true); } } // 监听RadioGroup选中状态变化 @Override public void onCheckedChanged(RadioGroup group, int checkedId) { if (checkedId == R.id.rb_password) { login_passFun.setText(R.string.login_password); login_input.setHint(R.string.password_hint); login_input_option.setText(R.string.forget_password); remember_password_layout.setVisibility(View.VISIBLE); } else if (checkedId == R.id.rb_phonecode) { login_passFun.setText(R.string.login_phonecode); login_input.setHint(R.string.code_hint); login_input_option.setText(R.string.get_code); remember_password_layout.setVisibility(View.GONE); } } // 监听点击事件 @Override public void onClick(View v) { String phoneNum = et_phone.getText().toString(); if (phoneNum.length() \u0026lt; 11) { Toast.makeText(this, \u0026#34;您输入的手机号不足11位，请重新输入\u0026#34;, Toast.LENGTH_SHORT).show(); return; } if (v.getId() == R.id.login_input_option) { if (rb_password.isChecked()) { Intent intent = new Intent(this, FindPasswordActivity.class); intent.putExtra(\u0026#34;phone\u0026#34;, phoneNum); register.launch(intent); // 启动FindPasswordActivity } else if (rb_phonecode.isChecked()) { mVerifyCode = String.format(\u0026#34;%06d\u0026#34;, new Random().nextInt(999999)); // 生成随机验证码 AlertDialog.Builder builder = new AlertDialog.Builder(this); builder.setTitle(\u0026#34;手机验证码\u0026#34;); builder.setMessage(\u0026#34;手机号\u0026#34; + phoneNum + \u0026#34;, 本次验证码是\u0026#34; + mVerifyCode); builder.setPositiveButton(\u0026#34;好的\u0026#34;, null); AlertDialog dialog = builder.create(); dialog.show(); } } else if (v.getId() == R.id.login) { if (rb_password.isChecked()) { if (!mPassword.equals(login_input.getText().toString())) { Toast.makeText(this, \u0026#34;用户名或密码错误，请检查输入：\u0026#34;, Toast.LENGTH_SHORT).show(); return; } loginSuccess(); } else if (rb_phonecode.isChecked()) { if (mVerifyCode == null || !mVerifyCode.equals(login_input.getText().toString())) { Toast.makeText(this, \u0026#34;验证码错误，请检查输入：\u0026#34;, Toast.LENGTH_SHORT).show(); return; } loginSuccess(); } } } // 登录成功处理 private void loginSuccess() { String desc = String.format(\u0026#34;你的手机号是%s, 恭喜你登录成功，点击确认返回上一个页面\u0026#34;, et_phone.getText().toString()); AlertDialog.Builder builder = new AlertDialog.Builder(this); builder.setTitle(\u0026#34;登录成功\u0026#34;); builder.setMessage(desc); builder.setPositiveButton(\u0026#34;确认返回\u0026#34;, (dialog, which) -\u0026gt; { finish(); // 结束当前活动 }); builder.setNegativeButton(\u0026#34;我再看看吧\u0026#34;, null); AlertDialog dialog = builder.create(); dialog.show(); if (rb_password.isChecked() \u0026amp;\u0026amp; ck_save_password.isChecked()) { SharedPreferences.Editor editor = preferences.edit(); editor.putString(\u0026#34;account\u0026#34;, et_phone.getText().toString()); editor.putString(\u0026#34;password\u0026#34;, login_input.getText().toString()); editor.putBoolean(\u0026#34;is_save_password\u0026#34;, true); editor.commit(); // 提交保存 } LoginInfo info = new LoginInfo(et_phone.getText().toString(), login_input.getText().toString(), ck_save_password.isChecked()); mHelper.insert(info); // 将用户信息插入数据库 } // 监听控件焦点变化 @Override public void onFocusChange(View v, boolean hasFocus) { if (v.getId() == R.id.login_input \u0026amp;\u0026amp; hasFocus) { LoginInfo info = mHelper.queryByPhone(et_phone.getText().toString()); if (info != null) { login_input.setText(info.getPassword()); ck_save_password.setChecked(true); } else { login_input.setText(\u0026#34;\u0026#34;); ck_save_password.setChecked(false); } } } // 自定义TextWatcher类，用于隐藏输入法 class HideTextWatcher implements TextWatcher { private EditText mView; private int maxLength; public HideTextWatcher(EditText editText, int maxLength) { this.mView = editText; this.maxLength = maxLength; } @Override public void beforeTextChanged(CharSequence s, int start, int count, int after) { // 在文本改变前执行的操作 } @Override public void onTextChanged(CharSequence s, int start, int before, int count) { // 在文本改变时执行的操作 } @Override public void afterTextChanged(Editable s) { // 在文本改变后执行的操作 if (s.toString().length() == maxLength) { ViewUtil.hideOneInputMethod(LoginSQLliteActivity.this, mView); } } } } 数据库管理器SQLiteDatabase SQLiteDatabase是SQLite的数据库管理类，它提供了托干操作数据表的API， 常用的方法有3类： 管理类，用户数据库层面的操作 openDatabase：打开指定路径的数据库 isOpen：判断数据库是否已打开 close：关闭数据库 getVersion：获取数据库的版本号 setVersion：设置数据库的版本号 SQLiteDatabase实现保存密码 效果和SharePreference一致，但是是保存在数据库中。\nLoginDBHelper.java package com.showguan.chapter06.database; import android.content.ContentValues; import android.content.Context; import android.database.Cursor; import android.database.sqlite.SQLiteDatabase; import android.database.sqlite.SQLiteOpenHelper; import android.util.Log; import androidx.annotation.Nullable; import com.showguan.chapter06.enity.LoginInfo; import com.showguan.chapter06.enity.User; import java.util.ArrayList; import java.util.List; public class LoginDBHelper extends SQLiteOpenHelper { private static final String DB_NAME = \u0026#34;login.db\u0026#34;; private static final String TABLE_NAME = \u0026#34;login_info\u0026#34;; private static final int DB_VERSION = 1; private static LoginDBHelper mHelper = null; private SQLiteDatabase mRDB = null; private SQLiteDatabase mWDB = null; private LoginDBHelper(@Nullable Context context) { super(context, DB_NAME, null, DB_VERSION); } public static LoginDBHelper getInstance(Context context) { if (mHelper == null) { mHelper = new LoginDBHelper(context); } return mHelper; } public SQLiteDatabase openReadLink() { if (mRDB == null || !mRDB.isOpen()) { mRDB = mHelper.getReadableDatabase(); } return mRDB; } public SQLiteDatabase openWriteLink() { if (mWDB == null || !mWDB.isOpen()) { mWDB = mHelper.getReadableDatabase(); } return mWDB; } public void closeLink() { if (mRDB != null \u0026amp;\u0026amp; mRDB.isOpen()) { mRDB.close(); mRDB = null; } if (mWDB != null \u0026amp;\u0026amp; mWDB.isOpen()) { mWDB.close(); mWDB = null; } } @Override public void onCreate(SQLiteDatabase db) { String sql = \u0026#34;CREATE TABLE IF NOT EXISTS \u0026#34; + TABLE_NAME + \u0026#34; (\u0026#34; + \u0026#34;_id INTEGER PRIMARY KEY AUTOINCREMENT NOT NULL,\u0026#34; + \u0026#34; phone VARCHAR NOT NULL,\u0026#34; + \u0026#34; password VARCHAR NOT NULL,\u0026#34; + \u0026#34; remember INTEGER NOT NULL);\u0026#34;; db.execSQL(sql); } @Override public void onUpgrade(SQLiteDatabase db, int oldVersion, int newVersion) { // 数据库版本更新时使用 String sql = \u0026#34;ALTER TABLE \u0026#34; + TABLE_NAME + \u0026#34; ADD COLUMN phone VARCHAR;\u0026#34;; db.execSQL(sql); sql = \u0026#34;ALTER TABLE \u0026#34; + TABLE_NAME + \u0026#34; ADD COLUMN password VARCHAR;\u0026#34;; db.execSQL(sql); } public void save(LoginInfo info){ try { mWDB.beginTransaction(); delete(info); insert(info); mWDB.setTransactionSuccessful(); }catch (Exception e){ e.printStackTrace(); }finally { mWDB.endTransaction(); } } public long delete(LoginInfo info){ return mWDB.delete(TABLE_NAME, \u0026#34;phone=?\u0026#34;, new String[]{ info.getPhone() }); } public long insert(LoginInfo info) { ContentValues values = new ContentValues(); values.put(\u0026#34;phone\u0026#34;, info.getPhone()); values.put(\u0026#34;password\u0026#34;, info.getPassword()); values.put(\u0026#34;remember\u0026#34;, info.isRemember()); // 返回行号 return mWDB.insert(TABLE_NAME, null, values); } public long deleteByName(String name) { return mWDB.delete(TABLE_NAME, \u0026#34;name = ?\u0026#34;, new String[]{ name }); } public List\u0026lt;User\u0026gt; queryAll() { List\u0026lt;User\u0026gt; list = new ArrayList\u0026lt;\u0026gt;(); Cursor cursor = mRDB.query(TABLE_NAME, null, null, null, null, null, null); while (cursor.moveToNext()) { User user = new User(); user.setId(cursor.getInt(0)); user.setName(cursor.getString(1)); user.setAge(cursor.getInt(2)); user.setHeight(cursor.getFloat(3)); user.setWeight(cursor.getFloat(4)); user.setMarried(cursor.getInt(5) == 1 ? true : false); list.add(user); } return list; } public LoginInfo queryTop() { LoginInfo info = null; String sql = \u0026#34;SELECT * FROM \u0026#34; + TABLE_NAME + \u0026#34; WHERE remember = 1 ORDER BY _id DESC LIMIT 1\u0026#34;; Cursor cursor = null; try { cursor = mRDB.rawQuery(sql, null); if (cursor != null \u0026amp;\u0026amp; cursor.moveToNext()) { info = new LoginInfo(); int phoneIndex = cursor.getColumnIndex(\u0026#34;phone\u0026#34;); int passwordIndex = cursor.getColumnIndex(\u0026#34;password\u0026#34;); int rememberIndex = cursor.getColumnIndex(\u0026#34;remember\u0026#34;); if (phoneIndex != -1) { info.setPhone(cursor.getString(phoneIndex)); } if (passwordIndex != -1) { info.setPassword(cursor.getString(passwordIndex)); } if (rememberIndex != -1) { info.setRemember(cursor.getInt(rememberIndex) == 1); } } } finally { if (cursor != null) { cursor.close(); } } return info; } public LoginInfo queryByPhone(String phone) { LoginInfo info = null; String sql = \u0026#34;SELECT * FROM \u0026#34; + TABLE_NAME; Cursor cursor = mRDB.query(TABLE_NAME, null, \u0026#34;phone=? and remember=1\u0026#34;, new String[]{phone}, null, null, null); try { if (cursor != null \u0026amp;\u0026amp; cursor.moveToNext()) { info = new LoginInfo(); int phoneIndex = cursor.getColumnIndex(\u0026#34;phone\u0026#34;); int passwordIndex = cursor.getColumnIndex(\u0026#34;password\u0026#34;); int rememberIndex = cursor.getColumnIndex(\u0026#34;remember\u0026#34;); if (phoneIndex != -1) { info.setPhone(cursor.getString(phoneIndex)); } if (passwordIndex != -1) { info.setPassword(cursor.getString(passwordIndex)); } if (rememberIndex != -1) { info.setRemember(cursor.getInt(rememberIndex) == 1); } } } finally { if (cursor != null) { cursor.close(); } } return info; } } 实体类LoginInfo.java package com.showguan.chapter06.enity; public class LoginInfo { private String phone; private String password; private boolean remember; public LoginInfo(String phone, String password, boolean remember) { this.phone = phone; this.password = password; this.remember = remember; } public LoginInfo() { } public String getPhone() { return phone; } public void setPhone(String phone) { this.phone = phone; } public String getPassword() { return password; } public void setPassword(String password) { this.password = password; } public boolean isRemember() { return remember; } public void setRemember(boolean remember) { this.remember = remember; } @Override public String toString() { return \u0026#34;LoginInfo{\u0026#34; + \u0026#34;phone=\u0026#39;\u0026#34; + phone + \u0026#39;\\\u0026#39;\u0026#39; + \u0026#34;, password=\u0026#39;\u0026#34; + password + \u0026#39;\\\u0026#39;\u0026#39; + \u0026#34;, remember=\u0026#34; + remember + \u0026#39;}\u0026#39;; } } LoginSQLliteActivity.java package com.showguan.chapter06; public class LoginSQLliteActivity extends AppCompatActivity implements RadioGroup.OnCheckedChangeListener, View.OnClickListener, View.OnFocusChangeListener { // UI元素 private TextView login_passFun; private EditText login_input; private TextView login_input_option; private View remember_password_layout; private RadioButton rb_phonecode; private RadioButton rb_password; private CheckBox ck_save_password; private EditText et_phone; private Button login; // 密码和验证码 private String mPassword = \u0026#34;123456\u0026#34;; private String mVerifyCode; // ActivityResultLauncher 用于启动另一个Activity并接收结果 private ActivityResultLauncher\u0026lt;Intent\u0026gt; register = registerForActivityResult(new ActivityResultContracts.StartActivityForResult(), new ActivityResultCallback\u0026lt;ActivityResult\u0026gt;() { @Override public void onActivityResult(ActivityResult o) { Intent intent = o.getData(); if (intent != null \u0026amp;\u0026amp; o.getResultCode() == Activity.RESULT_OK) { // 获取从FindPasswordActivity返回的新密码 mPassword = intent.getStringExtra(\u0026#34;new_password\u0026#34;); } } }); // SharedPreferences 用于存储数据 private SharedPreferences preferences; // SQLite数据库助手 private LoginDBHelper mHelper; // Activity生命周期方法，在Activity启动时调用 @Override protected void onStart() { super.onStart(); // 打开数据库读写连接 mHelper = LoginDBHelper.getInstance(this); mHelper.openReadLink(); mHelper.openWriteLink(); // 重新加载登录信息 reload(); } // Activity生命周期方法，在Activity停止时调用 @Override protected void onStop() { super.onStop(); // 关闭数据库连接 mHelper.closeLink(); } // Activity创建时调用 @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); // 设置Activity的布局文件 setContentView(R.layout.activity_login_main); // 绑定UI元素 RadioGroup rg_login = findViewById(R.id.rg_login); login_passFun = findViewById(R.id.login_passFun); login_input = findViewById(R.id.login_input); login_input_option = findViewById(R.id.login_input_option); remember_password_layout = findViewById(R.id.remember_password_layout); rb_password = findViewById(R.id.rb_password); rb_phonecode = findViewById(R.id.rb_phonecode); et_phone = findViewById(R.id.et_phone); ck_save_password = findViewById(R.id.ck_save_password); login = findViewById(R.id.login); // 设置事件监听 rg_login.setOnCheckedChangeListener(this); et_phone.addTextChangedListener(new HideTextWatcher(et_phone, 11)); login_input.addTextChangedListener(new HideTextWatcher(login_input, 6)); login_input.setOnFocusChangeListener(this); login_input_option.setOnClickListener(this); login.setOnClickListener(this); // 初始化SharedPreferences preferences = getSharedPreferences(\u0026#34;config\u0026#34;, Context.MODE_PRIVATE); } // 重新加载登录信息 private void reload() { LoginInfo info = mHelper.queryTop(); if (info != null \u0026amp;\u0026amp; info.isRemember()) { // 如果有保存的登录信息，填充到UI元素中 et_phone.setText(info.getPhone()); login_input.setText(info.getPassword()); ck_save_password.setChecked(true); } } // RadioGroup选项变化时调用 @Override public void onCheckedChanged(RadioGroup group, int checkedId) { if (checkedId == R.id.rb_password) { // 选择密码登录 login_passFun.setText(R.string.login_password); login_input.setHint(R.string.password_hint); login_input_option.setText(R.string.forget_password); remember_password_layout.setVisibility(View.VISIBLE); } else if (checkedId == R.id.rb_phonecode) { // 选择验证码登录 login_passFun.setText(R.string.login_phonecode); login_input.setHint(R.string.code_hint); login_input_option.setText(R.string.get_code); remember_password_layout.setVisibility(View.GONE); } } // 点击事件处理 @Override public void onClick(View v) { String phoneNum = et_phone.getText().toString(); if (phoneNum.length() \u0026lt; 11) { // 手机号不足11位，提示用户 Toast.makeText(this, \u0026#34;您输入的手机号不足11位，请重新输入\u0026#34;, Toast.LENGTH_SHORT).show(); return; } if (v.getId() == R.id.login_input_option) { if (rb_password.isChecked()) { // 找回密码 Intent intent = new Intent(this, FindPasswordActivity.class); intent.putExtra(\u0026#34;phone\u0026#34;, phoneNum); register.launch(intent); } else if (rb_phonecode.isChecked()) { // 获取验证码 mVerifyCode = String.format(\u0026#34;%06d\u0026#34;, new Random().nextInt(999999)); AlertDialog.Builder builder = new AlertDialog.Builder(this); builder.setTitle(\u0026#34;手机验证码\u0026#34;); builder.setMessage(\u0026#34;手机号\u0026#34; + phoneNum + \u0026#34;, 本次验证码是\u0026#34; + mVerifyCode); builder.setPositiveButton(\u0026#34;好的\u0026#34;, null); AlertDialog dialog = builder.create(); dialog.show(); } } else if (v.getId() == R.id.login) { if (rb_password.isChecked()) { // 验证密码登录 if (!mPassword.equals(login_input.getText().toString())) { Toast.makeText(this, \u0026#34;用户名或密码错误，请检查输入：\u0026#34;, Toast.LENGTH_SHORT).show(); return; } loginSuccess(); } else if (rb_phonecode.isChecked()) { // 验证验证码登录 if (mVerifyCode == null || !mVerifyCode.equals(login_input.getText().toString())) { Toast.makeText(this, \u0026#34;验证码错误，请检查输入：\u0026#34;, Toast.LENGTH_SHORT).show(); return; } loginSuccess(); } } } // 登录成功处理 private void loginSuccess() { String desc = String.format(\u0026#34;你的手机号是%s, 恭喜你登录成功，点击确认返回上一个页面\u0026#34;, et_phone.getText().toString()); AlertDialog.Builder builder = new AlertDialog.Builder(this); builder.setTitle(\u0026#34;登录成功\u0026#34;); builder.setMessage(desc); builder.setPositiveButton(\u0026#34;确认返回\u0026#34;, (dialog, which) -\u0026gt; { finish(); }); builder.setNegativeButton(\u0026#34;我再看看吧\u0026#34;, null); AlertDialog dialog = builder.create(); dialog.show(); if (rb_password.isChecked() \u0026amp;\u0026amp; ck_save_password.isChecked()) { // 保存密码到SharedPreferences SharedPreferences.Editor editor = preferences.edit(); editor.putString(\u0026#34;account\u0026#34;, et_phone.getText().toString()); editor.putString(\u0026#34;password\u0026#34;, login_input.getText().toString()); editor.putBoolean(\u0026#34;is_save_password\u0026#34;, true); editor.commit(); } if (rb_password.isChecked()) { // 保存登录信息到SQLite LoginInfo info = new LoginInfo(et_phone.getText().toString(), login_input.getText().toString(), ck_save_password.isChecked()); mHelper.insert(info); } } // 焦点变化处理 @Override public void onFocusChange(View v, boolean hasFocus) { if (v.getId() == R.id.login_input \u0026amp;\u0026amp; hasFocus) { // 输入框获得焦点时，从数据库中查询对应的密码 LoginInfo info = mHelper.queryByPhone(et_phone.getText().toString()); if (info != null) { login_input.setText(info.getPassword()); ck_save_password.setChecked(true); } else { login_input.setText(\u0026#34;\u0026#34;); ck_save_password.setChecked(false); } } } // 自定义TextWatcher类，用于监听文本变化 class HideTextWatcher implements TextWatcher { private EditText mView; private int maxLength; public HideTextWatcher(EditText editText, int i) { this.mView = editText; this.maxLength = i; } @Override public void beforeTextChanged(CharSequence s, int start, int count, int after) { } @Override public void onTextChanged(CharSequence s, int start, int before, int count) { } @Override public void afterTextChanged(Editable s) { if (s.toString().length() == maxLength) { // 当文本长度达到最大值时隐藏输入法 ViewUtil.hideOneInputMethod(LoginSQLliteActivity.this, mView); } } } } 存储卡存储 私有存储空间与公共存储空间\nXML \u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;utf-8\u0026#34;?\u0026gt; \u0026lt;LinearLayout xmlns:android=\u0026#34;http://schemas.android.com/apk/res/android\u0026#34; android:id=\u0026#34;@+id/main\u0026#34; android:layout_width=\u0026#34;match_parent\u0026#34; android:layout_height=\u0026#34;match_parent\u0026#34; android:orientation=\u0026#34;vertical\u0026#34;\u0026gt; \u0026lt;LinearLayout android:layout_width=\u0026#34;match_parent\u0026#34; android:layout_height=\u0026#34;wrap_content\u0026#34; android:orientation=\u0026#34;horizontal\u0026#34; android:layout_marginTop=\u0026#34;10dp\u0026#34;\u0026gt; \u0026lt;TextView android:layout_width=\u0026#34;wrap_content\u0026#34; android:layout_height=\u0026#34;wrap_content\u0026#34; android:text=\u0026#34;姓名: \u0026#34; android:textSize=\u0026#34;@dimen/common_font_size\u0026#34;/\u0026gt; \u0026lt;EditText android:id=\u0026#34;@+id/et_name\u0026#34; android:layout_width=\u0026#34;match_parent\u0026#34; android:layout_height=\u0026#34;wrap_content\u0026#34; android:background=\u0026#34;@drawable/edittext_selector\u0026#34;/\u0026gt; \u0026lt;/LinearLayout\u0026gt; \u0026lt;LinearLayout android:layout_width=\u0026#34;match_parent\u0026#34; android:layout_height=\u0026#34;wrap_content\u0026#34; android:orientation=\u0026#34;horizontal\u0026#34; android:layout_marginTop=\u0026#34;10dp\u0026#34;\u0026gt; \u0026lt;TextView android:layout_width=\u0026#34;wrap_content\u0026#34; android:layout_height=\u0026#34;wrap_content\u0026#34; android:text=\u0026#34;年龄: \u0026#34; android:textSize=\u0026#34;@dimen/common_font_size\u0026#34;/\u0026gt; \u0026lt;EditText android:id=\u0026#34;@+id/et_age\u0026#34; android:layout_width=\u0026#34;match_parent\u0026#34; android:layout_height=\u0026#34;wrap_content\u0026#34; android:background=\u0026#34;@drawable/edittext_selector\u0026#34;/\u0026gt; \u0026lt;/LinearLayout\u0026gt; \u0026lt;LinearLayout android:layout_width=\u0026#34;match_parent\u0026#34; android:layout_height=\u0026#34;wrap_content\u0026#34; android:orientation=\u0026#34;horizontal\u0026#34; android:layout_marginTop=\u0026#34;10dp\u0026#34;\u0026gt; \u0026lt;TextView android:layout_width=\u0026#34;wrap_content\u0026#34; android:layout_height=\u0026#34;wrap_content\u0026#34; android:text=\u0026#34;身高: \u0026#34; android:textSize=\u0026#34;@dimen/common_font_size\u0026#34;/\u0026gt; \u0026lt;EditText android:id=\u0026#34;@+id/et_height\u0026#34; android:layout_width=\u0026#34;match_parent\u0026#34; android:layout_height=\u0026#34;wrap_content\u0026#34; android:background=\u0026#34;@drawable/edittext_selector\u0026#34;/\u0026gt; \u0026lt;/LinearLayout\u0026gt; \u0026lt;LinearLayout android:layout_width=\u0026#34;match_parent\u0026#34; android:layout_height=\u0026#34;wrap_content\u0026#34; android:orientation=\u0026#34;horizontal\u0026#34; android:layout_marginTop=\u0026#34;10dp\u0026#34;\u0026gt; \u0026lt;TextView android:layout_width=\u0026#34;wrap_content\u0026#34; android:layout_height=\u0026#34;wrap_content\u0026#34; android:text=\u0026#34;体重: \u0026#34; android:textSize=\u0026#34;@dimen/common_font_size\u0026#34;/\u0026gt; \u0026lt;EditText android:id=\u0026#34;@+id/et_weight\u0026#34; android:layout_width=\u0026#34;match_parent\u0026#34; android:layout_height=\u0026#34;wrap_content\u0026#34; android:background=\u0026#34;@drawable/edittext_selector\u0026#34;/\u0026gt; \u0026lt;/LinearLayout\u0026gt; \u0026lt;LinearLayout android:layout_width=\u0026#34;match_parent\u0026#34; android:layout_height=\u0026#34;wrap_content\u0026#34; android:orientation=\u0026#34;horizontal\u0026#34;\u0026gt; \u0026lt;CheckBox android:id=\u0026#34;@+id/ck_isMarried\u0026#34; android:layout_width=\u0026#34;wrap_content\u0026#34; android:layout_height=\u0026#34;wrap_content\u0026#34;/\u0026gt; \u0026lt;TextView android:layout_width=\u0026#34;wrap_content\u0026#34; android:layout_height=\u0026#34;wrap_content\u0026#34; android:text=\u0026#34;已婚\u0026#34; android:textSize=\u0026#34;@dimen/common_small_font_size\u0026#34;/\u0026gt; \u0026lt;/LinearLayout\u0026gt; \u0026lt;Button android:id=\u0026#34;@+id/btn_write\u0026#34; android:layout_width=\u0026#34;match_parent\u0026#34; android:layout_height=\u0026#34;wrap_content\u0026#34; android:text=\u0026#34;保存\u0026#34;/\u0026gt; \u0026lt;Button android:id=\u0026#34;@+id/btn_read\u0026#34; android:layout_width=\u0026#34;match_parent\u0026#34; android:layout_height=\u0026#34;wrap_content\u0026#34; android:text=\u0026#34;读取\u0026#34;/\u0026gt; \u0026lt;TextView android:id=\u0026#34;@+id/tv_content\u0026#34; android:layout_width=\u0026#34;match_parent\u0026#34; android:layout_height=\u0026#34;wrap_content\u0026#34; /\u0026gt; \u0026lt;/LinearLayout\u0026gt; Java package com.showguan.chapter06; public class FileWriteActivity extends AppCompatActivity implements View.OnClickListener { // 定义界面中的控件 private EditText et_name; private EditText et_age; private EditText et_height; private EditText et_weight; private SharedPreferences preferences; private CheckBox ck_isMarried; private String path; private TextView tv_content; @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); // 设置活动布局 setContentView(R.layout.activity_file_write); // 初始化控件 et_name = findViewById(R.id.et_name); et_age = findViewById(R.id.et_age); et_height = findViewById(R.id.et_height); et_weight = findViewById(R.id.et_weight); ck_isMarried = findViewById(R.id.ck_isMarried); tv_content = findViewById(R.id.tv_content); // 设置按钮点击事件监听器 findViewById(R.id.btn_write).setOnClickListener(this); findViewById(R.id.btn_read).setOnClickListener(this); // 获取SharedPreferences对象，模式为私有 preferences = getSharedPreferences(\u0026#34;config\u0026#34;, Context.MODE_PRIVATE); } @Override public void onClick(View v) { if(v.getId() == R.id.btn_write){ // 获取输入框中的文本内容 String name = et_name.getText().toString(); String age = et_age.getText().toString(); String height = et_height.getText().toString(); String weight = et_weight.getText().toString(); // 拼接字符串内容 StringBuilder sb = new StringBuilder(); sb.append(\u0026#34;姓名:\u0026#34;).append(name); sb.append(\u0026#34;\\n年龄:\u0026#34;).append(age); sb.append(\u0026#34;\\n身高:\u0026#34;).append(height); sb.append(\u0026#34;\\n体重:\u0026#34;).append(weight); sb.append(\u0026#34;\\n婚否:\u0026#34;).append(ck_isMarried.isChecked()); String directory; String fileName = System.currentTimeMillis() + \u0026#34;.txt\u0026#34;; // 使用内部存储空间，卸载应用后文件将被删除 directory = getFilesDir().toString(); path = directory + File.separatorChar + fileName; // 打印路径日志 Log.d(\u0026#34;Kennem\u0026#34;, path); // 保存文本内容到文件 FileUtil.saveText(path, sb.toString()); // 显示保存成功的Toast消息 Toast.makeText(this, \u0026#34;保存成功\u0026#34;, Toast.LENGTH_SHORT).show(); } else if (v.getId() == R.id.btn_read) { // 从文件读取内容并显示到TextView tv_content.setText(FileUtil.openText(path)); } } } 存储卡保存图片 实际保存的文件路径：/sdcard/Android/data/com.showguan.chapter06/files/Download/1719307975140.jpg\nJava package com.showguan.chapter06; import android.graphics.Bitmap; import android.graphics.BitmapFactory; import android.net.Uri; import android.os.Bundle; import android.os.Environment; import android.util.Log; import android.view.View; import android.widget.ImageView; import android.widget.Toast; import androidx.activity.EdgeToEdge; import androidx.appcompat.app.AppCompatActivity; import androidx.core.graphics.Insets; import androidx.core.view.ViewCompat; import androidx.core.view.WindowInsetsCompat; import com.showguan.chapter06.util.FileUtil; import java.io.File; public class ImageWriteActivity extends AppCompatActivity implements View.OnClickListener { private ImageView iv_pic; private String path; @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.activity_image_write); findViewById(R.id.btn_read).setOnClickListener(this); findViewById(R.id.btn_save).setOnClickListener(this); iv_pic = findViewById(R.id.iv_pic); } @Override public void onClick(View v) { if(v.getId() == R.id.btn_save){ String directory = getExternalFilesDir(Environment.DIRECTORY_DOWNLOADS).toString(); String fileName = System.currentTimeMillis() + \u0026#34;.jpg\u0026#34;; path = directory + File.separatorChar + fileName; Log.d(\u0026#34;Kennem\u0026#34;, path); Bitmap bitmap = BitmapFactory.decodeResource(getResources(), R.drawable.cat2); FileUtil.saveImage(path, bitmap); Toast.makeText(this, \u0026#34;保存成功\u0026#34;, Toast.LENGTH_SHORT).show(); } else if (v.getId() == R.id.btn_read) { // 使用FileUtil工具类从指定路径读取图片文件并设置到ImageView中显示 // 注意：这里假设FileUtil类中有一个名为readImage的方法，可以根据路径返回Bitmap对象。 // 由于具体的FileUtil类实现不明确，这段代码是假设性的示例。 // 方法一：使用FileUtil工具类读取图片文件 // Bitmap bitmap = FileUtil.readImage(path); // 假设FileUtil类有这个方法 // iv_pic.setImageBitmap(bitmap); // 将读取的Bitmap对象设置到ImageView中显示 // 方法二：直接使用BitmapFactory解码指定路径的图片文件为Bitmap对象 // Bitmap bitmap = BitmapFactory.decodeFile(path); // 使用BitmapFactory解码文件 // iv_pic.setImageBitmap(bitmap); // 将解码得到的Bitmap对象设置到ImageView中显示 // 方法三：使用Uri对象加载指定路径的图片文件到ImageView中显示 iv_pic.setImageURI(Uri.parse(path)); // 将指定路径的图片文件通过Uri加载并显示到ImageView } } } FileUtil package com.showguan.chapter06.util; public class FileUtil { // 保存文本到指定路径 public static void saveText(String path, String txt) { // 注意，这里需要确保os被正确关闭之后才能保存文件 try (BufferedWriter os = new BufferedWriter(new FileWriter(path))) { os.write(txt); Log.d(\u0026#34;Kennem\u0026#34;, \u0026#34;保存成功\u0026#34;); Log.d(\u0026#34;Kennem\u0026#34;, \u0026#34;保存的内容\u0026#34; + txt); } catch (Exception e) { e.printStackTrace(); } } //从指定路径的文本文件中读取为字符串 public static String openText(String path){ BufferedReader is = null; StringBuilder sb = new StringBuilder(); try{ is = new BufferedReader(new FileReader(path)); String line = null; while((line = is.readLine()) != null){ sb.append(line); } }catch (Exception e){ e.printStackTrace(); }finally { if(is != null){ try{ is.close(); }catch (Exception e){ e.printStackTrace(); } } } return sb.toString(); } public static void saveImage(String path, Bitmap bitmap) { try(FileOutputStream fos = new FileOutputStream(path)){ bitmap.compress(Bitmap.CompressFormat.JPEG, 100, fos); }catch (Exception e){ e.printStackTrace(); } } public static Bitmap readImage(String path) { Bitmap bitmap = null; try(FileInputStream fis = new FileInputStream(path)) { bitmap = BitmapFactory.decodeStream(fis); }catch (Exception e){ e.printStackTrace(); } return bitmap; } } Application 声明周期 首先自定义一个Application\npackage com.showguan.chapter06; import android.app.Application; import android.content.res.Configuration; import android.util.Log; import androidx.annotation.NonNull; import java.util.HashMap; public class MyApplication extends Application { private static MyApplication mApp; public HashMap\u0026lt;String, String\u0026gt; infoMap = new HashMap\u0026lt;\u0026gt;(); public static MyApplication getInstance(){ return mApp; } @Override public void onCreate() { super.onCreate(); Log.d(\u0026#34;Kennem\u0026#34;, \u0026#34;MyApplication onCreate: \u0026#34;); } @Override public void onTerminate() { super.onTerminate(); Log.d(\u0026#34;Kennem\u0026#34;, \u0026#34;MyApplication onTerminate: \u0026#34;); } @Override public void onConfigurationChanged(@NonNull Configuration newConfig) { super.onConfigurationChanged(newConfig); Log.d(\u0026#34;Kennem\u0026#34;, \u0026#34;MyApplication onConfigurationChanged: \u0026#34;); } } 2、修改manifest文件\n3、Application声明周期\nApplication在Activity之前创建， 并且旋转屏幕时会调用onConfigurationChanged方法，并会重新创建Activity。\nApplication全局变量 数和在Application中保存的全局变量主要有下面三种数据：\n会频繁读取的信息，如用户名，手机号等。 不方便由意图传递的数据，例如位图对象，非字符串类型的集合对象等 容易因频繁分配内存二导致内存泄漏的对象，如Handler对象等。 通过在MyApplication中定义全局变量infoMap, 通过单例类获取app对象，实现在infoMap中， 即内存中存储数据。\nMyAppliaction.java package com.showguan.chapter06; import android.app.Application; import android.content.res.Configuration; import android.util.Log; import androidx.annotation.NonNull; import java.util.HashMap; public class MyApplication extends Application { private static MyApplication mApp = new MyApplication(); public HashMap\u0026lt;String, String\u0026gt; infoMap = new HashMap\u0026lt;\u0026gt;(); public static MyApplication getInstance(){ return mApp; } @Override public void onCreate() { super.onCreate(); Log.d(\u0026#34;Kennem\u0026#34;, \u0026#34;MyApplication onCreate: \u0026#34;); } @Override public void onTerminate() { super.onTerminate(); Log.d(\u0026#34;Kennem\u0026#34;, \u0026#34;MyApplication onTerminate: \u0026#34;); } @Override public void onConfigurationChanged(@NonNull Configuration newConfig) { super.onConfigurationChanged(newConfig); Log.d(\u0026#34;Kennem\u0026#34;, \u0026#34;MyApplication onConfigurationChanged: \u0026#34;); } } AppWriteActivity.java package com.showguan.chapter06; import android.content.SharedPreferences; import android.os.Bundle; import android.view.View; import android.widget.CheckBox; import android.widget.EditText; import androidx.appcompat.app.AppCompatActivity; import com.showguan.chapter06.util.ToastUtil; public class AppWriteActivity extends AppCompatActivity implements View.OnClickListener { private EditText et_name; private EditText et_age; private EditText et_height; private EditText et_weight; private SharedPreferences preferences; private CheckBox ck_isMarried; private MyApplication app; @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.activity_app_write); et_name = findViewById(R.id.et_name); et_age = findViewById(R.id.et_age); et_height = findViewById(R.id.et_height); et_weight = findViewById(R.id.et_weight); ck_isMarried = findViewById(R.id.ck_isMarried); findViewById(R.id.btn_save).setOnClickListener(this); app = MyApplication.getInstance(); reload(); } private void reload() { String name = app.infoMap.get(\u0026#34;name\u0026#34;); if (name == null) { return; } String age = app.infoMap.get(\u0026#34;age\u0026#34;); String height = app.infoMap.get(\u0026#34;height\u0026#34;); String weight = app.infoMap.get(\u0026#34;weight\u0026#34;); String married = app.infoMap.get(\u0026#34;married\u0026#34;); et_name.setText(name); et_age.setText(age); et_height.setText(height); et_weight.setText(weight); ck_isMarried.setChecked(married == \u0026#34;是\u0026#34;); } // @Override public void onClick(View v) { String name = et_name.getText().toString(); String age = et_age.getText().toString(); String height = et_height.getText().toString(); String weight = et_weight.getText().toString(); app.infoMap.put(\u0026#34;name\u0026#34;, name); app.infoMap.put(\u0026#34;age\u0026#34;, age); app.infoMap.put(\u0026#34;height\u0026#34;, height); app.infoMap.put(\u0026#34;weight\u0026#34;, weight); app.infoMap.put(\u0026#34;married\u0026#34;, ck_isMarried.isChecked() ? \u0026#34;是\u0026#34; : \u0026#34;否\u0026#34;); ToastUtil.show(this, \u0026#34;保存成功\u0026#34;); } } Room框架的导入 Room时谷歌公司推出的数据库处理框架，该框架同样基于SQLite, 但它通过注解技术极大简化了数据库操作，减少了原来相当一部分编码工作量。\n在使用Room之前，要先修改模块的build.gradle文件，往dependencies节点添加下面的配置，表示导入指定版本的Room库 dependencies { implementation \u0026#39;androidx.room:room-runtime:2.6.1\u0026#39; annotationProcessor \u0026#39;androidx.room:room-compiler:2.6.1\u0026#39; } 1、创建实体类 BookInfo.java package com.showguan.chapter06.enity; import androidx.room.Entity; import androidx.room.PrimaryKey; @Entity public class BookInfo { @PrimaryKey(autoGenerate = true) private int id; private String name; private String author; private String publish; private double price; public int getId() { return id; } public void setId(int id) { this.id = id; } public String getName() { return name; } public void setName(String name) { this.name = name; } public String getAuthor() { return author; } public void setAuthor(String author) { this.author = author; } public String getPublish() { return publish; } public void setPublish(String publish) { this.publish = publish; } public double getPrice() { return price; } public void setPrice(double price) { this.price = price; } @Override public String toString() { return \u0026#34;BookInfo{\u0026#34; + \u0026#34;id=\u0026#34; + id + \u0026#34;, name=\u0026#39;\u0026#34; + name + \u0026#39;\\\u0026#39;\u0026#39; + \u0026#34;, author=\u0026#39;\u0026#34; + author + \u0026#39;\\\u0026#39;\u0026#39; + \u0026#34;, publish=\u0026#39;\u0026#34; + publish + \u0026#39;\\\u0026#39;\u0026#39; + \u0026#34;, price=\u0026#34; + price + \u0026#39;}\u0026#39;; } } 2、创建Dao数据访问对象 package com.showguan.chapter06.dao; import androidx.room.Dao; import androidx.room.Delete; import androidx.room.Insert; import androidx.room.Query; import androidx.room.Update; import com.showguan.chapter06.enity.BookInfo; import java.util.List; @Dao public interface BookDao { @Insert void insert(BookInfo... bookInfos); @Delete void delete(BookInfo... bookInfos); @Query(\u0026#34;DELETE FROM BookInfo\u0026#34;) void deleteAll(); @Update int update(BookInfo... bookInfos); @Query(\u0026#34;SELECT * FROM BookInfo\u0026#34;) List\u0026lt;BookInfo\u0026gt; queryAll(); @Query(\u0026#34;SELECT * FROM BookInfo WHERE name = :name ORDER BY id DESC LIMIT 1\u0026#34;) BookInfo queryByName(String name); } 3、创建 BookDatabase 连接实体类和Dao package com.showguan.chapter06.database; import androidx.room.Database; import androidx.room.RoomDatabase; import com.showguan.chapter06.dao.BookDao; import com.showguan.chapter06.enity.BookInfo; @Database(entities = {BookInfo.class}, version = 1, exportSchema = true) public abstract class BookDatabase extends RoomDatabase{ public abstract BookDao bookDao(); } 4、在MyApplication中构建并返回数据库对象 package com.showguan.chapter06; import android.app.Application; import android.content.res.Configuration; import android.util.Log; import androidx.annotation.NonNull; import androidx.room.DatabaseConfiguration; import androidx.room.InvalidationTracker; import androidx.room.Room; import androidx.sqlite.db.SupportSQLiteOpenHelper; import com.showguan.chapter06.dao.BookDao; import com.showguan.chapter06.database.BookDatabase; import java.util.HashMap; public class MyApplication extends Application { private static MyApplication mApp = new MyApplication(); public HashMap\u0026lt;String, String\u0026gt; infoMap = new HashMap\u0026lt;\u0026gt;(); private static BookDatabase bookDatabase; public static MyApplication getInstance(){ return mApp; } @Override public void onCreate() { super.onCreate(); Log.d(\u0026#34;Kennem\u0026#34;, \u0026#34;MyApplication onCreate: \u0026#34;); bookDatabase = Room.databaseBuilder(this, BookDatabase.class, \u0026#34;book\u0026#34;) .addMigrations() // 允许迁移数据库（发生数据库变更时，Room默认删除原数据库再创建新数据库， 这样原来的数据会消失。 .allowMainThreadQueries() //允许再主线程中操作数据库（Room默认不能在主线程中操作数据库） .build(); } @Override public void onTerminate() { super.onTerminate(); Log.d(\u0026#34;Kennem\u0026#34;, \u0026#34;MyApplication onTerminate: \u0026#34;); } @Override public void onConfigurationChanged(@NonNull Configuration newConfig) { super.onConfigurationChanged(newConfig); Log.d(\u0026#34;Kennem\u0026#34;, \u0026#34;MyApplication onConfigurationChanged: \u0026#34;); } public BookDatabase getBookDatabase(){ return bookDatabase; } } 5、在使用时只需要用BookDao调用相应的方法即可 package com.showguan.chapter06; import android.os.Bundle; import android.util.Log; import android.view.View; import android.widget.EditText; import androidx.appcompat.app.AppCompatActivity; import com.showguan.chapter06.dao.BookDao; import com.showguan.chapter06.enity.BookInfo; import com.showguan.chapter06.util.ToastUtil; import java.util.List; public class RoomWriteActivity extends AppCompatActivity implements View.OnClickListener { private String TAG = \u0026#34;Kennem\u0026#34;; private EditText et_name; private EditText et_author; private EditText et_publish; private EditText et_price; private BookDao bookDao; @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.activity_room_write); et_name = findViewById(R.id.et_name); et_author = findViewById(R.id.et_author); et_publish = findViewById(R.id.et_publish); et_price = findViewById(R.id.et_price); findViewById(R.id.btn_add).setOnClickListener(this); findViewById(R.id.btn_delete).setOnClickListener(this); findViewById(R.id.btn_update).setOnClickListener(this); findViewById(R.id.btn_select).setOnClickListener(this); findViewById(R.id.btn_deleteAll).setOnClickListener(this); bookDao = MyApplication.getInstance().getBookDatabase().bookDao(); } @Override public void onClick(View v) { String name = null; String author = null; String publish = null; Double price = 0.0; if (!et_name.getText().toString().equals(\u0026#34;\u0026#34;)) { name = et_name.getText().toString(); } if (!et_author.getText().toString().equals(\u0026#34;\u0026#34;)) { author = et_author.getText().toString(); } if (!et_publish.getText().toString().equals(\u0026#34;\u0026#34;)) { publish = et_publish.getText().toString(); } if (!et_price.getText().toString().equals(\u0026#34;\u0026#34;)) { // Log.d(TAG, et_price.getText().toString()); price = Double.valueOf(et_price.getText().toString()); } if (v.getId() == R.id.btn_add) { BookInfo bookInfo = new BookInfo(); bookInfo.setName(name); bookInfo.setAuthor(author); bookInfo.setPublish(publish); bookInfo.setPrice(price); bookDao.insert(bookInfo); ToastUtil.show(this, \u0026#34;保存成功！\u0026#34;); } else if (v.getId() == R.id.btn_delete) { BookInfo b = new BookInfo(); int id = bookDao.queryByName(name).getId(); b.setId(id); bookDao.delete(b); } else if (v.getId() == R.id.btn_update) { BookInfo b3 = new BookInfo(); BookInfo b4 = bookDao.queryByName(name); b3.setId(b4.getId()); b3.setName(name); b3.setAuthor(author); b3.setPublish(publish); b3.setPrice(price); bookDao.update(b3); } else if (v.getId() == R.id.btn_select) { List\u0026lt;BookInfo\u0026gt; bookInfos = bookDao.queryAll(); for (BookInfo bookInfo : bookInfos) { Log.d(TAG, bookInfo.toString()); } } else if (v.getId() == R.id.btn_deleteAll) { bookDao.deleteAll(); } } } 案例-实现购物车 ","permalink":"https://kennems.github.io/zh/posts/tech/android3/","summary":"Android（3） 数据存储 共享参数的用法 SharedPreferences 是 Android的一个轻量级存储工具，采用的存储结构是key-value的键值对方式 共享参数的存","title":"Android（3）"},{"content":"Android（1） 【金山文档 | WPS云文档】 Kotlin 讲义\rhttps://kdocs.cn/l/cu14rrCtfKxv\r【金山文档 | WPS云文档】 Android 四大组件课程概要 https://kdocs.cn/l/croaFl0RS5LA\r【金山文档 | WPS云文档】 Fragment 重点知识\rhttps://kdocs.cn/l/cj89XRLXypb8\r【金山文档 | WPS云文档】 Android UI 课程重点知识\rhttps://kdocs.cn/l/cokrSwEg1GF4\r【金山文档 | WPS云文档】 Android布局与优化\rhttps://kdocs.cn/l/ciwSdaSLRAwB\r【金山文档 | WPS云文档】 组件库\rhttps://kdocs.cn/l/cvsBNce6AfjI\r【金山文档 | WPS云文档】 Android 动画\rhttps://kdocs.cn/l/cf4bQiAeZdlI\r【金山文档 | WPS云文档】 自定义控件的实现\rhttps://kdocs.cn/l/cu3bUFFJVvn8\r【金山文档 | WPS云文档】 权限与网络请求课程预习\rhttps://kdocs.cn/l/cme7bRkDMYcB\r【金山文档 | WPS云文档】 内存泄漏和ANR预习\rhttps://kdocs.cn/l/cpFLi1gGV4Xs ctrl + alt + o 自动组织导入\nApp开发语言\nApp开发主要有两大技术路径，分别是原生开发和混合开发 Android的官方编程语言包括Java和Kotlin XML：Extensible Markup Language, 即可扩展标记语言\ngradle下载镜像\n使用官网下载非常的慢，建议使用镜像站：\n（1）官网地址：https://services.gradle.org/distributions/ （2）腾讯镜像 Gradle下载地址：https://mirrors.cloud.tencent.com/gradle/ （3）阿里云镜像 Gradle下载地址：https://mirrors.aliyun.com/macports/distfiles/gradle/\n虚拟机改成冷启动\nhttps://blog.csdn.net/gh8609123/article/details/118514352\n类似网页，XML描述界面，Java做交互效果\n简单控件 字体大小设置 Java代码 tv.setTextSize(10); 在XML文件中则通过属性android:textSize指定文本大小，此时需要指定字号单位。 px：是手机屏幕的最小显示单位，与设备的显示屏有关 dp：是与设备无关的显示单位**，只与屏幕的尺寸有关** sp：专门用来设置字体大小，在系统设置中可以调整字体大小 Dpi(像素密度dots-per-inch)计算规则\n以$4.95$英寸 $1920*1080$ 的手机设备为例：\n计算直角边像素数量：$1920^2 + 1080^2 = 2202^2$ 计算Dpi：$2205/4.95=445$ 得到Dpi为$445$ （每英寸的距离有$445$个像素） Density\n指屏幕上每平方英寸中含有的像素点数， $445^2$\nDip/dp (设备独立像素Device Independent Pixel)\n所有显示到屏幕上的图像都是以px为单位的，Dip是开发中使用的长度单位，最后也需要转换成px，计算这个设备上1dip等于多少px\n$px = dip * dpi / 160$\n根据换算关系：\n320*480像素，3.6寸的手机：dpi 为160，$ 1dp = 1px$\npublic class TextSizeActivity extends AppCompatActivity { @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); EdgeToEdge.enable(this); setContentView(R.layout.activity_text_size); TextView viewById = findViewById(R.id.hello_tv); viewById.setTextSize(30); } } \u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;utf-8\u0026#34;?\u0026gt; \u0026lt;LinearLayout xmlns:android=\u0026#34;http://schemas.android.com/apk/res/android\u0026#34; android:layout_width=\u0026#34;match_parent\u0026#34; android:layout_height=\u0026#34;match_parent\u0026#34; android:orientation=\u0026#34;vertical\u0026#34; android:gravity=\u0026#34;center\u0026#34; \u0026gt; \u0026lt;TextView android:id=\u0026#34;@+id/tv_TextSize_px\u0026#34; android:layout_width=\u0026#34;wrap_content\u0026#34; android:layout_height=\u0026#34;wrap_content\u0026#34; android:text=\u0026#34;@string/textSize\u0026#34; android:textSize=\u0026#34;30px\u0026#34; /\u0026gt; \u0026lt;TextView android:id=\u0026#34;@+id/tv_TextSize_dp\u0026#34; android:layout_width=\u0026#34;wrap_content\u0026#34; android:layout_height=\u0026#34;wrap_content\u0026#34; android:text=\u0026#34;@string/textSize\u0026#34; android:textSize=\u0026#34;30dp\u0026#34; /\u0026gt; \u0026lt;TextView android:id=\u0026#34;@+id/tv_TextSize_sp\u0026#34; android:layout_width=\u0026#34;wrap_content\u0026#34; android:layout_height=\u0026#34;wrap_content\u0026#34; android:text=\u0026#34;@string/textSize\u0026#34; android:textSize=\u0026#34;30sp\u0026#34; /\u0026gt; \u0026lt;!-- sp跟随系统字体变大而变大--\u0026gt; \u0026lt;TextView android:id=\u0026#34;@+id/hello_tv\u0026#34; android:layout_width=\u0026#34;wrap_content\u0026#34; android:layout_height=\u0026#34;wrap_content\u0026#34; android:text=\u0026#34;@string/textSize\u0026#34; android:textSize=\u0026#34;30px\u0026#34; /\u0026gt; \u0026lt;/LinearLayout\u0026gt; 字体颜色设置 在XML文件中通过属性android:textColor指定文本颜色，色值由透明度alpha和RGB三原色（红色red, 绿色green, 蓝色blue）联合定义。 色值有八位十六进制和六位十六进制两种表达方式，例如八位编码FFEEDDCC中，FF表示透明度，EE表示红色的浓度，DD表示绿色的浓度，CC表示蓝色的浓度。 透明度为FF表示完全不透明，为00表示完全透明。RGB三色的数值越大，表示颜色越浓，也就越亮；数值越小，表示颜色越淡，也就越暗。 Java中透明度设置的是透明（例如：0x00ff00 实际为：0x0000ff00），而XML文件中透明度设置默认为不透明（例如黑色：#000000， 实际为#ff000000）\n\u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;utf-8\u0026#34;?\u0026gt; \u0026lt;LinearLayout xmlns:android=\u0026#34;http://schemas.android.com/apk/res/android\u0026#34; android:layout_width=\u0026#34;match_parent\u0026#34; android:layout_height=\u0026#34;match_parent\u0026#34; android:gravity=\u0026#34;center\u0026#34; android:orientation=\u0026#34;vertical\u0026#34;\u0026gt; \u0026lt;TextView android:id=\u0026#34;@+id/tv_TextSize_code_system\u0026#34; android:layout_width=\u0026#34;wrap_content\u0026#34; android:layout_height=\u0026#34;wrap_content\u0026#34; android:text=\u0026#34;普通颜色设置\u0026#34; android:textSize=\u0026#34;17sp\u0026#34; /\u0026gt; \u0026lt;TextView android:id=\u0026#34;@+id/tv_code_eight\u0026#34; android:layout_width=\u0026#34;wrap_content\u0026#34; android:layout_height=\u0026#34;wrap_content\u0026#34; android:text=\u0026#34;八位十六进制颜色设置\u0026#34; android:textSize=\u0026#34;17sp\u0026#34; /\u0026gt; \u0026lt;TextView android:id=\u0026#34;@+id/tv_code_six\u0026#34; android:layout_width=\u0026#34;wrap_content\u0026#34; android:layout_height=\u0026#34;wrap_content\u0026#34; android:text=\u0026#34;六位十六进制颜色设置\u0026#34; android:textSize=\u0026#34;17sp\u0026#34; /\u0026gt; \u0026lt;TextView android:id=\u0026#34;@+id/tv_xml\u0026#34; android:layout_width=\u0026#34;wrap_content\u0026#34; android:layout_height=\u0026#34;wrap_content\u0026#34; android:text=\u0026#34;XML文件默认透明度颜色设置\u0026#34; android:textColor=\u0026#34;#00ff00\u0026#34; android:textSize=\u0026#34;17sp\u0026#34; /\u0026gt; \u0026lt;TextView android:id=\u0026#34;@+id/tv_values\u0026#34; android:layout_width=\u0026#34;wrap_content\u0026#34; android:layout_height=\u0026#34;wrap_content\u0026#34; android:text=\u0026#34;自定义颜色设置\u0026#34; android:textColor=\u0026#34;@color/kennemColor\u0026#34; android:textSize=\u0026#34;17sp\u0026#34; /\u0026gt; \u0026lt;TextView android:id=\u0026#34;@+id/tv_bgc\u0026#34; android:layout_width=\u0026#34;wrap_content\u0026#34; android:layout_height=\u0026#34;wrap_content\u0026#34; android:background=\u0026#34;@color/kennemColor\u0026#34; android:text=\u0026#34;XML背景色颜色设置\u0026#34; android:textSize=\u0026#34;17sp\u0026#34; /\u0026gt; \u0026lt;TextView android:id=\u0026#34;@+id/tv_java_bgc\u0026#34; android:layout_width=\u0026#34;wrap_content\u0026#34; android:layout_height=\u0026#34;wrap_content\u0026#34; android:text=\u0026#34;Java背景色设置\u0026#34; android:textSize=\u0026#34;17sp\u0026#34; /\u0026gt; \u0026lt;/LinearLayout\u0026gt; public class TextColorActivity extends AppCompatActivity { @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); // 设置当前活动的布局视图，布局文件为 activity_text_color.xml setContentView(R.layout.activity_text_color); // 获取布局文件中的 TextView，其 ID 为 tv_TextSize_code_system TextView textView = findViewById(R.id.tv_TextSize_code_system); // 将该 TextView 的文本颜色设置为绿色，使用 Color 类的静态常量 textView.setTextColor(Color.GREEN); // 获取布局文件中的 TextView，其 ID 为 tv_code_eight TextView tv_code_eight = findViewById(R.id.tv_code_eight); // 将该 TextView 的文本颜色设置为绿色，使用 ARGB 格式的 8 位十六进制颜色值 tv_code_eight.setTextColor(0xff00ff00); // 获取布局文件中的 TextView，其 ID 为 tv_code_six TextView tv_code_six = findViewById(R.id.tv_code_six); // 将该 TextView 的文本颜色设置为绿色，使用 RGB 格式的 6 位十六进制颜色值（0x00ff00） // 注意：这行代码存在问题，因为 0x00ff00 实际上是一个 24 位的值，会被解析为透明颜色。 // 应该使用 0xff00ff00 这种 32 位格式。 tv_code_six.setTextColor(0xff00ff00); // 修改了原有的错误 // 获取布局文件中的 TextView，其 ID 为 tv_java_bgc TextView tv_java_bgc = findViewById(R.id.tv_java_bgc); // 将该 TextView 的背景颜色设置为红色，使用 Color 类的静态常量 tv_java_bgc.setBackgroundColor(Color.RED); } } 设置视图的宽高 视图宽度通过属性android:layout_width表达，试图高度通过属性android:lay_height表达，宽高的取值主要有下列三种\nmatch_parent：表示与上级试图保持一致 wrap_content：表示与内容自适应 以dp为单位的具体尺寸 \u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;utf-8\u0026#34;?\u0026gt; \u0026lt;LinearLayout xmlns:android=\u0026#34;http://schemas.android.com/apk/res/android\u0026#34; android:layout_width=\u0026#34;match_parent\u0026#34; android:layout_height=\u0026#34;match_parent\u0026#34; android:gravity=\u0026#34;center\u0026#34; android:orientation=\u0026#34;vertical\u0026#34;\u0026gt; \u0026lt;TextView android:layout_width=\u0026#34;wrap_content\u0026#34; android:layout_height=\u0026#34;wrap_content\u0026#34; android:layout_marginTop=\u0026#34;5dp\u0026#34; android:background=\u0026#34;#00ffff\u0026#34; android:text=\u0026#34;视图宽高均用wrap_content定义\u0026#34; android:textColor=\u0026#34;#000000\u0026#34; android:textSize=\u0026#34;17sp\u0026#34; /\u0026gt; \u0026lt;TextView android:layout_width=\u0026#34;match_parent\u0026#34; android:layout_height=\u0026#34;wrap_content\u0026#34; android:layout_marginTop=\u0026#34;5dp\u0026#34; android:background=\u0026#34;#00ffff\u0026#34; android:text=\u0026#34;视图宽高均用match_parent定义\u0026#34; android:textColor=\u0026#34;#000000\u0026#34; android:textSize=\u0026#34;17sp\u0026#34; /\u0026gt; \u0026lt;TextView android:layout_width=\u0026#34;300dp\u0026#34; android:layout_height=\u0026#34;wrap_content\u0026#34; android:layout_marginTop=\u0026#34;5dp\u0026#34; android:background=\u0026#34;#00ffff\u0026#34; android:text=\u0026#34;视图宽度指定固定大小\u0026#34; android:textColor=\u0026#34;#000000\u0026#34; android:textSize=\u0026#34;17sp\u0026#34; /\u0026gt; \u0026lt;TextView android:id=\u0026#34;@+id/tv_code\u0026#34; android:layout_width=\u0026#34;wrap_content\u0026#34; android:layout_height=\u0026#34;wrap_content\u0026#34; android:layout_marginTop=\u0026#34;5dp\u0026#34; android:background=\u0026#34;#00ffff\u0026#34; android:text=\u0026#34;用代码定义视图宽高\u0026#34; android:textColor=\u0026#34;#000000\u0026#34; android:textSize=\u0026#34;17sp\u0026#34; /\u0026gt; \u0026lt;/LinearLayout\u0026gt; 设置视图的间距 layout_margin ： 当前视图与周围平级视图之间的距离。包括layout_margin， layout_marginLeft, layout_marginTop, layout_marginRight, layout_marginBottom.\nlayout_padding ： 当前视图和内部下级视图之间的关系， 包括padding, paddingLeft, paddingTop, paddingRight, paddingBottom\n\u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;utf-8\u0026#34;?\u0026gt; \u0026lt;LinearLayout xmlns:android=\u0026#34;http://schemas.android.com/apk/res/android\u0026#34; android:layout_width=\u0026#34;match_parent\u0026#34; android:layout_height=\u0026#34;300dp\u0026#34; android:background=\u0026#34;#00AAFF\u0026#34; android:orientation=\u0026#34;vertical\u0026#34;\u0026gt; \u0026lt;LinearLayout android:layout_width=\u0026#34;match_parent\u0026#34; android:layout_height=\u0026#34;match_parent\u0026#34; android:layout_margin=\u0026#34;20dp\u0026#34; android:background=\u0026#34;#FFFF99\u0026#34; android:padding=\u0026#34;60dp\u0026#34;\u0026gt; \u0026lt;View android:layout_width=\u0026#34;match_parent\u0026#34; android:layout_height=\u0026#34;match_parent\u0026#34; android:background=\u0026#34;#FF0000\u0026#34; /\u0026gt; \u0026lt;/LinearLayout\u0026gt; \u0026lt;/LinearLayout\u0026gt; 设置视图的对齐方式 设置视图的对齐方式有两种途径\n采用layout_gravity属性，它指定了当前视图相对于上级视图的对齐方式 采用gravity属性，它指定了下级视图相对于当前视图的对齐方式 layout_gravity与gravity的取值包括：left, top, right, bottom, 还可以用竖线连接各取值，例如 \u0026quot;left|top\u0026quot; 表示即靠左又靠上，左上角对齐。\n\u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;utf-8\u0026#34;?\u0026gt; \u0026lt;LinearLayout xmlns:android=\u0026#34;http://schemas.android.com/apk/res/android\u0026#34; android:layout_width=\u0026#34;match_parent\u0026#34; android:layout_height=\u0026#34;300dp\u0026#34; android:background=\u0026#34;#ffff99\u0026#34; android:orientation=\u0026#34;horizontal\u0026#34; \u0026gt; \u0026lt;LinearLayout android:layout_width=\u0026#34;0dp\u0026#34; android:layout_height=\u0026#34;200dp\u0026#34; android:layout_weight=\u0026#34;1\u0026#34; android:layout_margin=\u0026#34;10dp\u0026#34; android:background=\u0026#34;#ff0000\u0026#34; android:padding=\u0026#34;10dp\u0026#34; android:layout_gravity=\u0026#34;bottom\u0026#34; android:gravity=\u0026#34;left\u0026#34;\u0026gt; \u0026lt;View android:layout_width=\u0026#34;100dp\u0026#34; android:layout_height=\u0026#34;100dp\u0026#34; android:background=\u0026#34;#00ffff\u0026#34;/\u0026gt; \u0026lt;/LinearLayout\u0026gt; \u0026lt;LinearLayout android:layout_width=\u0026#34;0dp\u0026#34; android:layout_height=\u0026#34;200dp\u0026#34; android:layout_weight=\u0026#34;1\u0026#34; android:layout_margin=\u0026#34;10dp\u0026#34; android:background=\u0026#34;#ff0000\u0026#34; android:padding=\u0026#34;10dp\u0026#34; android:layout_gravity=\u0026#34;top\u0026#34; android:gravity=\u0026#34;right\u0026#34;\u0026gt; \u0026lt;View android:layout_width=\u0026#34;100dp\u0026#34; android:layout_height=\u0026#34;100dp\u0026#34; android:background=\u0026#34;#00ffff\u0026#34; /\u0026gt; \u0026lt;/LinearLayout\u0026gt; \u0026lt;/LinearLayout\u0026gt; 常用布局 线性布局LinearLayout 线性布局的权重\n线性布局的权重概念，指的是线性布局的下级视图各自拥有多大比例的宽高 权重属性名叫layout_weight， 但该属性不在LinearLayout节点设置，而在线性布局的直接下级视图设置，表示该下级视图占据的宽高比例。 layout_width填0dp时，layout_weight表示水平方向的宽度比例。 layout_height填0dp时， layout_weight表示垂直方向的高度比例。 \u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;utf-8\u0026#34;?\u0026gt; \u0026lt;LinearLayout xmlns:android=\u0026#34;http://schemas.android.com/apk/res/android\u0026#34; android:id=\u0026#34;@+id/main\u0026#34; android:layout_width=\u0026#34;match_parent\u0026#34; android:layout_height=\u0026#34;match_parent\u0026#34; android:orientation=\u0026#34;vertical\u0026#34; android:background=\u0026#34;@color/backgroundColor\u0026#34;\u0026gt; \u0026lt;LinearLayout android:layout_width=\u0026#34;match_parent\u0026#34; android:layout_height=\u0026#34;wrap_content\u0026#34; android:orientation=\u0026#34;horizontal\u0026#34;\u0026gt; \u0026lt;TextView android:layout_width=\u0026#34;0dp\u0026#34; android:layout_height=\u0026#34;wrap_content\u0026#34; android:layout_weight=\u0026#34;1\u0026#34; android:text=\u0026#34;The 横排第一个\u0026#34; android:textColor=\u0026#34;@color/kennemColor\u0026#34; android:textSize=\u0026#34;17sp\u0026#34; /\u0026gt; \u0026lt;TextView android:layout_width=\u0026#34;0dp\u0026#34; android:layout_height=\u0026#34;wrap_content\u0026#34; android:layout_weight=\u0026#34;2\u0026#34; android:text=\u0026#34;The 横排第二个\u0026#34; android:textColor=\u0026#34;@color/kennemColor\u0026#34; android:textSize=\u0026#34;17sp\u0026#34; /\u0026gt; \u0026lt;/LinearLayout\u0026gt; \u0026lt;LinearLayout android:layout_width=\u0026#34;match_parent\u0026#34; android:layout_height=\u0026#34;wrap_content\u0026#34; android:orientation=\u0026#34;vertical\u0026#34;\u0026gt; \u0026lt;TextView android:layout_width=\u0026#34;wrap_content\u0026#34; android:layout_height=\u0026#34;0dp\u0026#34; android:layout_weight=\u0026#34;1\u0026#34; android:text=\u0026#34;The 竖排第一个\u0026#34; android:textColor=\u0026#34;@color/kennemColor\u0026#34; android:textSize=\u0026#34;17sp\u0026#34; /\u0026gt; \u0026lt;TextView android:layout_width=\u0026#34;wrap_content\u0026#34; android:layout_height=\u0026#34;0dp\u0026#34; android:layout_weight=\u0026#34;1\u0026#34; android:text=\u0026#34;The 竖排第二个\u0026#34; android:textColor=\u0026#34;@color/kennemColor\u0026#34; android:textSize=\u0026#34;17sp\u0026#34; /\u0026gt; \u0026lt;/LinearLayout\u0026gt; \u0026lt;/LinearLayout\u0026gt; 相对布局RelativeLayout 相对布局的下级视图位置又其他视图决定。用于确定下级视图位置的参照物分两种： 与该视图自身平级的视图 该视图的上级视图（也就是它归属的RelativeLayout） 如果不设定下级视图的参照物，那么下级视图默认显示在RelativeLayout内部的坐上角。 ​\t\u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;utf-8\u0026#34;?\u0026gt; \u0026lt;RelativeLayout xmlns:android=\u0026#34;http://schemas.android.com/apk/res/android\u0026#34; android:layout_width=\u0026#34;match_parent\u0026#34; android:layout_height=\u0026#34;150dp\u0026#34; android:orientation=\u0026#34;vertical\u0026#34;\u0026gt; \u0026lt;TextView android:id=\u0026#34;@+id/tv_center\u0026#34; android:layout_width=\u0026#34;wrap_content\u0026#34; android:layout_height=\u0026#34;wrap_content\u0026#34; android:layout_centerInParent=\u0026#34;true\u0026#34; android:background=\u0026#34;#ffffff\u0026#34; android:text=\u0026#34;我在中间\u0026#34; android:textSize=\u0026#34;11sp\u0026#34; android:textColor=\u0026#34;@color/kennemColor\u0026#34;/\u0026gt; \u0026lt;TextView android:id=\u0026#34;@+id/tv_center_horizontal\u0026#34; android:layout_width=\u0026#34;wrap_content\u0026#34; android:layout_height=\u0026#34;wrap_content\u0026#34; android:layout_centerHorizontal=\u0026#34;true\u0026#34; android:background=\u0026#34;#ffffff\u0026#34; android:text=\u0026#34;我在水平中间\u0026#34; android:textSize=\u0026#34;11sp\u0026#34; android:textColor=\u0026#34;@color/kennemColor\u0026#34;/\u0026gt; \u0026lt;TextView android:id=\u0026#34;@+id/tv_center_vertical\u0026#34; android:layout_width=\u0026#34;wrap_content\u0026#34; android:layout_height=\u0026#34;wrap_content\u0026#34; android:layout_centerVertical=\u0026#34;true\u0026#34; android:background=\u0026#34;#ffffff\u0026#34; android:text=\u0026#34;我在垂直中间\u0026#34; android:textSize=\u0026#34;11sp\u0026#34; android:textColor=\u0026#34;@color/kennemColor\u0026#34;/\u0026gt; \u0026lt;TextView android:id=\u0026#34;@+id/tv_parent_left\u0026#34; android:layout_width=\u0026#34;wrap_content\u0026#34; android:layout_height=\u0026#34;wrap_content\u0026#34; android:layout_alignParentLeft=\u0026#34;true\u0026#34; android:background=\u0026#34;#ffffff\u0026#34; android:text=\u0026#34;和上级的左边对齐\u0026#34; android:textSize=\u0026#34;11sp\u0026#34; android:textColor=\u0026#34;@color/kennemColor\u0026#34;/\u0026gt; \u0026lt;TextView android:id=\u0026#34;@+id/tv_parent_right\u0026#34; android:layout_width=\u0026#34;wrap_content\u0026#34; android:layout_height=\u0026#34;wrap_content\u0026#34; android:layout_alignParentRight=\u0026#34;true\u0026#34; android:background=\u0026#34;#ffffff\u0026#34; android:text=\u0026#34;和上级的右边对齐\u0026#34; android:textSize=\u0026#34;11sp\u0026#34; android:textColor=\u0026#34;@color/kennemColor\u0026#34;/\u0026gt; \u0026lt;TextView android:id=\u0026#34;@+id/tv_parent_top\u0026#34; android:layout_width=\u0026#34;wrap_content\u0026#34; android:layout_height=\u0026#34;wrap_content\u0026#34; android:layout_alignParentTop=\u0026#34;true\u0026#34; android:background=\u0026#34;#ffffff\u0026#34; android:text=\u0026#34;和上级的顶部对齐\u0026#34; android:textSize=\u0026#34;11sp\u0026#34; android:textColor=\u0026#34;@color/kennemColor\u0026#34;/\u0026gt; \u0026lt;TextView android:id=\u0026#34;@+id/tv_parent_bottom\u0026#34; android:layout_width=\u0026#34;wrap_content\u0026#34; android:layout_height=\u0026#34;wrap_content\u0026#34; android:layout_alignParentBottom=\u0026#34;true\u0026#34; android:background=\u0026#34;#ffffff\u0026#34; android:text=\u0026#34;和上级的底部对齐\u0026#34; android:textSize=\u0026#34;11sp\u0026#34; android:textColor=\u0026#34;@color/kennemColor\u0026#34;/\u0026gt; \u0026lt;TextView android:id=\u0026#34;@+id/tv_left_center\u0026#34; android:layout_width=\u0026#34;wrap_content\u0026#34; android:layout_height=\u0026#34;wrap_content\u0026#34; android:layout_toLeftOf=\u0026#34;@id/tv_center\u0026#34; android:layout_alignTop=\u0026#34;@+id/tv_center\u0026#34; android:background=\u0026#34;#ffffff\u0026#34; android:text=\u0026#34;我在中间的左边\u0026#34; android:textSize=\u0026#34;11sp\u0026#34; android:textColor=\u0026#34;@color/kennemColor\u0026#34;/\u0026gt; \u0026lt;TextView android:id=\u0026#34;@+id/tv_right_center\u0026#34; android:layout_width=\u0026#34;wrap_content\u0026#34; android:layout_height=\u0026#34;wrap_content\u0026#34; android:layout_toRightOf=\u0026#34;@id/tv_center\u0026#34; android:layout_alignBottom=\u0026#34;@+id/tv_center\u0026#34; android:background=\u0026#34;#ffffff\u0026#34; android:text=\u0026#34;我在中间的右边\u0026#34; android:textSize=\u0026#34;11sp\u0026#34; android:textColor=\u0026#34;@color/kennemColor\u0026#34;/\u0026gt; \u0026lt;TextView android:id=\u0026#34;@+id/tv_top_center\u0026#34; android:layout_width=\u0026#34;wrap_content\u0026#34; android:layout_height=\u0026#34;wrap_content\u0026#34; android:layout_above=\u0026#34;@id/tv_center\u0026#34; android:layout_alignLeft=\u0026#34;@+id/tv_center\u0026#34; android:background=\u0026#34;#ffffff\u0026#34; android:text=\u0026#34;我在中间的上边\u0026#34; android:textSize=\u0026#34;11sp\u0026#34; android:textColor=\u0026#34;@color/kennemColor\u0026#34;/\u0026gt; \u0026lt;TextView android:id=\u0026#34;@+id/tv_blow_center\u0026#34; android:layout_width=\u0026#34;wrap_content\u0026#34; android:layout_height=\u0026#34;wrap_content\u0026#34; android:layout_below=\u0026#34;@id/tv_center\u0026#34; android:layout_alignRight=\u0026#34;@+id/tv_center\u0026#34; android:background=\u0026#34;#ffffff\u0026#34; android:text=\u0026#34;我在中间的下边\u0026#34; android:textSize=\u0026#34;11sp\u0026#34; android:textColor=\u0026#34;@color/kennemColor\u0026#34;/\u0026gt; \u0026lt;/RelativeLayout\u0026gt; 网格布局GridLayout 网格布局支持多行多列的表格排列。 网格布局默认从左往右、从上到下排列，它新增了两个属性： columnCount属性，它指定了网格的列数，即每行能放多少个视图； rowCount属性，它指定了网格的行数，即每列能放多少个视图 滚动视图ScrollView 滚动视图有两种：\nScrollView， 它是垂直方向的滚动视图，垂直方向滚动时，layout_width属性值设置为match_parent， layout_height属性值设置为wrap_content。\nHorizontalScrollView， 它是水平方向的滚动视图；水平方向滚动时，layout_width属性值设置为wrap_content， layout_height属性值设置为match_parent。\n哪个方向要滑动就将哪个方向设置为wrap_content\n\u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;utf-8\u0026#34;?\u0026gt; \u0026lt;LinearLayout xmlns:android=\u0026#34;http://schemas.android.com/apk/res/android\u0026#34; android:id=\u0026#34;@+id/main\u0026#34; android:layout_width=\u0026#34;match_parent\u0026#34; android:layout_height=\u0026#34;match_parent\u0026#34; android:orientation=\u0026#34;vertical\u0026#34;\u0026gt; \u0026lt;HorizontalScrollView android:layout_width=\u0026#34;wrap_content\u0026#34; android:layout_height=\u0026#34;200dp\u0026#34;\u0026gt; \u0026lt;LinearLayout android:layout_width=\u0026#34;wrap_content\u0026#34; android:layout_height=\u0026#34;match_parent\u0026#34; android:orientation=\u0026#34;horizontal\u0026#34;\u0026gt; \u0026lt;View android:layout_width=\u0026#34;300dp\u0026#34; android:layout_height=\u0026#34;match_parent\u0026#34; android:background=\u0026#34;#ffff00\u0026#34; /\u0026gt; \u0026lt;View android:layout_width=\u0026#34;300dp\u0026#34; android:layout_height=\u0026#34;match_parent\u0026#34; android:background=\u0026#34;#aaffff\u0026#34; /\u0026gt; \u0026lt;/LinearLayout\u0026gt; \u0026lt;/HorizontalScrollView\u0026gt; \u0026lt;ScrollView android:layout_width=\u0026#34;match_parent\u0026#34; android:layout_height=\u0026#34;wrap_content\u0026#34;\u0026gt; \u0026lt;LinearLayout android:layout_width=\u0026#34;wrap_content\u0026#34; android:layout_height=\u0026#34;match_parent\u0026#34; android:orientation=\u0026#34;vertical\u0026#34;\u0026gt; \u0026lt;View android:layout_width=\u0026#34;match_parent\u0026#34; android:layout_height=\u0026#34;700dp\u0026#34; android:background=\u0026#34;#aaff00\u0026#34; /\u0026gt; \u0026lt;View android:layout_width=\u0026#34;match_parent\u0026#34; android:layout_height=\u0026#34;700dp\u0026#34; android:background=\u0026#34;#ff6600\u0026#34; /\u0026gt; \u0026lt;/LinearLayout\u0026gt; \u0026lt;/ScrollView\u0026gt; \u0026lt;/LinearLayout\u0026gt; 按钮控件Button 按钮控件Button由TextView派生而来，它们之间的区别有：\nButton拥有默认的按钮背景，而TextView默认无背景 Button的内部文本默认居中对齐，而TextView的内部文本默认靠左对齐 Button会默认将英文字母转为大写，而TextView保持原始的英文大小写（新版保持原有格式） 按钮控件的新增属性 与TextView相比，Button增加了两个新属性：\ntextAllCaps属性，它指定了是否将英文字母转为大写，为true表示自动转为大写，为false表示不做大写转换 onClick属性：它用来接管用户的点击动作，指定了点击按钮时要触发哪个方法 ButtonStyleActivity.java 将 findViewById(R.id.button_result) 存储到一个全局变量中，快捷键：ctrl + alt + f\npublic class ButtonStyleActivity extends AppCompatActivity { private TextView button_result; @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.activity_button_style); button_result = findViewById(R.id.button_result); } public void doClick(View view){ String desc = String.format(\u0026#34;%s 您点击了按钮：%s\u0026#34;, DateUtil.getNowTime(), ((Button)view).getText()); button_result.setText(desc); } } 布局文件： \u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;utf-8\u0026#34;?\u0026gt; \u0026lt;LinearLayout xmlns:android=\u0026#34;http://schemas.android.com/apk/res/android\u0026#34; android:id=\u0026#34;@+id/main\u0026#34; android:layout_width=\u0026#34;match_parent\u0026#34; android:layout_height=\u0026#34;match_parent\u0026#34; android:orientation=\u0026#34;vertical\u0026#34; android:padding=\u0026#34;5dp\u0026#34;\u0026gt; \u0026lt;TextView android:layout_width=\u0026#34;wrap_content\u0026#34; android:layout_height=\u0026#34;wrap_content\u0026#34; android:text=\u0026#34;下面的button字母默认大写：\u0026#34; android:layout_gravity=\u0026#34;center\u0026#34; /\u0026gt; \u0026lt;Button android:layout_width=\u0026#34;match_parent\u0026#34; android:layout_height=\u0026#34;wrap_content\u0026#34; android:text=\u0026#34;Hello Button\u0026#34; android:textColor=\u0026#34;@color/black\u0026#34; android:textSize=\u0026#34;16sp\u0026#34; /\u0026gt; \u0026lt;Button android:layout_width=\u0026#34;match_parent\u0026#34; android:layout_height=\u0026#34;wrap_content\u0026#34; android:text=\u0026#34;直接指定点击方法\u0026#34; android:textColor=\u0026#34;@color/black\u0026#34; android:textSize=\u0026#34;16sp\u0026#34; android:onClick=\u0026#34;doClick\u0026#34; /\u0026gt; \u0026lt;TextView android:id=\u0026#34;@+id/button_result\u0026#34; android:layout_width=\u0026#34;wrap_content\u0026#34; android:layout_height=\u0026#34;wrap_content\u0026#34; android:text=\u0026#34;下面时点击按钮查看到的结果 \u0026#34; android:layout_gravity=\u0026#34;center\u0026#34; /\u0026gt; \u0026lt;/LinearLayout\u0026gt; 点击事件和长按事件 监听器，意思是对专门监听控件的动作行为。只有控件发生了指定的动作，监听器才会触发开关去执行对应的代码逻辑 按钮控件有两种常用的监听器： 点击监听器：通过setOnClickListener方法设置。按钮被按住少于500毫秒时，会触发点击事件 长按监听器，通过setOnLongClickListener方法设置。按钮被按住超过500毫秒时，会触发长按事件。 单击事件 XML布局文件 \u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;utf-8\u0026#34;?\u0026gt; \u0026lt;LinearLayout xmlns:android=\u0026#34;http://schemas.android.com/apk/res/android\u0026#34; android:id=\u0026#34;@+id/main\u0026#34; android:layout_width=\u0026#34;match_parent\u0026#34; android:layout_height=\u0026#34;match_parent\u0026#34; android:orientation=\u0026#34;vertical\u0026#34;\u0026gt; \u0026lt;Button android:id=\u0026#34;@+id/btn_click_sigle\u0026#34; android:layout_width=\u0026#34;match_parent\u0026#34; android:layout_height=\u0026#34;wrap_content\u0026#34; android:text=\u0026#34;指定单独的单击按钮\u0026#34; android:textColor=\u0026#34;@color/black\u0026#34; android:textSize=\u0026#34;15sp\u0026#34; /\u0026gt; \u0026lt;Button android:id=\u0026#34;@+id/btn_click_public\u0026#34; android:layout_width=\u0026#34;match_parent\u0026#34; android:layout_height=\u0026#34;wrap_content\u0026#34; android:text=\u0026#34;指定公共的单击按钮\u0026#34; android:textColor=\u0026#34;@color/black\u0026#34; android:textSize=\u0026#34;15sp\u0026#34; /\u0026gt; \u0026lt;TextView android:id=\u0026#34;@+id/tv_result\u0026#34; android:layout_width=\u0026#34;match_parent\u0026#34; android:layout_height=\u0026#34;wrap_content\u0026#34; android:padding=\u0026#34;5dp\u0026#34; android:gravity=\u0026#34;center\u0026#34; android:textColor=\u0026#34;@color/black\u0026#34; android:textSize=\u0026#34;15sp\u0026#34; android:text=\u0026#34;点击按钮查看显示结果\u0026#34;/\u0026gt; \u0026lt;/LinearLayout\u0026gt; Java文件 /** * ButtonClickActivity类，继承AppCompatActivity，实现View.OnClickListener接口 * 用于处理按钮点击事件 */ public class ButtonClickActivity extends AppCompatActivity implements View.OnClickListener { // 定义View和TextView类型的成员变量 private View btn_click_sigle; private TextView tv_result; /** * 在Activity创建时调用，初始化Activity * @param savedInstanceState 用于保存Activity的状态 */ @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.activity_button_click); // 设置布局文件 // 获取布局中的TextView控件 tv_result = findViewById(R.id.tv_result); // 获取布局中的按钮控件 btn_click_sigle = findViewById(R.id.btn_click_sigle); // 设置按钮的点击监听器 btn_click_sigle.setOnClickListener(new MyOnClickListener(tv_result)); // 获取另一个按钮控件 Button btn_click_public = findViewById(R.id.btn_click_public); // 设置当前类为按钮的点击监听器 btn_click_public.setOnClickListener(this); } /** * 重写View.OnClickListener接口中的onClick方法 * 处理按钮的点击事件 * @param v 被点击的View */ @Override public void onClick(View v) { if (v.getId() == R.id.btn_click_public) { // 判断点击的是否为btn_click_public按钮 // 获取当前时间和按钮文本，格式化字符串 String desc = String.format(\u0026#34;%s 您点击了按钮：%s\u0026#34;, DateUtil.getNowTime(), ((Button) v).getText()); // 设置TextView的文本内容 tv_result.setText(desc); } } /** * 静态内部类，实现View.OnClickListener接口 * 防止内存泄漏，处理按钮的点击事件 */ static class MyOnClickListener implements View.OnClickListener { // 定义TextView类型的成员变量 private final TextView tv_result; /** * 构造函数，初始化TextView * @param tv_result TextView控件 */ public MyOnClickListener(TextView tv_result) { this.tv_result = tv_result; } /** * 重写View.OnClickListener接口中的onClick方法 * 处理按钮的点击事件 * @param v 被点击的View */ @Override public void onClick(View v) { // 获取当前时间和按钮文本，格式化字符串 String desc = String.format(\u0026#34;%s 您点击了按钮：%s\u0026#34;, DateUtil.getNowTime(), ((Button) v).getText()); // 设置TextView的文本内容 tv_result.setText(desc); } } } 长按事件 XML \u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;utf-8\u0026#34;?\u0026gt; \u0026lt;LinearLayout xmlns:android=\u0026#34;http://schemas.android.com/apk/res/android\u0026#34; android:id=\u0026#34;@+id/main\u0026#34; android:layout_width=\u0026#34;match_parent\u0026#34; android:layout_height=\u0026#34;match_parent\u0026#34; android:orientation=\u0026#34;vertical\u0026#34;\u0026gt; \u0026lt;Button android:id=\u0026#34;@+id/btn_long_click\u0026#34; android:layout_width=\u0026#34;match_parent\u0026#34; android:layout_height=\u0026#34;wrap_content\u0026#34; android:text=\u0026#34;指定长按的点击监听器\u0026#34; android:textColor=\u0026#34;@color/black\u0026#34; android:textSize=\u0026#34;15sp\u0026#34; /\u0026gt; \u0026lt;TextView android:id=\u0026#34;@+id/tv_result\u0026#34; android:layout_width=\u0026#34;match_parent\u0026#34; android:layout_height=\u0026#34;wrap_content\u0026#34; android:padding=\u0026#34;5dp\u0026#34; android:gravity=\u0026#34;center\u0026#34; android:textColor=\u0026#34;@color/black\u0026#34; android:textSize=\u0026#34;15sp\u0026#34; android:text=\u0026#34;点击按钮查看显示结果\u0026#34;/\u0026gt; \u0026lt;/LinearLayout\u0026gt; Java package com.showguan.myapplication; import android.os.Bundle; import android.view.View; import android.widget.Button; import android.widget.TextView; import androidx.activity.EdgeToEdge; import androidx.appcompat.app.AppCompatActivity; import androidx.core.graphics.Insets; import androidx.core.view.ViewCompat; import androidx.core.view.WindowInsetsCompat; import com.showguan.myapplication.util.DateUtil; public class ButtomLongClickActivity extends AppCompatActivity { private TextView tv_result; @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.activity_buttom_long_click); tv_result = findViewById(R.id.tv_result); Button btn_long_click = findViewById(R.id.btn_long_click); btn_long_click.setOnLongClickListener(v -\u0026gt; { String desc = String.format(\u0026#34;%s 您点击了按钮：%s\u0026#34;, DateUtil.getNowTime(), ((Button) v).getText()); tv_result.setText(desc); return true; }); } } 禁用和恢复 在实际业务中，按钮通常拥有两种状态，即不可用状态和可用状态，它们在外观和功能上的区别如下：\n不可用按钮：按钮不允许点击，即使点击也没反应，同时按钮文字为灰色 可用按钮：按钮允许点击，点击按钮会触发点击事件，同时按钮文字为正常的黑色。 是否允许点击由enabled属性控制，属性值为true时表示允许点击，为false时表示不允许点击。\nXML文件 \u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;utf-8\u0026#34;?\u0026gt; \u0026lt;LinearLayout xmlns:android=\u0026#34;http://schemas.android.com/apk/res/android\u0026#34; android:id=\u0026#34;@+id/main\u0026#34; android:layout_width=\u0026#34;match_parent\u0026#34; android:layout_height=\u0026#34;match_parent\u0026#34; android:orientation=\u0026#34;vertical\u0026#34;\u0026gt; \u0026lt;LinearLayout android:layout_width=\u0026#34;match_parent\u0026#34; android:layout_height=\u0026#34;wrap_content\u0026#34;\u0026gt; \u0026lt;Button android:id=\u0026#34;@+id/btn_enable\u0026#34; android:layout_width=\u0026#34;0dp\u0026#34; android:layout_weight=\u0026#34;1\u0026#34; android:layout_height=\u0026#34;wrap_content\u0026#34; android:text=\u0026#34;启动测试按钮\u0026#34; android:textColor=\u0026#34;@color/black\u0026#34; android:textSize=\u0026#34;17sp\u0026#34;/\u0026gt; \u0026lt;Button android:id=\u0026#34;@+id/btn_disenable\u0026#34; android:layout_width=\u0026#34;0dp\u0026#34; android:layout_weight=\u0026#34;1\u0026#34; android:layout_height=\u0026#34;wrap_content\u0026#34; android:text=\u0026#34;禁用测试按钮\u0026#34; android:textColor=\u0026#34;@color/black\u0026#34; android:textSize=\u0026#34;17sp\u0026#34;/\u0026gt; \u0026lt;/LinearLayout\u0026gt; \u0026lt;Button android:id=\u0026#34;@+id/btn_test\u0026#34; android:layout_width=\u0026#34;match_parent\u0026#34; android:layout_height=\u0026#34;wrap_content\u0026#34; android:text=\u0026#34;测试按钮\u0026#34; android:textColor=\u0026#34;@color/black\u0026#34; android:textSize=\u0026#34;17sp\u0026#34; android:enabled=\u0026#34;false\u0026#34;/\u0026gt; \u0026lt;TextView android:id=\u0026#34;@+id/tv_content\u0026#34; android:layout_width=\u0026#34;match_parent\u0026#34; android:layout_height=\u0026#34;wrap_content\u0026#34; android:text=\u0026#34;这里查看测试按钮的结果\u0026#34; android:textColor=\u0026#34;@color/kennemColor\u0026#34; android:textSize=\u0026#34;17sp\u0026#34;/\u0026gt; \u0026lt;/LinearLayout\u0026gt; Java /** * ButtonEnableActivity类，继承AppCompatActivity，实现View.OnClickListener接口 * 用于处理按钮启用和禁用的功能 */ public class ButtonEnableActivity extends AppCompatActivity implements View.OnClickListener { // 定义TextView和Button类型的成员变量 private TextView tv_content; private Button btn_test; private Button btn_enable; private Button btn_disenable; /** * 在Activity创建时调用，初始化Activity * @param savedInstanceState 用于保存Activity的状态 */ @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.activity_button_enable); // 设置布局文件 // 获取布局中的按钮控件 btn_enable = findViewById(R.id.btn_enable); btn_disenable = findViewById(R.id.btn_disenable); btn_test = findViewById(R.id.btn_test); // 获取布局中的TextView控件 tv_content = findViewById(R.id.tv_content); // 设置按钮的点击监听器 btn_enable.setOnClickListener(this); btn_disenable.setOnClickListener(this); btn_test.setOnClickListener(this); } /** * 重写View.OnClickListener接口中的onClick方法 * 处理按钮的点击事件 * @param v 被点击的View */ @Override public void onClick(View v) { int id = v.getId(); // 获取被点击View的ID if (id == R.id.btn_enable) { // 如果点击的是启用按钮 btn_test.setEnabled(true); // 启用测试按钮 btn_test.setTextColor(Color.BLACK); // 设置按钮文字颜色为黑色 } else if (id == R.id.btn_disenable) { // 如果点击的是禁用按钮 btn_test.setEnabled(false); // 禁用测试按钮 btn_test.setTextColor(Color.GRAY); // 设置按钮文字颜色为灰色 } else if (id == R.id.btn_test) { // 如果点击的是测试按钮 tv_content.setText(\u0026#34;测试按钮被点击了\u0026#34;); // 设置TextView的文本内容 } } } 图像显示ImageView 图像视图展示的图片通常位于res/drawable***目录下，设置图像视图的显示图片有两种方式\n在XML文件中，通过属性android:src属性值格式如\u0026quot;@drawable/不含扩展名的图片名称\u0026quot; 在Java代码中，调用setImageResource方法设置图片资源，方法参数格式形如\u0026quot;R.drawable.不含扩展名的图片名称\u0026quot;。 centerInside和center， fitCenter的区别： fitCenter既允许缩小图片，也允许放大图片，centerInside只允许缩小图片，不允许放大图片，而center自始至终保持原始尺寸，既不允许缩小图片，也不允许放大图片\n默认为fitCenter\n代码设置方式：\nImageView iv_scale = findViewById(R.id.iv_scale); iv_scale.setImageResource(R.drawable.cat); iv_scale.setScaleType(ImageView.ScaleType.FIT_END); 图像按钮ImageButton ImageButton是显示图片的图像按钮，但它继承自ImageView， 而非继承Button\nImageButton 和 Button之间的区别：\nButton既可显示文本也可显示图片，ImageButton只能显示图片不能显示文本。 ImageButton上的图像可按比例缩放，而Button通过背景设置的图像会拉伸变形 Button只能靠背景显示一张图片，而ImageButton可分别在前景和背景显示图片，从而实现两张图片的叠加效果 \u0026lt;ImageButton android:layout_width=\u0026#34;match_parent\u0026#34; android:layout_height=\u0026#34;80dp\u0026#34; android:src=\u0026#34;@drawable/cat\u0026#34; android:scaleType=\u0026#34;fitCenter\u0026#34; \u0026gt;\u0026lt;/ImageButton\u0026gt; 同时展示文本与图像 XML 文件 \u0026lt;Button android:layout_width=\u0026#34;wrap_content\u0026#34; android:layout_height=\u0026#34;wrap_content\u0026#34; android:background=\u0026#34;#ffffffff\u0026#34; android:drawableRight=\u0026#34;@drawable/ic_launcher_foreground\u0026#34; android:drawablePadding=\u0026#34;15dp\u0026#34; android:text=\u0026#34;图标文字\u0026#34; android:textSize=\u0026#34;17sp\u0026#34; /\u0026gt; 坚持，一定要坚持下去，持续投入，一万小时定律 有困难了就停下来想一想 接受痛苦, 战胜痛苦 ","permalink":"https://kennems.github.io/zh/posts/tech/android1/","summary":"Android（1） 【金山文档 | WPS云文档】 Kotlin 讲义 https://kdocs.cn/l/cu14rrCtfKxv 【金山文档 | WPS云文档】 Android 四大组件课程概要 https://kdocs.cn/l/croaFl0RS5LA 【金山文档 | WPS云文档】 Fragment 重点知识 https://kdocs.cn/l/cj89XRLXypb8 【","title":"Android（1）"},{"content":"Java Web开发(7) Spring原理 配置优先级 SpringBoot中支持三种格式配置文件的优先级\nproperties yaml yml 配置 SpringBoot除了支持配置文件属性配置，还支持Java系统属性和命令行参数的方式进行属性配置\nJava系统属性\n-Dserver.port=9000 命令行参数\n--server.port=10010 打包时指定端口号(cmd 命令)\njava -Dserver.port=9000 -jar tilas-web-management-0.0.1-SNAPSHOT.jar --server.port=10011 powershell命令行参数解释不同\njava -D\u0026#34;server.port=9000\u0026#34; -jar .\\tilas-web-management-0.0.1-SNAPSHOT.jar --server.port=10011 Java系统属性-Dserver.port=9000优先级高于三种配置文件， 而--server.port=10011高于Java系统属性\nBean管理 获取bean\n默认情况下，Spring项目启动时，会把bean都创建好放在IOC容器中，如果想要主动获取这些bean， 可以通过如下方式\n根据name获取bean\nObject getBean(String name) 根据类型获取bean\n\u0026lt;T\u0026gt; T getBean(Class\u0026lt;T\u0026gt; requiredType) 根据name获取bean（带类型转换）\n\u0026lt;T\u0026gt; T getBean(String name, Class\u0026lt;T\u0026gt; requiredType) BUG解决Could not autowire. No beans of 'ApplicationContext' type found.的问题\nidea导入出错\nimport org.springframework.context.ApplicationContext; DeptController bean1 = (DeptController) applicationContext.getBean(\u0026#34;deptController\u0026#34;); System.out.println(bean1); DeptController bean2 = (DeptController) applicationContext.getBean(DeptController.class); System.out.println(bean2); DeptController bean3 = (DeptController) applicationContext.getBean(\u0026#34;deptController\u0026#34;, DeptController.class); System.out.println(bean3); bean的作用域 作用域 说明 singleton 容器内同名称的bean只有一个实例（单例）默认 prototype 每次使用该bean时会创建新的实例（非单例） request 每个请求范围内会创建新的实例（web环境中，了解） session 每个会话范围内会创建新的实例（web环境中，了解） application 每个应用范围内会创建新的实例（web环境中，了解） //@Lazy @Scope(\u0026#34;prototype\u0026#34;) 注意事项：\n默认singleton的bean，在容器启动时背创建，可以使用@Lazy注解来延迟初始化（延迟到第一次使用） prototype的bean，每一次使用该bean的时候都会创建一个新的实例 实际开发中，绝大部分的bean都是单例的，也就是说绝大部分的bean不需要配置scope属性 第三方bean 如果要管理的bean对象来自第三方（不是自定义的），是无法使用@Component及衍生注解声明bean的，就需要用到@Bean注解 若要管理的第三方bean对象，建议对这些bean进行集中分类配置，可以通过@Configuration注解声明一个配置类。 @Configuration public class CommonConfig { @Bean // 第三方bean对象 // 获取bean对象 : 如果没有指定bean名称，则默认为方法名 // 第三方bean对象需要对象注入，只需要在方法参数中写该参数即可 public SAXReader reader(DeptService deptService){ System.out.println(deptService); return new SAXReader(); } } @Component及衍生注解与@Bean注解使用场景：\n项目中自定义的，使用@Component及其衍生注解 项目中引入第三方的，使用@Bean注解 SpringBoot原理 起步依赖：SpringBoot使用Maven依赖传递管理依赖，可以自动配置依赖\n自动配置：\nSpringBoot的自动配置就是当Spring容器启动后，一些配置类，bean对象就自动存入到了IOC容器中，不需要我们手动去声明，从而简化了开发，省去了繁琐的配置操作。 自动配置原理 方案一：@ComponentScan 组件扫描\n@ComponentScan({\u0026#34;com.example\u0026#34;, \u0026#34;com.showguan\u0026#34;}) public class TilasWebManagementApplication { 方案二：@Import导入。使用@Import导入的类会被Spring加载到IOC容器中，导入形式\n导入普通类 导入配置类 导入ImportSelector接口实现类 @EnableXXX注解，封装@Import注解 //@Import({TokenParser.class}) //@Import({HeaderConfig.class}) //@Import({MyImportSelector.class}) @EnableHeaderConfig public class TilasWebManagementApplication { } 源码跟踪 @SpringBootApplication\n该注解标识在SpringBoot工程引导类上，是SpringBoot中最最最重要的注解。 @SpringBootConfiguration：该注解与@Configuration注解作用相同，用来声明当前也是一个配置类 @ComponentScan：组件扫描，默认扫描当前引导类所在包及其子包 @EnableAutoConfiguration：SpringBoot实现自动化配置的核心注解 @Conditional 作用：按照一定的条件进行判断，在满足给定条件后才会注册对应的bean对象到Spring IOC容器中 位置：方法，类 @Conditional 本身是一个父注解，派生出大量的子注解 @ConditionalOnClass：判断环境中是否有对应字节码文件，才注册bean到IOC容器 @ConditonalOnMissingBean：判断环境中没有对应的bean（类型或名称），才注册这个bean到IOC容器中 （常用场景：先使用自己创建的bean，如果自己没有创建，则使用系统默认的bean）\u0026ndash; 指定类型（value属性） 或 名称（name属性） @ConditionalProperty：判断配置文件中有对应属性和值，才注册bean到IOC容器中 自定义starter 场景：在实际开发中，经常会定义一些公共组件，提供给项目团队使用。而在SpringBoot的项目中，一般会将这些公共组件封装为SpringBoot的starter 步骤：\n创建aliyun-oss-spring-boot-starter模块 创建aliyun-oss-spring-boot-autoconfigure模块，在starter中引入该模块 在aliyun-oss-spring-boot-autoconfigure 模块中的定义自动配置功能，并定义自动配置文件 META-INF/spring/xxx.imports 文件目录结构：\n外部类需要使用OSS功能时：\n1、引入依赖 2、编写yml文件的必要参数 3、直接注入即可\n总结 Web三层架构\nSpringMVC 是 Spring framework中的Web模块\nSSM(SpringMVC + Spring framework + Mybatis)\nMVN高级 maven生成imi文件\nmvn idea:module 为什么要分模块设计？ 方便项目的管理维护，扩展，也方便模块间的相互调用，资源共享。\n注意事项 分模块设计需要先针对模块功能进行设计，再进行编码。不会先将工程开发完毕，然后进行拆分。 继承关系实现 常见打包方式：\njar：普通模块打包，springboot项目基本都是jar包（内嵌tomcat运行） war：普通web程序打包，需要部署在外部的tomcat服务器上 pom：父工程或聚合工程，该模块不写代码，仅进行依赖管理 步骤:\n创建maven模块 tlias-parent，该工程为父工程， 设置打包方式pom\n\u0026lt;!-- 设置spring工程的父工程--\u0026gt; \u0026lt;parent\u0026gt; \u0026lt;groupId\u0026gt;org.springframework.boot\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-boot-starter-parent\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;3.2.6\u0026lt;/version\u0026gt; \u0026lt;relativePath/\u0026gt; \u0026lt;!-- lookup parent from repository --\u0026gt; \u0026lt;/parent\u0026gt; \u0026lt;groupId\u0026gt;com.showguan\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;tlias-parent\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;1.0-SNAPSHOT\u0026lt;/version\u0026gt; \u0026lt;!-- 设置打包方式--\u0026gt; \u0026lt;packaging\u0026gt;pom\u0026lt;/packaging\u0026gt; 在子工程的pom.xml文件中，配置继承关系\n\u0026lt;parent\u0026gt; \u0026lt;groupId\u0026gt;com.showguan\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;tlias-parent\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;1.0-SNAPSHOT\u0026lt;/version\u0026gt; \u0026lt;relativePath\u0026gt;../tlias-parent/pom.xml\u0026lt;/relativePath\u0026gt; \u0026lt;/parent\u0026gt; 注意事项：\n在子工程中，配置了继承关系之后，坐标中的groupid是可以省略的，因为会自动继承父工程的。 relativePath指定父工程的pom文件的相对位置（如果不指定，将从本地仓库/远程仓库查找该工程）。 在父工程中配置各个工程共有的依赖（子工程会自动继承父工程的依赖）\n\u0026lt;dependencies\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.projectlombok\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;lombok\u0026lt;/artifactId\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;/dependencies\u0026gt; 若父子工程都配置了同一个依赖，以子工程的依赖为准。 版本锁定 在maven中，可以在父工程的pom文件中 通过 \u0026lt;dependencyManagement\u0026gt; 来统一管理依赖版本 父工程：\n\u0026lt;properties\u0026gt; \u0026lt;jjwt.version\u0026gt;0.9.1\u0026lt;/jjwt.version\u0026gt; \u0026lt;/properties\u0026gt; \u0026lt;dependencyManagement\u0026gt; \u0026lt;dependencies\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;io.jsonwebtoken\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;jjwt\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;${jjwt.version}\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependencies\u0026gt; \u0026lt;dependencyManagement\u0026gt; 子工程（仍需引入依赖，但是不需要版本号）：\n\u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;io.jsonwebtoken\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;jjwt\u0026lt;/artifactId\u0026gt; \u0026lt;/dependency\u0026gt; 注意事项：\n子工程引入依赖时，无需指定\u0026lt;version\u0026gt;版本号，父工程统一管理，变更依赖版本，只需要父工程中统一变更。 聚合 将多个模块组织成一个整体，同时进行项目的构建\n聚合工程 一个不具有业务功能的\u0026quot;空\u0026quot;工程（有且仅有一个pom文件\n作用：快速构建项目（无需根据依赖关系手动构建，直接在聚合工程上构建即可）\n在parent 的pom.xml文件内添加\n\u0026lt;modules\u0026gt; \u0026lt;module\u0026gt;../tlias-pojo\u0026lt;/module\u0026gt; \u0026lt;module\u0026gt;../tlias-utils\u0026lt;/module\u0026gt; \u0026lt;module\u0026gt;../tlias-web-management\u0026lt;/module\u0026gt; \u0026lt;/modules\u0026gt; 聚合和继承：\n作用 聚合用于快速构建项目 继承用于简化依赖配置、统一管理依赖 相同点 聚合与继承的pom.xml文件打包方式均为pom， 可以将两种关系制作到同一个pom文件中 聚合与继承均属于设计型模块，并无实际的模块内容 不同点 聚合是在聚合工程中配置关系，聚合可以感知到参与聚合的模块有哪些 继承是在子模块中配置关系，父模块无法感知哪些子模块继承了自己 私服 私服是一种特殊的仓库，它是架设在局域网内的仓库服务，用来代理位于外部的中央仓库，用于解决团队内部的资源共享和资源同步问题。 资源上传与下载\n项目版本：\n\u0026lt;artifactId\u0026gt;tlias-web-management\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;0.0.1-SNAPSHOT\u0026lt;/version\u0026gt; \u0026lt;name\u0026gt;tilas-web-management\u0026lt;/name\u0026gt; \u0026lt;description\u0026gt;tilas-web-management\u0026lt;/description\u0026gt; RELEASE（发行版本）：功能趋于稳定，当前更新停止，可以用于发行的版本，存储在私服中的RELEASE仓库中。 SNAPSHOT（快照版本）：功能不稳定，尚处于开发中的版本，即快照版本，存储在私服的SNAPSHOT仓库中。 ","permalink":"https://kennems.github.io/zh/posts/tech/java-web%E5%BC%80%E5%8F%917/","summary":"Java Web开发(7) Spring原理 配置优先级 SpringBoot中支持三种格式配置文件的优先级 properties yaml yml 配置 SpringBoot除了支持配置文件","title":"Java Web开发(7)"},{"content":"每天三道八股， 复习三天的八股 八股分为：基础知识，底层原理，场景应用\n基础知识：javaguide, 死记硬背，思维导图 底层原理：八股合集，面经+GPT+整理 场景应用：面经+积累 20240610 20240611 面向面经背八股，小米面经\n小米一面面经 自我介绍（项目经历和实习经历） 在自我介绍时，可以简要介绍自己的教育背景、工作经历、主要技能和项目经历。着重突出在项目中的具体职责和贡献，以及所使用的技术和取得的成果。\n1. Java的基本数据类型 Java有8种基本数据类型：\nbyte: 8位，范围是 -128 到 127 short: 16位，范围是 -32,768 到 32,767 int: 32位，范围是 -2^31 到 2^31-1 long: 64位，范围是 -2^63 到 2^63-1 float: 32位，单精度浮点数 double: 64位，双精度浮点数 char: 16位，无符号 Unicode 字符 boolean: 只有两个值：true 和 false 2. 了解哪些基本的数据结构 常见的数据结构包括：\n数组 链表（单链表、双链表） 栈 队列（普通队列、优先队列、循环队列） 哈希表 树（如二叉树、红黑树、B树、B+树） 图（有向图、无向图） 堆（如二叉堆、斐波那契堆） 3. 简单介绍二叉树 二叉树是一种树形数据结构，其中每个节点最多有两个子节点，分别称为左子节点和右子节点。常见的二叉树类型有：\n完全二叉树：除了最后一层，所有层的节点都填满，最后一层的节点都靠左对齐。 满二叉树：每个节点要么是叶子节点，要么有两个子节点。 二叉搜索树：对于每个节点，其左子节点的值小于该节点的值，其右子节点的值大于该节点的值。 4. 知道MySQL吗？MySQL中跟二叉树相关的结构你知道吗？ 在MySQL中，索引结构与二叉树相关的是B树和B+树。B树是一种自平衡的多路搜索树，B+树是B树的一种改进版，所有的叶子节点形成一个有序链表。MySQL的InnoDB存储引擎使用B+树来实现索引。\n5. 展开说说B树和B+树 B树：一种自平衡的多路搜索树，节点可以有多个子节点。所有叶子节点的深度相同，节点中的元素按顺序排列。 B+树：B树的改进版，非叶子节点不存储数据，只存储索引，所有数据都存储在叶子节点中。叶子节点之间形成一个有序链表，方便范围查询。 6. MySQL中现在主要用B树还是B+树？B+树的优势？ MySQL中的InnoDB存储引擎主要使用B+树。B+树的优势包括：\n所有数据都在叶子节点，查询效率高 叶子节点形成有序链表，方便范围查询 非叶子节点只存储索引，减少了树的高度，提高了查询效率 7. Redis的基本类型 Redis支持以下基本数据类型：\n字符串（String） 列表（List） 集合（Set） 有序集合（Sorted Set） 哈希（Hash） 8. Redis中Set和Sorted Set的区别 Set：无序集合，不允许重复元素，操作时间复杂度为O(1)。 Sorted Set：有序集合，每个元素都会关联一个分数，Redis通过分数进行排序，操作时间复杂度为O(log N)。 9. 有了解过JVM方面的知识吗？垃圾回收 JVM（Java虚拟机）是Java程序运行的基础，负责内存管理和垃圾回收。垃圾回收机制（GC）主要有以下几种算法：\n标记-清除（Mark-Sweep） 标记-整理（Mark-Compact） 复制（Copying） 分代收集（Generational Collecting）：年轻代（Young Generation）和老年代（Old Generation）分别采用不同的GC算法。 10. TCP通过什么来保证可靠传输的？ TCP通过以下机制保证可靠传输：\n三次握手建立连接 序列号和确认号 滑动窗口 超时重传 流量控制 拥塞控制 11. 细说三次握手、四次挥手 三次握手：\n客户端发送SYN包（同步序列编号）请求建立连接。 服务器接收到SYN包，返回一个SYN+ACK包表示同意建立连接。 客户端收到SYN+ACK包，回复一个ACK包，连接建立成功。 四次挥手：\n客户端发送FIN包（结束连接）请求断开连接。 服务器接收到FIN包，返回一个ACK包，表示确认断开连接请求。 服务器发送FIN包请求断开连接。 客户端收到FIN包，返回一个ACK包，连接断开。 「手撕」 链表相关 将链表转成数字，相加之后再转成链表。示例：\n输入：链表一：1-\u0026gt;6-\u0026gt;3，链表二：7-\u0026gt;1-\u0026gt;2 相当于361 + 217 = 578 输出：8-\u0026gt;7-\u0026gt;5 class ListNode { int val; ListNode next; ListNode(int x) { val = x; } } public class Solution { public ListNode addTwoNumbers(ListNode l1, ListNode l2) { ListNode dummyHead = new ListNode(0); ListNode p = l1, q = l2, curr = dummyHead; int carry = 0; while (p != null || q != null) { int x = (p != null) ? p.val : 0; int y = (q != null) ? q.val : 0; int sum = carry + x + y; carry = sum / 10; curr.next = new ListNode(sum % 10); curr = curr.next; if (p != null) p = p.next; if (q != null) q = q.next; } if (carry \u0026gt; 0) { curr.next = new ListNode(carry); } return dummyHead.next; } } 「继续QA」 1. 手撕这个算法的时间复杂度 上述算法的时间复杂度是O(max(m, n))，其中m和n分别是两个链表的长度。因为需要遍历两个链表的每一个节点。\n2. 如果能实习，每周几天、实习周期？ 根据个人情况回答，可以说出每周可以实习的天数和希望的实习周期长度。例如：\n每周3-5天 实习周期为3-6个月 参考资料 牛客网：https://www.nowcoder.com/feed/main/detail/61f2b3801d6b42d4b39adcf461b784b5?sourceSSR=users 小米二面面经 #面经 「QA」\nMyBatis 具体是干什么用的？在使用它之前可能会遇到什么问题，使用它之后会给你的项目带来什么便利？ 项目中有没有用到线程池？ MyBatis 中涉及到动态 sql，sql 的标签能说几个吗 MyBatis 能执行一对一或者一对多关联的查询吗？有哪些实现方式？ SpringBoot 中，读取配置的时候有哪些方式？ Integer 对象和基本数据类型 int，哪个占用更多的内存 ArrayList 和 LinkedList 的区别 对象的浅拷贝和深拷贝 了解哪些设计模式？ (逐渐离谱了起来)：tensorflow 是用来干嘛的 解释一下 softmax (聊我的科研项目里) 常用的强化学习算法 为什么用 PPO 算法不用 DQN 算法？ 为什么不用 A3C 算法？ 讲讲 Transformer…… 「手撕」\n很简单的数组题 2min 做完 反转链表 II 力扣 92 题（写过但忘了 啊啊啊啊啊啊） 好的，以下是对这些面试问题的详细回答：\n1. MyBatis 具体是干什么用的？在使用它之前可能会遇到什么问题，使用它之后会给你的项目带来什么便利？ MyBatis 是一款优秀的持久层框架，它支持定制化 SQL、存储过程以及高级映射。MyBatis 避免了几乎所有的 JDBC 代码和手动设置参数以及获取结果集。使用前可能遇到的问题包括：\n学习曲线：需要花时间学习和理解 MyBatis 的配置和使用方式。 配置复杂性：需要配置 XML 文件或注解，初期配置较复杂。 使用之后的便利包括： 降低了直接使用 JDBC 的复杂性，提高开发效率。 支持动态 SQL，灵活性高。 支持高级映射，可以方便地将查询结果映射为 Java 对象。 2. 项目中有没有用到线程池？ 线程池用于管理和复用多个线程，避免频繁创建和销毁线程带来的开销，提高系统性能。常用的线程池有：\nExecutors.newFixedThreadPool(int n): 固定大小的线程池。 Executors.newCachedThreadPool(): 可缓存的线程池。 Executors.newScheduledThreadPool(int n): 支持定时和周期性任务的线程池。 Executors.newSingleThreadExecutor(): 单线程池。 3. MyBatis 中涉及到动态 sql，sql 的标签能说几个吗 MyBatis 中的动态 SQL 标签包括：\n\u0026lt;if\u0026gt;: 根据条件是否包含某段 SQL。 \u0026lt;choose\u0026gt;: 类似 switch 语句，包含 \u0026lt;when\u0026gt; 和 \u0026lt;otherwise\u0026gt;。 \u0026lt;where\u0026gt;: 自动处理 AND/OR 逻辑。 \u0026lt;set\u0026gt;: 用于动态更新语句。 \u0026lt;foreach\u0026gt;: 用于遍历集合生成动态 SQL。 \u0026lt;trim\u0026gt;: 自定义 SQL 片段。 4. MyBatis 能执行一对一或者一对多关联的查询吗？有哪些实现方式？ MyBatis 可以执行一对一或一对多的关联查询。实现方式包括：\n使用 resultMap 进行结果映射，定义关联关系。 在 SQL 中使用 JOIN 语句进行关联查询。 使用 association 和 collection 标签实现一对一和一对多映射。 5. SpringBoot 中，读取配置的时候有哪些方式？ SpringBoot 读取配置的方式包括：\n@Value: 注入单个配置属性。 @ConfigurationProperties: 批量注入配置属性。 Environment 对象：通过 environment.getProperty 方法获取配置。 @PropertySource: 加载自定义配置文件。 application.properties 或 application.yml: 默认配置文件。 6. Integer 对象和基本数据类型 int，哪个占用更多的内存 Integer 对象占用的内存更多。int 是基本数据类型，直接存储数值，占用 4 个字节。而 Integer 是包装类，除了存储数值外，还包含对象头信息，至少占用 16 个字节（具体根据 JVM 实现和对象头信息有所不同）。\n7. ArrayList 和 LinkedList 的区别 ArrayList: 基于动态数组实现，查询速度快（O(1)），增删速度慢（O(n)）。 LinkedList: 基于双向链表实现，查询速度慢（O(n)），增删速度快（O(1)）。 8. 对象的浅拷贝和深拷贝 浅拷贝: 只复制对象的基本类型和引用类型的地址，不复制引用对象本身。修改引用对象会影响原对象。 深拷贝: 复制对象的基本类型和引用对象，生成一个全新的对象，互不影响。 9. 了解哪些设计模式？ 常见的设计模式包括：\n创建型模式: 工厂模式、抽象工厂模式、单例模式、建造者模式、原型模式。 结构型模式: 适配器模式、装饰器模式、代理模式、外观模式、桥接模式、组合模式、享元模式。 行为型模式: 策略模式、模板方法模式、观察者模式、迭代器模式、责任链模式、命令模式、备忘录模式、状态模式、访问者模式、解释器模式、中介者模式。 10. TensorFlow 是用来干嘛的 TensorFlow 是一个开源的机器学习框架，主要用于深度学习模型的开发、训练和部署。它提供了灵活的计算图结构，可以在 CPU、GPU 和 TPU 上运行，支持分布式计算。\n11. 解释一下 softmax Softmax 是一种激活函数，常用于多分类模型的输出层。它将输入的 logits 转换为概率分布，公式如下： [ \\text{softmax}(x_i) = \\frac{e^{x_i}}{\\sum_{j} e^{x_j}} ] 其中，( x_i ) 是输入向量的第 i 个分量，输出的每个分量都是介于 0 和 1 之间的概率值，且所有分量的和为 1。\n12. 常用的强化学习算法 为什么用 PPO 算法不用 DQN 算法？ PPO（Proximal Policy Optimization）和 DQN（Deep Q-Network）都是常用的强化学习算法。选择 PPO 而不是 DQN 的原因包括：\nPPO 是基于策略梯度的算法，适用于连续动作空间，而 DQN 主要用于离散动作空间。 PPO 引入了剪切概率比（clipped probability ratio），在更新策略时保持平稳，训练更稳定。 PPO 更加简单高效，不需要像 DQN 那样复杂的经验回放和目标网络。 13. 为什么不用 A3C 算法？ 尽管 A3C（Asynchronous Advantage Actor-Critic）是一个有效的算法，但相较于 PPO，有以下缺点：\nA3C 使用多线程并行，容易受到线程调度和同步的影响。 PPO 不需要复杂的多线程设置，具有更高的样本效率和训练稳定性。 PPO 算法相对更简单，更容易调试和实现。 14. 讲讲 Transformer Transformer 是一种用于自然语言处理的神经网络模型，克服了传统 RNN 模型在处理长序列时的局限性。它主要由以下部分组成：\n编码器（Encoder）: 由多个相同的编码层堆叠而成，每层包含自注意力机制和前馈神经网络。 解码器（Decoder）: 结构类似于编码器，但每个解码层在自注意力机制之后还增加了一个对编码器输出的注意力机制。 自注意力机制（Self-Attention）: 计算输入序列中每个元素与其他元素的关系，以捕捉全局依赖关系。 位置编码（Positional Encoding）: 为了保留序列信息，向输入中添加位置信息。 Transformer 的优势包括： 并行化计算效率高，适合处理长序列。 能够捕捉序列中全局依赖关系。 「手撕」 1. 很简单的数组题 2min 做完 假设这是一个简单的求数组最大值的题目，代码如下：\npublic int findMax(int[] nums) { int max = nums[0]; for (int num : nums) { if (num \u0026gt; max) { max = num; } } return max; } 2. 反转链表 II 力扣 92 题 反转链表 II 的解题思路是找到要反转的起点和终点，进行局部反转。代码如下：\npublic ListNode reverseBetween(ListNode head, int m, int n) { if (head == null) return null; ListNode dummy = new ListNode(0); dummy.next = head; ListNode pre = dummy; for (int i = 0; i \u0026lt; m - 1; i++) pre = pre.next; ListNode start = pre.next; ListNode then = start.next; for (int i = 0; i \u0026lt; n - m; i++) { start.next = then.next; then.next = pre.next; pre.next = then; then = start.next; } return dummy.next; } /** * Definition for singly-linked list. * public class ListNode { * int val; * ListNode next; * ListNode() {} * ListNode(int val) { this.val = val; } * ListNode(int val, ListNode next) { this.val = val; this.next = next; } * } */ class Solution { public ListNode reverseBetween(ListNode head, int m, int n) { if (head == null) return null; ListNode dummy = new ListNode(0); dummy.next = head; ListNode pre = dummy; for (int i = 0; i \u0026lt; m - 1; i++) pre = pre.next; ListNode start = pre.next; ListNode cur = null; ListNode newEnd = start; for (int i = 0; i \u0026lt;= n - m; i++) { ListNode nxt = start.next; start.next = cur; cur = start; start = nxt; } pre.next = cur; newEnd.next = start; return dummy.next; } } 希望这些回答能帮助你更好地准备面试。祝你面试成功！\n","permalink":"https://kennems.github.io/zh/posts/tech/%E6%AF%8F%E5%A4%A9%E4%B8%89%E9%81%93%E5%85%AB%E8%82%A1-%E5%A4%8D%E4%B9%A0%E4%B8%89%E5%A4%A9%E7%9A%84%E5%85%AB%E8%82%A1/","summary":"每天三道八股， 复习三天的八股 八股分为：基础知识，底层原理，场景应用 基础知识：javaguide, 死记硬背，思维导图 底层原理：八股合集，面经+","title":"八股笔记"},{"content":"Java Web开发(6) 事务：事务是一组操作的集合，它是一个不可分割的工作单位，这些操作要么同时成功，要么同时失败\nstart transaction / begin commit rollback Spring事务管理 @Transactional 位置：业务（service）层的方法上、类上、接口上 作用：将当前方法交给spring进行事务管理，方法执行前，开启事务；成功执行完毕，提交事务；出现异常，回滚事务。 事务属性\n默认情况下，只有出现RuntimeException 才回滚异常。rollbackFor属性用于控制出现何种异常类型是回滚事务 @Transactional(rollbackFor = Exception.class) 传播行为\npropagation\n事务传播行为：指的是当一个事务方法被另一个事务方法调用时，这个事务方法应该如何进行事务控制\nREQUIRED：大部分情况下都是用该传播行为即可\nREQUIRES_NEW：当我们不希望事务之间相互影响时，可以使用该传播行为。比如：下订单前需要记录日志，不论订单保存成功与否，都需要保证日志记录能够记录成功。\nAOP AOP（Aspect Oriented Programming）面向切面编程，面向方面编程，其实就是面向特定方法编程。 场景：\n统计Service各项方法的运行耗时\n@Slf4j @Component @Aspect public class TimeAspect { @Around(\u0026#34;execution(* com.showguan.service.*.*(..))\u0026#34;) public Object recordTime(ProceedingJoinPoint joinPoint) throws Throwable { long begin = System.currentTimeMillis(); Object result = joinPoint.proceed(); long end = System.currentTimeMillis(); log.info(joinPoint.getSignature() + \u0026#34;方法耗时 :{} ms\u0026#34;, (end-begin)); return result; } } AOP核心概念\n连接点：JoinPoint，可以被AOP控制的方法（暗含方法执行时的相关信息） 通知：Advice， 指哪些重复的逻辑，也就是共性功能（最终体现为一个方法） 切入点：PointCut，匹配连接点的条件，通知仅会在切入点方法执行时被应用 切面：Aspect，描述通知与切入点的对应关系（通知+切入点） 目标对象：Target, 通知所应用的对象 通知类型\n@Around：环绕通知，此注解标注的通知方法在目标方法前后都被执行 @Before：前置通知，此注解标注的通知方法在目标方法前被执行 @After：后置通知，此注解标注的通知方法在目标方法后被执行，无论是否有异常都会执行 @AfterReturning：返回后通知，此注解标注的通知方法在目标方法后被执行，有异常不会执行 @AfterThrowing：异常后通知，此注解标注的通知方法发生异常后执行 注意事项；\n@Around 环绕通知需要自己调用 Object result = proceedingJoinPoint.proceed(); 来让原始方法执行，其他通知不需要考虑目标方法执行\n@Around 环绕通知方法的返回值，必须指定为Object，来接收原始方法的返回值 通知顺序 当有多个切面的切入点都匹配到了目标方法，目标方法运行时，多个通知方法都会被执行\n执行顺序\n不同切面类中，默认按照切面类的类名字母排序 目标方法前的通知方法：字母排名靠前的先执行 目标方法后的通知方法：字母排名靠前的后执行 用@Order（数字）加在切面类上来控制顺序 目标方法前的通知方法：数字小的先执行 目标方法后的通知方法：数字小的后执行 切入点表达式\n描述切入点方法的一种表达式 作用：主要用来决定项目中哪些方法需要加入通知 常见形式 execution(...)：根据方法的签名来匹配 @annotation(...)：根据注解匹配 execution根据方法的返回值，包名，类名，方法名，方法参数等信息来匹配，语法为：\nexecution(访问修饰符? 返回值 包名.类名.?方法名(方法参数) throws 异常?) 其中带 ? 表示可以省略的部分\n访问修饰符：可省略（public, protected) 包名.类名：可省略 throws异常：可省略（注意时方法上声明抛出的异常，不是实际抛出的异常） 可以使用通配符描述切入点\n*：单个独立的任意符号，可以通配任意返回值，包名，类名，方法名，任意类型的一个参数，也可以统配包，类，方法名的一部分\nexecution(* com.*.service.*.update*(*)) .. : 多个连续的任意符号，可以通配任意层级的包，或任意类型，任意个数的参数\nexecution(* com.showguan..DeptService.*(..)) 根据业务需要， 可以使用 \u0026amp;\u0026amp;， ||， ! 来组合比较复杂的切入点表达式\n书写建议：\n所有业务方法名在命名时尽量规范，方便切入点表达式快速匹配。如：查询类方法都是find开头，更新类方法都是update开头 描述切入点方法通常基于接口描述，而不是直接描述实现类，增强拓展性 在满足业务需要的前提下，尽量缩小切入点的匹配范围，如：包名尽量不使用\u0026hellip;， 使用*匹配单个包名 注解形式 在apo文件夹内新建注解文件 Mylog.java\n@Retention(RetentionPolicy.RUNTIME) //什么时候运行 @Target(ElementType.METHOD) // 运行范围 public @interface MyLog { } Aspect文件配置：\n@Slf4j @Component @Aspect public class MyAspect2 { // @Pointcut(\u0026#34;execution(* com.showguan.service.DeptService.list()) ||\u0026#34; + // \u0026#34;execution(* com.showguan.service.DeptService.delete(java.lang.Integer))\u0026#34; // ) @Pointcut(\u0026#34;@annotation(com.showguan.apo.MyLog)\u0026#34;) private void pt(){} @Before(\u0026#34;pt()\u0026#34;) private void before(){ log.info(\u0026#34;My Aspect6 ... Before ...\u0026#34;); } } 在需要匹配的方法前面加上 @MyLog 注解即可。\n连接点\n在Spring中用JoinPoint抽象了连接点，用它可以后的方法执行时的相关信息，如目标类名，方法名，方法参数等 对于@Around通知，获取连接点信息只能用ProceedingJoinPoing 对于其他四种通知，获取连接点信息只能使用JointPoint， 它是ProceedingPoint的父类型 package com.showguan.apo; import lombok.extern.slf4j.Slf4j; import net.sf.jsqlparser.statement.select.Join; import org.aspectj.lang.JoinPoint; import org.aspectj.lang.ProceedingJoinPoint; import org.aspectj.lang.annotation.Around; import org.aspectj.lang.annotation.Aspect; import org.aspectj.lang.annotation.Before; import org.aspectj.lang.annotation.Pointcut; import org.springframework.stereotype.Component; @Slf4j @Component @Aspect public class MyAspect3 { @Pointcut(\u0026#34;execution(* com.showguan.service.impl.DeptServiceImpl.*(..))\u0026#34;) // private void pt(){} public void pt(){} @Before(\u0026#34;pt()\u0026#34;) public void before(JoinPoint joinPoint){ log.info(\u0026#34;before ...\u0026#34;); } @Around(\u0026#34;pt()\u0026#34;) public Object around(ProceedingJoinPoint JoinPoint) throws Throwable { log.info(\u0026#34;around before\u0026#34;); Object target = JoinPoint.getTarget(); log.info(\u0026#34;目标 对象的类名：{}\u0026#34;, JoinPoint); String name = JoinPoint.getSignature().getName(); log.info(\u0026#34;目标方法的方法名\u0026#34;, name); Object[] args = JoinPoint.getArgs(); log.info(\u0026#34;目标方法运行时传入的参数：{}\u0026#34;, args); Object result = JoinPoint.proceed(); log.info(\u0026#34;目标方法的返回值：{}\u0026#34;, result); log.info(\u0026#34;around after ...\u0026#34;); return result; } } 实践 对员工和部分的增删改部分进行日志记录\n@Slf4j @Component @Aspect public class LogAspect { @Autowired private OperateLogMapper operateLogMapper; @Autowired private HttpServletRequest request; @Around(\u0026#34;@annotation(com.showguan.anno.Log)\u0026#34;) public Object recordLog(ProceedingJoinPoint joinPoint) throws Throwable { String jwt = request.getHeader(\u0026#34;token\u0026#34;); Claims claims = JwtUtils.parseJWT(jwt); Integer operateUser = (Integer) claims.get(\u0026#34;id\u0026#34;); LocalDateTime operateTime = LocalDateTime.now(); String className = joinPoint.getTarget().getClass().getName(); String methodName = joinPoint.getSignature().getName(); Object[] args = joinPoint.getArgs(); String methodParams = Arrays.toString(args); long begin = System.currentTimeMillis(); Object result = joinPoint.proceed(); long end = System.currentTimeMillis(); String returnValue = JSONObject.toJSONString(result); Long costTime = end - begin; OperateLog operateLog = new OperateLog(null, operateUser, operateTime, className, methodName, methodParams, returnValue, costTime); operateLogMapper.insert(operateLog); return result; } } ","permalink":"https://kennems.github.io/zh/posts/tech/java-web%E5%BC%80%E5%8F%916/","summary":"Java Web开发(6) 事务：事务是一组操作的集合，它是一个不可分割的工作单位，这些操作要么同时成功，要么同时失败 start transaction / begin commit rollback Spring事务管理","title":"Java Web开发(6)"},{"content":"LeetCode双周赛132 \u0026amp; 周赛401(240608/09) 3181. 执行操作可获得的最大总奖励 II周赛第四题 题目大意 给定一个整数数组 rewardValues，长度为 n，表示不同位置的奖励值。初始时，总奖励 x 为 0，所有下标都是未标记的。可以执行以下操作任意次：\n从区间 [0, n-1] 中选择一个未标记的下标 i。 如果 rewardValues[i] 大于当前的总奖励 x，则将 rewardValues[i] 加到 x 上，并标记下标 i。 要求返回执行最优操作能够获得的最大总奖励。\n实现思路 使用动态规划的思想解决问题，考虑如何选择操作能使得总奖励最大化。 使用一个状态 f 表示当前可以达到的最大总奖励的二进制表示。初始状态 f = 1 表示可以达到总奖励为 0 的状态。 遍历奖励值 rewardValues 的不同值，对每个值进行处理： 将该奖励值作为新的状态加入到当前状态 f 中。 最终 f 的位长度减去 1 即为可以达到的最大总奖励。 该解法利用了动态规划和位运算的特性，通过状态的更新和转移，实现了对最优操作序列的求解，保证了时间复杂度在合理范围内。\nclass Solution: def maxTotalReward(self, r: List[int]) -\u0026gt; int: f = 1 for v in sorted(set(r)): mask = (1 \u0026lt;\u0026lt; v) - 1 mask = mask \u0026amp; f mask = mask \u0026lt;\u0026lt; v f |= mask return f.bit_length() - 1 3177. 求出最长好子序列 II双周赛第四题 题目大意 给你一个整数数组 nums 和一个非负整数 k。如果一个整数序列 seq 满足在下标范围 [0, seq.length - 2] 中存在不超过 k 个下标 i 使得 seq[i] != seq[i + 1]，那么我们称这个整数序列为 好序列。\n请你返回 nums 中 好子序列 的最长长度。\n实现思路 预处理：将 nums 中的元素离散化，即将每个元素映射到一个新的唯一整数，这样可以简化后续的处理。用 d 字典保存每个元素的离散化后的值。 动态规划：使用二维数组 f 记录当前子序列的最大长度，其中 f[nm][i] 表示以 nm 结尾且有 i 次不连续的最大长度。 另用 mx 记录使用 i 次变换的最大长度，lst 记录该最大长度对应的最后一个元素。 状态转移：遍历 nums 中的每个元素 nm，并更新 f 和 mx、lst。 如果 i \u0026gt; 0，则 f[nm][i] 更新为 f[lst[i-1]][i-1] + 1。 更新 mx[i] 和 lst[i]，保证它们记录当前的最大值和对应元素。 结果：最终的结果为 res，记录所有情况下的最大长度。 class Solution: def maximumLength(self, nums: List[int], k: int) -\u0026gt; int: # 离散化 d = {v: i for i, v in enumerate(set(nums))} if len(d) == 1: return len(nums) n = len(d) nums = [d[x] for x in nums] # 初始化动态规划数组 f = [[0] * (k + 1) for _ in range(n + 1)] mx, lst = [0] * (k + 1), [0] * (k + 1) res = 0 for nm in nums: for i in range(k, -1, -1): f[nm][i] += 1 if i and f[lst[i - 1]][i - 1] + 1 \u0026gt; f[nm][i]: f[nm][i] = f[lst[i - 1]][i - 1] + 1 if f[nm][i] \u0026gt; mx[i]: mx[i] = f[nm][i] lst[i] = nm if f[nm][i] \u0026gt; res: res = f[nm][i] return res ","permalink":"https://kennems.github.io/zh/posts/tech/leetcode%E5%8F%8C%E5%91%A8%E8%B5%9B132--%E5%91%A8%E8%B5%9B40124060809/","summary":"LeetCode双周赛132 \u0026amp; 周赛401(240608/09) 3181. 执行操作可获得的最大总奖励 II周赛第四题 题目大意 给定一个整数数组 reward","title":"LeetCode双周赛132 \u0026 周赛401(240608/09)"},{"content":"Java Web开发(5) MyBatis MyBatis是一款优秀的持久层框架，用于简化JDBC的开发。 使用Mybatis查询所有用户数据\n创建SpringBoot工程， 数据库表user， 实体类User\n引入Mybatis的相关依赖，配置Mybatis\n\u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.mybatis.spring.boot\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;mybatis-spring-boot-starter-test\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;3.0.3\u0026lt;/version\u0026gt; \u0026lt;scope\u0026gt;test\u0026lt;/scope\u0026gt; \u0026lt;/dependency\u0026gt; 编写SQL语句（注解/XML）\n遇到的Bug 在mybatisquickstart 中的MybatisQuickstartApplication.java添加下面这一行\n@MapperScan(\u0026#34;com.showguan.mapper\u0026#34;) // 添加这一行 package com.showguan.mybatisquickstart; import org.mybatis.spring.annotation.MapperScan; import org.springframework.boot.SpringApplication; import org.springframework.boot.autoconfigure.SpringBootApplication; @SpringBootApplication @MapperScan(\u0026#34;com.showguan.mapper\u0026#34;) // 添加这一行 public class MybatisQuickstartApplication { public static void main(String[] args) { SpringApplication.run(MybatisQuickstartApplication.class, args); } } JDBC JDBC：(Java DataBase Connectivity)， 就是使用Java语言操作关系型数据库的一套API。\n本质：\nSun公司官方定义的一套操作所有关系型数据库的规范， 即接口 各个数据库厂商去实现这套接口，提供数据库驱动jar包 我们可以使用这套接口（JDBC）编程， 真正执行的代码是驱动jar包中的实现类 数据库连接池 数据库连接池是一个容器，负责分配，管理数据库连接（Connection） 它允许应用程序重复使用一个现有的数据库连接，而不是再重新建立一个 释放空闲时间超过最大空闲时间的连接，来避免因为没有释放连接而引起的数据库连接遗漏 标准接口：DataSource\n官方提供的数据库连接池接口，由第三方组织实现此接口 功能：获取连接 Druid(德鲁伊)， Hikari\nLombok Lombok是一个实用的Java类库， 能通过注解的形式自动生成构造器，getter/setter, equals, hashcode, toString等方法， 并可以自动化生成日志变量， 简化Java开发， 提高效率。 \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.projectlombok\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;lombok\u0026lt;/artifactId\u0026gt; \u0026lt;/dependency\u0026gt; 注解 作用 @Getter/Setter 为所有的属性提供get/set方法 @ToString 会给类自动生成易阅读的toString方法 @EqualsAndHashCode 根据类所拥有的非静态字段自动重写equals方法和hashCode方法 @Data 提供更综合的生成代码功能（@Getter + @Setter + @ToString + @EqualsAndHashCode） @NoArgsConstructor 为实体类生成无参数的构造器方法 @AllArgsConstructor 为实体类生成除了static修饰的字段之外的带有各参数的构造器方法 Mybatis基础操作 删除和新增操作\nMybatisCrudApplicationTests\n@SpringBootTest class MybatisCrudApplicationTests { @Autowired private EmpMapper empMapper; @Test public void testDelete() { int delete = empMapper.delete(17); System.out.println(delete); } @Test public void testInsert(){ Emp emp = new Emp(152, \u0026#34;Tom1\u0026#34;, \u0026#34;0303\u0026#34;, \u0026#34;Tom\u0026#34;, (short)1, \u0026#34;1.jpg\u0026#34;, (short)1, LocalDate.of(2001, 3, 4), 1, LocalDateTime.now(), LocalDateTime.now()); empMapper.insert(emp); System.out.println(emp.getId()); } } application.properties\nspring.datasource.driver-class-name=com.mysql.cj.jdbc.Driver spring.datasource.url=jdbc:mysql://localhost:3306/mybatis spring.datasource.username=root spring.datasource.password=20230205.ken #配置mybatis的日志, 指定输出到控制台 mybatis.configuration.log-impl=org.apache.ibatis.logging.stdout.StdOutImpl #开启mybatis的驼峰命名自动映射开关 a_column ------\u0026gt; aCloumn mybatis.configuration.map-underscore-to-camel-case=true Emp.java\npackage com.showguan.pojo; import lombok.AllArgsConstructor; import lombok.Data; import lombok.NoArgsConstructor; import java.time.LocalDate; import java.time.LocalDateTime; @Data @NoArgsConstructor @AllArgsConstructor public class Emp { private Integer id; private String username; private String password; private String name; private Short gender; private String image; private Short job; private LocalDate entrydate; private Integer deptId; private LocalDateTime createTime; private LocalDateTime updateTime; } MybatisCrudApplication.java\npackage com.showguan.mybatiscrud; import org.mybatis.spring.annotation.MapperScan; import org.springframework.boot.SpringApplication; import org.springframework.boot.autoconfigure.SpringBootApplication; @SpringBootApplication @MapperScan(\u0026#34;com.showguan.mapper\u0026#34;) // 添加这一行 public class MybatisCrudApplication { public static void main(String[] args) { SpringApplication.run(MybatisCrudApplication.class, args); } } EmpMapper.java(定义为接口)\npackage com.showguan.mapper; import com.showguan.pojo.Emp; import org.apache.ibatis.annotations.*; @Mapper public interface EmpMapper { @Delete(\u0026#34;delete from emp where id = #{id}\u0026#34;) // public void delete(Integer id); public int delete(Integer id); // 定义为int返回值, 获取删除的个数信息 @Insert(\u0026#34;insert into emp(id, username, password, name, gender, image, job, entrydate, dept_id, create_time, update_time)\\n\u0026#34; + \u0026#34; values (#{id}, #{username}, #{password}, #{name}, #{gender}, #{image}, #{job}, #{entrydate}, #{deptId}, #{createTime}, #{updateTime});\u0026#34;) public void insert(Emp emp); } 注意事项\n如果mapper接口方法形参中只有一个普通类型的参数， #{ }里面的属性名可以随便写， 如 ： #{id}, #{xxx} (推荐保持一致) 预编译SQL\n优势：\n性能更高 更安全（放置SQL注入） SQL注入 SQL注入是通过操作输入的数据来修改事先定义好的SQL语句， 以达到执行代码对服务器进行攻击的方法。 面试题 : 参数占位符 #{\u0026hellip;} 执行SQL时， 会将#{\u0026hellip;}替换为?, 生成预编译SQL， 会自动设置参数值 使用时机：参数传递， 都使用{\u0026hellip;} ${\u0026hellip;} 拼接SQL。直接将参数拼接再SQL语句中，存在SQL注入问题 使用时机：如果对表名，列表进行动态设置时使用 数据封装 起别名：在SQL语句中，对不一样的列名起别名，别名和实体类属性名一样 @Select(\u0026#34;select id, username, password, name, gender, image, job, entrydate, dept_id deptId, create_time createTime, update_time updateTime from emp where id = #{id}\u0026#34;) public Emp getById(Integer id); 手动结果映射：通过 @Results 及 @Result 进行手动结果映射 @Select(\u0026#34;select * from emp where id = #{id}\u0026#34;) @Results({ @Result(column = \u0026#34;dept_id\u0026#34;, property = \u0026#34;deptId\u0026#34;), @Result(column = \u0026#34;create_time\u0026#34;, property = \u0026#34;createTime\u0026#34;), @Result(column = \u0026#34;update_time\u0026#34;, property = \u0026#34;updateTime\u0026#34;) }) public Emp getById(Integer id); 开启驼峰命名：如果字段名和属性名称符合驼峰命名规则， mybatis会自动通过驼峰命名规则映射\n#开启mybatis的驼峰命名自动映射开关 a_column ------\u0026gt; aCloumn mybatis.configuration.map-underscore-to-camel-case=true mybatis 查询 @Select(\u0026#34;select * from emp where id = #{id}\u0026#34;) public Emp getById(Integer id); // @Select(\u0026#34;select id, username, password, name, gender, image, job, entrydate, dept_id deptId, create_time createTime, update_time updateTime from emp where id = #{id}\u0026#34;) // public Emp getById(Integer id); // @Select(\u0026#34;select * from emp where id = #{id}\u0026#34;) // @Results({ // @Result(column = \u0026#34;dept_id\u0026#34;, property = \u0026#34;deptId\u0026#34;), // @Result(column = \u0026#34;create_time\u0026#34;, property = \u0026#34;createTime\u0026#34;), // @Result(column = \u0026#34;update_time\u0026#34;, property = \u0026#34;updateTime\u0026#34;) // }) // public Emp getById(Integer id); // 使用${} // @Select(\u0026#34;select *\\n\u0026#34; + // \u0026#34;from emp\\n\u0026#34; + // \u0026#34;where name like \u0026#39;%${name}%\u0026#39;\\n\u0026#34; + // \u0026#34; and gender = #{gender}\\n\u0026#34; + // \u0026#34; and entrydate between #{begin}\\n\u0026#34; + // \u0026#34; and #{end}\\n\u0026#34; + // \u0026#34;order by update_time\u0026#34;) // public List\u0026lt;Emp\u0026gt; list(String name, Short gender, LocalDate begin, LocalDate end); //解决上面的 #{}出现在引号之内 @Select(\u0026#34;select *\\n\u0026#34; + \u0026#34;from emp\\n\u0026#34; + \u0026#34;where name like concat(\u0026#39;%\u0026#39;, #{name}, \u0026#39;%\u0026#39;)\\n\u0026#34; + \u0026#34; and gender = #{gender}\\n\u0026#34; + \u0026#34; and entrydate between #{begin}\\n\u0026#34; + \u0026#34; and #{end}\\n\u0026#34; + \u0026#34;order by update_time\u0026#34;) public List\u0026lt;Emp\u0026gt; list(String name, Short gender, LocalDate begin, LocalDate end); 参数名说明\n在SpringBoot的 1.x 版本中单独使用mybatis XML映射文件 规范\nXML映射文件的名称与Mapper接口名称一致，并且将XML文件和Mapper接口放置在相同包下（同包同名） XML映射文件的 namespace 属性为Mapper接口全限定名一致 XML映射文件SQL语句的id和Mapper接口的方法名一致，并保持返回类型一致。 \u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;UTF-8\u0026#34; ?\u0026gt; \u0026lt;!DOCTYPE mapper PUBLIC \u0026#34;-//mybatis.org//DTD Mapper 3.0//EN\u0026#34; \u0026#34;http://mybatis.org/dtd/mybatis-3-mapper.dtd\u0026#34;\u0026gt; \u0026lt;mapper namespace=\u0026#34;com.showguan.mapper.EmpMapper\u0026#34;\u0026gt; \u0026lt;select id=\u0026#34;list\u0026#34; resultType=\u0026#34;com.showguan.pojo.Emp\u0026#34;\u0026gt; select * from emp where name like concat(\u0026#39;%\u0026#39;, \u0026#39;张\u0026#39;, \u0026#39;%\u0026#39;) and gender = 1 and entrydate between \u0026#39;2000-01-01\u0026#39; and \u0026#39;2030-01-01\u0026#39; order by update_time; \u0026lt;/select\u0026gt; \u0026lt;/mapper\u0026gt; Mybatis动态SQL 查询\u0026lt;if\u0026gt; \u0026lt;where\u0026gt;(可以删除多余的and和or)\n\u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;UTF-8\u0026#34; ?\u0026gt; \u0026lt;!DOCTYPE mapper PUBLIC \u0026#34;-//mybatis.org//DTD Mapper 3.0//EN\u0026#34; \u0026#34;http://mybatis.org/dtd/mybatis-3-mapper.dtd\u0026#34;\u0026gt; \u0026lt;mapper namespace=\u0026#34;com.showguan.mapper.EmpMapper\u0026#34;\u0026gt; \u0026lt;select id=\u0026#34;list\u0026#34; resultType=\u0026#34;com.showguan.pojo.Emp\u0026#34;\u0026gt; select * from emp \u0026lt;where\u0026gt; \u0026lt;if test=\u0026#34;name != null\u0026#34;\u0026gt; name like concat(\u0026#39;%\u0026#39;, \u0026#39;张\u0026#39;, \u0026#39;%\u0026#39;) \u0026lt;/if\u0026gt; \u0026lt;if test=\u0026#34;gender != null\u0026#34;\u0026gt; and gender = 1 \u0026lt;/if\u0026gt; \u0026lt;if test=\u0026#34;begin != null and end != null\u0026#34;\u0026gt; and entrydate between \u0026#39;2000-01-01\u0026#39; and \u0026#39;2030-01-01\u0026#39; \u0026lt;/if\u0026gt; \u0026lt;/where\u0026gt; order by update_time desc; \u0026lt;/select\u0026gt; \u0026lt;/mapper\u0026gt; 更新\u0026lt;set\u0026gt;（可以删除多余的,）\n\u0026lt;update id=\u0026#34;update2\u0026#34;\u0026gt; update emp \u0026lt;set\u0026gt; \u0026lt;if test=\u0026#34;username != null\u0026#34;\u0026gt; username = #{username}, \u0026lt;/if\u0026gt; \u0026lt;if test=\u0026#34;password != null\u0026#34;\u0026gt; password = #{password}, \u0026lt;/if\u0026gt; \u0026lt;if test=\u0026#34;name != null\u0026#34;\u0026gt; name = #{name}, \u0026lt;/if\u0026gt; \u0026lt;if test=\u0026#34;gender != null\u0026#34;\u0026gt; gender = #{gender}, \u0026lt;/if\u0026gt; \u0026lt;if test=\u0026#34;image != null\u0026#34;\u0026gt; image = #{image}, \u0026lt;/if\u0026gt; \u0026lt;if test=\u0026#34;job != null\u0026#34;\u0026gt; job = #{job}, \u0026lt;/if\u0026gt; \u0026lt;if test=\u0026#34;deptId != null\u0026#34;\u0026gt; dept_id = #{deptId}, \u0026lt;/if\u0026gt; \u0026lt;if test=\u0026#34;createTime != null\u0026#34;\u0026gt; create_time = #{createTime}, \u0026lt;/if\u0026gt; \u0026lt;if test=\u0026#34;updateTime != null\u0026#34;\u0026gt; update_time = #{updateTime} \u0026lt;/if\u0026gt; \u0026lt;/set\u0026gt; where id = #{id}; \u0026lt;/update\u0026gt; \u0026lt;foreach\u0026gt;\n\u0026lt;delete id=\u0026#34;deleteByIds\u0026#34;\u0026gt; delete from emp where id in \u0026lt;foreach collection=\u0026#34;ids\u0026#34; item=\u0026#34;id\u0026#34; separator=\u0026#34;,\u0026#34; open=\u0026#34;(\u0026#34; close=\u0026#34;)\u0026#34;\u0026gt; #{id} \u0026lt;/foreach\u0026gt;; \u0026lt;/delete\u0026gt; 开发规范-Restful\nREST(REPresentational State Transfer), 表述性状态转换， 它是一种软件架构风格 注意事项：\nREST是风格， 是约定方式，约定不是规定，可以打破 描述模块的功能通常使用复数， 也就是加s的格式来描述，表示此类资源，而非单个资源。如：users, emps, books, 接口开发流程 明确需求 接口文档 思路分析 接口开发\n接口测试 postman测试 前后端联调\n日志小技巧 使用logback记录日志\n@Slf4j // 接口 @RestController 查询部门 /** * 查询部分数据 * @return */ // @RequestMapping(value = \u0026#34;/depts\u0026#34;, method = RequestMethod.GET) @GetMapping(\u0026#34;/depts\u0026#34;) public Result list(){ log.info(\u0026#34;查询全部\u0026#34;); List\u0026lt;Dept\u0026gt; deptList = deptService.list(); return Result.success(deptList); } 删除部门 /** * 删除部门数据 */ @DeleteMapping(\u0026#34;/depts/{id}\u0026#34;) public Result delete(@PathVariable Integer id){ log.info(\u0026#34;根据id删除部分：{}\u0026#34;, id); deptService.delete(id); return Result.success(); } 员工查询 易错点：\n一定要加@AutoWired\nPostMan请求，从第一页开始，如果是第0则返回的是查询的数量\n@Autowired private EmpMapper empMapper; // @Override // public PageBean page(Integer page, Integer pageSize) { // Long count = empMapper.count(); // // Integer start = (page - 1) * pageSize; // List\u0026lt;Emp\u0026gt; empList = empMapper.page(start, pageSize); // PageBean pageBean = new PageBean(count, empList); // return pageBean; // } @Override public PageBean page(Integer page, Integer pageSize,String name, Short gender,LocalDate begin,LocalDate end) { //1. 设置分页参数 PageHelper.startPage(page,pageSize); //2. 执行查询 List\u0026lt;Emp\u0026gt; empList = empMapper.list(name, gender, begin, end); Page\u0026lt;Emp\u0026gt; p = (Page\u0026lt;Emp\u0026gt;) empList; //3. 封装PageBean对象 PageBean pageBean = new PageBean(p.getTotal(), p.getResult()); return pageBean; } @Override public void delete(List\u0026lt;Integer\u0026gt; ids) { empMapper.delete(ids); } @Override public void save(Emp emp) { emp.setCreateTime(LocalDateTime.now()); emp.setUpdateTime(LocalDateTime.now()); empMapper.insert(emp); } /** * 根据id查询员工 * @param id * @return */ @Override public Emp getById(Integer id) { Emp emp = empMapper.getById(id); return emp; } @Override public void modify(Emp emp) { emp.setUpdateTime(LocalDateTime.now()); empMapper.modify(emp); } PageHelper 分页查询时使用PageHelper\n\u0026lt;!-- PageHelper依赖--\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;com.github.pagehelper\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;pagehelper-spring-boot-starter\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;1.4.7\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; 文件上传 前端：\n必须要一个表单项type=\u0026quot;file\u0026quot; 必须是POST请求 method=\u0026quot;post\u0026quot; 编码格式enctype=\u0026quot;multipart/form-data\u0026quot; \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html lang=\u0026#34;en\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;UTF-8\u0026#34;\u0026gt; \u0026lt;title\u0026gt;上传文件\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;form action=\u0026#34;/upload\u0026#34; method=\u0026#34;post\u0026#34; enctype=\u0026#34;multipart/form-data\u0026#34;\u0026gt; 姓名: \u0026lt;input type=\u0026#34;text\u0026#34; name=\u0026#34;username\u0026#34;\u0026gt;\u0026lt;br\u0026gt; 年龄: \u0026lt;input type=\u0026#34;text\u0026#34; name=\u0026#34;age\u0026#34;\u0026gt;\u0026lt;br\u0026gt; 头像: \u0026lt;input type=\u0026#34;file\u0026#34; name=\u0026#34;image\u0026#34;\u0026gt;\u0026lt;br\u0026gt; \u0026lt;input type=\u0026#34;submit\u0026#34; value=\u0026#34;提交\u0026#34;\u0026gt; \u0026lt;/form\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; 阿里云OSS 阿里云对象存储OSS（Object Storage Service）\n在utils文件夹内编写 AliOSSUtils\npackage com.showguan.utils; import com.aliyun.oss.OSS; import com.aliyun.oss.OSSClientBuilder; import org.springframework.beans.factory.annotation.Value; import org.springframework.stereotype.Component; import org.springframework.web.multipart.MultipartFile; import java.io.*; import java.util.UUID; /** * 阿里云 OSS 工具类 */ @Component public class AliOSSUtils { @Value(\u0026#34;${aiyun.oss.endpoint}\u0026#34;) private String endpoint; @Value(\u0026#34;${aiyun.oss.accessKeyId}\u0026#34;) private String accessKeyId ; @Value(\u0026#34;${aiyun.oss.accessKeySecret}\u0026#34;) private String accessKeySecret; @Value(\u0026#34;${aiyun.oss.bucketName}\u0026#34;) private String bucketName; /** * 实现上传图片到OSS */ public String upload(MultipartFile file) throws IOException { // 获取上传的文件的输入流 InputStream inputStream = file.getInputStream(); // 避免文件覆盖 String originalFilename = file.getOriginalFilename(); String fileName = UUID.randomUUID().toString() + originalFilename.substring(originalFilename.lastIndexOf(\u0026#34;.\u0026#34;)); //上传文件到 OSS OSS ossClient = new OSSClientBuilder().build(endpoint, accessKeyId, accessKeySecret); ossClient.putObject(bucketName, fileName, inputStream); //文件访问路径 String url = endpoint.split(\u0026#34;//\u0026#34;)[0] + \u0026#34;//\u0026#34; + bucketName + \u0026#34;.\u0026#34; + endpoint.split(\u0026#34;//\u0026#34;)[1] + \u0026#34;/\u0026#34; + fileName; // 关闭ossClient ossClient.shutdown(); return url;// 把上传到oss的路径返回 } } 配置文件均配置到properties文件中， 而在AliOSSUtils中用@Value注入\n配置文件 SpringBoot提供了多种属性配置方式\napplication.properties\nserver.port=8080 server.address=127.0.0.1 yml/yaml 简洁，数据为中心\nserver: port: 8080 address: 127.0.0.1 基本语法\n大小写敏感 数值前必须有空格，作为分隔符 使用缩进表示层级关系，缩进时，不允许使用tab键，只能用空格（idea会自动将Tab转换为空格） 空格的数目不重要，只要相同层级的元素左侧对齐即可 # 表示注释， 从这个字符一直到结尾，都会被解释器忽略。 @ConfigurationProperties 在utils中新建文件AliOSSUtilsProperties.java， 编写下面的程序\n@Data @Component @ConfigurationProperties(prefix = \u0026#34;aliyun.oss\u0026#34;) public class AliOSSUtilsProperties { private String endpoint; private String accessKeyId; private String accessKeySecret; private String bucketName; } 在AliOssutils.java中只需要编写下面的程序即可\n@Autowired private AliOSSUtilsProperties aliOSSUtilsProperties; /** * 实现上传图片到OSS */ String endpoint = aliOSSUtilsProperties.getEndpoint(); String accessKeyId = aliOSSUtilsProperties.getAccessKeyId(); String accessKeySecret = aliOSSUtilsProperties.getAccessKeySecret(); String bucketName = aliOSSUtilsProperties.getBucketName(); 和@Value对比\n相同点 都是用来注入外部配置的属性的 不同点 @Value注解只能一个一个的进行外部属性的注入。 @ConfigurationProperties可以批量的将外部的属性配置注入到bean对象的属性中。 统一拦截 会话技术 会话：用户打开浏览器，访问web服务器的资源，会话建立，知道有一方断开连接，会话结束，在一次会话中可以包含多次请求和响应\n会话跟踪：一种维护浏览器状态的方法，服务器需要识别多次请求是否来自于同一浏览器，以便在同一次会话的多次请求间共享数据\n会话跟踪技术方案：\n客户端会话跟踪技术：Cookie 服务端会话跟踪技术：Session 令牌技术 Cookie 优点：\nHTTP协议中支持的技术 缺点：\n移动端APP无法使用Cookie 不安全， 用户可以自己禁用Cookie Cookie不能跨域 跨域区分三个维度：协议，IP/域名，端口 @GetMapping(\u0026#34;/cookie1\u0026#34;) public Result cookie1(HttpServletResponse response){ response.addCookie(new Cookie(\u0026#34;login_username\u0026#34;, \u0026#34;Kennem\u0026#34;)); return Result.success(); } @GetMapping(\u0026#34;/cookie2\u0026#34;) public Result cookie2(HttpServletRequest request){ Cookie[] cookies = request.getCookies(); for(Cookie cookie : cookies){ if(cookie.getName().equals(\u0026#34;login_username\u0026#34;)){ System.out.println(\u0026#34;login_username: \u0026#34; + cookie.getValue()); } } return Result.success(); } Session 优点：\n存储在服务端，安全 服务器集群环境下无法直接使用Session Cookie的缺点 @GetMapping(\u0026#34;/session1\u0026#34;) public Result session1(HttpSession httpSession){ log.info(\u0026#34;HttpSession-s1 {}\u0026#34;, httpSession.hashCode()); httpSession.setAttribute(\u0026#34;loginUser\u0026#34;, \u0026#34;Kennem\u0026#34;); return Result.success(); } @GetMapping(\u0026#34;/session2\u0026#34;) public Result session2(HttpServletRequest request){ HttpSession session = request.getSession(); log.info(\u0026#34;HttpSession-s2 {}\u0026#34;, session.hashCode()); Object loginUser = session.getAttribute(\u0026#34;loginUser\u0026#34;); log.info(\u0026#34;loginUser {}\u0026#34;, loginUser); return Result.success(loginUser); } 令牌技术 优点：\n支持PC端，移动端 解决集群环境下的认证问题 减轻服务端存储压力 缺点：\n需要自己实现 JWT JSON Web Token 定义了一种简洁的，自包含的格式，用于在通信双方以json数据格式安全的传输信息。由于数字签名的存在，这些信息时可靠的。 组成： 第一部分：Header（头），记录令牌类型，签名算法等。例如：{\u0026ldquo;alg\u0026rdquo;:\u0026ldquo;HS256\u0026rdquo;, \u0026ldquo;\u0026rdquo;} 第二部分：Payload（有效载荷），携带一些自定义信息，默认信息等。例如：{‘\u0026ldquo;id\u0026rdquo;:\u0026ldquo;1\u0026rdquo;, \u0026ldquo;username\u0026rdquo;:\u0026ldquo;Tom\u0026rdquo;} 第三部分：Signature（签名），放置Token被篡改，确保安全性。将header，payload, 并加入指定密钥，同过指定签名算法而来。 Base64：是一种基于64个可打印字符（A-Z, a-z, 0-9, + /)来表示二进制数据的编码方式\n场景：登录认证 登录成功后，生成令牌 后续的每个请求，都要携带JWT令牌，系统在每次请求处理之前，先校验灵摆，通过后，再处理。 @Test public void testGenJwt(){ Map\u0026lt;String, Object\u0026gt; claims = new HashMap\u0026lt;\u0026gt;(); claims.put(\u0026#34;id\u0026#34;, 1); claims.put(\u0026#34;name\u0026#34;, 2); claims.put(\u0026#34;company\u0026#34;, \u0026#34;xiaomi\u0026#34;); String jwt = Jwts.builder() .signWith(SignatureAlgorithm.HS256, \u0026#34;Kennem\u0026#34;) .setClaims(claims) .setExpiration(new Date(System.currentTimeMillis())) // 设置有效期为一个小时 .compact(); System.out.println(jwt); } @Test public void parseJwt(){ Claims claims = Jwts.parser() .setSigningKey(\u0026#34;Kennem\u0026#34;) .parseClaimsJws(\u0026#34;eyJhbGciOiJIUzI1NiJ9.eyJuYW1lIjoyLCJjb21wYW55IjoieGlhb21pIiwiaWQiOjEsImV4cCI6MTcxODAwMzMwM30.raK4huIfzd9RY0T3U2a9DGsxHFYLRGYbzTrbqXJabaA\u0026#34;) .getBody(); System.out.println(claims); } 注意事项：\nJWT校验时使用的签名密钥，必须和生成JWT令牌时使用的密钥时配套的。 如果JWT令牌解析校验时报错，则说明JWT令牌被篡改或失效了，令牌非法。 过滤器Filter Filter过滤器，时Java web三大组件（Servlet, Filter, Listener）之一 过滤器可以把对资源的请求拦截下来，从而实现一些特殊的功能 过滤器一般完成一些通用的操作，比如：登录校验、统一编码处理，敏感字符处理等。 //@WebFilter(urlPatterns = \u0026#34;/*\u0026#34;) //@WebFilter(urlPatterns = \u0026#34;/login\u0026#34;) @WebFilter(urlPatterns = \u0026#34;/depts/*\u0026#34;) public class DemoFilter implements Filter { @Override public void init(FilterConfig filterConfig) throws ServletException { System.out.println(\u0026#34;Init!\u0026#34;); } @Override public void doFilter(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain chain) throws IOException, ServletException { System.out.println(\u0026#34;Do Fileter!\u0026#34;); chain.doFilter(servletRequest, servletResponse); } @Override public void destroy() { System.out.println(\u0026#34;Destroy!\u0026#34;); } } 执行流程：\n请求 -\u0026gt; 放行前逻辑 -\u0026gt;放行 -\u0026gt;资源 -\u0026gt;放行后逻辑 过滤器链 一个Web应用中，可以配置多个过滤器，这多个过滤器形成一个过滤器链\n顺序：注解配置的Filter，优先级时按照过滤器类名（字符串）的自然排序(字典序)\n登录校验 @Slf4j @WebFilter(urlPatterns = \u0026#34;/*\u0026#34;) public class LoginCheckFilter implements Filter { @Override public void doFilter(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain filterChain) throws IOException, ServletException { HttpServletRequest req = (HttpServletRequest) servletRequest; HttpServletResponse resp = (HttpServletResponse) servletResponse; String url = req.getRequestURI().toString(); log.info(\u0026#34;请求的url {}\u0026#34;, url); if(url.contains(\u0026#34;login\u0026#34;)){ log.info(\u0026#34;登录操作， 放行...\u0026#34;); filterChain.doFilter(servletRequest, servletResponse); return; } String jwt = req.getHeader(\u0026#34;token\u0026#34;); if(!StringUtils.hasLength(jwt)){ log.info(\u0026#34;请求头token为空， 返回未登录的信息\u0026#34;); Result error = Result.error(\u0026#34;NOT_LOGIN\u0026#34;); String notLogin = JSONObject.toJSONString(error); resp.getWriter().write(notLogin); return ; } try{ JwtUtils.parseJWT(jwt); }catch (Exception e){ e.printStackTrace(); log.info(\u0026#34;解析令牌失败，返回未登录错误信息\u0026#34;); Result error = Result.error(\u0026#34;NOT_LOGIN\u0026#34;); // 前端收到NOT_LOGIN 会返回到登录界面 String notLogin = JSONObject.toJSONString(error); resp.getWriter().write(notLogin); return ; } log.info(\u0026#34;成功登录\u0026#34;); filterChain.doFilter(servletRequest, servletResponse); } } 拦截器 Interceptor Spring 提供的， 只能拦截Spring环境中的资源\n用来动态拦截控制器方法的执行\n拦截请求，再指定的方法调用前后，根据业务需要执行预先设定的代码 /* 表示一级路径\n/** 表示任意级别的路径\n配置需要拦截的路径和不需要拦截的路径\n@Override public void addInterceptors(InterceptorRegistry registry) { registry.addInterceptor(loginCheckinterceptor).addPathPatterns(\u0026#34;/**\u0026#34;).excludePathPatterns(\u0026#34;/login\u0026#34;); } Filter 和 Interceptor\n接口规范不同：过滤器需要实现Filter接口，而拦截器需要实现HandlerInterceptor接口 拦截范围不同：过滤器Filter会拦截所有的资源，而Interceptor只会拦截Spring环境中的资源。 @Override // 目标资源方法运行前运行， true:放行 false:不放行 public boolean preHandle(HttpServletRequest req, HttpServletResponse resp, Object handler) throws Exception { String url = req.getRequestURI().toString(); log.info(\u0026#34;请求的url {}\u0026#34;, url); if(url.contains(\u0026#34;login\u0026#34;)){ log.info(\u0026#34;登录操作， 放行...\u0026#34;); return true; } String jwt = req.getHeader(\u0026#34;token\u0026#34;); if(!StringUtils.hasLength(jwt)){ log.info(\u0026#34;请求头token为空， 返回未登录的信息\u0026#34;); Result error = Result.error(\u0026#34;NOT_LOGIN\u0026#34;); String notLogin = JSONObject.toJSONString(error); resp.getWriter().write(notLogin); return false; } try{ JwtUtils.parseJWT(jwt); }catch (Exception e){ e.printStackTrace(); log.info(\u0026#34;解析令牌失败，返回未登录错误信息\u0026#34;); Result error = Result.error(\u0026#34;NOT_LOGIN\u0026#34;); // 前端收到NOT_LOGIN 会返回到登录界面 String notLogin = JSONObject.toJSONString(error); resp.getWriter().write(notLogin); return false; } log.info(\u0026#34;成功登录\u0026#34;); return true; } @Override // 目标资源方法运行后运行 public void postHandle(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView) throws Exception { System.out.println(\u0026#34;postHandle ...\u0026#34;); } @Override // 视图渲染完毕后运行，最后运行 public void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex) throws Exception { System.out.println(\u0026#34;afterCompletion ...\u0026#34;); } 异常处理 全局异常处理器\nexception/GlobalExceptionHandler\n/** * 全局异常处理器 */ @RestControllerAdvice public class GlobalExceptionHandler{ @ExceptionHandler(Exception.class) public Result ex(Exception ex){ ex.printStackTrace(); return Result.error(\u0026#34;操作错误！可能的原因：名称重复\u0026#34;); } } ","permalink":"https://kennems.github.io/zh/posts/tech/java-web%E5%BC%80%E5%8F%915/","summary":"Java Web开发(5) MyBatis MyBatis是一款优秀的持久层框架，用于简化JDBC的开发。 使用Mybatis查询所有用户数据 创建SpringBoot","title":"Java Web开发(5)"},{"content":"双周赛131(240525) AK的第二场😝， 第四题是用C++ 找网上模板，套用查找最长的连0串过的， 最后两分钟才过，很惊险。赛后发现做法并不优秀，但是不需要平衡树。\n3161. 物块放置查询 题目大意：\n有一条无限长的数轴，原点在 0 处，沿着 x 轴正方向无限延伸。给定一个二维数组 queries 包含两种操作：\n操作类型 1：在距离原点 x 处建一个障碍物。 操作类型 2：判断在数轴范围 [0, x] 内是否可以放置一个长度为 sz 的物块，该物块需要完全放置在范围 [0, x] 内。如果物块与任何障碍物有重合，则该物块不能被放置，但物块可以与障碍物刚好接触。 对于操作类型 2 的查询，若可以放置物块，则返回 true，否则返回 false。\n实现思路：\n线段树的构建和维护：\n使用一个数组 tr 来表示线段树，初始化为全零。数组的长度可以通过查询中的最大范围确定，即 m = max(q[1] for q in queries)。 定义 pushup 函数用于更新线段树中的节点信息，每当修改线段树中某个节点的值时调用。 定义 modify 函数用于修改线段树中的值，将某个位置的值更新为新值，并根据需要递归更新父节点的信息。 定义 query 函数用于查询线段树中某个区间内的最大值。 Sorted List 的维护：\n使用 SortedList 结构来维护障碍物的位置信息，SortedSet 是一个有序的集合数据结构。 在操作类型 1 中，即添加障碍物时，使用 bisect_left 找到应该插入的位置，并在相应的位置插入新的障碍物位置，并更新线段树的信息。 查询操作类型 2：\n对于每一个操作类型 2 的查询，先找到该位置之前最近的障碍物的位置 pre，然后通过线段树查询该区间内的最大值。 如果该值大于等于所需放置物块的大小，则说明可以放置物块，否则不行。 from sortedcontainers import SortedList class Solution: def getResults(self, queries: List[List[int]]) -\u0026gt; List[bool]: m = max(q[1] for q in queries) tr = [0]*(1\u0026lt;\u0026lt;m.bit_length() + 1) def pushup(u): tr[u] = max(tr[u\u0026lt;\u0026lt;1], tr[u\u0026lt;\u0026lt;1|1]) def modify(u, l, r, x, val): if l==r: tr[u] = val else: mid = l+r\u0026gt;\u0026gt;1 if x\u0026lt;=mid: modify(u\u0026lt;\u0026lt;1, l, mid, x, val) else: modify(u\u0026lt;\u0026lt;1|1, mid+1, r, x, val) pushup(u) def query(u, l, r, ql, qr): if ql\u0026lt;=l and r\u0026lt;=qr: return tr[u] mid = l+r\u0026gt;\u0026gt;1 res = 0 if ql\u0026lt;=mid: res = query(u\u0026lt;\u0026lt;1, l, mid, ql, qr) if qr\u0026gt;mid: res = max(res, query(u\u0026lt;\u0026lt;1|1, mid+1, r, ql, qr)) return res sl = SortedList([0, m]) res = [] for q in queries: x = q[1] i = sl.bisect_left(x) pre = sl[i-1] if q[0]==1: nxt = sl[i] sl.add(x) modify(1, 0, m, x, x-pre) modify(1, 0, m, nxt, nxt-x) else: sz = q[2] ans = max(x-pre, query(1, 0, m, 0, pre)) res.append(ans \u0026gt;= sz) return res 比赛时的做法，本来是C++，转成了python\nclass Node: def __init__(self): self.l = 0 self.r = 0 self.d = 0 self.ld = 0 self.rd = 0 self.low = -1 class Solution: def getResults(self, queries): def build(u, l, r): tr[u].l = l tr[u].r = r tr[u].d = r - l + 1 tr[u].ld = r - l + 1 tr[u].rd = r - l + 1 tr[u].low = -1 if l != r: mid = (l + r) \u0026gt;\u0026gt; 1 build(u \u0026lt;\u0026lt; 1, l, mid) build(u \u0026lt;\u0026lt; 1 | 1, mid + 1, r) def pushup(u): tr[u].ld = tr[u \u0026lt;\u0026lt; 1].ld if tr[u \u0026lt;\u0026lt; 1].ld == tr[u \u0026lt;\u0026lt; 1].r - tr[u \u0026lt;\u0026lt; 1].l + 1: tr[u].ld += tr[u \u0026lt;\u0026lt; 1 | 1].ld tr[u].rd = tr[u \u0026lt;\u0026lt; 1 | 1].rd if tr[u \u0026lt;\u0026lt; 1 | 1].rd == tr[u \u0026lt;\u0026lt; 1 | 1].r - tr[u \u0026lt;\u0026lt; 1 | 1].l + 1: tr[u].rd += tr[u \u0026lt;\u0026lt; 1].rd tr[u].d = max(max(tr[u \u0026lt;\u0026lt; 1].d, tr[u \u0026lt;\u0026lt; 1 | 1].d), tr[u \u0026lt;\u0026lt; 1].rd + tr[u \u0026lt;\u0026lt; 1 | 1].ld) def pushdown(u): if tr[u].low == -1: return tr[u \u0026lt;\u0026lt; 1].low = tr[u \u0026lt;\u0026lt; 1 | 1].low = tr[u].low if tr[u].low: tr[u \u0026lt;\u0026lt; 1].d = tr[u \u0026lt;\u0026lt; 1].ld = tr[u \u0026lt;\u0026lt; 1].rd = 0 tr[u \u0026lt;\u0026lt; 1 | 1].d = tr[u \u0026lt;\u0026lt; 1 | 1].ld = tr[u \u0026lt;\u0026lt; 1 | 1].rd = 0 else: tr[u \u0026lt;\u0026lt; 1].d = tr[u \u0026lt;\u0026lt; 1].ld = tr[u \u0026lt;\u0026lt; 1].rd = tr[u \u0026lt;\u0026lt; 1].r - tr[u \u0026lt;\u0026lt; 1].l + 1 tr[u \u0026lt;\u0026lt; 1 | 1].d = tr[u \u0026lt;\u0026lt; 1 | 1].ld = tr[u \u0026lt;\u0026lt; 1 | 1].rd = tr[u \u0026lt;\u0026lt; 1 | 1].r - tr[u \u0026lt;\u0026lt; 1 | 1].l + 1 tr[u].low = -1 def query(u, ql, qr): if tr[u].l \u0026gt; qr or tr[u].r \u0026lt; ql: return 0 if tr[u].l \u0026gt;= ql and tr[u].r \u0026lt;= qr: return tr[u].d pushdown(u) mid = (tr[u].l + tr[u].r) \u0026gt;\u0026gt; 1 res = 0 if ql \u0026lt;= mid: res = max(res, query(u \u0026lt;\u0026lt; 1, ql, qr)) if qr \u0026gt; mid: res = max(res, query(u \u0026lt;\u0026lt; 1 | 1, ql, qr)) # Cross left and right subintervals handling if ql \u0026lt;= mid and qr \u0026gt; mid: left_suffix = min(tr[u \u0026lt;\u0026lt; 1].rd, mid - ql + 1) right_prefix = min(tr[u \u0026lt;\u0026lt; 1 | 1].ld, qr - mid) res = max(res, left_suffix + right_prefix) return res def modify(u, l, r, d): if tr[u].l \u0026gt;= l and tr[u].r \u0026lt;= r: if d: tr[u].d = tr[u].ld = tr[u].rd = 0 tr[u].low = 1 else: tr[u].d = tr[u].ld = tr[u].rd = tr[u].r - tr[u].l + 1 tr[u].low = 0 return pushdown(u) mid = (tr[u].l + tr[u].r) \u0026gt;\u0026gt; 1 if l \u0026lt;= mid: modify(u \u0026lt;\u0026lt; 1, l, r, d) if r \u0026gt; mid: modify(u \u0026lt;\u0026lt; 1 | 1, l, r, d) pushup(u) n = max(q[1] for q in queries) tr = [Node() for _ in range(1\u0026lt;\u0026lt;n.bit_length() + 1)] build(1, 0, n) res = [] modify(1, 0, 0, 1) mp = {} for q in queries: if q[0] == 1: x = q[1] modify(1, x, x, 1) mp[x] = 1 else: x = q[1] sz = q[2] if x \u0026lt; sz: res.append(False) continue if mp.get(x) != 1: modify(1, x, x, 1) ans = query(1, 0, x) if mp.get(x) != 1: modify(1, x, x, 0) res.append(ans \u0026gt;= sz-1) return res ","permalink":"https://kennems.github.io/zh/posts/tech/%E5%8F%8C%E5%91%A8%E8%B5%9B131240525/","summary":"双周赛131(240525) AK的第二场😝， 第四题是用C++ 找网上模板，套用查找最长的连0串过的， 最后两分钟才过，很惊险。赛后发现做法并不优","title":"LeetCode双周赛131(240525)"},{"content":"周赛399(240526) 这场掉分了，第四题没思路，而且罚时太多了😥\n第三题3164. 优质数对的总数 II 题目大意： 给定两个整数数组nums1和nums2，以及一个正整数k。如果nums1[i]可以被nums2[j]*k整除，则称数对(i, j)为优质数对。要求计算优质数对的总数。\n实现思路：\n首先，使用Counter统计nums1中可以被k整除的数除以k的结果，得到c1。 然后，找到c1中的最大值mx，如果c1为空，则mx为0。 使用Counter统计nums2中各个数出现的次数，得到c2。 初始化结果res为0。 遍历c2中的每个数nm和其出现的次数c，对于每个数nm，从nm开始递增到mx，步长为nm，计算c * c1[j]并累加到res中。 最终返回res作为优质数对的总数。 class Solution: def numberOfPairs(self, nums1: List[int], nums2: List[int], k: int) -\u0026gt; int: c1 = Counter(nm//k for nm in nums1 if nm%k==0) mx = max(nm for nm, _ in c1.items()) if c1 else 0 c2 = Counter(nums2) res = 0 for nm, c in c2.items(): for j in range(nm, mx+1, nm): res += c * c1[j] return res 第四题3165. 不包含相邻元素的子序列的最大和 题目大意 给定一个整数数组 nums 和一个二维数组 queries，其中 queries[i] = [posi, xi] 表示对于每个查询 i，首先将 nums[posi] 设置为 xi，然后计算查询 i 的答案。答案为 nums 中不包含相邻元素的子序列的最大和。最终返回所有查询的答案之和。\n实现思路 构建线段树：使用线段树维护区间的最大和。 线段树节点 tr[u] 存储了四个值，分别表示： 不跨越区间的最大和（无相邻元素）。 区间左端点为起点的最大和（无相邻元素）。 区间右端点为起点的最大和（无相邻元素）。 区间的最大和。 定义 pushup 函数更新节点值，定义 build 函数构建线段树。 更新操作：更新线段树中的节点值。 定义 update 函数更新线段树中的节点值。 遍历查询：对每个查询，更新 nums 中对应位置的值，并计算当前的最大和。 最终返回所有查询的答案之和，记得对结果取模。 class Solution: def maximumSumSubsequence(self, nums: List[int], queries: List[List[int]]) -\u0026gt; int: def pushup(u): l, r = tr[u\u0026lt;\u0026lt;1], tr[u\u0026lt;\u0026lt;1|1] tr[u][0] = max(l[1]+r[0], l[0]+r[2]) tr[u][1] = max(l[0]+r[3], l[1]+r[1]) tr[u][2] = max(l[2]+r[2], l[3]+r[0]) tr[u][3] = max(l[2]+r[3], l[3]+r[1]) def build(u, l, r): if l==r: tr[u][3] = max(nums[l], 0) else: mid = l+r\u0026gt;\u0026gt;1 build(u\u0026lt;\u0026lt;1, l, mid) build(u\u0026lt;\u0026lt;1|1, mid+1, r) pushup(u) def update(u, l, r, x, val): if l==r: tr[u][3] = max(0, val) return mid = l+r\u0026gt;\u0026gt;1 if x\u0026lt;=mid: update(u\u0026lt;\u0026lt;1, l, mid, x, val) else: update(u\u0026lt;\u0026lt;1|1, mid+1, r, x, val) pushup(u) n = len(nums) tr = [[0]*4 for _ in range(1\u0026lt;\u0026lt;n.bit_length() + 1)] mod = int(1e9) + 7 res = 0 build(1, 0, n-1) for pos, x in queries: update(1, 0, n-1, pos, x) res = (res + tr[1][3])%mod return res ","permalink":"https://kennems.github.io/zh/posts/tech/%E5%91%A8%E8%B5%9B399240526/","summary":"周赛399(240526) 这场掉分了，第四题没思路，而且罚时太多了😥 第三题3164. 优质数对的总数 II 题目大意： 给定两个整数数组nums1和n","title":"LeetCode周赛399(240526)"},{"content":"周赛250519 终于终于AK了一场😆\n第四题100298. 到达第 K 级台阶的方案数 题目大意\n给定一个非负整数 k，表示目标台阶的编号。虎老师从台阶 1 开始，通过一系列操作到达台阶 k。操作分为两种：\n向下走一级到 i - 1，但该操作不能连续使用，如果在台阶 0 也不能使用。 向上走到台阶 i + 2^jump 处，然后 jump 变为 jump + 1。 目标是计算虎老师到达台阶 k 的总方案数。\n实现思路\n定义递归函数：定义一个递归函数 dfs(p, j, f)，其中 p 表示当前所在的台阶，j 表示当前 jump 的次数，f 表示上一次操作是否是向下走一级的标志。 递归终止条件： 当 p == k 时，表示已经到达目标台阶，返回 1 表示找到一种方案。 当 p \u0026lt; 0 时，表示超出范围，返回 0。 当 p - 1 \u0026gt; k 或者 p - 1 == k 且 f == 1 时，表示向下走超过目标或在目标时无法向下走，返回 0。 递归计算： up：计算向上走到 p + 2^j 的方案数，并将 j 加 1，表示使用了一次向上跳跃。 down：计算向下走到 p - 1 的方案数，当 p \u0026gt; 0 且 f == 0 时才可以向下走。 返回 up + down + more 的和，其中 more 表示当前正好在目标台阶的情况。 记忆化搜索：使用 @cache 修饰递归函数，避免重复计算。 class Solution: def waysToReachStair(self, k: int) -\u0026gt; int: @cache def dfs(p, j, f): # flag 1: 上一次是下移， 0：上一次不是 more = 0 if p == k: more = 1 if p \u0026lt; 0: return 0 if p-1\u0026gt;k or (p-1==k and f==1): return 0 up = dfs(p + (1 \u0026lt;\u0026lt; j), j + 1, 0) if p \u0026gt; 0 and f==0: down = dfs(p - 1, j, 1) else: down = 0 return up + down + more return dfs(1, 0, 0) ","permalink":"https://kennems.github.io/zh/posts/tech/%E5%91%A8%E8%B5%9B250519/","summary":"周赛250519 终于终于AK了一场😆 第四题100298. 到达第 K 级台阶的方案数 题目大意 给定一个非负整数 k，表示目标台阶的编号。虎老师从台阶 1","title":"LeetCode周赛398(240519)"},{"content":"周赛20240505 第四题 100288. 使数组中所有元素相等的最小开销 题目大意：给定一个整数数组 nums 和两个整数 cost1 和 cost2，可以执行两种操作来使数组中所有元素相等：1. 选择某个元素增加1，开销为cost1；2. 选择两个不同的元素同时增加1，开销为cost2。目标是使数组中所有元素相等，返回需要的最小开销之和。\n实现思路：首先计算数组中最大值mx和最小值mn，然后计算基础开销base，即将最大值变为最小值所需的开销。然后根据两种操作的开销比较，若cost1*2 \u0026lt;= cost2，则只需考虑将最大值变为最小值的开销，直接返回即可。若cost1*2 \u0026gt; cost2，则需要考虑两种操作的比较，通过二分搜索找到使得总开销最小的情况。具体实现中，定义了函数f(x)，表示将最大值变为x时的总开销，然后在mx的范围内进行二分搜索找到最小总开销。\nclass Solution: def minCostToEqualizeArray(self, nums: List[int], c1: int, c2: int) -\u0026gt; int: mod = int(1e9) + 7 mx = max(nums); mn = min(nums) n = len(nums) base = mx*n - sum(nums) if c1*2 \u0026lt;= c2: return base * c1 % mod def f(x): d = x - mn s = base + (x-mx) * n if d \u0026lt;= s-d: return s//2 * c2 + s%2*c1 return (s-d) * c2 + (d-(s-d)) * c1 ans = inf if mx\u0026amp;1: ans = f(mx) mx += 1 base += n k0 = bisect_left( range(mx), True, mx//2, key = lambda m: f(m*2) \u0026lt; f((m+1)*2) ) k1 = bisect_left( range(mx), True, mx//2, key = lambda m: f(m*2+1) \u0026lt; f((m+1)*2 + 1) ) ans = min(ans, f(k0*2), f(k1*2 + 1)) return ans%mod ","permalink":"https://kennems.github.io/zh/posts/tech/%E5%91%A8%E8%B5%9B20240505/","summary":"周赛20240505 第四题 100288. 使数组中所有元素相等的最小开销 题目大意：给定一个整数数组 nums 和两个整数 cost1 和 cost2，可以执行两种操作来使数组中所","title":"LeetCode周赛396(240505)"},{"content":"LeetCode每日一题(2405) 1235. 规划兼职工作 题目大意：给定n份兼职工作，每份工作都有开始时间、结束时间和报酬。任务是选择一些工作，使得在不重叠的情况下能够获得最大报酬。\n实现思路：首先对工作按照结束时间进行排序，然后使用动态规划来求解最大报酬。在动态规划的过程中，维护一个数组f，其中f[i]表示在考虑前i个工作时可以获得的最大报酬。遍历每个工作，对于第i个工作，找到在其开始时间之前且结束时间最接近的工作j，然后更新f[i]为f[j] + 第i个工作的报酬。最终返回f[n]即为所求的最大报酬。\nclass Solution: def jobScheduling(self, startTime: List[int], endTime: List[int], profit: List[int]) -\u0026gt; int: # 兵贵神速，现在能领先一秒，以后就能按照复利一直领先 n = len(startTime) job = [(0, 0, 0)] + sorted(zip(endTime, startTime, profit)) f = [0]*(n+1) for i, (_, st, p) in enumerate(job[1:], start = 1): # l, r = 0, i-1 # while l\u0026lt;r: # mid = (l+r+1)\u0026gt;\u0026gt;1 # if job[mid][0] \u0026gt; st: # r = mid-1 # else: # l = mid # f[i] = max(f[i-1], f[l] + p) l = bisect_left(job, (st+1, ), hi = i, lo = 0) # 内置库只能查找 严格 \u0026gt; \u0026lt; 的值 # 无法找到 \u0026gt;= \u0026lt;=的值，但是可以在找到最大的 \u0026lt;目标值的 i, i-1即为\u0026lt;=目标值的下标 f[i] = max(f[i-1], f[l-1] + p) return f[n] 741. 摘樱桃 题目大意：给定一个网格，其中包含空格、樱桃和荆棘，要求从左上角到右下角，然后返回左上角，按照规定的走法，最多能摘到的樱桃数量。\n记忆化搜索 实现思路：这是一个动态规划问题。定义一个递归函数dfs(t, j, l)，表示在时刻t，第一个人位于(j, t-j)，第二个人位于(l, t-l)时，能够得到的最大樱桃数量。递归终止条件是当其中一个人走到了边界之外或者碰到了荆棘时，返回负无穷。然后递归地计算四种可能的移动方向：向下走、向右走、向下和向右走、向左走，同时更新樱桃数量。最后返回经过路径能够摘到的最多樱桃数量。\nclass Solution: def cherryPickup(self, g: List[List[int]]) -\u0026gt; int: @cache def dfs(t, j, l): if j\u0026lt;0 or l\u0026lt;0 or t-j\u0026lt;0 or t-l\u0026lt;0 or g[t-j][j]==-1 or g[t-l][l]==-1: return -inf if t==0: return g[0][0] return max(dfs(t-1, j, l), dfs(t-1, j-1, l), dfs(t-1, j, l-1), dfs(t-1, j-1, l-1)) \\ + g[t-j][j] + (g[t-l][l] if j!=l else 0) n = len(g) return max(0, dfs(2*n-2, n-1, n-1)) 递推 实现思路：\n使用动态规划来解决。定义一个三维数组 f，其中 f[t][i][j] 表示在 t 步中，第一个人位于 (i-1, t-i)、第二个人位于 (j-1, t-j) 时所能摘到的最大樱桃数。 初始条件为 f[0][1][1] = grid[0][0]，表示开始时第一个人和第二个人都在左上角，第一个格子上的樱桃数。 然后进行状态转移，对于每一步 t，遍历两个人可能的位置 (i, t-i)，(j, t-j)： 如果该位置不是荆棘，则计算能从上一步到达当前位置的最大樱桃数。状态转移方程为：f[t][i][j] = max(f[t-1][i][j], f[t-1][i-1][j], f[t-1][i][j-1], f[t-1][i-1][j-1]) + 当前格子上的樱桃数。 最后返回 f[2*n-2][n][n]，表示在返回过程中最多能摘到的樱桃数。 class Solution: def cherryPickup(self, grid: List[List[int]]) -\u0026gt; int: n = len(grid) f = [[[-inf]*(n+1) for _ in range(n+1)] for _ in range(2*n-1)] f[0][1][1] = grid[0][0] for t in range(1, 2*n-1): for j in range(max(t-n+1, 0), min(n, t+1)): if grid[t-j][j]==-1: continue for k in range(j, min(n, t+1)): if grid[t-k][k]==-1: continue f[t][j+1][k+1] = max(f[t-1][j+1][k+1], f[t-1][j][k+1], f[t-1][j+1][k], f[t-1][j][k]) \\ + grid[t-j][j] + (grid[t-k][k] if j!=k else 0) return max(0, f[2*n-2][n][n]) 463. 摘樱桃 II 题目大意：给定一个矩阵表示樱桃地，两个机器人分别从左上角和右上角出发，每个机器人只能向下一行的左下、下方和右下方移动，当机器人到达一个格子时，会摘取该格子内所有的樱桃并将其置空。两个机器人不能同时摘取同一个格子的樱桃，求两个机器人能够摘取的最大樱桃总数。\n记忆化搜索 实现思路：可以使用动态规划来解决。定义一个递归函数 dfs(i, j, k) 表示机器人1位于第i行第j列，机器人2位于第i行第k列时，能够摘取的最大樱桃总数。递归过程中，对于每个机器人，都有三种移动方式，即向下一行的左下、下方和右下方移动。递归终止条件为机器人到达最后一行。使用缓存装饰器 @cache 可以避免重复计算。最后，返回dfs(0, 0, m-1)，其中m为矩阵的列数。\nclass Solution: def cherryPickup(self, grid: List[List[int]]) -\u0026gt; int: n, m = len(grid), len(grid[0]) @cache def dfs(i, j, k): if i==n or j\u0026lt;0 or j\u0026gt;=m or k\u0026lt;0 or k\u0026gt;=m: return 0 return max(dfs(i+1, nj, nk) for nj in range(j-1, j+2) for nk in range(k-1, k+2)) \\ + grid[i][j] + (grid[i][k] if j!=k else 0) return dfs(0, 0, m-1) 递推 实现思路：使用动态规划进行解决。定义一个三维数组 f，其中 f[i][j+1][k+1] 表示机器人1位于第i行第j列，机器人2位于第i行第k列时，能够摘取的最大樱桃总数。通过三重循环，依次遍历每一行和每一列，更新 f[i][j+1][k+1] 的值，其中 i 表示当前行，j 表示机器人1的列数，k 表示机器人2的列数。在更新 f[i][j+1][k+1] 的过程中，通过遍历机器人1和机器人2的位置，计算能够摘取的最大樱桃总数。最后返回 f[0][1][m]，其中 m 为矩阵的列数。\nclass Solution: def cherryPickup(self, grid: List[List[int]]) -\u0026gt; int: n, m = len(grid), len(grid[0]) f = [[[0]*(m+2) for _ in range(m+2)] for _ in range(n+1)] for i in range(n-1, -1, -1): for j in range(min(i+1, m)): for k in range(max(j+1, m-1-i), m): t = 0 for nj in range(j, j+3): for nk in range(k, k+3): t = max(t, f[i+1][nj][nk]) f[i][j+1][k+1] = t + grid[i][j] + grid[i][k] return f[0][1][m] ","permalink":"https://kennems.github.io/zh/posts/tech/leetcode%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98202405/","summary":"LeetCode每日一题(2405) 1235. 规划兼职工作 题目大意：给定n份兼职工作，每份工作都有开始时间、结束时间和报酬。任务是选择一些工作，使得","title":"LeetCode每日一题(202405)"},{"content":"双周赛20230427 第三/四题3130. 找出所有稳定的二进制数组 II 题目大意：给定三个正整数 zero、one 和 limit，定义一个二进制数组 arr，要求满足以下条件：数组中 0 出现的次数为 zero，1 出现的次数为 one，并且数组中每个长度超过 limit 的子数组都同时包含 0 和 1。求稳定二进制数组的总数目。\n实现思路：这是一个典型的动态规划问题。我们可以使用递归函数 dfs(i, j, k) 来表示以 i 个 0 和 j 个 1 开头，并且最后一个元素为 k 的稳定二进制数组的个数。其中，k 取值为 0 或 1，表示最后一个元素为 0 或 1。递归的边界条件是当 i 或 j 为 0 时，返回 1 或 0，表示当前情况下有 1 个或 0 个稳定数组。在递归过程中，我们需要考虑当前元素添加为 0 或 1 时的情况，并且根据 limit 来控制子数组的长度，避免不稳定的情况。最后，我们可以通过递归计算得到所有满足条件的稳定二进制数组的个数，并取模返回。\nclass Solution: def numberOfStableArrays(self, zero: int, one: int, limit: int) -\u0026gt; int: mod = int(1e9)+7 @cache def dfs(i, j, k): if i==0: return 1 if k==1 and j\u0026lt;=limit else 0 if j==0: return 1 if k==0 and i\u0026lt;=limit else 0 if k==0: return ( dfs(i-1, j, 0) + dfs(i-1, j, 1) - (dfs(i-limit-1, j, 1) if i\u0026gt;limit else 0) ) %mod else: return ( dfs(i, j-1, 0) + dfs(i, j-1, 1) - (dfs(i, j-limit-1, 0) if j\u0026gt;limit else 0) ) %mod ans = (dfs(zero, one, 1) + dfs(zero, one, 0))%mod dfs.cache_clear() # 防止爆内存 return ans ","permalink":"https://kennems.github.io/zh/posts/tech/%E5%8F%8C%E5%91%A8%E8%B5%9B20230427/","summary":"双周赛20230427 第三/四题3130. 找出所有稳定的二进制数组 II 题目大意：给定三个正整数 zero、one 和 limit，定义一个二进制数组","title":"LeetCode双周赛129(240427)"},{"content":"周赛20230428 第四题134. 找出唯一性数组的中位数 题目大意：给定一个整数数组nums，唯一性数组是一个按元素从小到大排序的数组，包含了nums的所有非空子数组中不同元素的个数。要求返回nums唯一性数组的中位数，即有序唯一性数组的中间元素。\n实现思路：首先，我们需要明确唯一性数组的生成方式，即通过遍历所有非空子数组，计算其中不同元素的个数。然后，我们可以使用二分查找的方法确定唯一性数组的中位数。在二分查找的过程中，我们需要一个辅助函数来判断给定的中位数是否满足条件，即唯一性数组中不同元素的个数大于等于中位数。如果满足条件，我们更新右边界，否则更新左边界，直到左右边界相遇，即找到了唯一性数组的中位数。\nclass Solution: def medianOfUniquenessArray(self, nums: List[int]) -\u0026gt; int: n = len(nums) k = (n * (n + 1) // 2 + 1) // 2 def check(mid): j, cnt = 0, 0 fre = Counter() for i, num in enumerate(nums): fre[num] += 1 while len(fre) \u0026gt; mid: fre[nums[j]] -= 1 if fre[nums[j]] == 0: del fre[nums[j]] j += 1 cnt += i - j + 1 return cnt \u0026gt;= k l, r = 1, len(set(nums)) while l \u0026lt; r: mid = l + r \u0026gt;\u0026gt; 1 if check(mid): r = mid else: l = mid + 1 return l ","permalink":"https://kennems.github.io/zh/posts/tech/%E5%91%A8%E8%B5%9B240428/","summary":"周赛20230428 第四题134. 找出唯一性数组的中位数 题目大意：给定一个整数数组nums，唯一性数组是一个按元素从小到大排序的数组，包含了","title":"LeetCode周赛395(240428)"},{"content":"Java Web开发(3) Maven Maven是一款管理和构建java项目的工具\n依赖管理 统一的项目结构 项目构建 \u0026lt;maven.compiler.source\u0026gt;11\u0026lt;/maven.compiler.source\u0026gt; \u0026lt;maven.compiler.target\u0026gt;11\u0026lt;/maven.compiler.target\u0026gt; MVN坐标 Maven中的坐标是资源的唯一标识，通过该坐标可以唯一定位资源位置 使用坐标来定义项目或引入项目中所需要的依赖 Maven的坐标主要组成\ngroupid:定义当前Maven项目隶属组织名称（通常是域名反写） artifactId：定义当前Maven项目名称（通常是模块名称，例如 order-service, goods-service） version：定义当前项目版本号 导入maven工程：\nMaven中项目依赖配置 在\u0026lt;dependencies\u0026gt;中添加\n\u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;ch.qos.logback\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;logback-classic\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;1.2.3\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; 如果所引入的依赖，在本地仓库不存在，将会连接远程仓库/中央仓库，然后下载依赖 如果不知道依赖的坐标信息，到https://mvnrepository.com/中搜索。 Maven依赖管理 依赖具有传递性 直接依赖：在当前项目中通过依赖配置建立的依赖关系 间接依赖：被依赖的资源如果依赖其他资源，当前项目间接依赖其他资源 排除依赖 \u0026lt;!-- 排除依赖--\u0026gt; \u0026lt;exclusions\u0026gt; \u0026lt;exclusion\u0026gt; \u0026lt;groupId\u0026gt;junit\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;junit\u0026lt;/artifactId\u0026gt; \u0026lt;/exclusion\u0026gt; \u0026lt;/exclusions\u0026gt; 依赖范围 依赖的jar包，默认情况下，可以在任何地方使用，可以通过\u0026lt;scope\u0026gt;...\u0026lt;/scope\u0026gt;设置其作用范围\n作用范围： 主程序范围有效。（main文件夹范围内） 测试程序范围有效。（test文件夹范围内） 是否参与打包运行。（package指令范围内） scope值 提供库 编译时 运行时 范例 compile Y Y Y log4j test - Y - junit provided Y Y - servlet-api runtime - Y Y jdbc驱动 Maven生命周期 每套生命周期包含一些阶段（phase），阶段是有顺序的，后面的阶段依赖于前面的阶段\nclean : 移除上一次构建生成的文件 compile : 编译项目源代码 test : 使用合适的单元测试框架运行测试（junit） package ： 将编译后的文件打包，如：jar, war等 install ： 安装项目到本地仓库 同一套生命周期中，当运行后面的阶段时，前面的阶段都会运行。\nSpringBoot开发 创建SpringWeb工程\npackage com.showguan; import org.springframework.web.bind.annotation.RequestMapping; import org.springframework.web.bind.annotation.RestController; @RestController public class HelloController { @RequestMapping(\u0026#34;/hello\u0026#34;) public String hello() { System.out.println(\u0026#34;hello world\u0026#34;); return \u0026#34;hello world!\u0026#34;; } } HTTP协议 Hyper Text Transfer Protocol, 超文本传输协议，规定了浏览器和服务器之间的数据传输的规则 特点：\n基于TCP协议：面向连接，安全 基于请求-响应模型的：一次请求对应一次响应 HTTP协议是无状态的协议：对于事物处理没有记忆能力。每次请求-响应都是独立的。 缺点：多次请求间不能共享数据 优点：速度快 HTTP请求协议 请求行（请求方式，资源路径, 协议） GET /hello HTTP/1.1\rPOST /hello HTTP/1.1 请求头：第二行开始，格式 ： key:value 名称 值 Host 请填写您的网站域名 User-Agent 用户代理，标识发出请求的浏览器和操作系统，例如Mozilla/5.0 (Windows NT\u0026hellip;) like Gecko Accept 可接受的响应内容类型，例如text/*, image/*等 Accept-Language 可接受的响应内容语言，例如zh-CN,zh;q=0.8 Accept-Encoding 可接受的响应内容编码方式，例如gzip, deflate等 Content-Type 请求体的媒体类型 Content-Length 请求体的长度（单位：字节） 请求体：POST请求，存放请求参数 请求方式-GET：请求参数在请求行中，没有请求体 请求方式-POST：请求参数在请求体中，POST请求大小是没有限制的 HTTP响应协议 响应格式 响应行：响应数据第一行（协议，状态码，描述） 状态码分类 说明 1xx 响应中 \u0026mdash; 临时状态码。表示请求已经接受，告诉客户端应该继续请求或者如果已经完成则忽略 2xx 成功 \u0026mdash; 表示请求已经被成功接收，处理已完成 3xx 重定向 \u0026mdash; 重定向到其它地方，让客户端再发起一个请求以完成整个处理 4xx 客户端错误 \u0026mdash; 处理发生错误，责任在客户端，如：客户端的请求一个不存在的资源，客户端未被授权，禁止访问等 5xx 服务器端错误 \u0026mdash; 处理发生错误，责任在服务端，如：服务端抛出异常，路由出错，HTTP版本不支持等 一、状态码大类 状态码分类 说明 1xx 响应中——临时状态码，表示请求已经接受，告诉客户端应该继续请求或者如果它已经完成则忽略它 2xx 成功——表示请求已经被成功接收，处理已完成 3xx 重定向——重定向到其它地方：它让客户端再发起一个请求以完成整个处理。 4xx 客户端错误——处理发生错误，责任在客户端，如：客户端的请求一个不存在的资源，客户端未被授权，禁止访问等 5xx 服务器端错误——处理发生错误，责任在服务端，如：服务端抛出异常，路由出错，HTTP版本不支持等 二、常见的响应状态码 状态码 英文描述 解释 ==200== OK 客户端请求成功，即处理成功，这是我们最想看到的状态码 302 Found 指示所请求的资源已移动到由Location响应头给定的 URL，浏览器会自动重新访问到这个页面 304 Not Modified 告诉客户端，你请求的资源至上次取得后，服务端并未更改，你直接用你本地缓存吧。隐式重定向 400 Bad Request 客户端请求有语法错误，不能被服务器所理解 403 Forbidden 服务器收到请求，但是拒绝提供服务，比如：没有权限访问相关资源 ==404== Not Found 请求资源不存在，一般是URL输入有误，或者网站资源被删除了 405 Method Not Allowed 请求方式有误，比如应该用GET请求方式的资源，用了POST 428 Precondition Required 服务器要求有条件的请求，告诉客户端要想访问该资源，必须携带特定的请求头 429 Too Many Requests 指示用户在给定时间内发送了太多请求（“限速”），配合 Retry-After(多长时间后可以请求)响应头一起使用 431 Request Header Fields Too Large 请求头太大，服务器不愿意处理请求，因为它的头部字段太大。请求可以在减少请求头域的大小后重新提交。 ==500== Internal Server Error 服务器发生不可预期的错误。服务器出异常了，赶紧看日志去吧 503 Service Unavailable 服务器尚未准备好处理请求，服务器刚刚启动，还未初始化好 状态码大全：https://cloud.tencent.com/developer/chapter/13553\n响应头：第二行开始，格式 key:value 响应体：最后一部分，存放响应数据 Web服务器 Web服务器是一个软件程序，对HTTP协议的操作进行封装，使得程序员不必直接对协议进行操作，让Web开发更加便捷。主要功能是“提供网上信息浏览服务”。\nTomCat Apache软件基金会一个核心小木，是一个开源免费的轻量级Web服务器，支持Servlet/JSP少量JavaEE规范 TomCat也被称为Web容器，Servlet容器。Servlet程序需要依赖于TomCat才能运行 启动方式：bin/startup.bat\n修改TomCat端口号\nconf/server.xml\nLocalhost默认端口号就是80\n用tomcat部署，将html文件复制到webapps文件夹中\n起步依赖：\n基于SpringBoot开发的web应用程序，内置了tomcat服务器，当启动类运行时，会自动启动内嵌的tomcat服务器 请求 前后端分离开发\nPostMan\n实体参数 实体对象参数：请求参数名与形参对象属性名相同， 即可直接通过POJO接受\n数组集合参数 数组参数：请求参数名与形参数组名称相同且请求参数为多个，定义数组类型形参即可接受参数 路径参数 通过请求URL直接传递参数，使用{...}来标识该路径参数，使用@PathVariable获取路径参数 响应 ResponseBody\n类型：方法注解，类注解 位置：Controller方法上/类上 作用：将方法返回值直接响应，如果返回值类型时 实体类型/集合，将会转换为JSON格式响应 说明：@RestController = @Controller + @ResponseBody 统一响应结果 Result(code, msg, data) public class Result { private Integer code ;//1 成功 , 0 失败 private String msg; //提示信息 private Object data; //数据 data } 分层解耦 三层架构\ncontroller:控制层，接受前端发送的请求，对请求进行处理，并响应数据 service:业务逻辑层，处理具体的业务逻辑 dao:数据访问层（Data Access Object）（持久层），负责数据访问操作，包括数据的增、删、改、查。 内聚：软件中各个功能模块内部的功能联系\n耦合：衡量软件中各个层/模块之间的依赖、关联的程度\n软件设计原则：高内聚低耦合\n控制反转：Inversion Of Control（IOC）。对象的创建控制权由车光绪自身转移到外部(容器)， 这种思想称为控制反转。\n依赖注入：Dependency Injection, 简称DI。 容器为应用程序提供运行时，所以来的组员，称之为依赖注入。\nBean对象：IOC容器中创建、管理的对象，称之为bean。\n用@Component标识容器\nIOC控制反转 除了@Component之外还有@Service, @Repository， @Controller\n注意事项：\n声明bean的时候，可以通过value属性指定bean的名字，如果没有指定，默认为类名首字母小写 使用以上四个注解都可以声明bean， 但是在springboot继承web开发中，声明控制器bean只能用@Controller Bean组件扫描：\n声明bean若要想生效，需要被组件扫描注解@ComponentScan扫描 @ComponentScan注解虽然没有显式配置，但是实际上已经包含在了启动类声明注解@SpringBootApplication中，默认扫描的范围时启动类所在包及其子包 Bean注入 @Autowired注解，默认时按照类型进行，如果存在多个相同类型的bean， 将会报出如下错误：\n如果同类型的bean存在多个：\n@Primary @Autowired + @Qualifier(\u0026quot;bean的名称\u0026quot;) @Resource(name = \u0026quot;bean的名称\u0026quot;) 面试题\n@Resource和@Autowired的区别： @Autowired是spring框架提供的注解，而@Resource是JDK提供的注解。 @Autowired默认是按照类型注入，而@Resource默认是按照名称注入的。 ","permalink":"https://kennems.github.io/zh/posts/tech/java-web%E5%BC%80%E5%8F%913/","summary":"Java Web开发(3) Maven Maven是一款管理和构建java项目的工具 依赖管理 统一的项目结构 项目构建 \u0026lt;maven.compiler.source\u0026gt;11\u0026lt;/maven.compiler.source\u0026gt; \u0026lt;maven.compiler.target\u0026gt;11\u0026lt;/maven.compiler.target\u0026gt; MVN坐标 Maven中的坐标是资源的唯一标","title":"Java Web开发(3)"},{"content":"Java Web开发(4) 数据库 数据库：DataBase(DB) ， 是存储和管理数据的仓库 DBMS， SQL MySql登录，首先在服务中启动mysql\nmysql -uroot -p\u0026#34;password\u0026#34; 或者\nmysql -uroot -p 之后输入密码\n连接远程数据库\nmysql -h192.168.88.130 -P3306 -utopeet -p\u0026#34;password\u0026#34; 查看当前的数据库\nselect database(); 关系型数据库（RDBMS）：建立在关系模型基础上，由多张相互连接的二维表组成的数据库\nSQL：一门操作关系型数据库的编程语言，定义操作所有关系型数据库的统一标准\nSQL语句可以单行或多行书写，以分号结尾 SQL语句可以使用空格/缩进来增强语句的可读性 MySQL数据库的SQL语句不区分大小写 注释： 单行注释： \u0026ndash; 注释内容 或者 #注释内容（MySQL特有） 多行注释：/* 注释内容 */ create database db02; DDL， DML， DQL， DCL\ncreate database if not exists db02; drop database if exists db03; show databases; select database(); show schemas; DDL 创建表 约束：\n非空约束 not null 唯一约束 unique 主键约束 primary key （auto_increment自增） 默认约束 default 外键约束 foreign key (至少有两张表) 数据类型 主要分为三类：数值类型，字符串类型，日期时间类型\n数值类型：\n类型 大小 有符号范围 无符号范围 描述 tinyint 1 （-128， 127） （0， 255） 小整数值 smallint 2 （-32768, 32767) （0, 65535) 大整数值 mediumint 3 （-8388608， 8388607） （0， 16777215） 大整数值 int 4 （-2147483647， 2147483648） （0， 4294967295） 大整数值 bigint 8 （-2^63, 2^63-1) （0， 2^64-1) 极大整数值 float 4 单精度浮点值 float(5, 2)表示整个数字长度为5， 小数位数为2 double 8 双精度浮点值 decimal 小数值（精度更高） 金额计算 查询当前数据库的所有表：\nshow tables; 查询表结构：\ndesc 表名 查询建表语句：\nshow create table 表名 -- 员工管理(带约束) create table tb_emp ( id int unsigned primary key auto_increment comment \u0026#39;ID\u0026#39;, username varchar(20) not null unique comment \u0026#39;用户名\u0026#39;, password varchar(32) default \u0026#39;123456\u0026#39; comment \u0026#39;密码\u0026#39;, name varchar(10) not null comment \u0026#39;姓名\u0026#39;, gender tinyint unsigned not null comment \u0026#39;性别, 说明: 1 男, 2 女\u0026#39;, image varchar(300) comment \u0026#39;图像\u0026#39;, job tinyint unsigned comment \u0026#39;职位, 说明: 1 班主任,2 讲师, 3 学工主管, 4 教研主管\u0026#39;, entrydate date comment \u0026#39;入职时间\u0026#39;, create_time datetime not null comment \u0026#39;创建时间\u0026#39;, update_time datetime not null comment \u0026#39;修改时间\u0026#39; ) comment \u0026#39;员工表\u0026#39;; alter table tb_emp add qq varchar(11) comment \u0026#39;QQ\u0026#39;; alter table tb_emp modify qq varchar(13) comment \u0026#39;QQ\u0026#39;; alter table tb_emp change qq qq_num varchar(13) comment \u0026#39;QQ\u0026#39;; alter table tb_emp drop column qq_num; rename table tb_emp to emp; drop table if exists tb_emp; DML Data Manipulation Language(数据操作语言)， 用来对数据库中表的数据记录进行增，删，改操作。\ninsert into tb_emp(username,name,gender,create_time,update_time) values (\u0026#39;Kennem\u0026#39;, \u0026#39;张无忌\u0026#39;, \u0026#39;1\u0026#39;,now(),now()); # 插入的内容包含所有字段（可以省略所有字段） insert into tb_emp(id, username, password, name, gender, image, job, entrydate, create_time, update_time) values (null, \u0026#39;zhiruo\u0026#39;, \u0026#39;123\u0026#39;, \u0026#39;kdkd\u0026#39;, 2, \u0026#39;1.jpg\u0026#39;, 1, \u0026#39;2021-01-20\u0026#39;,now(), now()); # 插入多组数据 insert into tb_emp(username, password, name, gender, image, job, entrydate, create_time, update_time) values (\u0026#39;Oliver\u0026#39;, \u0026#39;123\u0026#39;, \u0026#39;kdkd\u0026#39;, 2, \u0026#39;1.jpg\u0026#39;, 1, \u0026#39;2021-01-20\u0026#39;,now(), now()),(\u0026#39;Linux\u0026#39;, \u0026#39;123\u0026#39;, \u0026#39;kdkd\u0026#39;, 2, \u0026#39;1.jpg\u0026#39;, 1, \u0026#39;2021-01-20\u0026#39;,now(), now()); # 更新数据 update tb_emp set name = \u0026#39;张三\u0026#39;, update_time = now() where id = 1; # 更新所有数据的此字段 update tb_emp set entrydate = \u0026#39;2010-01-01\u0026#39;, update_time = now(); # 更新所有行 # 删除id=1的数据 delete from emp where id=1; # 删除所有数据 delete from emp; # delete不能删除某一字段的值，可以用update将这一字段设置为NULL DQL Data Query Language（数据查询语言）， 用来查询数据库表中的记录 关键字：SELECT select from where group by having order by limit 聚合函数：\ncount max min avg sum select name, entrydate from tb_emp; select tb_emp.id, tb_emp.username, tb_emp.password, tb_emp.name, tb_emp.gender, tb_emp.image, tb_emp.job, tb_emp.entrydate, tb_emp.create_time, tb_emp.update_time from tb_emp; select * from tb_emp; select name as 姓名, entrydate as 入职日期 from tb_emp; select name as \u0026#39;姓 名\u0026#39;, entrydate as 入职日期 from tb_emp; select distinct job from tb_emp; -- 选择tb_emp表中的name和entrydate字段 select name, entrydate from tb_emp; -- 选择tb_emp表中的所有字段，并且显式列出它们 select tb_emp.id, tb_emp.username, tb_emp.password, tb_emp.name, tb_emp.gender, tb_emp.image, tb_emp.job, tb_emp.entrydate, tb_emp.create_time, tb_emp.update_time from tb_emp; -- 选择tb_emp表中的所有字段（不直观，性能较低） select * from tb_emp; -- 选择tb_emp表中的name和entrydate字段，并将它们重命名为“姓名”和“入职日期” select name as 姓名, entrydate as 入职日期 from tb_emp; -- 选择tb_emp表中的name和entrydate字段，并将它们重命名为“姓 名”和“入职日期” select name \u0026#39;姓 名\u0026#39;, entrydate 入职日期 from tb_emp; -- 选择tb_emp表中不同的job字段值 select distinct job from tb_emp; -- 从tb_emp表中选择name为“杨逍”的记录 select * from tb_emp where name = \u0026#39;杨逍\u0026#39;; -- 从tb_emp表中选择id小于等于5的记录 select * from tb_emp where id \u0026lt;= 5; -- 从tb_emp表中选择job字段为null的记录 select * from tb_emp where job is null; -- 从tb_emp表中选择job字段不为null的记录 select * from tb_emp where job is not null; -- 从tb_emp表中选择password字段不等于“123456”的记录 select * from tb_emp where password != \u0026#39;123456\u0026#39;; -- 从tb_emp表中选择password字段不等于“123456”的记录（另一种写法） select * from tb_emp where password \u0026lt;\u0026gt; \u0026#39;123456\u0026#39;; -- 从tb_emp表中选择entrydate在2000-01-01到2010-01-01之间的记录 select * from tb_emp where entrydate \u0026gt;= \u0026#39;2000-01-01\u0026#39; and entrydate \u0026lt;= \u0026#39;2010-01-01\u0026#39;; -- 从tb_emp表中选择entrydate在2000-01-01到2010-01-01之间的记录（使用between） select * from tb_emp where entrydate between \u0026#39;2000-01-01\u0026#39; and \u0026#39;2010-01-01\u0026#39;; -- 重复的语句，选择entrydate在2000-01-01到2010-01-01之间的记录（使用between） select * from tb_emp where entrydate between \u0026#39;2000-01-01\u0026#39; and \u0026#39;2010-01-01\u0026#39;; -- 重复的语句，选择entrydate在2000-01-01到2010-01-01之间的记录 select * from tb_emp where entrydate \u0026gt;= \u0026#39;2000-01-01\u0026#39; and entrydate \u0026lt;= \u0026#39;2010-01-01\u0026#39;; -- 从tb_emp表中选择entrydate在2000-01-01到2010-01-01之间，且gender为2的记录 select * from tb_emp where entrydate \u0026gt;= \u0026#39;2000-01-01\u0026#39; and entrydate \u0026lt;= \u0026#39;2010-01-01\u0026#39; and gender = 2; -- 从tb_emp表中选择job为2、3或4的记录 select * from tb_emp where job = 2 or job = 3 or job = 4; -- 从tb_emp表中选择job在2, 3, 4中的记录（使用in） select * from tb_emp where job in (2, 3, 4); -- 使用通配符_表示单个字符，选择name字段长度为2的记录 select * from tb_emp where name like \u0026#39;__\u0026#39;; -- 使用通配符_表示单个字符，选择name字段长度为3的记录 select * from tb_emp where name like \u0026#39;___\u0026#39;; -- 使用通配符%表示任意个字符，选择name以“张”开头的记录 select * from tb_emp where name like \u0026#39;张%\u0026#39;; -- 计数id字段的非空值 select count(id) from tb_emp; -- 计数表中的记录数，常量\u0026#39;A\u0026#39;对计数没有影响 select count(\u0026#39;A\u0026#39;) from tb_emp; -- 推荐的计数表中记录数的写法 select count(*) from tb_emp; -- 选择tb_emp表中entrydate的最小值 select min(entrydate) from tb_emp; -- 选择tb_emp表中entry -- 选择tb_emp表中entrydate的最大值 select max(entrydate) from tb_emp; -- 计算tb_emp表中id字段的平均值 select avg(id) from tb_emp; -- 计算tb_emp表中id字段的总和 select sum(id) from tb_emp; -- 按gender字段分组，并计数每个性别的记录数 select gender, count(*) from tb_emp group by gender; -- 按job字段分组，并选择entrydate小于等于2015-01-01的记录 -- 只包括记录数大于等于2的组 select job, count(*) from tb_emp where entrydate \u0026lt;= \u0026#39;2015-01-01\u0026#39; group by job having count(*) \u0026gt;= 2; -- 从tb_emp表中选择所有字段，并按entrydate字段升序排序 select * from tb_emp order by entrydate; -- 从tb_emp表中选择所有字段，并按entrydate字段降序排序 select * from tb_emp order by entrydate DESC; -- 从tb_emp表中选择所有字段，先按entrydate字段升序排序， -- 对于相同entrydate的记录，再按update_time字段降序排序 select * from tb_emp order by entrydate, update_time DESC; -- 从tb_emp表中选择所有字段，分页显示 -- 第二页的记录，每页显示5条记录 -- 起始索引为5，即从第6条记录开始（索引从0开始） select * from tb_emp limit 5, 5; -- 从tb_emp表中选择所有字段，分页显示 -- 第三页的记录，每页显示5条记录 -- 起始索引为10，即从第11条记录开始（索引从0开始） select * from tb_emp limit 10, 5; 面试题 DQL-分组查询， where与having区别\n执行时机不同：where是分组之前进行过滤，不满足where条件，不参与分组，而having是分组之后对结果进行过滤 判断条件不同：where不能对聚合函数进行判断，而having可以 注意事项：\n分组之后，查询的字段一般为聚合函数和分组字段，查询其他字段没有意义 执行顺序： where \u0026gt; 聚合函数 \u0026gt; having 案例 -- 从tb_emp表中选择指定字段，满足以下条件： -- name包含“张”，gender为1，entrydate在2000-01-01到2015-12-31之间 -- 结果按update_time降序排序，并分页显示 -- 显示第2页的记录，每页10条记录，即从第11条到第20条记录 select tb_emp.id, tb_emp.username, tb_emp.password, tb_emp.name, tb_emp.gender, tb_emp.image, tb_emp.job, tb_emp.entrydate, tb_emp.create_time, tb_emp.update_time from tb_emp where name like \u0026#39;%张%\u0026#39; and gender = 1 and entrydate between \u0026#39;2000-01-01\u0026#39; and \u0026#39;2015-12-31\u0026#39; order by update_time DESC limit 10, 10; -- 使用IF函数，根据gender字段的值判断性别，并计数每个性别的记录数 -- 使用IF函数：如果gender为1，则显示“男性员工”；否则显示“女性员工” select if(gender = 1, \u0026#39;男性员工\u0026#39;, \u0026#39;女性员工\u0026#39;) 性别, count(*) 人数 from tb_emp group by gender; -- 使用CASE语句，根据job字段的值确定职位名称，并计数每个职位的记录数 -- 使用CASE语句：当job为1时，显示“班主任”；当job为2时，显示“讲师”； -- 当job为3时，显示“学工主管”；当job为4时，显示“教研主管”；否则显示“未分配职位” select (case job when 1 then \u0026#39;班主任\u0026#39; when 2 then \u0026#39;讲师\u0026#39; when 3 then \u0026#39;学工主管\u0026#39; when 4 then \u0026#39;教研主管\u0026#39; else \u0026#39;未分配职位\u0026#39; end) 职位, count(*) 人数 from tb_emp group by job; 多表设计 项目开发中，在进行数据表结构设计时，会根据业务需求及业务模块之间的关系，分析并设计表结构，由于业务之间相互关联，所以各个表结构之间也存在着各种联系\n一对多(多对一) 多对多 一对一 一对多 部门和员工 物理外键\n概念：使用foreign key定义外键关联另外一张表。 缺点： 影响增，删，改的效率（需要检查外键关系） 仅用于单节点数据库，不适用与分布式，集群场景 容易引发数据库的死锁问题，消耗性能 alter table tb_emp add constraint tb_emp___fk_dept_id foreign key (dept_id) references tb_dept (id); 逻辑外键\n概念：在业务逻辑中，解决外键关联 通过逻辑外键，就可以很方便的解决上述问题 一对一 案例：用户与身份证信息的关系\n关系：一对一关系，多用于单表拆分，将一张表的基础字段放在一张表中，其他字段放在另一张表中，以提升操作效率\n实现：在任意一方加入外键，关联另外一方，并且设置外键为唯一的（UNIQUE）\n-- 创建用户信息表 tb_user create table tb_user ( id int unsigned primary key auto_increment comment \u0026#39;ID\u0026#39;, -- 自增主键ID name varchar(10) not null comment \u0026#39;姓名\u0026#39;, -- 用户姓名 gender tinyint unsigned not null comment \u0026#39;性别, 1 男 2 女\u0026#39;, -- 性别，1表示男，2表示女 phone char(11) comment \u0026#39;手机号\u0026#39;, -- 手机号 degree varchar(10) comment \u0026#39;学历\u0026#39; -- 学历 ) comment \u0026#39;用户信息表\u0026#39;; -- 表注释 -- 插入用户信息表 tb_user 的数据 insert into tb_user values (1, \u0026#39;白眉鹰王\u0026#39;, 1, \u0026#39;18812340001\u0026#39;, \u0026#39;初中\u0026#39;), (2, \u0026#39;青翼蝠王\u0026#39;, 1, \u0026#39;18812340002\u0026#39;, \u0026#39;大专\u0026#39;), (3, \u0026#39;金毛狮王\u0026#39;, 1, \u0026#39;18812340003\u0026#39;, \u0026#39;初中\u0026#39;), (4, \u0026#39;紫衫龙王\u0026#39;, 2, \u0026#39;18812340004\u0026#39;, \u0026#39;硕士\u0026#39;); -- 创建用户详细信息表 tb_user_card create table tb_user_card ( id int unsigned primary key auto_increment comment \u0026#39;ID\u0026#39;, -- 自增主键ID nationality varchar(10) not null comment \u0026#39;民族\u0026#39;, -- 民族 birthday date not null comment \u0026#39;生日\u0026#39;, -- 生日 idcard char(18) not null comment \u0026#39;身份证号\u0026#39;, -- 身份证号 issued varchar(20) not null comment \u0026#39;签发机关\u0026#39;, -- 签发机关 expire_begin date not null comment \u0026#39;有效期限-开始\u0026#39;, -- 有效期限开始日期 expire_end date comment \u0026#39;有效期限-结束\u0026#39;, -- 有效期限结束日期 user_id int unsigned not null unique comment \u0026#39;用户ID\u0026#39;, -- 用户ID，唯一且非空 constraint fk_user_id foreign key (user_id) references tb_user (id) -- 外键约束，引用 tb_user 表的 id 字段 ) comment \u0026#39;用户信息表\u0026#39;; -- 表注释 -- 插入用户详细信息表 tb_user_card 的数据 insert into tb_user_card values (1, \u0026#39;汉\u0026#39;, \u0026#39;1960-11-06\u0026#39;, \u0026#39;100000100000100001\u0026#39;, \u0026#39;朝阳区公安局\u0026#39;, \u0026#39;2000-06-10\u0026#39;, null, 1), (2, \u0026#39;汉\u0026#39;, \u0026#39;1971-11-06\u0026#39;, \u0026#39;100000100000100002\u0026#39;, \u0026#39;静安区公安局\u0026#39;, \u0026#39;2005-06-10\u0026#39;, \u0026#39;2025-06-10\u0026#39;, 2), (3, \u0026#39;汉\u0026#39;, \u0026#39;1963-11-06\u0026#39;, \u0026#39;100000100000100003\u0026#39;, \u0026#39;昌平区公安局\u0026#39;, \u0026#39;2006-06-10\u0026#39;, null, 3), (4, \u0026#39;回\u0026#39;, \u0026#39;1980-11-06\u0026#39;, \u0026#39;100000100000100004\u0026#39;, \u0026#39;海淀区公安局\u0026#39;, \u0026#39;2008-06-10\u0026#39;, \u0026#39;2028-06-10\u0026#39;, 4); 多对多 案例：学生与课程的关系\n关系：一个学生可以选修多门课程，一门课程也可以供多个学生选择\n使用中间表来对应多对多的关系\n-- 创建学生表 tb_student create table tb_student ( id int auto_increment primary key comment \u0026#39;主键ID\u0026#39;, -- 自增主键ID name varchar(10) comment \u0026#39;姓名\u0026#39;, -- 学生姓名 no varchar(10) comment \u0026#39;学号\u0026#39; -- 学生学号 ) comment \u0026#39;学生表\u0026#39;; -- 表注释 -- 插入学生表 tb_student 的数据 insert into tb_student (name, no) values (\u0026#39;黛绮丝\u0026#39;, \u0026#39;2000100101\u0026#39;), (\u0026#39;谢逊\u0026#39;, \u0026#39;2000100102\u0026#39;), (\u0026#39;殷天正\u0026#39;, \u0026#39;2000100103\u0026#39;), (\u0026#39;韦一笑\u0026#39;, \u0026#39;2000100104\u0026#39;); -- 创建课程表 tb_course create table tb_course ( id int auto_increment primary key comment \u0026#39;主键ID\u0026#39;, -- 自增主键ID name varchar(10) comment \u0026#39;课程名称\u0026#39; -- 课程名称 ) comment \u0026#39;课程表\u0026#39;; -- 表注释 -- 插入课程表 tb_course 的数据 insert into tb_course (name) values (\u0026#39;Java\u0026#39;), (\u0026#39;PHP\u0026#39;), (\u0026#39;MySQL\u0026#39;), (\u0026#39;Hadoop\u0026#39;); -- 创建学生课程中间表 tb_student_course，用于表示学生和课程的多对多关系 create table tb_student_course ( id int auto_increment comment \u0026#39;主键\u0026#39; primary key, -- 自增主键ID student_id int not null comment \u0026#39;学生ID\u0026#39;, -- 学生ID，非空 course_id int not null comment \u0026#39;课程ID\u0026#39;, -- 课程ID，非空 constraint fk_courseid foreign key (course_id) references tb_course (id), -- 外键约束，引用 tb_course 表的 id 字段 constraint fk_studentid foreign key (student_id) references tb_student (id) -- 外键约束，引用 tb_student 表的 id 字段 ) comment \u0026#39;学生课程中间表\u0026#39;; -- 表注释 -- 插入学生课程中间表 tb_student_course 的数据，表示学生选择的课程 insert into tb_student_course (student_id, course_id) values (1, 1), -- 学生 ID 1 选择了课程 ID 1 (Java) (1, 2), -- 学生 ID 1 选择了课程 ID 2 (PHP) (1, 3), -- 学生 ID 1 选择了课程 ID 3 (MySQL) (2, 2), -- 学生 ID 2 选择了课程 ID 2 (PHP) (2, 3), -- 学生 ID 2 选择了课程 ID 3 (MySQL) (3, 4); -- 学生 ID 3 选择了课程 ID 4 (Hadoop) 案例 参考页面原型及需求，设计合理的表结构\n阅读页面原型及需求文档，分析各个模块涉及到的表结构，及表结构之间的关系 根据页面原型及需求文档，分析各个表结构中具体的字段及约束 总结 一对多\n在多的一方添加外键，关联另外一方的主键\n一对一\n任意一方，添加外键，关联另外一方的主键\n多对多\n通过中间表来维护，中间表的两个外键，分别关联另外两个表的主键\n多表查询 从多张表中查询数据\n分类\n连接查询 内连接：相当于查询A， B交集部分数据 -- 这是一个笛卡尔积查询，返回tb_emp和tb_dept表的所有组合。 select * from tb_emp, -- tb_emp 表（员工表） tb_dept; -- tb_dept 表（部门表） -- 这是一个内连接查询，返回tb_emp和tb_dept表中满足连接条件的所有记录。 select * from tb_emp, -- tb_emp 表（员工表） tb_dept -- tb_dept 表（部门表） where tb_emp.dept_id = tb_dept.id; -- 连接条件：tb_emp表中的dept_id等于tb_dept表中的id -- 这是一个内连接查询，只返回员工的姓名和所属部门的名称。 select tb_emp.name, -- tb_emp 表中的 name 列（员工姓名） tb_dept.name -- tb_dept 表中的 name 列（部门名称） from tb_emp, -- tb_emp 表（员工表） tb_dept -- tb_dept 表（部门表） where tb_emp.dept_id = tb_dept.id; -- 连接条件：tb_emp表中的dept_id等于tb_dept表中的id -- 这是一个使用INNER JOIN关键字的内连接查询，返回员工的姓名和所属部门的名称。 select tb_emp.name, -- tb_emp 表中的 name 列（员工姓名） tb_dept.name -- tb_dept 表中的 name 列（部门名称） from tb_emp -- tb_emp 表（员工表） inner join tb_dept -- tb_dept 表（部门表），使用INNER JOIN关键字进行连接 on tb_emp.dept_id = tb_dept.id; -- 连接条件：tb_emp表中的dept_id等于tb_dept表中的id -- 这是一个使用JOIN关键字的内连接查询，返回员工的姓名和所属部门的名称。 select tb_emp.name, -- tb_emp 表中的 name 列（员工姓名） tb_dept.name -- tb_dept 表中的 name 列（部门名称） from tb_emp -- tb_emp 表（员工表） join tb_dept -- tb_dept 表（部门表），使用JOIN关键字进行连接 on tb_emp.dept_id = tb_dept.id; -- 连接条件：tb_emp表中的dept_id等于tb_dept表中的id -- 这是一个使用表别名的内连接查询，返回员工的姓名和所属部门的名称。 select e.name, -- e 表（tb_emp 表的别名）中的 name 列（员工姓名） p.name -- p 表（tb_dept 表的别名）中的 name 列（部门名称） from tb_emp e, -- tb_emp 表（员工表），起别名为 e tb_dept p -- tb_dept 表（部门表），起别名为 p where e.dept_id = p.id; -- 连接条件：e 表（tb_emp 表）的 dept_id 等于 p 表（tb_dept 表）的 id 外连接： 左外连接：查询左表所有数据（包括两张表交集部分数据 右外连接：查询右表所有数据（包括两张表交集部分数据） -- 左连接：查询所有员工及其所属部门的名称，包含没有部门的员工 select e.name, -- e 表（tb_emp 表的别名）中的 name 列（员工姓名） p.name -- p 表（tb_dept 表的别名）中的 name 列（部门名称） from tb_emp e -- tb_emp 表（员工表），起别名为 e left join tb_dept p on e.dept_id = p.id; -- 左连接：tb_emp表中的dept_id等于tb_dept表中的id -- 右连接：查询所有部门及其员工的姓名，包含没有员工的部门 select e.name, -- e 表（tb_emp 表的别名）中的 name 列（员工姓名） p.name -- p 表（tb_dept 表的别名）中的 name 列（部门名称） from tb_emp e -- tb_emp 表（员工表），起别名为 e right join tb_dept p on e.dept_id = p.id; -- 右连接：tb_emp表中的dept_id等于tb_dept表中的id -- 左连接：查询所有部门及其员工的姓名，包含没有员工的部门（和上面的右连接查询结果相同） select e.name, -- e 表（tb_emp 表的别名）中的 name 列（员工姓名） p.name -- p 表（tb_dept 表的别名）中的 name 列（部门名称） from tb_dept p -- tb_dept 表（部门表），起别名为 p left join tb_emp e on p.id = e.dept_id; -- 左连接：tb_dept表中的id等于tb_emp表中的dept_id 子查询 -- 子查询：查询id等于教研部的部门id的员工信息 select * from tb_emp -- tb_emp 表（员工表） where id = (select id from tb_dept where tb_dept.name = \u0026#39;教研部\u0026#39;); -- 子查询：从tb_dept表中选择名称为\u0026#39;教研部\u0026#39;的部门id -- 标量子查询：查询入职日期晚于方东白的员工信息 select * from tb_emp -- tb_emp 表（员工表） where entrydate \u0026gt; (select tb_emp.entrydate from tb_emp where name = \u0026#39;方东白\u0026#39;); -- 子查询：从tb_emp表中选择名称为\u0026#39;方东白\u0026#39;的员工入职日期 -- 列子查询：查询部门为教研部或咨询部的员工信息 select * from tb_emp -- tb_emp 表（员工表） where dept_id in (select id from tb_dept where name in (\u0026#39;教研部\u0026#39;, \u0026#39;咨询部\u0026#39;)); -- 子查询：从tb_dept表中选择名称为\u0026#39;教研部\u0026#39;或\u0026#39;咨询部\u0026#39;的部门id -- 行子查询：查询入职日期和职位均与韦一笑相同的员工信息 select * from tb_emp -- tb_emp 表（员工表） where entrydate = (select entrydate from tb_emp where name = \u0026#39;韦一笑\u0026#39;) -- 子查询：从tb_emp表中选择名称为\u0026#39;韦一笑\u0026#39;的员工入职日期 and job = (select job from tb_emp where name = \u0026#39;韦一笑\u0026#39;); -- 子查询：从tb_emp表中选择名称为\u0026#39;韦一笑\u0026#39;的员工职位 -- 行子查询的另一种写法：查询入职日期和职位均与韦一笑相同的员工信息 select * from tb_emp -- tb_emp 表（员工表） where (entrydate, job) = (select entrydate, job from tb_emp where name = \u0026#39;韦一笑\u0026#39;); -- 子查询：从tb_emp表中选择名称为\u0026#39;韦一笑\u0026#39;的员工入职日期和职位 -- 表子查询：查询入职日期在2006-01-01之后的员工信息 select * from tb_emp -- tb_emp 表（员工表） where entrydate \u0026gt; \u0026#39;2006-01-01\u0026#39;; -- 条件：入职日期在2006-01-01之后 -- 表子查询的另一种写法：查询入职日期在2006-01-01之后的员工及其所属部门信息 select * from (select * from tb_emp where entrydate \u0026gt; \u0026#39;2006-01-01\u0026#39;) e, -- 子查询：从tb_emp表中选择入职日期在2006-01-01之后的员工，并起别名为 e tb_dept p -- tb_dept 表（部门表），起别名为 p where e.dept_id = p.id; -- 连接条件：子查询结果的dept_id等于tb_dept表中的id 案例 对菜品(dish)， 套餐(setmeal)，类别(category)，菜品和套餐(setmeal_dish)对应关系表进行多表查询\n-- 查询价格低于10元的菜品的名称和价格 SELECT d.name, d.price FROM dish d WHERE d.price \u0026lt; 10; -- 查询价格低于10元的菜品的名称、价格以及所属分类的名称 SELECT d.name, d.price, c.name FROM dish d, category c WHERE d.category_id = c.id -- 使用category_id连接菜品和分类 AND d.price \u0026lt; 10; -- 过滤价格低于10元的菜品 -- 查询价格在10到50元之间且状态为1的菜品的名称、价格以及所属分类的名称 SELECT d.name, d.price, c.name FROM dish d LEFT JOIN category c ON d.category_id = c.id -- 左连接，包含所有菜品，即使它们没有分类 WHERE d.price BETWEEN 10 AND 50 -- 过滤价格在10到50元之间的菜品 AND d.status = 1; -- 过滤状态为1的菜品 -- 查询所有有菜品的分类的名称，按分类名称分组 SELECT c.name FROM dish d, category c WHERE d.category_id = c.id -- 使用category_id连接菜品和分类 GROUP BY c.name; -- 按分类名称分组，获取唯一的分类名称 -- 查询有3个或更多菜品的分类的名称及其菜品数量 SELECT c.name, COUNT(*) FROM dish d, category c WHERE d.category_id = c.id -- 使用category_id连接菜品和分类 GROUP BY c.name -- 按分类名称分组，计算每个分类的菜品数量 HAVING COUNT(*) \u0026gt;= 3; -- 仅包含菜品数量大于或等于3的分类 -- 查询每个分类的名称及其菜品的最高价格 SELECT c.name, MAX(d.price) FROM dish d, category c WHERE d.category_id = c.id -- 使用category_id连接菜品和分类 GROUP BY c.name; -- 按分类名称分组，获取每个分类的最高价格 -- 查询名为\u0026#39;商务套餐A\u0026#39;的套餐及其菜品的名称、价格和份数 SELECT s.name, s.price, d.name, d.price, sd.copies FROM setmeal s, setmeal_dish sd, dish d WHERE s.id = sd.setmeal_id -- 使用setmeal_id连接套餐和套餐菜品 AND sd.dish_id = d.id -- 使用dish_id连接套餐菜品和菜品 AND s.name = \u0026#39;商务套餐A\u0026#39;; -- 过滤出名称为\u0026#39;商务套餐A\u0026#39;的套餐 -- 查询价格低于所有菜品平均价格的菜品的所有列 SELECT * FROM dish WHERE price \u0026lt; (SELECT AVG(d.price) FROM dish d); -- 子查询获取所有菜品的平均价格 事物 事物是一组操作的集合，它是一个不可分割的工作单位， 事物会把所有的操作作为一个整体一起向系统提交或撤销操作请求，即这些操作要么同时成功， 要么同时失败。\nstart transaction; delete from tb_dept where id = 2; delete from tb_emp where dept_id = 2; commit; -- 如果在事务中的语句出现了问题， 则不能直接提交，需要回滚保证所有语句都没有问题 rollback; 四大特性 ACID\n原子性（Atomicity）：事务是不可分割的最小单元，要么全部成功，要么全部失败 一致性（Consistency）：事物完成后， 必须使所有的数据都保持一致状态 隔离性（Isolation）：数据库系统提供的隔离机制，保证事物在不受外部并发操作影响的独立环境下运行 持久性（Durability）：事物一旦提交或回滚，它对数据库中的数据的改变就是永久的 数据库优化 索引（index）：是帮助数据库高效获取数据的数据结构\n索引优缺点： 优点：\n提高数据查询的效率，降低数据库的IO成本 通过索引列对数据进行排序，降低数据排序的成本，降低CPU消耗 缺点：\n索引会占用存储空间 索引大大提高了查询效率，同时也降低了insert, update, delete的效率 索引的数据结构 MySQL数据库支持的索引结构有很多， 如：Hash索引， B+Tree索引， Full-Test索引等。如果没有特别指明，都是指默认的B+Tree结构组织的索引。\n页是数据库存储的最小单位，一个页为16KB\nB+Tree(多路平衡搜索树) 每个节点可以存储多个Key， 所有的Key都会在叶子节点中出现\n每个节点，可以存储多个key（有n个key， 就有n个指针）。 所有的数据都存储在叶子节点内，非叶子节点仅用于索引数据。 叶子节点形成了一颗双向链表，便于数据的排序及区间范围查询。 索引创建的SQL -- 在tb_emp表的name列上创建索引idx_tb_emp_name CREATE INDEX idx_tb_emp_name ON tb_emp(name); -- 显示tb_emp表中的所有索引 SHOW INDEX FROM tb_emp; -- 删除tb_emp表上的索引idx_tb_emp_name DROP INDEX idx_tb_emp_name ON tb_emp; ","permalink":"https://kennems.github.io/zh/posts/tech/java-web%E5%BC%80%E5%8F%914/","summary":"Java Web开发(4) 数据库 数据库：DataBase(DB) ， 是存储和管理数据的仓库 DBMS， SQL MySql登录，首先在服务中启动mysql mysql -uroot -p\u0026#34;password\u0026#34;","title":"Java Web开发(4)"},{"content":"Java Web开发(1) 什么是Web？ Web：全球广域网，也成为万维网（World Wide Web)，能够通过浏览器访问的网站 CRM OA ERP\n不谋全局者不足以谋一域\n前后端分离开发\n混合开发\nWeb标准也成为网页标准，有一系列的标准组成，大部分由W3C（万维网联盟）负责制定\n三个部分 HTML：负责网页的结果（页面元素和内容） CSS：负责网页的表现（页面元素的外观，位置等页面样式，如：颜色，大小等） JavaScript：负责网页的行为（交互效果） 什么是HTML，CSS？ HTML（HyperTextMarkupLanguage):超文本标记语言。 超文本：超越了文本的限制，比普通文本更强大。 标记语言：由标签构成的语言 HTML标签都是预定义号的。例如：使用\u0026lt;a\u0026gt;展示超链接，使用\u0026lt;img\u0026gt;展示图片，\u0026lt;video\u0026gt;展示视频。 HTML代码直接在浏览器中允许，HTML标签由浏览器解析。 标签不区分大小，单双引号都可以，语法结构比较松散\nCSS CSS（Cascading Style Sheet）：层叠样式表，用于控制页面的样式（表现） CSS引入方式： 行内样式：写在标签的style属性中（不推荐） 内嵌样式：写在style标签中（可以写在页面任何位置，但通常约定写在head标签中） 外联样式，写在一个单独的.css文件中（需要通过link标签在网页中引入） 颜色标识法： 关键字：预定义的颜色名（red, green, blue) rgb表示法：红绿蓝三原色，每项取值范围：0~255 十六进制表示法：#开头，将数字转换成十六进制表示，#000000， #ff0000, #cccccc， 简写为#000， #ccc \u0026lt;span\u0026gt;标签\n大量使用没有语义的布局标签 特点：一行可以显示多个（组合行内元素），宽度和高度默认由内容撑开 CSS选择器 元素选择器：标签名{\u0026hellip;} id选择器：#id属性值{\u0026hellip;} 类选择器：.class属性值{\u0026hellip;} 优先级：id选择器 \u0026gt; 类选择器 \u0026gt; 元素选择器 CSS属性 color， font-size(单位px) 超链接\n标签：\u0026lt;a\u0026gt; 属性：href：制定资源访问url target:指定在何处打开资源链接 _self：默认值，在当前页面打开 _blank：在空白页面打开 CSS属性\ntext-decoration:规定添加到文本的修饰，none表示定义标准的文本 color：定义文本的颜色 音频，视频标签\n\u0026lt;audio\u0026gt; \u0026lt;video\u0026gt; 换行，段落标签\n\u0026lt;br\u0026gt;, \u0026lt;p\u0026gt; 文本加粗标签\n\u0026lt;b\u0026gt;, \u0026lt;strong\u0026gt; CSS样式 line-height: 设置行高\ntext-indent: 定义第一个行内容的缩进\ntext-align:规定元素中的文本的水平对齐方式\nhtml中的空格占位符 \u0026amp;nbsp;\n页面布局 盒子：页面中的所有元素（标签），都可以看成一个盒子， 由盒子将页面中的元素包含在一个矩形区域内，通过盒子的视角更方便的进行页面布局\n盒子模型组成：内容区域（content）， 内边距区域（padding），边框区域（border），外边距区域(margin)\n布局标签：实际开发网页中，会大量频繁的使用div和span这两个没有语义的布局标签\n标签：\u0026lt;div\u0026gt;``\u0026lt;span\u0026gt;\n特点：\ndiv标签： 一行只显示一个（独占一行） 宽度默认是父元素的宽度，高度默认由内容撑开 可以设置宽高（width, height) span标签 一行可以显示多个 宽度和高度默认由内容撑开 不可设置宽高（width, height) 注意：如果只需要设置某一个方位的边框，内边距，外边距，可以在属性后米娜加上-位置， 例如：padding-top, padding-left, padding-right。\n表格标签 场景：在网页中以表格（行、列）形式整齐展示数据 标签 \u0026lt;table\u0026gt; 定义表格整体，可以包裹多个\u0026lt;tr\u0026gt; border:规定表格边框的宽度 width：规定表格的宽度 cellspacing：规定单元之间的空间 \u0026lt;tr\u0026gt;表格的行，可以包裹多个\u0026lt;td\u0026gt; \u0026lt;td\u0026gt;表格单元格（普通）， 可以包裹内容 \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html lang=\u0026#34;en\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;UTF-8\u0026#34;\u0026gt; \u0026lt;meta http-equiv=\u0026#34;X-UA-Compatible\u0026#34; content=\u0026#34;IE=edge\u0026#34;\u0026gt; \u0026lt;meta name=\u0026#34;viewport\u0026#34; content=\u0026#34;width=device-width, initial-scale=1.0\u0026#34;\u0026gt; \u0026lt;title\u0026gt;HTML-表格\u0026lt;/title\u0026gt; \u0026lt;style\u0026gt; /* 样式美化 */ td { text-align: center; /* 让单元格内容居中展示 */ } \u0026lt;/style\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;table border=\u0026#34;1px\u0026#34; cellspacing=\u0026#34;0\u0026#34; width=\u0026#34;600px\u0026#34;\u0026gt; \u0026lt;tr\u0026gt; \u0026lt;!-- 表头 --\u0026gt; \u0026lt;th\u0026gt;序号\u0026lt;/th\u0026gt; \u0026lt;th\u0026gt;品牌Logo\u0026lt;/th\u0026gt; \u0026lt;th\u0026gt;品牌名称\u0026lt;/th\u0026gt; \u0026lt;th\u0026gt;企业名称\u0026lt;/th\u0026gt; \u0026lt;/tr\u0026gt; \u0026lt;tr\u0026gt; \u0026lt;!-- 第一行数据 --\u0026gt; \u0026lt;td\u0026gt;1\u0026lt;/td\u0026gt; \u0026lt;td\u0026gt; \u0026lt;img src=\u0026#34;img/huawei.jpg\u0026#34; width=\u0026#34;100px\u0026#34;\u0026gt; \u0026lt;/td\u0026gt; \u0026lt;!-- 插入图片 --\u0026gt; \u0026lt;td\u0026gt;华为\u0026lt;/td\u0026gt; \u0026lt;td\u0026gt;华为技术有限公司\u0026lt;/td\u0026gt; \u0026lt;/tr\u0026gt; \u0026lt;tr\u0026gt; \u0026lt;!-- 第二行数据 --\u0026gt; \u0026lt;td\u0026gt;2\u0026lt;/td\u0026gt; \u0026lt;td\u0026gt; \u0026lt;img src=\u0026#34;img/alibaba.jpg\u0026#34; width=\u0026#34;100px\u0026#34;\u0026gt; \u0026lt;/td\u0026gt; \u0026lt;!-- 插入图片 --\u0026gt; \u0026lt;td\u0026gt;阿里\u0026lt;/td\u0026gt; \u0026lt;td\u0026gt;阿里巴巴集团控股有限公司\u0026lt;/td\u0026gt; \u0026lt;/tr\u0026gt; \u0026lt;/table\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; 表单标签 场景：在网页中主要负责数据采集功能，如 注册，登录等数据采集。\n标签：\u0026lt;form\u0026gt;\n表单项：不同类型的input元素，下俩列表，文本域等\n\u0026lt;input\u0026gt;: 定义表单项，通过type属性控制输入形式\n\u0026lt;select\u0026gt;：定义下拉列表\n\u0026lt;textarea\u0026gt;：定义文本域\n属性：\naction：规定当提交表单时向何处发送表单数据，URL\nmethod：规定用于发送表单数据的方式。\nGET表单数据拼接在url后面， 大小有限制 POST表单数据在请求体中携带，大小没有限制 表单必须由name属性\n\u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html lang=\u0026#34;en\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;UTF-8\u0026#34;\u0026gt; \u0026lt;meta http-equiv=\u0026#34;X-UA-Compatible\u0026#34; content=\u0026#34;IE=edge\u0026#34;\u0026gt; \u0026lt;meta name=\u0026#34;viewport\u0026#34; content=\u0026#34;width=device-width, initial-scale=1.0\u0026#34;\u0026gt; \u0026lt;title\u0026gt;HTML-表单\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;!-- form表单属性: action: 表单提交的URL，数据将会被提交到指定的URL地址。如果未指定，将默认提交到当前页面。 method: 表单的提交方式。 get: 将表单数据附加在URL后面，例如：?username=Tom\u0026amp;age=12。由于URL长度有限制，适合传递少量数据。默认值。 post: 将表单数据包含在消息体（请求体）中传递，没有参数大小限制，适合传递大量数据。 --\u0026gt; \u0026lt;form action=\u0026#34;\u0026#34; method=\u0026#34;post\u0026#34;\u0026gt; \u0026lt;!-- 输入框 --\u0026gt; 用户名: \u0026lt;input type=\u0026#34;text\u0026#34; name=\u0026#34;username\u0026#34;\u0026gt; 年龄: \u0026lt;input type=\u0026#34;text\u0026#34; name=\u0026#34;age\u0026#34;\u0026gt; 性别: \u0026lt;input type=\u0026#34;text\u0026#34; name=\u0026#34;sex\u0026#34;\u0026gt; \u0026lt;!-- 提交按钮 --\u0026gt; \u0026lt;input type=\u0026#34;submit\u0026#34; value=\u0026#34;提交\u0026#34;\u0026gt; \u0026lt;/form\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; 表单项 \u0026lt;input\u0026gt; ：表单项：通过type属性控制输入形式。 \u0026lt;select\u0026gt;：定义下拉列表，\u0026lt;option\u0026gt;定义列表项 \u0026lt;textarea\u0026gt;：文本域 \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html lang=\u0026#34;en\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;UTF-8\u0026#34;\u0026gt; \u0026lt;meta name=\u0026#34;viewport\u0026#34; content=\u0026#34;width=device-width, initial-scale=1.0\u0026#34;\u0026gt; \u0026lt;title\u0026gt;标题\u0026lt;/title\u0026gt; \u0026lt;!-- 内嵌样式 --\u0026gt; \u0026lt;style\u0026gt; /* CSS样式 */ h1 { color: #4d4f53; /* 设置标题颜色 */ } \u0026lt;/style\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;div id=\u0026#34;center\u0026#34;\u0026gt; \u0026lt;!-- 页面内容 --\u0026gt; \u0026lt;h1\u0026gt;标题\u0026lt;/h1\u0026gt; \u0026lt;!-- 标题 --\u0026gt; \u0026lt;hr\u0026gt; \u0026lt;!-- 水平分割线 --\u0026gt; \u0026lt;span id=\u0026#34;time\u0026#34;\u0026gt;2024年04月24日 16:32\u0026lt;/span\u0026gt; \u0026lt;!-- 时间 --\u0026gt; \u0026lt;hr\u0026gt; \u0026lt;!-- 水平分割线 --\u0026gt; \u0026lt;!-- 视频和音频播放器 --\u0026gt; \u0026lt;video src=\u0026#34;video\\1.mp4\u0026#34; controls width=\u0026#34;950px\u0026#34;\u0026gt;\u0026lt;/video\u0026gt; \u0026lt;audio src=\u0026#34;audio\\1.mp3\u0026#34; controls\u0026gt;\u0026lt;/audio\u0026gt; \u0026lt;!-- 文章内容 --\u0026gt; \u0026lt;p\u0026gt; 标题 \u0026lt;!-- 更多内容省略... --\u0026gt; \u0026lt;/p\u0026gt; \u0026lt;!-- 图片 --\u0026gt; \u0026lt;img src=\u0026#34;https://n.sinaimg.cn/sinakd20240424s/66/w554h312/20240424/6365-b8bea506131b4261f579f58304a45baa.png\u0026#34;\u0026gt; \u0026lt;!-- 更多内容省略... --\u0026gt; \u0026lt;!-- 责任编辑 --\u0026gt; \u0026lt;p id=\u0026#34;plast\u0026#34;\u0026gt; 责任编辑：xxx \u0026lt;/p\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; JavaScript JS是一门跨平台，面向对象的脚本语言。用来控制网页行为的，它能使网页可以交互 JavaScript引入方式 内部脚本：将JS代码定义在HTMl页面中\nJavaScript代码必须位于\u0026lt;script\u0026gt;``\u0026lt;/script\u0026gt;标签之间 在HTML文档中，可以在任意地方，放置任意数量的\u0026lt;script\u0026gt; 一般会把脚本置于\u0026lt;body\u0026gt;元素的底部，可改善显示速度 外部脚本：将JS代码定义在外部JS文件中，然后引入到HTML页面中\n外部JS文件中，只包含JS代码，不包含\u0026lt;script\u0026gt;标签 \u0026lt;script\u0026gt;标签不能自闭和 书写语法： 区分大小写 每行结尾的分号可有可无 注释 单行注释：//注释内容 多行注释：/* 注释内容 */ 大括号表示代码块 JS输出 \u0026lt;script\u0026gt; // alert(\u0026#34;H\u0026#34;) // /* 注释*/ // window.alert(\u0026#34;hello js\u0026#34;) document.write(\u0026#34;hi\u0026#34;) console.log(\u0026#34;hello\u0026#34;) \u0026lt;/script\u0026gt; 变量 JS中使用var关键字来声明变量 JS是一门弱类型语言，变量可以存放不同类型的值 变量名需要遵循如下规则： 组成字符可以是任何字母，数字，下划线(_)或者美元符号($) 数字不能开头 建议使用驼峰命名 原始数据类型：\nnumber：数字（整数，小数NaN) string : 字符串， 单双引号皆可 boolean：布尔， true, false null : 对象为空 undefined：为初始化时，默认值时undefined \u0026lt;script\u0026gt; // 注释示例 // 注释可以在代码中加入说明性文字，不会被执行 // 弹出对话框，显示\u0026#34;hello js\u0026#34; window.alert(\u0026#34;hello js\u0026#34;); // 在文档中写入\u0026#34;hi\u0026#34; document.write(\u0026#34;hi\u0026#34;); // 在控制台输出\u0026#34;hello\u0026#34; console.log(\u0026#34;hello\u0026#34;); \u0026lt;/script\u0026gt; \u0026lt;script\u0026gt; // 变量声明和赋值 var a = 10; a = \u0026#34;zs\u0026#34;; // 变量类型可以动态改变 alert(a); // 弹出\u0026#34;zs\u0026#34; // 使用let声明的变量具有块级作用域 { let x = 1; alert(x); // 弹出\u0026#34;1\u0026#34; } // 使用const声明常量，常量值不可修改 const pi = 3.14; pi = 3.15; // 会报错，常量值不可修改 alert(pi); // 弹出\u0026#34;3.14\u0026#34; \u0026lt;/script\u0026gt; \u0026lt;script\u0026gt; // typeof操作符用于检测变量或表达式的数据类型 alert(typeof 3); // 弹出\u0026#34;number\u0026#34; alert(typeof 3.14); // 弹出\u0026#34;number\u0026#34; alert(typeof \u0026#34;A\u0026#34;); // 弹出\u0026#34;string\u0026#34; alert(typeof true); // 弹出\u0026#34;boolean\u0026#34; alert(typeof null); // 弹出\u0026#34;object\u0026#34;，null被误判为object var a; alert(typeof a); // 弹出\u0026#34;undefined\u0026#34; \u0026lt;/script\u0026gt; \u0026lt;script\u0026gt; // 逻辑运算符 \u0026amp;\u0026amp; 和 || 的使用 if (0 \u0026amp;\u0026amp; NaN \u0026amp;\u0026amp; 1) { alert(\u0026#34;ok1\u0026#34;); // 不会执行，因为NaN为假 } if (0 || NaN || 1) { alert(\u0026#34;ok2\u0026#34;); // 执行，因为除了0和NaN外，其他都为真 } // 空字符串和空格字符串为真，null和undefined为假 if (\u0026#34;\u0026#34;) { alert(\u0026#34;字符串为真\u0026#34;); } if (\u0026#34; \u0026#34;) { alert(\u0026#34;字符串为真\u0026#34;); } if (null) { alert(\u0026#34;null为真\u0026#34;); } if (undefined) { alert(\u0026#34;undefined为真\u0026#34;); } \u0026lt;/script\u0026gt; \u0026lt;script\u0026gt; // 函数声明和函数表达式 // function add(a, b) { // return a + b; // } var add = function (a, b) { return a + b; } var res = add(1, 2, 5, 6); // 多余的参数会被忽略 alert(res); // 弹出\u0026#34;3\u0026#34;，因为只计算了前两个参数的和 \u0026lt;/script\u0026gt; JS对象 Array \u0026lt;script\u0026gt; // 创建数组的两种方式：使用Array构造函数和直接使用数组字面量 // var arr = new Array(1, 2, 3, 4); // console.log(arr); // 输出数组[1, 2, 3, 4] // console.log(arr[1]); // 输出数组索引为1的元素值，即2 // 使用数组字面量创建数组，并添加元素 var arr = [1, 2, 3, 4]; arr[10] = 10; // 添加元素到索引为10的位置 // console.log(arr[10]); // 输出数组索引为10的元素值，即10 // console.log(arr[9]); // 输出数组索引为9的元素值，由于未定义，默认为undefined arr[9] = \u0026#34;A\u0026#34;; // 修改索引为9的元素值为\u0026#34;A\u0026#34; arr[8] = \u0026#34;a;dlsfjakldjf\u0026#34;; // 修改索引为8的元素值 // console.log(arr[8]); // 输出数组索引为8的元素值 // console.log(arr[9]); // 输出数组索引为9的元素值 // 遍历数组的方式：for循环、forEach方法 // for (let i = 0; i \u0026lt; arr.length; i++) { // console.log(arr[i]); // 使用for循环遍历数组元素并输出 // } // arr.forEach(function (e) { // console.log(e); // 使用forEach方法遍历数组元素并输出 // }); // arr.forEach(e =\u0026gt; { // console.log(e); // 使用箭头函数和forEach方法遍历数组元素并输出 // }); // 向数组末尾添加元素：push方法 arr.push(7, 8, 9); arr.forEach(e =\u0026gt; { console.log(e); // 输出添加后的数组元素 }); console.log(\u0026#34;-----------\u0026#34;); // 从数组中删除元素：splice方法 arr.splice(1, 3); // 从索引为1的位置开始删除3个元素 arr.forEach(e =\u0026gt; { console.log(e); // 输出删除后的数组元素 }); \u0026lt;/script\u0026gt; String // 创建一个 String 对象并赋值为 \u0026#34;abc\u0026#34; var str1 = new String(\u0026#34;abc\u0026#34;); // 直接创建一个字符串变量并赋值为 \u0026#34; abccba \u0026#34; var str2 = \u0026#34; abccba \u0026#34;; // 打印字符串 str1 和 str2 console.log(str1); console.log(str2); // 输出 str1 的长度，即字符串中字符的个数 console.log(str1.length); // 返回 str1 中索引为 1 的字符，索引从 0 开始 console.log(str1.charAt(1)); // 返回指定字符在 str1 中第一次出现的位置，如果找不到则返回 -1 console.log(str1.indexOf(\u0026#34;c\u0026#34;)); // 去除字符串 str2 开头和结尾的空白字符，并赋值给变量 s var s = str2.trim(); console.log(s); // 返回 str1 中索引从 0 到 4（不包括 4）的子字符串 console.log(str1.substring(0, 4)); JSON Java Script Object Notation, JavaScript对象标记法 JSON是通过JavaScript对象标记法书写的文本 由于其语法简单，层次结构鲜明，现在多用于数据载体，在网络中进行数据传输 // 创建一个名为 user 的对象，包含 name、age、gender 和 intro 方法 var user = { name: \u0026#34;Tom\u0026#34;, age: 10, gender: \u0026#34;male\u0026#34;, intro: function () { alert(\u0026#34;I am \u0026#34; + this.name + \u0026#34; and I am \u0026#34; + this.age + \u0026#34; years old.\u0026#34;); } // 另一种定义方法的方式 // intro() { // alert(\u0026#34;I am \u0026#34; + this.name + \u0026#34; and I am \u0026#34; + this.age + \u0026#34; years old.\u0026#34;); // } } // 弹出 user 对象的 name 属性值 alert(user.name); // 调用 user 对象的 intro 方法，弹出一段介绍信息 user.intro(); // 创建一个 JSON 字符串 var jsonstr = \u0026#39;{\u0026#34;name\u0026#34;:\u0026#34;Tom\u0026#34;, \u0026#34;age\u0026#34;:10, \u0026#34;addr\u0026#34;:[\u0026#34;青岛\u0026#34;, \u0026#34;南京\u0026#34;]}\u0026#39;; // 使用 JSON.parse() 方法解析 JSON 字符串，并将其转换为 JavaScript 对象 var obj = JSON.parse(jsonstr); // 弹出解析后对象的 name 属性值 alert(obj.name); // 使用 JSON.stringify() 方法将 JavaScript 对象转换为 JSON 字符串，并弹出 alert(JSON.stringify(obj)); BOM 概念：Browser Object Model， 浏览器对象模型， 允许JavaScript与浏览器对话，JavaScript将浏览器的各个组成部分封装成对象。 Window 浏览器窗口对象 获取：直接使用window，其中window.可以成略 Location 地址栏对象 获取：使用window.location， 其中window.可以省略 // 弹出一个警告框显示 \u0026#34;Hello BOMWINDOWS\u0026#34; window.alert(\u0026#34;Hello BOMWINDOWS\u0026#34;); // 弹出一个警告框显示 \u0026#34;Hello BOM\u0026#34; alert(\u0026#34;Hello BOM\u0026#34;); // 弹出一个确认框，并根据用户的选择返回一个布尔值，true 表示确认，false 表示取消 var flag = confirm(\u0026#34;你确认删除吗？\u0026#34;); alert(flag); // 设置一个间隔定时器，每隔 2000 毫秒（2 秒）执行一次匿名函数，并在控制台打印执行次数 var i = 0; setInterval(function () { i += 1; console.log(\u0026#34;定时器执行了:\u0026#34; + i + \u0026#34;次\u0026#34;); }, 2000); // 设置一个定时器，在 2000 毫秒后弹出一个警告框显示 \u0026#34;Hello\u0026#34; setTimeout(function () { alert(\u0026#34;Hello\u0026#34;); }, 2000); // 弹出一个警告框显示当前页面的 URL alert(location.href); // 重定向当前页面到指定 URL location.href = \u0026#34;https://www.itcast.cn\u0026#34;; DOM Decument Object Model, 文档对象模型 将标记语言的各个部分封装为对应的对象 // 获取 id 为 \u0026#39;h1\u0026#39; 的元素 var img = document.getElementById(\u0026#39;h1\u0026#39;); alert(img); // 获取所有标签名为 \u0026#39;div\u0026#39; 的元素并弹出 var divs = document.getElementsByTagName(\u0026#39;div\u0026#39;); for (let i = 0; i \u0026lt; divs.length; i++) { alert(divs[i]); } // 获取所有 name 属性为 \u0026#39;hobby\u0026#39; 的元素并弹出 var ins = document.getElementsByName(\u0026#34;hobby\u0026#34;); for (let i = 0; i \u0026lt; ins.length; i++) { alert(ins[i]); } // 获取所有类名为 \u0026#39;cls\u0026#39; 的元素并弹出 var divs = document.getElementsByClassName(\u0026#39;cls\u0026#39;); for (let i = 0; i \u0026lt; divs.length; i++) { alert(divs[i]); } // 重新获取类名为 \u0026#39;cls\u0026#39; 的元素集合，并取第一个元素赋值给 div1，并弹出 var divs = document.getElementsByClassName(\u0026#39;cls\u0026#39;); var div1 = divs[0]; alert(div1); // 修改 div1 的 innerHTML 属性为 \u0026#34;666666\u0026#34; div1.innerHTML = \u0026#34;666666\u0026#34;; // 获取 id 为 \u0026#39;h1\u0026#39; 的元素并修改其 src 属性为 \u0026#34;img/on.gif\u0026#34; var img = document.getElementById(\u0026#39;h1\u0026#39;); img.src = \u0026#34;img/on.gif\u0026#34;; // 给所有标签名为 \u0026#39;div\u0026#39; 的元素追加内容 \u0026#34;\u0026lt;font color=\u0026#39;red\u0026#39;\u0026gt;Very Good\u0026lt;/font\u0026gt;\u0026#34; var divs = document.getElementsByTagName(\u0026#39;div\u0026#39;); for (let i = 0; i \u0026lt; divs.length; i++) { const element = divs[i]; element.innerHTML += \u0026#34;\u0026lt;font color=\u0026#39;red\u0026#39;\u0026gt;Very Good\u0026lt;/font\u0026gt;\u0026#34;; } // 获取所有 name 属性为 \u0026#39;hobby\u0026#39; 的元素，并设置它们的 checked 属性为 true var ins = document.getElementsByName(\u0026#34;hobby\u0026#34;); for (let i = 0; i \u0026lt; ins.length; i++) { const check = ins[i]; check.checked = true; } 小案例 \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html lang=\u0026#34;en\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;UTF-8\u0026#34;\u0026gt; \u0026lt;meta http-equiv=\u0026#34;X-UA-Compatible\u0026#34; content=\u0026#34;IE=edge\u0026#34;\u0026gt; \u0026lt;meta name=\u0026#34;viewport\u0026#34; content=\u0026#34;width=device-width, initial-scale=1.0\u0026#34;\u0026gt; \u0026lt;title\u0026gt;JS-事件-事件绑定\u0026lt;/title\u0026gt; \u0026lt;style\u0026gt; /* 样式美化 */ body { font-family: Arial, sans-serif; text-align: center; } #light { width: 100px; } .button { padding: 8px 16px; margin: 5px; font-size: 16px; cursor: pointer; } .checkbox-label { margin-right: 10px; } \u0026lt;/style\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;!-- 图片标签，用于显示灯的状态 --\u0026gt; \u0026lt;img id=\u0026#34;light\u0026#34; src=\u0026#34;img/off.gif\u0026#34; alt=\u0026#34;灯\u0026#34;\u0026gt; \u0026lt;br\u0026gt; \u0026lt;!-- 两个按钮，分别用于点亮和熄灭灯 --\u0026gt; \u0026lt;button class=\u0026#34;button\u0026#34; id=\u0026#34;btnOn\u0026#34; onclick=\u0026#34;on()\u0026#34;\u0026gt;点亮\u0026lt;/button\u0026gt; \u0026lt;button class=\u0026#34;button\u0026#34; id=\u0026#34;btnOff\u0026#34; onclick=\u0026#34;off()\u0026#34;\u0026gt;熄灭\u0026lt;/button\u0026gt; \u0026lt;!-- 文字标签 --\u0026gt; \u0026lt;div class=\u0026#34;cls\u0026#34;\u0026gt;黑马\u0026lt;/div\u0026gt; \u0026lt;br\u0026gt; \u0026lt;br\u0026gt; \u0026lt;!-- 输入框，输入内容转换为大写或小写 --\u0026gt; \u0026lt;input type=\u0026#34;text\u0026#34; id=\u0026#34;name\u0026#34; value=\u0026#34;itcast\u0026#34; onfocus=\u0026#34;lower()\u0026#34; onblur=\u0026#34;upper()\u0026#34;\u0026gt; \u0026lt;br\u0026gt; \u0026lt;!-- 多个复选框，用于选择爱好 --\u0026gt; \u0026lt;label class=\u0026#34;checkbox-label\u0026#34;\u0026gt;\u0026lt;input type=\u0026#34;checkbox\u0026#34; name=\u0026#34;hobby\u0026#34;\u0026gt; 电影\u0026lt;/label\u0026gt; \u0026lt;label class=\u0026#34;checkbox-label\u0026#34;\u0026gt;\u0026lt;input type=\u0026#34;checkbox\u0026#34; name=\u0026#34;hobby\u0026#34;\u0026gt; 旅游\u0026lt;/label\u0026gt; \u0026lt;label class=\u0026#34;checkbox-label\u0026#34;\u0026gt;\u0026lt;input type=\u0026#34;checkbox\u0026#34; name=\u0026#34;hobby\u0026#34;\u0026gt; 游戏\u0026lt;/label\u0026gt; \u0026lt;br\u0026gt; \u0026lt;!-- 全选和反选按钮 --\u0026gt; \u0026lt;button class=\u0026#34;button\u0026#34; id=\u0026#34;btnCheckAll\u0026#34; onclick=\u0026#34;checkAll()\u0026#34;\u0026gt;全选\u0026lt;/button\u0026gt; \u0026lt;button class=\u0026#34;button\u0026#34; id=\u0026#34;btnReverse\u0026#34; onclick=\u0026#34;reverse()\u0026#34;\u0026gt;反选\u0026lt;/button\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;script\u0026gt; // 点亮灯函数 function on() { var img = document.getElementById(\u0026#34;light\u0026#34;); img.src = \u0026#34;img/on.gif\u0026#34;; } // 熄灭灯函数 function off() { var img = document.getElementById(\u0026#34;light\u0026#34;); img.src = \u0026#34;img/off.gif\u0026#34;; } // 将输入内容转换为大写 function upper() { var input = document.getElementById(\u0026#34;name\u0026#34;); input.value = input.value.toUpperCase(); } // 将输入内容转换为小写 function lower() { var input = document.getElementById(\u0026#34;name\u0026#34;); input.value = input.value.toLowerCase(); } // 全选复选框函数 function checkAll() { var hobbys = document.getElementsByName(\u0026#34;hobby\u0026#34;); for (let i = 0; i \u0026lt; hobbys.length; i++) { const element = hobbys[i]; element.checked = true; } } // 反选复选框函数 function reverse() { var hobbys = document.getElementsByName(\u0026#34;hobby\u0026#34;); for (let i = 0; i \u0026lt; hobbys.length; i++) { const element = hobbys[i]; element.checked = !element.checked; // 切换选中状态 } } \u0026lt;/script\u0026gt; \u0026lt;/html\u0026gt; ","permalink":"https://kennems.github.io/zh/posts/tech/java-web%E5%BC%80%E5%8F%911/","summary":"Java Web开发(1) 什么是Web？ Web：全球广域网，也成为万维网（World Wide Web)，能够通过浏览器访问的网站 CRM OA ERP 不谋全局者不足以谋一域","title":"Java Web开发(1)"},{"content":"Java Web开发(2) Vue Vue是一套前端框架，免除原生的JavaScript中的DOM操作，简化书写。 基于MVVM（Model-View-View-Model）思想，实现数据的双向绑定，将编程的关注点放在数据上。 \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html lang=\u0026#34;en\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;UTF-8\u0026#34;\u0026gt; \u0026lt;meta name=\u0026#34;viewport\u0026#34; content=\u0026#34;width=device-width, initial-scale=1.0\u0026#34;\u0026gt; \u0026lt;title\u0026gt;Vue\u0026lt;/title\u0026gt; \u0026lt;!-- 引入Vue.js库 --\u0026gt; \u0026lt;script src=\u0026#34;../js/vue.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;div id=\u0026#34;app\u0026#34;\u0026gt; \u0026lt;!-- 输入框，使用v-model指令实现双向数据绑定 --\u0026gt; \u0026lt;input type=\u0026#34;text\u0026#34; v-model=\u0026#34;message\u0026#34;\u0026gt; \u0026lt;!-- 使用插值表达式显示message变量的值 --\u0026gt; {{ message }} \u0026lt;/div\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;script\u0026gt; // 创建一个Vue实例 new Vue({ // 将Vue实例挂载到id为\u0026#34;app\u0026#34;的元素上 el: \u0026#34;#app\u0026#34;, // 定义数据对象 data: { message: \u0026#34;Hello Vue\u0026#34; // 初始值为\u0026#34;Hello Vue\u0026#34; } }) \u0026lt;/script\u0026gt; \u0026lt;/html\u0026gt; Vue常用指令 \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html lang=\u0026#34;en\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;UTF-8\u0026#34;\u0026gt; \u0026lt;meta name=\u0026#34;viewport\u0026#34; content=\u0026#34;width=device-width, initial-scale=1.0\u0026#34;\u0026gt; \u0026lt;title\u0026gt;Vue\u0026lt;/title\u0026gt; \u0026lt;!-- 引入 Vue.js 文件 --\u0026gt; \u0026lt;script src=\u0026#34;../js/vue.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;!-- Vue 实例挂载的根节点 --\u0026gt; \u0026lt;div id=\u0026#34;app\u0026#34;\u0026gt; \u0026lt;table border=\u0026#34;1\u0026#34; cellspacing=\u0026#34;0\u0026#34; width=\u0026#34;60%\u0026#34;\u0026gt; \u0026lt;tr\u0026gt; \u0026lt;th\u0026gt;编号\u0026lt;/th\u0026gt; \u0026lt;th\u0026gt;姓名\u0026lt;/th\u0026gt; \u0026lt;th\u0026gt;年龄\u0026lt;/th\u0026gt; \u0026lt;th\u0026gt;性别\u0026lt;/th\u0026gt; \u0026lt;th\u0026gt;成绩\u0026lt;/th\u0026gt; \u0026lt;th\u0026gt;等级\u0026lt;/th\u0026gt; \u0026lt;/tr\u0026gt; \u0026lt;!-- 使用 v-for 循环渲染列表 --\u0026gt; \u0026lt;tr align=\u0026#34;center\u0026#34; v-for=\u0026#34;(user, index) in users\u0026#34;\u0026gt; \u0026lt;td\u0026gt;{{index + 1}}\u0026lt;/td\u0026gt; \u0026lt;td\u0026gt;{{user.name}}\u0026lt;/td\u0026gt; \u0026lt;td\u0026gt;{{user.age}}\u0026lt;/td\u0026gt; \u0026lt;td\u0026gt; \u0026lt;!-- 使用 v-if 条件渲染 --\u0026gt; \u0026lt;span v-if=\u0026#34;user.gender == 1\u0026#34;\u0026gt;男\u0026lt;/span\u0026gt; \u0026lt;span v-if=\u0026#34;user.gender == 2\u0026#34;\u0026gt;女\u0026lt;/span\u0026gt; \u0026lt;/td\u0026gt; \u0026lt;td\u0026gt;{{user.score}}\u0026lt;/td\u0026gt; \u0026lt;td\u0026gt; \u0026lt;!-- 使用 v-if、v-else-if、v-else 实现多条件渲染 --\u0026gt; \u0026lt;span v-if=\u0026#34;user.score \u0026gt;= 60 \u0026amp;\u0026amp; user.score \u0026lt; 85\u0026#34;\u0026gt;优秀\u0026lt;/span\u0026gt; \u0026lt;span v-else-if=\u0026#34;user.score \u0026gt;= 85\u0026#34;\u0026gt;及格\u0026lt;/span\u0026gt; \u0026lt;span style=\u0026#34;color:red\u0026#34; v-else\u0026gt;不及格\u0026lt;/span\u0026gt; \u0026lt;/td\u0026gt; \u0026lt;/tr\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;script\u0026gt; // 创建 Vue 实例 new Vue({ el: \u0026#34;#app\u0026#34;, // 指定实例挂载的根节点 data: { // 用于存储数据的对象 users: [{ name: \u0026#34;Tom\u0026#34;, age: 20, gender: 1, score: 30 }, { name: \u0026#34;Rose\u0026#34;, age: 18, gender: 2, score: 99 }, { name: \u0026#34;Jerry\u0026#34;, age: 16, gender: 1, score: 98 }, { name: \u0026#34;Kennem\u0026#34;, age: 21, gender: 1, score: 100 }] }, }) \u0026lt;/script\u0026gt; \u0026lt;/html\u0026gt; Vue生命周期 new new Vue({ el: \u0026#34;#app\u0026#34;, //接管区域 data: { }, methods: { }, mounted() { alert(\u0026#34;挂载完成!\u0026#34;); }, }) Ajax Asynchronous JavaScript And XML, 异步的JavaScript和XML 作用： 数据交换：通过Ajax可以给服务器发送请求，并获取服务器响应的数据。 异步交互：可以在不重新加载整个页面的情况下，与服务器交换数据并更新部分网页的技术，如：搜索联想，用户名是否可用的校验等。 \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html lang=\u0026#34;en\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;UTF-8\u0026#34;\u0026gt; \u0026lt;meta http-equiv=\u0026#34;X-UA-Compatible\u0026#34; content=\u0026#34;IE=edge\u0026#34;\u0026gt; \u0026lt;meta name=\u0026#34;viewport\u0026#34; content=\u0026#34;width=device-width, initial-scale=1.0\u0026#34;\u0026gt; \u0026lt;title\u0026gt;原生Ajax\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;input type=\u0026#34;button\u0026#34; value=\u0026#34;获取数据\u0026#34; onclick=\u0026#34;getData()\u0026#34;\u0026gt; \u0026lt;div id=\u0026#34;div1\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;script\u0026gt; function getData() { // 创建XMLHttpRequest对象 var xmlHttpRequest = new XMLHttpRequest(); // 发送异步请求 xmlHttpRequest.open(\u0026#39;GET\u0026#39;, \u0026#39;https://xxx/json_demo.json\u0026#39;); xmlHttpRequest.send(); // 发送请求 // 获取服务响应数据 xmlHttpRequest.onreadystatechange = function () { if (xmlHttpRequest.readyState == 4 \u0026amp;\u0026amp; xmlHttpRequest.status == 200) { document.getElementById(\u0026#39;div1\u0026#39;).innerHTML = xmlHttpRequest.responseText; } } } \u0026lt;/script\u0026gt; \u0026lt;/html\u0026gt; Axios Axios对原生的Ajax进行了封装，简化书写，快速开发。 \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html lang=\u0026#34;en\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;UTF-8\u0026#34;\u0026gt; \u0026lt;meta http-equiv=\u0026#34;X-UA-Compatible\u0026#34; content=\u0026#34;IE=edge\u0026#34;\u0026gt; \u0026lt;meta name=\u0026#34;viewport\u0026#34; content=\u0026#34;width=device-width, initial-scale=1.0\u0026#34;\u0026gt; \u0026lt;title\u0026gt;Ajax-Axios-案例\u0026lt;/title\u0026gt; \u0026lt;!-- 引入axios库 --\u0026gt; \u0026lt;script src=\u0026#34;js/axios-0.18.0.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;!-- 引入Vue.js --\u0026gt; \u0026lt;script src=\u0026#34;js/vue.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;div id=\u0026#34;app\u0026#34;\u0026gt; \u0026lt;!-- 数据展示表格 --\u0026gt; \u0026lt;table border=\u0026#34;1\u0026#34; cellspacing=\u0026#34;0\u0026#34; width=\u0026#34;60%\u0026#34;\u0026gt; \u0026lt;!-- 表头 --\u0026gt; \u0026lt;tr\u0026gt; \u0026lt;th\u0026gt;编号\u0026lt;/th\u0026gt; \u0026lt;th\u0026gt;姓名\u0026lt;/th\u0026gt; \u0026lt;th\u0026gt;图像\u0026lt;/th\u0026gt; \u0026lt;th\u0026gt;性别\u0026lt;/th\u0026gt; \u0026lt;th\u0026gt;职位\u0026lt;/th\u0026gt; \u0026lt;th\u0026gt;入职日期\u0026lt;/th\u0026gt; \u0026lt;th\u0026gt;最后操作时间\u0026lt;/th\u0026gt; \u0026lt;/tr\u0026gt; \u0026lt;!-- 数据行，使用Vue.js的v-for指令循环渲染 --\u0026gt; \u0026lt;tr align=\u0026#34;center\u0026#34; v-for=\u0026#34;(emp,index) in emps\u0026#34;\u0026gt; \u0026lt;td\u0026gt;{{index + 1}}\u0026lt;/td\u0026gt; \u0026lt;!-- 显示编号 --\u0026gt; \u0026lt;td\u0026gt;{{emp.name}}\u0026lt;/td\u0026gt; \u0026lt;!-- 显示姓名 --\u0026gt; \u0026lt;td\u0026gt; \u0026lt;img :src=\u0026#34;emp.image\u0026#34; width=\u0026#34;70px\u0026#34; height=\u0026#34;50px\u0026#34;\u0026gt; \u0026lt;!-- 显示图像 --\u0026gt; \u0026lt;/td\u0026gt; \u0026lt;td\u0026gt; \u0026lt;span v-if=\u0026#34;emp.gender == 1\u0026#34;\u0026gt;男\u0026lt;/span\u0026gt; \u0026lt;!-- 根据性别显示男或女 --\u0026gt; \u0026lt;span v-if=\u0026#34;emp.gender == 2\u0026#34;\u0026gt;女\u0026lt;/span\u0026gt; \u0026lt;/td\u0026gt; \u0026lt;td\u0026gt;{{emp.job}}\u0026lt;/td\u0026gt; \u0026lt;!-- 显示职位 --\u0026gt; \u0026lt;td\u0026gt;{{emp.entrydate}}\u0026lt;/td\u0026gt; \u0026lt;!-- 显示入职日期 --\u0026gt; \u0026lt;td\u0026gt;{{emp.updatetime}}\u0026lt;/td\u0026gt; \u0026lt;!-- 显示最后操作时间 --\u0026gt; \u0026lt;/tr\u0026gt; \u0026lt;/table\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;script\u0026gt; new Vue({ el: \u0026#34;#app\u0026#34;, data: { emps: [] // 存储员工数据的数组 }, mounted () { // 在Vue实例mounted生命周期钩子中发送异步请求加载数据 axios.get(\u0026#34;http://yapi.smart-xwork.cn/mock/169327/emp/list\u0026#34;).then(result =\u0026gt; { // 异步请求成功后将数据赋值给emps数组 this.emps = result.data.data; }) } }); \u0026lt;/script\u0026gt; \u0026lt;/html\u0026gt; 接口管理平台 Yapi apifox\n作为测试接口\nVue开发 Vue安装 npm -g install vue/cli vue 项目创建 vue create project-name Vue的组件文件以.vue结尾， 每个组件由三个部分组成\u0026lt;template\u0026gt;, \u0026lt;script\u0026gt;, \u0026lt;style\u0026gt;。 Element UI npm install element-ui@2.15.3 import ElementUI from \u0026#39;element-ui\u0026#39;; import \u0026#39;element-ui/lib/theme-chalk/index.css\u0026#39;; Vue.use(ElementUI); Vue路由 前端路由：URL中的hash(#)与组件之间的对应关系。 https://mock.apifox.cn/m1/3128855-0-default/emp/list Nginx 处理被占用的端口号：\nnetstat -ano | findStr 80 将测试好的前端网页复制到html静态资源中\n然后直接启动nginx即可。\n访问：\nhttp://localhost:80 员工管理项目 main.js // 引入Vue框架 import Vue from \u0026#39;vue\u0026#39; // 引入ElementUI组件库 import ElementUI from \u0026#39;element-ui\u0026#39;; // 引入Vue Router，用于管理页面路由 import router from \u0026#39;./router\u0026#39; // 引入ElementUI的样式文件 import \u0026#39;element-ui/lib/theme-chalk/index.css\u0026#39;; // 引入根组件App.vue import App from \u0026#39;./App.vue\u0026#39; // 在Vue中使用ElementUI Vue.use(ElementUI); // 关闭生产模式下的提示 Vue.config.productionTip = false // 创建Vue实例 new Vue({ // 注入路由 router, // 渲染根组件 render: h =\u0026gt; h(App), }).$mount(\u0026#39;#app\u0026#39;) app.vue \u0026lt;template\u0026gt; \u0026lt;div id=\u0026#34;app\u0026#34;\u0026gt; \u0026lt;!-- \u0026lt;emp-view\u0026gt; \u0026lt;/emp-view\u0026gt; --\u0026gt; \u0026lt;!-- 这是 Vue Router 的视图渲染出口，用于展示当前匹配的视图组件 --\u0026gt; \u0026lt;router-view\u0026gt; \u0026lt;/router-view\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;script\u0026gt; // 导入组件 // import EmpView from \u0026#39;./views/tlias/EmpView.vue\u0026#39; export default { // 注册组件 components: { /*EmpView*/ }, data() { // 组件的数据属性，可以在模板中使用 return { message: \u0026#34;\u0026#34; } }, methods: { // 组件的方法，用于定义各种功能 }, } \u0026lt;/script\u0026gt; \u0026lt;style\u0026gt; /* 组件的样式 */ #app { font-family: Consolas, Helvetica, Arial, sans-serif; -webkit-font-smoothing: antialiased; -moz-osx-font-smoothing: grayscale; text-align: center; color: #2c3e50; margin-top: 60px; } \u0026lt;/style\u0026gt; EmpView.vue \u0026lt;template\u0026gt; \u0026lt;div\u0026gt; \u0026lt;!-- Element UI 布局容器 --\u0026gt; \u0026lt;el-container style=\u0026#34;height: 700px; border: 2px solid #eee\u0026#34;\u0026gt; \u0026lt;!-- 头部区域 --\u0026gt; \u0026lt;el-header style=\u0026#34;font-size: 48px; background-color: rgb(238, 241, 246); text-align: left;\u0026#34;\u0026gt;Tlias智能学习辅助系统\u0026lt;/el-header\u0026gt; \u0026lt;el-container\u0026gt; \u0026lt;!-- 侧边栏区域 --\u0026gt; \u0026lt;el-aside width=\u0026#34;230px\u0026#34; style=\u0026#34; border: 2px solid #eee\u0026#34;\u0026gt; \u0026lt;!-- 侧边栏导航菜单 --\u0026gt; \u0026lt;el-menu :default-openeds=\u0026#34;[\u0026#39;1\u0026#39;, \u0026#39;3\u0026#39;]\u0026#34;\u0026gt; \u0026lt;el-submenu index=\u0026#34;1\u0026#34;\u0026gt; \u0026lt;template slot=\u0026#34;title\u0026#34;\u0026gt;\u0026lt;i class=\u0026#34;el-icon-message\u0026#34;\u0026gt;\u0026lt;/i\u0026gt;系统信息管理\u0026lt;/template\u0026gt; \u0026lt;el-menu-item-group\u0026gt; \u0026lt;!-- 导航链接 --\u0026gt; \u0026lt;el-menu-item index=\u0026#34;1-1\u0026#34;\u0026gt; \u0026lt;router-link to=\u0026#34;/dept\u0026#34;\u0026gt;部门管理\u0026lt;/router-link\u0026gt; \u0026lt;/el-menu-item\u0026gt; \u0026lt;el-menu-item index=\u0026#34;1-2\u0026#34;\u0026gt; \u0026lt;router-link to=\u0026#34;/emp\u0026#34;\u0026gt;员工管理\u0026lt;/router-link\u0026gt; \u0026lt;/el-menu-item\u0026gt; \u0026lt;/el-menu-item-group\u0026gt; \u0026lt;/el-submenu\u0026gt; \u0026lt;/el-menu\u0026gt; \u0026lt;/el-aside\u0026gt; \u0026lt;!-- 主体区域 --\u0026gt; \u0026lt;el-main\u0026gt; \u0026lt;!-- 查询表单 --\u0026gt; \u0026lt;el-form :inline=\u0026#34;true\u0026#34; :model=\u0026#34;searchForm\u0026#34; class=\u0026#34;demo-form-inline\u0026#34;\u0026gt; \u0026lt;el-form-item label=\u0026#34;姓名\u0026#34;\u0026gt; \u0026lt;el-input v-model=\u0026#34;searchForm.name\u0026#34; placeholder=\u0026#34;输入姓名\u0026#34;\u0026gt;\u0026lt;/el-input\u0026gt; \u0026lt;/el-form-item\u0026gt; \u0026lt;el-form-item label=\u0026#34;性别\u0026#34;\u0026gt; \u0026lt;el-select v-model=\u0026#34;searchForm.gender\u0026#34; placeholder=\u0026#34;输入性别\u0026#34;\u0026gt; \u0026lt;el-option label=\u0026#34;男\u0026#34; value=\u0026#34;1\u0026#34;\u0026gt;\u0026lt;/el-option\u0026gt; \u0026lt;el-option label=\u0026#34;女\u0026#34; value=\u0026#34;2\u0026#34;\u0026gt;\u0026lt;/el-option\u0026gt; \u0026lt;/el-select\u0026gt; \u0026lt;/el-form-item\u0026gt; \u0026lt;el-form-item label=\u0026#34;入职时间\u0026#34;\u0026gt; \u0026lt;el-date-picker v-model=\u0026#34;searchForm.entrydate\u0026#34; type=\u0026#34;daterange\u0026#34; range-separator=\u0026#34;至\u0026#34; start-placeholder=\u0026#34;开始日期\u0026#34; end-placeholder=\u0026#34;结束日期\u0026#34;\u0026gt; \u0026lt;/el-date-picker\u0026gt; \u0026lt;/el-form-item\u0026gt; \u0026lt;el-form-item\u0026gt; \u0026lt;el-button type=\u0026#34;primary\u0026#34; @click=\u0026#34;onSubmit\u0026#34;\u0026gt;查询\u0026lt;/el-button\u0026gt; \u0026lt;/el-form-item\u0026gt; \u0026lt;/el-form\u0026gt; \u0026lt;!-- 表格 --\u0026gt; \u0026lt;el-table :data=\u0026#34;tableData\u0026#34; border\u0026gt; \u0026lt;el-table-column prop=\u0026#34;name\u0026#34; label=\u0026#34;姓名\u0026#34; width=\u0026#34;180\u0026#34;\u0026gt; \u0026lt;/el-table-column\u0026gt; \u0026lt;el-table-column prop=\u0026#34;image\u0026#34; label=\u0026#34;图像\u0026#34; width=\u0026#34;180\u0026#34;\u0026gt; \u0026lt;!-- 作用域插槽 --\u0026gt; \u0026lt;template slot-scope=\u0026#34;scope\u0026#34;\u0026gt; \u0026lt;img :src=\u0026#34;scope.row.image\u0026#34; width=\u0026#34;100px\u0026#34; height=\u0026#34;70px\u0026#34;\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;/el-table-column\u0026gt; \u0026lt;el-table-column prop=\u0026#34;gender\u0026#34; label=\u0026#34;性别\u0026#34; width=\u0026#34;140\u0026#34;\u0026gt; \u0026lt;!-- 作用域插槽 --\u0026gt; \u0026lt;template slot-scope=\u0026#34;scope\u0026#34;\u0026gt; {{ scope.row.gender == 1 ? \u0026#34;男\u0026#34; : \u0026#34;女\u0026#34; }} \u0026lt;/template\u0026gt; \u0026lt;/el-table-column\u0026gt; \u0026lt;el-table-column prop=\u0026#34;job\u0026#34; label=\u0026#34;职位\u0026#34; width=\u0026#34;140\u0026#34;\u0026gt; \u0026lt;/el-table-column\u0026gt; \u0026lt;el-table-column prop=\u0026#34;entrydate\u0026#34; label=\u0026#34;入职日期\u0026#34; width=\u0026#34;180\u0026#34;\u0026gt; \u0026lt;/el-table-column\u0026gt; \u0026lt;el-table-column prop=\u0026#34;updatetime\u0026#34; label=\u0026#34;最后操作时间\u0026#34; width=\u0026#34;230\u0026#34;\u0026gt; \u0026lt;/el-table-column\u0026gt; \u0026lt;el-table-column label=\u0026#34;操作\u0026#34;\u0026gt; \u0026lt;el-button type=\u0026#34;primary\u0026#34; size=\u0026#34;mini\u0026#34;\u0026gt;编辑\u0026lt;/el-button\u0026gt; \u0026lt;el-button type=\u0026#34;danger\u0026#34; size=\u0026#34;mini\u0026#34;\u0026gt;删除\u0026lt;/el-button\u0026gt; \u0026lt;/el-table-column\u0026gt; \u0026lt;/el-table\u0026gt; \u0026lt;!-- 分页条 --\u0026gt; \u0026lt;el-pagination background layout=\u0026#34;sizes, prev, pager, next, jumper, total\u0026#34; @size-change=\u0026#34;handleSizeChange\u0026#34; @current-change=\u0026#34;handleCurrentChange\u0026#34; :total=\u0026#34;1000\u0026#34;\u0026gt;\u0026lt;/el-pagination\u0026gt; \u0026lt;/el-main\u0026gt; \u0026lt;/el-container\u0026gt; \u0026lt;/el-container\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;script\u0026gt; import axios from \u0026#39;axios\u0026#39;; export default { data() { return { // 表格数据 tableData: [], // 查询表单数据 searchForm: { name: \u0026#34;\u0026#34;, gender: \u0026#34;\u0026#34; }, // 入职日期范围 entrydate: [] } }, methods: { // 查询按钮点击事件 onsubmit() { alert(\u0026#34;查询数据！\u0026#34;); }, // 分页当前页改变事件 handleCurrentChange() { alert(\u0026#34;CurrentChange\u0026#34;); }, // 分页每页条数改变事件 handleSizeChange() { alert(\u0026#34;SizeChange\u0026#34;); } }, mounted() { // 组件初始化时从接口获取数据 axios.get(\u0026#34;https://mock.apifox.cn/m1/3128855-0-default/emp/list\u0026#34;).then((result) =\u0026gt; { this.tableData = result.data.data; }); }, } \u0026lt;/script\u0026gt; \u0026lt;style\u0026gt;\u0026lt;/style\u0026gt; DeptView.vue \u0026lt;template\u0026gt; \u0026lt;div\u0026gt; \u0026lt;!-- Element UI 布局容器 --\u0026gt; \u0026lt;el-container style=\u0026#34;height: 700px; border: 1px solid #eee\u0026#34;\u0026gt; \u0026lt;!-- 头部区域 --\u0026gt; \u0026lt;el-header style=\u0026#34;font-size:40px; background-color: rgb(238, 241, 246)\u0026#34;\u0026gt;tlias 智能学习辅助系统\u0026lt;/el-header\u0026gt; \u0026lt;el-container\u0026gt; \u0026lt;!-- 侧边栏区域 --\u0026gt; \u0026lt;el-aside width=\u0026#34;230px\u0026#34; style=\u0026#34;border: 1px solid #eee\u0026#34;\u0026gt; \u0026lt;!-- 侧边栏导航菜单 --\u0026gt; \u0026lt;el-menu :default-openeds=\u0026#34;[\u0026#39;1\u0026#39;, \u0026#39;3\u0026#39;]\u0026#34;\u0026gt; \u0026lt;el-submenu index=\u0026#34;1\u0026#34;\u0026gt; \u0026lt;template slot=\u0026#34;title\u0026#34;\u0026gt;\u0026lt;i class=\u0026#34;el-icon-message\u0026#34;\u0026gt;\u0026lt;/i\u0026gt;系统信息管理\u0026lt;/template\u0026gt; \u0026lt;!-- 导航链接 --\u0026gt; \u0026lt;el-menu-item index=\u0026#34;1-1\u0026#34;\u0026gt; \u0026lt;router-link to=\u0026#34;/dept\u0026#34;\u0026gt;部门管理\u0026lt;/router-link\u0026gt; \u0026lt;/el-menu-item\u0026gt; \u0026lt;el-menu-item index=\u0026#34;1-2\u0026#34;\u0026gt; \u0026lt;router-link to=\u0026#34;/emp\u0026#34;\u0026gt;员工管理\u0026lt;/router-link\u0026gt; \u0026lt;/el-menu-item\u0026gt; \u0026lt;/el-submenu\u0026gt; \u0026lt;/el-menu\u0026gt; \u0026lt;/el-aside\u0026gt; \u0026lt;!-- 主体区域 --\u0026gt; \u0026lt;el-main\u0026gt; \u0026lt;!-- 表格 --\u0026gt; \u0026lt;el-table :data=\u0026#34;tableData\u0026#34; border\u0026gt; \u0026lt;el-table-column prop=\u0026#34;name\u0026#34; label=\u0026#34;名称\u0026#34; width=\u0026#34;250\u0026#34;\u0026gt;\u0026lt;/el-table-column\u0026gt; \u0026lt;el-table-column prop=\u0026#34;updatetime\u0026#34; label=\u0026#34;最后操作时间\u0026#34; width=\u0026#34;250\u0026#34;\u0026gt;\u0026lt;/el-table-column\u0026gt; \u0026lt;el-table-column label=\u0026#34;操作\u0026#34;\u0026gt; \u0026lt;el-button type=\u0026#34;primary\u0026#34; size=\u0026#34;mini\u0026#34;\u0026gt;编辑\u0026lt;/el-button\u0026gt; \u0026lt;el-button type=\u0026#34;danger\u0026#34; size=\u0026#34;mini\u0026#34;\u0026gt;删除\u0026lt;/el-button\u0026gt; \u0026lt;/el-table-column\u0026gt; \u0026lt;/el-table\u0026gt; \u0026lt;/el-main\u0026gt; \u0026lt;/el-container\u0026gt; \u0026lt;/el-container\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;script\u0026gt; export default { data() { return { // 表格数据 tableData: [{ id: 1, name: \u0026#34;学工部\u0026#34;, updatetime: \u0026#34;2010-01-01 12:00:00\u0026#34; }, { id: 2, name: \u0026#34;教研部\u0026#34;, updatetime: \u0026#34;2010-01-01 12:00:00\u0026#34; }, { id: 3, name: \u0026#34;就业部\u0026#34;, updatetime: \u0026#34;2010-01-01 12:00:00\u0026#34; }, { id: 4, name: \u0026#34;人事部\u0026#34;, updatetime: \u0026#34;2010-01-01 12:00:00\u0026#34; }, { id: 5, name: \u0026#34;行政部\u0026#34;, updatetime: \u0026#34;2010-01-01 12:00:00\u0026#34; }] } }, methods: { // 可以在这里定义组件的方法 } } \u0026lt;/script\u0026gt; \u0026lt;style\u0026gt;\u0026lt;/style\u0026gt; index.js import Vue from \u0026#39;vue\u0026#39; // 导入 Vue Router import VueRouter from \u0026#39;vue-router\u0026#39; // 使用 Vue Router 插件 Vue.use(VueRouter) // 定义路由规则 const routes = [{ // 路由路径为 /emp path: \u0026#39;/emp\u0026#39;, // 路由名称为 emp name: \u0026#39;emp\u0026#39;, // 使用动态导入延迟加载组件 component: () =\u0026gt; import(\u0026#39;../views/tlias/EmpView.vue\u0026#39;) }, { // 路由路径为 /dept path: \u0026#39;/dept\u0026#39;, // 路由名称为 dept name: \u0026#39;dept\u0026#39;, // 使用动态导入延迟加载组件 component: () =\u0026gt; import(\u0026#39;../views/tlias/DeptView.vue\u0026#39;) }, { // 路由路径为 / path: \u0026#39;/\u0026#39;, // 重定向到 /dept redirect: \u0026#39;/dept\u0026#39; //默认访问dept } ] // 创建路由实例 const router = new VueRouter({ routes }) // 导出路由实例 export default router ","permalink":"https://kennems.github.io/zh/posts/tech/java-web%E5%BC%80%E5%8F%912/","summary":"Java Web开发(2) Vue Vue是一套前端框架，免除原生的JavaScript中的DOM操作，简化书写。 基于MVVM（Model-View-Vie","title":"Java Web开发(2)"},{"content":"Java20天速成——进阶课程(5) 网络编程 可以让设备中的程序与网络上其他设备中的程序进行数据交互（实现网络通信） 基本的通信架构\n基本的通信架构有2中形式：CS架构（Client客户端/Server服务端）、BS架构（Browser浏览器/Server服务器） 无论是CS架构，还是BS架构的软件都必须要依赖网络编程\n网络通信三要素： IP（Internet Protocol）： 设备在网络中的地址，是唯一的标识， 全称 “互联网协议地址”， 是分配给上网设备的唯一标志。\n两种形式：IPv4(32bit), IPv6(128bit) IPv6分成8段表示，每段每四位编码成一个十六进制位标识，数之间用冒号(:)分开。 公网IP， 内网IP\n公网IP：是可以连接互联网的IP地址； 内网IP：也叫局域网IP， 只能组织机构内部使用 192.168. 开头的就是常见的局域网地址，范围即为192.168.0.0--192.168.255.255，专门位组织机构内部使用 127.0.0.1 、localhost : 代表本机IP，只会寻找当前所在的主机 端口： 应用程序在设备中唯一的标识\n标记正在计算机设备上运行的应用程序的，被规定为一个16位的二进制，范围是0~65535 分类： 周知端口：0~1023： 被预先定义的知名应用占用（如：HTTP占用80， FTP占用21） 注册端口：1024~49151，分配给用户进程或某些应用程序 动态端口：49152到65535，之所以被称为动态端口，是因为它一般不固定分配某种进程，而是动态分配 协议： 连接和数据在网络中传输的规则\nInetAddress 代表IP地址 public static void main(String[] args) throws Exception { // 获取本地主机的 InetAddress InetAddress ip1 = InetAddress.getLocalHost(); System.out.println(ip1.getHostName()); // 输出本地主机的主机名 System.out.println(ip1.getHostAddress()); // 输出本地主机的 IP 地址 // 根据域名获取 InetAddress InetAddress ip2 = InetAddress.getByName(\u0026#34;www.baidu.com\u0026#34;); System.out.println(ip2.getHostName()); // 输出百度主机的主机名 System.out.println(ip2.getHostAddress()); // 输出百度主机的 IP 地址 // 检查主机是否可达（ping） System.out.println(ip2.isReachable(6000)); // 输出百度主机是否可达 } 开放式网络互联标准：OSI网络参考模型\nOSI网络参考模型：全球网络互联标准 传输层 UDP（User Datagram Protocol）：用户数据报协议；TCP（Transmission Control Protocol）：传输控制协议 UDP协议 特点：无连接，不可靠通信 不事先建立连接，数据按照包发，一包数据包含：自己的IP，程序端口，目的地IP，程序端口和数据（限制在64KB内）等, 发出去就不管了。 发送方不管对方是否在线，数据在中间丢失也不管，如果接受方收到数据也不返回确认，所以不可靠的 UDP通信 package com.showguan.InternetDemo; import java.net.DatagramPacket; import java.net.DatagramSocket; import java.net.InetAddress; import java.net.SocketException; import java.util.Scanner; public class Client { public static void main(String[] args) throws Exception { DatagramSocket socket = new DatagramSocket(); // 创建客户端 DatagramSocket 实例 Scanner sc = new Scanner(System.in); // 创建 Scanner 对象用于输入消息 while (true) { System.out.println(\u0026#34;请输入你需要发送的消息(exit退出)\u0026#34;); String msg = sc.nextLine(); // 读取用户输入的消息 if (msg.equals(\u0026#34;exit\u0026#34;)) { // 如果输入 exit，则退出循环 System.out.println(\u0026#34;退出成功\u0026#34;); socket.close(); // 关闭客户端 Socket break; } byte[] bytes = msg.getBytes(); // 将消息转换为字节数组 DatagramPacket packet = new DatagramPacket(bytes, bytes.length , InetAddress.getLocalHost(), 6666); // 创建要发送的 DatagramPacket socket.send(packet); // 发送数据报文到服务器 } } } package com.showguan.InternetDemo; import java.net.DatagramPacket; import java.net.DatagramSocket; import java.net.SocketException; public class Server { public static void main(String[] args) throws Exception { DatagramSocket socket = new DatagramSocket(6666); // 创建服务器端 DatagramSocket 实例，监听端口 6666 while (true) { byte[] buffer = new byte[1024*64]; // 创建字节数组用于存储接收的数据 DatagramPacket packet = new DatagramPacket(buffer, buffer.length); // 创建 DatagramPacket 用于接收数据 socket.receive(packet); // 接收客户端发送的数据报文 System.out.println(packet.getAddress()); // 打印客户端的 IP 地址 System.out.println(packet.getPort()); // 打印客户端的端口号 int len = packet.getLength(); // 获取接收到的数据长度 String s = new String(buffer, 0, len); // 将接收到的字节数组转换为字符串 System.out.println(s); // 打印接收到的消息 System.out.println(\u0026#34;--------------------\u0026#34;); } } } TCP协议 特点：面向连接，可靠通信 TCP的最终目的：要保证在不可靠的信道上实现可靠的传输 TCP主要有三个步骤实现可靠传输：三次握手建立连接，传输数据进行确认，四次挥手断开连接 可靠连接：确定通信双方，收发消息都是正常无问题的（全双工）\n三次握手才能确定彼此收发消息都是没问题的。\n传输数据会进行确认，以保证数据传输的可靠性\nTCP通信-支持与多个客户端同时通信 package com.showguan.CaseDemo; import java.io.DataOutputStream; import java.io.OutputStream; import java.net.Socket; import java.util.Scanner; public class Client { public static void main(String[] args) throws Exception { Socket socket = new Socket(\u0026#34;127.0.0.1\u0026#34;, 8888); // 创建客户端 Socket 并连接服务器 OutputStream os = socket.getOutputStream(); // 获取 Socket 的输出流 DataOutputStream dos = new DataOutputStream(os); // 包装输出流为 DataOutputStream Scanner sc = new Scanner(System.in); new ClientReaderThread(socket).start(); // 启动客户端读线程，用于接收服务端消息 while (true) { System.out.println(\u0026#34;请输入你需要发送的消息\u0026#34;); String msg = sc.nextLine(); // 读取用户输入的消息 if(msg.equals(\u0026#34;exit\u0026#34;)){ // 如果输入 exit，则退出循环 socket.close(); // 关闭客户端 Socket System.out.println(\u0026#34;成功退出通信\u0026#34;); dos.close(); // 关闭输出流 break; } dos.writeUTF(msg); // 向服务器发送消息 dos.flush(); // 刷新输出流，确保消息发送 } } } package com.showguan.CaseDemo; import java.io.DataInputStream; import java.io.InputStream; import java.net.Socket; public class ClientReaderThread extends Thread { private Socket socket; public ClientReaderThread(Socket socket) { this.socket = socket; // 初始化 Socket } @Override public void run() { try { InputStream is = socket.getInputStream(); // 获取输入流 DataInputStream dis = new DataInputStream(is); // 包装输入流为 DataInputStream while (true) { try { String msg = dis.readUTF(); // 读取服务端发送的消息 System.out.println(msg); // 打印接收到的消息 } catch (Exception e) { System.out.println(\u0026#34;您成功下线了！\u0026#34;); // 打印客户端下线信息 socket.close(); // 关闭 Socket 连接 dis.close(); // 关闭输入流 break; // 退出循环 } } } catch (Exception e) { e.printStackTrace(); } } } package com.showguan.CaseDemo; import java.io.*; import java.net.ServerSocket; import java.net.Socket; import java.util.ArrayList; import java.util.List; public class Server { public static List\u0026lt;Socket\u0026gt; onLineSockets = new ArrayList\u0026lt;\u0026gt;(); // 存储在线的客户端 Socket public static void main(String[] args) throws Exception { System.out.println(\u0026#34;服务端启动成功！\u0026#34;); ServerSocket serverSocket = new ServerSocket(8888); // 创建服务器端 ServerSocket，监听端口 8888 while (true) { Socket socket = serverSocket.accept(); // 等待客户端连接 onLineSockets.add(socket); // 添加客户端 Socket 到在线列表 System.out.println(\u0026#34;有人上线了！\u0026#34; + socket.getRemoteSocketAddress()); // 打印客户端地址信息 ServerReaderThread serverReaderThread = new ServerReaderThread(socket); // 创建服务器端读线程 serverReaderThread.start(); // 启动服务器端读线程处理客户端消息 } } } package com.showguan.CaseDemo; import java.io.*; import java.net.Socket; public class ServerReaderThread extends Thread { private Socket socket; public ServerReaderThread(Socket socket) { this.socket = socket; // 初始化 Socket } @Override public void run() { try { InputStream is = socket.getInputStream(); // 获取输入流 DataInputStream dis = new DataInputStream(is); // 包装输入流为 DataInputStream while (true) { String msg = null; try { msg = dis.readUTF(); // 读取客户端发送的消息 System.out.println(msg); // 打印接收到的消息 sendMsgToAll(msg); // 将消息发送给所有在线客户端 } catch (Exception e) { System.out.println(\u0026#34;用户： \u0026#34; + socket.getRemoteSocketAddress() + \u0026#34;下线了\u0026#34;); // 打印客户端下线信息 Server.onLineSockets.remove(socket); // 从在线列表中移除客户端 Socket socket.close(); // 关闭 Socket 连接 dis.close(); // 关闭输入流 break; // 退出循环 } } } catch (Exception e) { e.printStackTrace(); } } // 将消息发送给所有在线客户端 private void sendMsgToAll(String msg) throws Exception { for (Socket onLineSocket : Server.onLineSockets) { // 遍历在线客户端列表 if(onLineSocket.equals(socket)){ // 排除当前客户端 continue; } OutputStream os = onLineSocket.getOutputStream(); // 获取客户端的输出流 DataOutputStream dos = new DataOutputStream(os); // 包装输出流为 DataOutputStream dos.writeUTF(msg); // 发送消息给客户端 dos.flush(); // 刷新输出流 } } } BS 架构 import java.io.*; import java.net.*; import java.util.concurrent.*; /** * 一个简单的基于Socket的HTTP服务器示例 */ public class SimpleHttpServer { public static void main(String[] args) throws Exception { // 显示服务端启动成功信息 System.out.println(\u0026#34;服务端启动成功！\u0026#34;); // 创建ServerSocket并监听指定端口 ServerSocket serverSocket = new ServerSocket(8081); // 创建线程池，用于处理客户端请求 ThreadPoolExecutor pool = new ThreadPoolExecutor( 12 * 2, // 核心线程数 12 * 2, // 最大线程数 0, // 线程空闲超时时间 TimeUnit.SECONDS, // 时间单位 new ArrayBlockingQueue\u0026lt;\u0026gt;(8), // 任务队列 Executors.defaultThreadFactory(), // 线程工厂 new ThreadPoolExecutor.AbortPolicy()); // 拒绝策略 // 服务端循环监听客户端请求 while (true) { Socket socket = serverSocket.accept(); // 等待客户端连接 System.out.println(\u0026#34;有人访问网页！\u0026#34; + socket.getRemoteSocketAddress()); // 显示客户端连接信息 pool.execute(new ServerReaderThread(socket)); // 将连接交给线程池处理 } } } /** * 服务器读取线程，用于处理客户端请求 */ class ServerReaderThread extends Thread { private Socket socket; // 与客户端通信的Socket对象 /** * 构造方法，初始化Socket对象 * @param socket 与客户端通信的Socket对象 */ public ServerReaderThread(Socket socket) { this.socket = socket; } /** * 线程运行方法，处理客户端请求 */ @Override public void run() { try { OutputStream os = socket.getOutputStream(); // 获取输出流 PrintStream ps = new PrintStream(os); // 使用PrintStream包装输出流，方便写入响应数据 // HTTP响应头部信息 ps.println(\u0026#34;HTTP/1.1 200 OK\u0026#34;); // 响应状态码及状态信息 ps.println(\u0026#34;Content-Type:text/html;charset=UTF-8\u0026#34;); // 内容类型及编码 ps.println(); // 空行，表示头部信息结束 // HTTP响应体，返回一个简单的HTML页面 ps.println(\u0026#34;\u0026lt;div style=\u0026#39;color:red;font-size:120px;text-align:center\u0026#39;\u0026gt;Kennem\u0026lt;div\u0026gt;\u0026#34;); // 红色文本 ps.println(\u0026#34;\u0026lt;html\u0026gt;\u0026#34;); ps.println(\u0026#34;\u0026lt;head\u0026gt;\u0026#34;); ps.println(\u0026#34;\u0026lt;title\u0026gt;Welcome\u0026lt;/title\u0026gt;\u0026#34;); ps.println(\u0026#34;\u0026lt;/head\u0026gt;\u0026#34;); ps.println(\u0026#34;\u0026lt;body\u0026gt;\u0026#34;); ps.println(\u0026#34;\u0026lt;h1 style=\u0026#39;color:red;text-align:center;\u0026#39;\u0026gt;Welcome to my server!\u0026lt;/h1\u0026gt;\u0026#34;); ps.println(\u0026#34;\u0026lt;p style=\u0026#39;text-align:center;\u0026#39;\u0026gt;Here are some interesting links:\u0026lt;/p\u0026gt;\u0026#34;); ps.println(\u0026#34;\u0026lt;ul\u0026gt;\u0026#34;); ps.println(\u0026#34;\u0026lt;li\u0026gt;\u0026lt;a href=\u0026#39;https://www.example.com\u0026#39;\u0026gt;Example Website\u0026lt;/a\u0026gt;\u0026lt;/li\u0026gt;\u0026#34;); ps.println(\u0026#34;\u0026lt;li\u0026gt;\u0026lt;a href=\u0026#39;https://www.example2.com\u0026#39;\u0026gt;Another Example Website\u0026lt;/a\u0026gt;\u0026lt;/li\u0026gt;\u0026#34;); ps.println(\u0026#34;\u0026lt;/ul\u0026gt;\u0026#34;); ps.println(\u0026#34;\u0026lt;p style=\u0026#39;text-align:center;\u0026#39;\u0026gt;And here\u0026#39;s an image:\u0026lt;/p\u0026gt;\u0026#34;); ps.println(\u0026#34;\u0026lt;div style=\u0026#39;text-align:center;\u0026#39;\u0026gt;\u0026lt;img src=\u0026#39;https://th.bing.com/th/id/OIG3.ryWiFmseYX.jWcO7pmoz?pid=ImgGn\u0026#39; alt=\u0026#39;Example Image\u0026#39;\u0026gt;\u0026lt;/div\u0026gt;\u0026#34;); ps.println(\u0026#34;\u0026lt;/body\u0026gt;\u0026#34;); ps.println(\u0026#34;\u0026lt;/html\u0026gt;\u0026#34;); ps.close(); // 关闭输出流 } catch (Exception e) { e.printStackTrace(); // 输出异常信息 } } } 单元测试 就是针对最小的功能单元（方法），编写测试代码对其进行正确性测试。 Junit单元测试框架\n可以用来对方法进行测试，是第三方公司开源出来的 优点\n可以灵活的编写测试代码，可以针对某个方法执行测试，也支持一键完成对全部方法的自动化测试，且各自独立 不需要程序员去分析测试的结果，会自动生成测试报告 /** * StringUtilTest 类是用于测试 StringUtil 类中各个方法的测试类。 * 主要测试了 StringUtil 类中 printNumber() 和 getMaxIndex() 方法的功能和正确性。 * * 测试方法说明： * - testprintNumber(): 测试 printNumber() 方法，验证其对输入字符串的处理是否正确。 * - testGetMaxIndex(): 测试 getMaxIndex() 方法，验证其返回字符串中最大字母的索引是否正确。 * * 测试生命周期注解说明： * - @BeforeClass: 在该测试类的所有测试方法执行之前执行，用于初始化静态资源或执行一次性设置。 * - test11(): 测试 BeforeClass 生命周期方法，用于打印 BeforeClass 执行信息。 * * - @Before: 在每个测试方法执行之前执行，用于准备测试环境或执行某些预处理操作。 * - test1(): 测试 Before 生命周期方法，用于打印 Before 执行信息。 * * - @Test: 表示该方法是一个测试方法。 * - testprintNumber(): 测试 printNumber() 方法，验证其功能是否正确。 * - testGetMaxIndex(): 测试 getMaxIndex() 方法，验证其功能和返回值是否正确。 * * - @After: 在每个测试方法执行之后执行，用于清理测试环境或执行某些收尾操作。 * - test2(): 测试 After 生命周期方法，用于打印 After 执行信息。 * * - @AfterClass: 在该测试类的所有测试方法执行之后执行，用于执行清理操作或释放资源。 * - test22(): 测试 AfterClass 生命周期方法，用于打印 AfterClass 执行信息。 * * 其他说明： * - 使用断言机制验证 getMaxIndex() 方法的正确性。 * - 在 testGetMaxIndex() 方法中，使用 Assert.assertEquals() 断言方法，对比预期返回值和实际返回值是否相等。 */ public class StringUtilTest { /** * 在所有测试方法执行之前执行的静态方法，用于初始化静态资源或执行一次性设置。 */ @BeforeClass public static void test11() { System.out.println(\u0026#34;---test11 beforeClass 执行了---\u0026#34;); } /** * 在每个测试方法执行之前执行的方法，用于准备测试环境或执行某些预处理操作。 */ @Before public void test1() { System.out.println(\u0026#34;---test1 before 执行了---\u0026#34;); } /** * 测试 printNumber() 方法，验证其对输入字符串的处理是否正确。 */ @Test public void testprintNumber() { StringUtil.printNumber(\u0026#34;abcdefg\u0026#34;); StringUtil.printNumber(null); } /** * 测试 getMaxIndex() 方法，验证其返回字符串中最大字母的索引是否正确。 */ @Test public void testGetMaxIndex() { int idx1 = StringUtil.getMaxIndex(\u0026#34;abcdefg\u0026#34;); System.out.println(idx1); int idx2 = StringUtil.getMaxIndex(null); System.out.println(idx2); // 断言机制 Assert.assertEquals(\u0026#34;方法内部有bug\u0026#34;, 6, idx1); } /** * 在每个测试方法执行之后执行的方法，用于清理测试环境或执行某些收尾操作。 */ @After public void test2() { System.out.println(\u0026#34;---test2 after 执行了---\u0026#34;); } /** * 在所有测试方法执行之后执行的静态方法，用于执行清理操作或释放资源。 */ @AfterClass public static void test22() { System.out.println(\u0026#34;---test22 afterClass 执行了---\u0026#34;); } } 在测试方法执行前执行的方法：常用于：初始化资源 在测试方法执行完后再执行的方法，常用于：释放资源 在Junit 5.xxxx版本\n@Before-\u0026gt;@BeforeEach @After-\u0026gt;@AfterEach @BeforeClass-\u0026gt;@BeforeAll @AfterClass-\u0026gt;@AfterAll 反射(Reflection) 反射：加载类，并允许以编程的方式解剖类中的各种成分（成员变量，方法，构造器等） 1.加载类 public class Test1Class { public static void main(String[] args) throws Exception { // 1. 直接通过类名获取 Class 对象 Class c1 = String.class; System.out.println(c1.getName()); System.out.println(c1.getSimpleName()); // 2. 通过 Class.forName() 方法根据类的全限定名获取 Class 对象 Class c2 = Class.forName(\u0026#34;com.showguan.reflect_demo.Student\u0026#34;); System.out.println(c1 == c2); // 3. 通过实例对象的 getClass() 方法获取 Class 对象 Student s = new Student(); Class c3 = s.getClass(); System.out.println(c1 == c3); } } 2.获取构造器 public class Test2Constructor { /** * 获取类的所有公共构造方法并输出构造方法的名称和参数个数。 */ @Test public void testGetConstructors(){ Class c = Cat.class; Constructor[] constructors = c.getConstructors(); for (Constructor constructor : constructors) { System.out.println(constructor.getName() + \u0026#34;---\u0026gt;\u0026#34; + constructor.getParameterCount()); } } /** * 获取指定构造方法并通过 newInstance() 方法创建对象。 * 使用 setAccessible(true) 方法解除私有构造方法的访问限制。 */ @Test public void testGetConstructor() throws Exception { Class c = Cat.class; // 获取无参构造方法 Constructor constructor = c.getDeclaredConstructor(); System.out.println(constructor.getName() + \u0026#34; \u0026#34; + constructor.getParameterCount()); constructor.setAccessible(true); Cat cat = (Cat) constructor.newInstance(); System.out.println(cat); // 获取带参数的构造方法 Constructor constructor1 = c.getDeclaredConstructor(String.class, int.class); System.out.println(constructor1.getName() + \u0026#34; \u0026#34; + constructor1.getParameterCount()); constructor1.setAccessible(true); Cat cat1 = (Cat) constructor1.newInstance(\u0026#34;奶牛猫\u0026#34;, 3); System.out.println(cat1); } } 3.获取成员变量 public class Test4Field { /** * 获取类的所有字段信息，并演示了如何操作类的字段。 */ @Test public void testGetFields() throws Exception { Class c = Cat.class; // 获取类的所有字段信息并输出字段名和类型 Field[] fields = c.getDeclaredFields(); for (Field field : fields) { System.out.println(field.getName() + \u0026#34;---\u0026gt;\u0026#34; + field.getType()); } // 定位到特定成员变量 Field fAge = c.getDeclaredField(\u0026#34;age\u0026#34;); System.out.println(fAge.getName() + \u0026#34;---\u0026gt;\u0026#34; + fAge.getType()); Field fName = c.getDeclaredField(\u0026#34;name\u0026#34;); System.out.println(fName.getName() + \u0026#34;---\u0026gt;\u0026#34; + fName.getType()); // 创建 Cat 对象，并通过反射操作字段 Cat cat = new Cat(); fName.setAccessible(true); // 设置私有字段可访问 fName.set(cat, \u0026#34;奶牛猫\u0026#34;); // 设置字段值 String name = (String) fName.get(cat); // 获取字段值 System.out.println(name); } } 4.获取类方法 public class Test4Method { /** * 获取类的所有方法信息，并演示了如何通过反射调用类的方法。 */ @Test public void testGetMethods() throws Exception { Class c = Cat.class; // 获取类的所有方法信息并输出方法名、参数个数和返回类型 Method[] methods = c.getDeclaredMethods(); for (Method method : methods) { System.out.println(method.getName() + \u0026#34;---\u0026gt;\u0026#34; + method.getParameterCount() + \u0026#34;---\u0026gt;\u0026#34; + method.getReturnType()); } // 获取特定方法信息并输出 Method run = c.getDeclaredMethod(\u0026#34;run\u0026#34;); System.out.println(run.getName() + \u0026#34;---\u0026gt;\u0026#34; + run.getParameterCount() + \u0026#34;---\u0026gt;\u0026#34; + run.getReturnType()); Method eat = c.getDeclaredMethod(\u0026#34;eat\u0026#34;, String.class); System.out.println(eat.getName() + \u0026#34;---\u0026gt;\u0026#34; + eat.getParameterCount() + \u0026#34;---\u0026gt;\u0026#34; + eat.getReturnType()); // 创建 Cat 对象，并通过反射调用方法 Cat cat = new Cat(); run.setAccessible(true); // 设置私有方法可访问 Object invoke = run.invoke(cat); // 调用方法 System.out.println(invoke); eat.setAccessible(true); // 设置私有方法可访问 Object invoke1 = eat.invoke(cat, \u0026#34;鱼饼干\u0026#34;); // 调用方法 System.out.println(invoke1); } } 案例 public class ObjectFrame { /** * 将对象信息保存到文件。 * * @param obj 要保存信息的对象 * @throws Exception 可能抛出的异常 */ public static void saveObject(Object obj) throws Exception { // 创建 PrintStream 对象，用于写入文件 PrintStream ps = new PrintStream(new FileOutputStream(\u0026#34;junit-reflect-annotation-proxy-app\\\\src\\\\com\\\\showguan\\\\reflect_demo\\\\data.txt\u0026#34;, true)); Class c = obj.getClass(); String cName = c.getSimpleName(); ps.println(\u0026#34;--------------\u0026#34; + cName + \u0026#34;-----------------\u0026#34;); // 获取对象的所有字段信息，并写入文件 Field[] fields = c.getDeclaredFields(); for (Field field : fields) { String name = field.getName(); field.setAccessible(true); // 设置字段可访问 String value = field.get(obj) + \u0026#34;\u0026#34;; // 获取字段值 ps.println(name + \u0026#34; \u0026#34; + value); } ps.close(); // 关闭流 } } /** * Test5 类是一个用于测试 ObjectFrame 类的主程序。 * 主要创建了一个 Student 对象和一个 Teacher 对象，并将它们的信息保存到文件中。 */ package com.showguan.reflect_demo; public class Test5 { public static void main(String[] args) throws Exception{ // 创建 Student 对象和 Teacher 对象 Student s1 = new Student(\u0026#34;Kennem\u0026#34;, \u0026#39;男\u0026#39;, 21, 181.2, \u0026#34;lelele\u0026#34;); Teacher t1 = new Teacher(\u0026#34;tytytyt\u0026#34;, 21000); // 将对象信息保存到文件中 ObjectFrame.saveObject(s1); ObjectFrame.saveObject(t1); } } 注解（Annotation） 就是Java代码里的特殊标记，比如@Override, @Test等，作用是：让其他程序根据注解信息来决定怎么执行该程序 注意：注解可以用在类上，构造器上，方法上，成员变量上，参数上，等位置 自定义注解 /** * MyTest1 注解是一个自定义注解，具有三个属性： * - a：字符串类型属性。 * - b：布尔类型属性，默认值为 true。 * - c：字符串数组类型属性。 */ package com.showguan.annotation_demo; public @interface MyTest1 { String a(); boolean b() default true; String[] c(); } /** * MyTest2 注解是一个自定义注解，具有两个属性： * - value：字符串类型属性。 * - age：整数类型属性，默认值为 23。 * 如果注解中只有一个 value 属性，使用注解时，value 名称可以不写。 */ package com.showguan.annotation_demo; public @interface MyTest2 { // 特殊属性名 // 如果注解中只有一个value属性，使用注解时，value名称可以不写 String value(); int age() default 23; } /** * AnnotationTest1 类是一个演示注解的使用的示例程序。 * 使用了 MyTest1 和 MyTest2 两个自定义注解。 */ package com.showguan.annotation_demo; @MyTest1(a=\u0026#34;Kennem\u0026#34;, c={\u0026#34;HTML\u0026#34;, \u0026#34;CSS\u0026#34;}) public class AnnotationTest1 { /** * 使用了 MyTest1 注解，并指定了各属性的值。 */ @MyTest1(a=\u0026#34;tytyt\u0026#34;, b=false, c={\u0026#34;python\u0026#34;, \u0026#34;c++\u0026#34;}) public static void main(String[] args) { } /** * 使用了 MyTest2 注解，并指定了 value 属性的值。 */ @MyTest2(\u0026#34;value\u0026#34;) public static void test1(){ } } 元注解 修饰注解的注解 /** * MyTest3 注解是一个自定义注解，用于标记类、方法和字段。 * 它具有以下特性： * - @Target({ElementType.TYPE, ElementType.METHOD, ElementType.FIELD})：指定该注解可以用于类、方法和字段上。 * - @Retention(RetentionPolicy.RUNTIME)：声明注解的保留周期为运行时，使得该注解在运行时可以通过反射获取到。 */ package com.showguan.annotation_demo; import java.lang.annotation.ElementType; import java.lang.annotation.Retention; import java.lang.annotation.RetentionPolicy; import java.lang.annotation.Target; @Target({ElementType.TYPE, ElementType.METHOD, ElementType.FIELD}) @Retention(RetentionPolicy.RUNTIME) public @interface MyTest3 { } /** * AnnotationTest2 类是一个演示注解的使用的示例程序。 * 使用了 MyTest3 注解，并标记了类、字段和方法。 */ package com.showguan.annotation_demo; import org.junit.Test; @MyTest3 public class AnnotationTest2 { /** * 使用了 MyTest3 注解，标记了字段。 */ @MyTest3 private int test; /** * 使用了 MyTest3 注解，标记了方法。 */ @MyTest3 @Test public void m() { } } 注解的解析\n就是判断类上，方法上，成员变量上是否存在注解，并把注解里的内容给解析出来 解析注解 package com.showguan.annotation_demo; import java.lang.annotation.ElementType; import java.lang.annotation.Retention; import java.lang.annotation.RetentionPolicy; import java.lang.annotation.Target; // 定义一个自定义注解 MyTest4 @Target({ElementType.TYPE, ElementType.METHOD}) // 可以标记在类和方法上 @Retention(RetentionPolicy.RUNTIME) // 注解信息在运行时保留 public @interface MyTest4 { String value(); // 声明一个属性 value，类型为 String double aaa() default 100; // 声明一个属性 aaa，类型为 double，默认值为 100 String[] bbb(); // 声明一个属性 bbb，类型为 String 数组 } package com.showguan.annotation_demo; // 使用自定义注解 MyTest4 标记类和方法 @MyTest4(value = \u0026#34;Kennem\u0026#34;, aaa = 10.0, bbb = {\u0026#34;至尊宝\u0026#34;, \u0026#34;tytt\u0026#34;}) public class Demo { // 使用自定义注解 MyTest4 标记方法 @MyTest4(value = \u0026#34;yl\u0026#34;, aaa = 199.2, bbb = {\u0026#34;best\u0026#34;, \u0026#34;牛夫人\u0026#34;}) public void test1(){ } } package com.showguan.annotation_demo; import org.junit.Test; import java.lang.annotation.Annotation; import java.lang.reflect.Method; import java.util.Arrays; // 测试解析自定义注解 MyTest4 public class AnnotationTest3 { // 解析类上的自定义注解 @Test public void parseClass(){ Class c = Demo.class; if(c.isAnnotationPresent(MyTest4.class)){ MyTest4 myTest4 = (MyTest4) c.getDeclaredAnnotation(MyTest4.class); System.out.println(myTest4.value()); System.out.println(myTest4.aaa()); System.out.println(Arrays.toString(myTest4.bbb())); } } // 解析方法上的自定义注解 @Test public void parseMethod() throws Exception{ Class c = Demo.class; Method m = c.getDeclaredMethod(\u0026#34;test1\u0026#34;); if(m.isAnnotationPresent(MyTest4.class)){ MyTest4 myTest4 = (MyTest4) m.getDeclaredAnnotation(MyTest4.class); System.out.println(myTest4.value()); System.out.println(myTest4.aaa()); System.out.println(Arrays.toString(myTest4.bbb())); } } } 模拟Junit框架 package com.showguan.annotation_demo; import java.lang.annotation.ElementType; import java.lang.annotation.Retention; import java.lang.annotation.RetentionPolicy; import java.lang.annotation.Target; // 定义一个自定义注解 MyTest，用于标记方法 @Target(ElementType.METHOD) // 可以标记在方法上 @Retention(RetentionPolicy.RUNTIME) // 注解信息在运行时保留 public @interface MyTest { } package com.showguan.annotation_demo; import org.junit.Test; import java.lang.reflect.InvocationTargetException; import java.lang.reflect.Method; // 测试自定义注解 MyTest public class AnnotationTest4 { // 标记为 MyTest 的方法 @MyTest public void test1(){ System.out.println(\u0026#34;---test1---\u0026#34;); } // 标记为 MyTest 的方法 @MyTest public void test2(){ System.out.println(\u0026#34;---test2---\u0026#34;); } // 没有标记为 MyTest 的方法 public void test3(){ System.out.println(\u0026#34;---test3---\u0026#34;); } // 没有标记为 MyTest 的方法 public void test4(){ System.out.println(\u0026#34;---test4---\u0026#34;); } // 主方法用于运行测试标记为 MyTest 的方法 public static void main(String[] args) throws Exception{ AnnotationTest4 a = new AnnotationTest4(); Class c = AnnotationTest4.class; Method[] methods = c.getDeclaredMethods(); for (Method method : methods) { if(method.isAnnotationPresent(MyTest.class)){ method.invoke(a); // 调用标记为 MyTest 的方法 } } } } 动态代理 Proxy类 package com.showguan.proxy_demo; import java.lang.reflect.InvocationHandler; import java.lang.reflect.Method; import java.lang.reflect.Proxy; // 代理模式示例 public class ProxyUtil { // 创建代理对象的方法 public static Star createProxy(BigStar bigStar) { // 使用Java的动态代理创建代理对象 Star starProxy = (Star) Proxy.newProxyInstance( ProxyUtil.class.getClassLoader(), // 使用当前类的类加载器加载代理类 new Class[]{Star.class}, // 指定代理对象实现的接口，这里是Star接口 new InvocationHandler() { // 设置代理对象的调用处理器，即InvocationHandler @Override public Object invoke(Object proxy, Method method, Object[] args) throws Throwable { /** * Object proxy：代理对象，用于调用被代理对象的方法或执行其他操作。 * Method method：表示被调用的方法，允许获取方法的相关信息或调用该方法。 * Object[] args：方法的参数数组，包含了被调用方法的参数列表，允许获取和处理参数。 */ // 对代理对象的方法进行拦截和增强 if (method.getName().equals(\u0026#34;sing\u0026#34;)) { // 如果是sing方法 System.out.println(\u0026#34;准备话筒，收钱20万\u0026#34;); // 增强处理：准备话筒 return method.invoke(bigStar, args); // 调用原始对象的方法 } else if (method.getName().equals(\u0026#34;dance\u0026#34;)) { // 如果是dance方法 System.out.println(\u0026#34;准备场地，收钱1000万\u0026#34;); // 增强处理：准备场地 return method.invoke(bigStar, args); // 调用原始对象的方法 } return method.invoke(bigStar, args); // 对于其他方法，直接调用原始对象的方法 } }); return starProxy; // 返回创建的代理对象 } } Star接口 package com.showguan.proxy_demo; // 明星接口，定义了唱歌和跳舞的方法 public interface Star { String sing(String name); // 唱歌方法，传入歌曲名字，返回感谢信息 void dance(); // 跳舞方法 } BigStar类 package com.showguan.proxy_demo; // 具体的明星类，实现了Star接口 public class BigStar implements Star { private String name; // 明星的姓名 // 构造方法，传入明星的姓名 public BigStar(String name) { this.name = name; } // 获取明星姓名的方法 public String getName() { return name; } // 设置明星姓名的方法 public void setName(String name) { this.name = name; } // 实现唱歌方法，传入歌曲名字，打印出歌手名字和歌曲名字，并返回感谢信息 @Override public String sing(String name) { System.out.println(this.name + \u0026#34;正在唱歌:\u0026#34; + name); return \u0026#34;感谢大家\u0026#34;; } // 实现跳舞方法，打印出歌手名字并提示正在跳舞 @Override public void dance() { System.out.println(this.name + \u0026#34;正在优美的跳舞\u0026#34;); } } Test类 package com.showguan.proxy_demo; // 测试类 public class Test { public static void main(String[] args) { BigStar s = new BigStar(\u0026#34;ycy\u0026#34;); // 创建一个具体的明星对象 Star starProxy = ProxyUtil.createProxy(s); // 使用代理工具类创建代理对象 String rs = starProxy.sing(\u0026#34;卡路里\u0026#34;); // 调用代理对象的唱歌方法 System.out.println(rs); // 打印唱歌方法的返回值 starProxy.dance(); // 调用代理对象的跳舞方法 } } 使用案例 接口 package com.showguan.proxy_demo2; // 用户服务接口，定义了登录、删除用户和查询用户的方法 public interface UserService { void login(String loginName, String passWrod) throws Exception; // 登录方法，传入登录名和密码 void deleteUsers() throws Exception; // 删除用户方法 String[] selectUsers() throws Exception; // 查询用户方法，返回用户数组 } 接口实现 package com.showguan.proxy_demo2; // 用户服务实现类，实现了UserService接口 public class UserServiceImpl implements UserService { // 实现登录方法，验证用户名密码并输出登录成功或失败信息 @Override public void login(String loginName, String passWrod) throws Exception { if (\u0026#34;admin\u0026#34;.equals(loginName) \u0026amp;\u0026amp; passWrod.equals(\u0026#34;123456\u0026#34;)) { System.out.println(\u0026#34;登录成功！\u0026#34;); } else { System.out.println(\u0026#34;用户名或密码错误！\u0026#34;); } Thread.sleep(1000); // 模拟登录操作耗时 } // 实现删除用户方法，输出删除成功信息 @Override public void deleteUsers() throws Exception { System.out.println(\u0026#34;成功删除了10000个用户\u0026#34;); Thread.sleep(1000); // 模拟删除操作耗时 } // 实现查询用户方法，输出查询结果并返回用户数组 @Override public String[] selectUsers() throws Exception { System.out.println(\u0026#34;查询出三个用户：\u0026#34;); String[] names = {\u0026#34;kenene\u0026#34;, \u0026#34;Kennem\u0026#34;, \u0026#34;kkk\u0026#34;}; Thread.sleep(1000); // 模拟查询操作耗时 return names; } } 代理工具类 package com.showguan.proxy_demo2; import java.lang.reflect.InvocationHandler; import java.lang.reflect.Method; import java.lang.reflect.Proxy; // 代理工具类，用于创建代理对象 public class ProxyUtil { // 创建代理对象的方法 public static UserService createProxy(UserService userService) { UserService userServiceProxy = (UserService) Proxy.newProxyInstance( ProxyUtil.class.getClassLoader(), // 使用当前类的类加载器加载代理类 new Class[]{UserService.class}, // 指定代理对象实现的接口，这里是UserService接口 new InvocationHandler() { // 设置代理对象的调用处理器，即InvocationHandler @Override public Object invoke(Object proxy, Method method, Object[] args) throws Throwable { if (method.getName().equals(\u0026#34;login\u0026#34;) || method.getName().equals(\u0026#34;deleteUsers\u0026#34;) || method.getName().equals(\u0026#34;selectUsers\u0026#34;)) { // 如果是登录、删除用户或查询用户方法 long startTime = System.currentTimeMillis(); // 记录方法调用开始时间 Object rs = method.invoke(userService, args); // 调用原始对象的方法 long endTime = System.currentTimeMillis(); // 记录方法调用结束时间 System.out.println(method.getName() + \u0026#34;方法执行耗时:\u0026#34; + (endTime - startTime) / (1000.0) + \u0026#34;s\u0026#34;); // 输出方法执行耗时 return rs; // 返回方法调用结果 } else { // 对于其他方法，直接调用原始对象的方法 Object rs = method.invoke(userService, args); return rs; } } }); return userServiceProxy; // 返回创建的代理对象 } } 测试类 package com.showguan.proxy_demo2; // 测试类 public class Test { public static void main(String[] args) throws Exception { UserService us = ProxyUtil.createProxy(new UserServiceImpl()); // 使用代理工具类创建代理对象 us.login(\u0026#34;admin\u0026#34;, \u0026#34;123456\u0026#34;); // 调用代理对象的登录方法 System.out.println(\u0026#34;---------------\u0026#34;); us.deleteUsers(); // 调用代理对象的删除用户方法 System.out.println(\u0026#34;---------------\u0026#34;); us.selectUsers(); // 调用代理对象的查询用户方法 System.out.println(\u0026#34;---------------\u0026#34;); } } ","permalink":"https://kennems.github.io/zh/posts/tech/java20%E5%A4%A9%E9%80%9F%E6%88%90%E8%BF%9B%E9%98%B6%E8%AF%BE%E7%A8%8B5/","summary":"Java20天速成——进阶课程(5) 网络编程 可以让设备中的程序与网络上其他设备中的程序进行数据交互（实现网络通信） 基本的通信架构 基本的通信架","title":"Java20天速成——进阶课程(5)"},{"content":"力扣周赛394(20240421) 第三题100290. 使矩阵满足条件的最少操作次数 题目大意：给定一个大小为 m x n 的二维矩形 grid，每次操作可以将任意格子的值修改为任意非负整数。完成所有操作后，需要确保每个格子 grid[i][j] 的值满足以下条件：如果下面相邻格子存在的话，它们的值相等；如果右边相邻格子存在的话，它们的值不相等。返回需要的最少操作次数。 记忆化 实现思路：首先，统计每一列中各个数字的出现次数。然后，使用动态规划的方法，定义函数dfs(i, pre)，表示处理到第i列时，前一列的值为pre时的最大操作次数。在dfs中，对于当前列的每个数字，考虑是否修改当前列的值，然后递归处理下一列。利用缓存来避免重复计算。最后返回总的操作次数。 class Solution: # 如果你想不出来，1、你不知道这个知识点 2、 你知道这个知识点但是方向错了 def minimumOperations(self, g: List[List[int]]) -\u0026gt; int: n, m = len(g), len(g[0]) cnt = [[0]*10 for _ in range(m)] for row in g: for k, v in enumerate(row): cnt[k][v]+=1 @cache def dfs(i, pre): if i\u0026lt;0: return 0 res = 0 for v in range(10): if v!=pre: res = max(res, dfs(i-1, v) + cnt[i][v]) return res return m*n - dfs(m-1, -1) 递推 实现思路：首先，对每一列进行遍历，并统计每列中每个数字的出现次数。然后，通过动态规划的方法，使用两个变量f0和f1分别表示当前列处理时，前一列最大能保留的个数和次大能够保留的个数。接着，通过遍历每列中的每个数字，计算当前列的最大操作次数，并更新f0和f1。最后返回总的操作次数。 class Solution: def minimumOperations(self, grid: List[List[int]]) -\u0026gt; int: n, m = len(grid), len(grid[0]) f0, f1, pre = 0, 0, -1 for col in zip(*grid): mx, mx2, x = f0, f1, -1 for v, c in Counter(col).items(): res = (f0 if v!=pre else f1) + c if res \u0026gt; mx: mx, mx2, x = res, mx, v elif res \u0026gt; mx2: mx2 = res f0, f1, pre = mx, mx2, x return m*n - f0 第四题100276. 最短路径中的边 题目大意：给定一个包含n个节点的无向带权图，节点编号从0到n-1，总共有m条边。对于节点0为出发点，节点n-1为结束点的所有最短路，需要返回一个长度为m的布尔数组，如果edges[i]至少在其中一条最短路上，则answer[i]为true，否则为false。\n实现思路：首先构建图的邻接表表示。然后使用Dijkstra算法求解最短路径，并记录最短路径的长度。接着，从结束点开始反向遍历最短路径，标记经过的边。最后返回标记结果。\nclass Solution: # 多动脑子，把外界的干扰降到最低，人生永远充满着干扰 def findAnswer(self, n: int, edges: List[List[int]]) -\u0026gt; List[bool]: m = len(edges) g = defaultdict(list) INF = 0x3f3f3f3f dis, st = [INF]*(n+5), [False]*(n+5) for i, val in enumerate(edges): x, y, w = val g[x].append((y, w, i)) g[y].append((x, w, i)) def dijkstra(): dis[0]=0 h=[] heappush(h, (0, 0)) while h: dist, ver = heappop(h) if st[ver]: continue st[ver]=True for y, w, _ in g[ver]: if dis[y]\u0026gt;dis[ver]+w: dis[y]=dis[ver]+w heappush(h, (dis[y], y)) if dis[n-1]==INF: return -1 else: return dis[n-1] res = [False]*m dn = dijkstra() if dn==-1: return res q = deque() q.append(n-1) while q: f = q.popleft() for y, w, i in g[f]: if dis[y]+w == dis[f]: res[i]=True q.append(y) return res ","permalink":"https://kennems.github.io/zh/posts/tech/%E5%8A%9B%E6%89%A3%E5%91%A8%E8%B5%9B39420240421/","summary":"力扣周赛394(20240421) 第三题100290. 使矩阵满足条件的最少操作次数 题目大意：给定一个大小为 m x n 的二维矩形 grid，每次操作","title":"LeetCode周赛240421"},{"content":"Java20天速成——进阶课程(4) 特殊文件 properties, xml\n为什么要用这些特殊文件？\n存储多个用户的：用户名， 密码， 家乡， 性别\n日志技术\n把程序运行的信息，记录到文件中，方便程序员定位bug， 并了解程序的执行情况等。\nProperties 是一个Map集合（键值对集合）， 但是一般不会当集合使用 核心作用：Properties是用来代表属性文件的，通过Properties可以读写属性文件里面的内容 public static void main(String[] args) throws IOException { // 创建一个Properties对象 Properties properties = new Properties(); // 输出初始的Properties对象，此时为空 System.out.println(properties); // 从文件加载Properties数据 properties.load(new FileReader(\u0026#34;file-io-app\\\\properties-xml-log-app\\\\src\\\\users.properties\u0026#34;)); // 输出加载后的Properties对象，包含从文件中读取的键值对 System.out.println(properties); // 根据指定键取得对应的值 System.out.println(properties.get(\u0026#34;ken\u0026#34;)); // 获取Properties对象中所有的键，并遍历输出每个键值对 Set\u0026lt;String\u0026gt; keys = properties.stringPropertyNames(); for (String key : keys) { String val = properties.getProperty(key); System.out.println(key + \u0026#34;----\u0026gt;\u0026#34; + val); } } XML 本质是一种数据的格式，可以用来存储复杂的数据结构，和数据关系 XML特点\nXML中的\u0026lt;标签名\u0026gt;称为一个标签或一个元素，一般是成对出现的 xml解析(dom4j) public static void main(String[] args) throws DocumentException { // 创建SAXReader对象 SAXReader saxReader = new SAXReader(); // 使用SAXReader解析XML文件并生成Document对象 Document document = saxReader.read(\u0026#34;file-io-app\\\\properties-xml-log-app\\\\src\\\\helloworld.xml\u0026#34;); // 获取XML文档的根元素并输出其名称 Element root = document.getRootElement(); System.out.println(root.getName()); // 获取根元素下名为\u0026#34;user\u0026#34;的所有子元素并输出它们的名称 List\u0026lt;Element\u0026gt; elements = root.elements(\u0026#34;user\u0026#34;); for (Element element : elements) { System.out.println(element.getName()); } // 获取名为\u0026#34;people\u0026#34;的元素的文本内容并输出 Element people = root.element(\u0026#34;people\u0026#34;); System.out.println(people.getText()); // 获取名为\u0026#34;user\u0026#34;的元素下名为\u0026#34;user\u0026#34;的子元素的文本内容并输出 Element user = root.element(\u0026#34;user\u0026#34;); System.out.println(user.elementText(\u0026#34;user\u0026#34;)); // 获取名为\u0026#34;user\u0026#34;的元素的名为\u0026#34;id\u0026#34;的属性值并输出 System.out.println(user.attributeValue(\u0026#34;id\u0026#34;)); // 获取名为\u0026#34;user\u0026#34;的元素的名为\u0026#34;id\u0026#34;的属性，并输出属性名和属性值 Attribute id = user.attribute(\u0026#34;id\u0026#34;); System.out.println(id.getName()); System.out.println(id.getValue()); // 获取名为\u0026#34;user\u0026#34;的元素的所有属性，并输出它们的名和值 List\u0026lt;Attribute\u0026gt; attributes = user.attributes(); for (Attribute attribute : attributes) { System.out.println(attribute.getName() + attribute.getValue()); } // 输出名为\u0026#34;user\u0026#34;的元素下名为\u0026#34;name\u0026#34;、\u0026#34;地址\u0026#34;和\u0026#34;password\u0026#34;的子元素的文本内容 System.out.println(user.elementText(\u0026#34;name\u0026#34;)); System.out.println(user.elementText(\u0026#34;地址\u0026#34;)); System.out.println(user.elementText(\u0026#34;password\u0026#34;)); // 获取名为\u0026#34;user\u0026#34;的元素下名为\u0026#34;data\u0026#34;的子元素的文本内容，并输出包括前后空格的文本和去除前后空格的文本 Element data = user.element(\u0026#34;data\u0026#34;); System.out.println(data.getText()); System.out.println(data.getTextTrim()); //去除前后空格 } 写入XML文件 使用程序把数据写出到xml中\n不建议使用dom4j， 推荐直接把程序里的数据拼接成xml格式\npublic static void main(String[] args) throws IOException { // 创建一个StringBuilder对象，用于构建XML内容 StringBuilder sb = new StringBuilder(); // 构建XML头部信息和根元素 sb.append(\u0026#34;\u0026lt;?xml version=\\\u0026#34;1.0\\\u0026#34; encoding=\\\u0026#34;utf-8\\\u0026#34; ?\u0026gt;\u0026#34;); sb.append(\u0026#34;\u0026lt;book\u0026gt;\\r\\n\u0026#34;); // 添加书名、作者和价格信息作为子元素 sb.append(\u0026#34;\u0026lt;name\u0026gt;\u0026#34;).append(\u0026#34;从入门到删库\u0026#34;).append(\u0026#34;\u0026lt;/name\u0026gt;\\r\\n\u0026#34;); sb.append(\u0026#34;\u0026lt;author\u0026gt;\u0026#34;).append(\u0026#34;ai\u0026#34;).append(\u0026#34;\u0026lt;/author\u0026gt;\\r\\n\u0026#34;); sb.append(\u0026#34;\u0026lt;price\u0026gt;\u0026#34;).append(999.999).append(\u0026#34;\u0026lt;/price\u0026gt;\\r\\n\u0026#34;); // 关闭根元素 sb.append(\u0026#34;\u0026lt;/book\u0026gt;\\r\\n\u0026#34;); try ( // 使用try-with-resources语法创建BufferedWriter对象，将内容写入到文件中 BufferedWriter bw = new BufferedWriter(new FileWriter(\u0026#34;file-io-app\\\\properties-xml-log-app\\\\src\\\\test.xml\u0026#34;)); ){ bw.write(sb.toString()); // 将StringBuilder对象中的内容写入到文件中 } catch (Exception e) { e.printStackTrace(); // 打印异常信息 } } 约束XML文件的书写 就是限制XML文件只能按照某种格式进行书写 约束文档：\n专门用来显示xml书写格式的文档，比如：限制标签，属性该怎么写 约束文档的分类\nDTD文档 Schema文档 XML文档结束-DTD的使用 需求：利用DTD约束文档，约束一个XML文件的编写。\nDTD(约束文档)\n\u0026lt;!ELEMENT 书架 (书+)\u0026gt; \u0026lt;!ELEMENT 书 (书名,作者,售价)\u0026gt; \u0026lt;!ELEMENT 书名 (#PCDATA)\u0026gt; \u0026lt;!ELEMENT 作者 (#PCDATA)\u0026gt; \u0026lt;!ELEMENT 售价 (#PCDATA)\u0026gt; XML文档\n\u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;UTF-8\u0026#34; ?\u0026gt; \u0026lt;!DOCTYPE 书架 SYSTEM \u0026#34;data.dtd\u0026#34;\u0026gt; \u0026lt;书架\u0026gt; \u0026lt;书\u0026gt; \u0026lt;书名\u0026gt;从删库到跑路\u0026lt;/书名\u0026gt; \u0026lt;作者\u0026gt;Kenn\u0026lt;/作者\u0026gt; \u0026lt;售价\u0026gt;0.3\u0026lt;/售价\u0026gt; \u0026lt;/书\u0026gt; \u0026lt;/书架\u0026gt; XML文档结束-schema的使用 可以约束XML文件的编写、和数据类型 \u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;UTF-8\u0026#34; ?\u0026gt; \u0026lt;schema xmlns=\u0026#34;http://www.w3.org/2001/XMLSchema\u0026#34; targetNamespace=\u0026#34;http://www.itcast.cn\u0026#34; elementFormDefault=\u0026#34;qualified\u0026#34; \u0026gt; \u0026lt;!-- targetNamespace:申明约束文档的地址（命名空间）--\u0026gt; \u0026lt;element name=\u0026#39;书架\u0026#39;\u0026gt; \u0026lt;!-- 写子元素 --\u0026gt; \u0026lt;complexType\u0026gt; \u0026lt;!-- maxOccurs=\u0026#39;unbounded\u0026#39;: 书架下的子元素可以有任意多个！--\u0026gt; \u0026lt;sequence maxOccurs=\u0026#39;unbounded\u0026#39;\u0026gt; \u0026lt;element name=\u0026#39;书\u0026#39;\u0026gt; \u0026lt;!-- 写子元素 --\u0026gt; \u0026lt;complexType\u0026gt; \u0026lt;sequence\u0026gt; \u0026lt;element name=\u0026#39;书名\u0026#39; type=\u0026#39;string\u0026#39;/\u0026gt; \u0026lt;element name=\u0026#39;作者\u0026#39; type=\u0026#39;string\u0026#39;/\u0026gt; \u0026lt;element name=\u0026#39;售价\u0026#39; type=\u0026#39;double\u0026#39;/\u0026gt; \u0026lt;/sequence\u0026gt; \u0026lt;/complexType\u0026gt; \u0026lt;/element\u0026gt; \u0026lt;/sequence\u0026gt; \u0026lt;/complexType\u0026gt; \u0026lt;/element\u0026gt; \u0026lt;/schema\u0026gt; XML\n\u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;UTF-8\u0026#34; ?\u0026gt; \u0026lt;书架 xmlns=\u0026#34;http://www.itcast.cn\u0026#34; xmlns:xsi=\u0026#34;http://www.w3.org/2001/XMLSchema-instance\u0026#34; xsi:schemaLocation=\u0026#34;http://www.itcast.cn data.xsd\u0026#34;\u0026gt; \u0026lt;!-- xmlns=\u0026#34;http://www.itcast.cn\u0026#34; 基本位置 xsi:schemaLocation=\u0026#34;http://www.itcast.cn books02.xsd\u0026#34; 具体的位置 --\u0026gt; \u0026lt;书\u0026gt; \u0026lt;书名\u0026gt;从入门到删除\u0026lt;/书名\u0026gt; \u0026lt;作者\u0026gt;dlei\u0026lt;/作者\u0026gt; \u0026lt;售价\u0026gt;0.03\u0026lt;/售价\u0026gt; \u0026lt;/书\u0026gt; \u0026lt;书\u0026gt; \u0026lt;书名\u0026gt;从入门到删除\u0026lt;/书名\u0026gt; \u0026lt;作者\u0026gt;dlei\u0026lt;/作者\u0026gt; \u0026lt;售价\u0026gt;0.9\u0026lt;/售价\u0026gt; \u0026lt;/书\u0026gt; \u0026lt;/书架\u0026gt; Logback快速入门 需求：\n使用Logback日志框架，记录系统的运行信息 实现步骤\n导入Logback框架到项目中去\nslf4j-api：日志接口 logback-core logback-classic 将Logback框架的核心配置文件logback.xml直接拷贝到src目录下（必须是src下）\n创建Logback框架提供的Logger对象，然后用Logger对象调用其提供的方法就可记录系统的日志信息。\npublic static final Logger LOGGER = LoggerFactory.getLogger(\u0026#34;LogBackTest\u0026#34;); 核心配置文件logback.xml\n对Logback日志框架进行控制 Logback设置日志级别\n日志级别指的是日志信息的类型，日志都会分级别，常见的日志级别如下（优先级依次升高） 日志级别 说明 trace 追踪，指明程序运行轨迹 debug 调试，实际应用中一般将其作为最低级别 info 输出重要的运行信息，数据连接，网络连接，IO操作等等，使用较多 warn 警告信息，可能会发生问题，使用较多 error 错误信息，使用较多 配置文件配置如下：\n\u0026lt;root level=\u0026#34;debug\u0026#34;\u0026gt; \u0026lt;appender-ref ref=\u0026#34;CONSOLE\u0026#34;/\u0026gt; \u0026lt;appender-ref ref=\u0026#34;FILE\u0026#34; /\u0026gt; \u0026lt;/root\u0026gt; 只有日志的级别是大于或等于核心配置文件配值的日志级别，才会被记录，否则不记录。 多线程 线程（Thread）是一个程序内部的一条执行流程 程序中如果只有一条执行流程，那这个程序就是单线程的程序 多线程\n多线程是指从软硬件上实现的多条执行流程的技术（多条线程由CPU负责调度执行） 方式一：继承Thread类 public class MyThread extends Thread{ @Override public void run() { for (int i = 0; i \u0026lt; 100; i++) { System.out.println(\u0026#34;子线程MyThread\u0026#34; + i); } } } public static void main(String[] args) { MyThread t = new MyThread(); t.start(); for (int i = 0; i \u0026lt; 100; i++) { System.out.println(\u0026#34;主线程main输出：\u0026#34; + i); } } 优缺点：\n优点：编码简单 缺点：线程类已经继承Thread, 无法继承其他类，不利于功能的扩展 注意事项：\n调用的是start而不是run 不要把主线程任务放在启动子线程之前 方式二：实现Runnable接口 public class Demo2 { public static void main(String[] args) { MyRunnable target = new MyRunnable(); new Thread(target).start(); for (int i = 0; i \u0026lt; 1000; i++) { System.out.println(\u0026#34;===主线程输出\u0026#34; + i); } } } public class MyRunnable implements Runnable{ @Override public void run() { for (int i = 0; i \u0026lt; 1000; i++) { System.out.println(\u0026#34;子线程输出===\u0026#34; + i); } } } 定义一个线程任务类MyRunnable实现Runnable接口， 重写run()方法 创建MyRunnable任务对象 把MyRunnbale任务对象交给Thread处理 优缺点：\n优点：实现Runnable接口后，可以继续继承其他类，实现其他接口，扩展性强 缺点：需要多一个Runnable对象 public static void main(String[] args) { // 创建并启动第一个子线程 Runnable target1 = new Runnable() { @Override public void run() { for (int i = 0; i \u0026lt; 100; i++) { System.out.println(\u0026#34;子线程输出:\u0026#34; + i); } } }; new Thread(target1).start(); // 主线程执行 for (int i = 0; i \u0026lt; 100; i++) { System.out.println(\u0026#34;主线程:\u0026#34; + i); } // 创建并启动第二个子线程，使用Lambda表达式 new Thread(() -\u0026gt; { for (int i = 0; i \u0026lt; 100; i++) { System.out.println(\u0026#34;子线程2:\u0026#34; + i); } }).start(); // 主线程继续执行 for (int i = 0; i \u0026lt; 100; i++) { System.out.println(\u0026#34;主线程:\u0026#34; + i); } } 方式三：利用Callable接口，FutureTask类来实现 MyCallable\npackage com.showguan.ThreadDemo; import java.util.concurrent.Callable; public class MyCallable implements Callable\u0026lt;String\u0026gt; { private int n; public MyCallable() { } public MyCallable(int n) { this.n = n; } @Override public String call() throws Exception { int sum = 0; for (int i = 0; i \u0026lt; n; i++) { sum += i; } return \u0026#34;线程求和结果为\u0026#34; + sum; } } package com.showguan.ThreadDemo; import java.util.concurrent.Callable; import java.util.concurrent.ExecutionException; import java.util.concurrent.FutureTask; public class Demo4 { public static void main(String[] args) throws ExecutionException, InterruptedException { Callable\u0026lt;String\u0026gt; call = new MyCallable(100); FutureTask\u0026lt;String\u0026gt; ft = new FutureTask\u0026lt;\u0026gt;(call); new Thread(ft).start(); Callable\u0026lt;String\u0026gt; call2 = new MyCallable(200); FutureTask\u0026lt;String\u0026gt; ft2 = new FutureTask\u0026lt;\u0026gt;(call2); new Thread(ft2).start(); String rs = ft.get(); System.out.println(rs); //线程求和结果为4950 String rs2 = ft2.get(); System.out.println(rs2); //线程求和结果为19900 } } 优点：\n线程任务类只是实现接口，可以继续继承类和实现接口，扩展性强；可以在线程执行完毕后去获取线程执行的结果。 线程常用方法 为线程设置名称 public class Main { public static void main(String[] args) { // 创建并启动线程 t1 Thread t1 = new MyThread(\u0026#34;线程一号\u0026#34;); t1.start(); System.out.println(t1.getName()); // 打印线程 t1 的名称 // 创建并启动线程 t2 Thread t2 = new MyThread(\u0026#34;线程二号\u0026#34;); t2.start(); System.out.println(t2.getName()); // 打印线程 t2 的名称 // 获取当前线程，并将其名称设置为 \u0026#34;max线程\u0026#34; Thread m = Thread.currentThread(); m.setName(\u0026#34;max线程\u0026#34;); System.out.println(m.getName()); // 打印当前线程的名称 // 在当前线程中执行一个简单的 for 循环，打印输出当前线程的名称和循环变量 i for (int i = 0; i \u0026lt; 100; i++) { System.out.println(m.getName() + \u0026#34;线程输出\u0026#34; + i); } } } // 自定义线程类 MyThread package com.showguan.ThreadDemo; public class MyThread extends Thread { public MyThread() { } public MyThread(String name) { super(name); } @Override public void run() { for (int i = 0; i \u0026lt; 100; i++) { System.out.println(Thread.currentThread().getName() + \u0026#34;开始执行。\u0026#34;); System.out.println(\u0026#34;子线程MyThread\u0026#34; + i); } } } 使用线程的 join() 方法来实现线程的顺序执行，在循环中使用 sleep() 方法来控制线程的执行 public static void main(String[] args) throws InterruptedException { // 循环遍历整数 0 到 5 for (int i = 0; i \u0026lt;= 5; i++) { System.out.println(i); // 打印当前整数值 // 如果当前整数值等于 3，则让当前线程休眠 5 秒钟 if (i == 3) { Thread.sleep(5000); } } // 创建并启动线程 t1，并在主线程中等待 t1 线程执行完成 Thread t1 = new MyThread(\u0026#34;1号线程\u0026#34;); t1.start(); t1.join(); // 创建并启动线程 t2，并在主线程中等待 t2 线程执行完成 Thread t2 = new MyThread(\u0026#34;2号线程\u0026#34;); t2.start(); t2.join(); // 创建并启动线程 t3，并在主线程中等待 t3 线程执行完成 Thread t3 = new MyThread(\u0026#34;3号线程\u0026#34;); t3.start(); t3.join(); } yield, interrupt, 守护线程，线程优先级等\u0026hellip;\n线程安全 什么是线程安全问题？\n多个线程，同时操作同一个共享资源的时候，可能会出现业务安全问题 package com.showguan.ThreadSafeDemo; public class Account { private String cardId; private double money; public Account() { } public Account(String cardId, double money) { this.cardId = cardId; this.money = money; } public String getCardId() { return cardId; } public void setCardId(String cardId) { this.cardId = cardId; } public double getMoney() { return money; } public void setMoney(double money) { this.money = money; } // 使用 synchronized 关键字确保线程安全 public synchronized void drawMoney(double money) { String name = Thread.currentThread().getName(); if(this.money\u0026gt;=money){ System.out.println(name + \u0026#34;来取钱\u0026#34; + money + \u0026#34;成功！\u0026#34;); this.money -= money; System.out.println(name + \u0026#34;取钱之后，余额剩余: \u0026#34; + this.money); }else{ System.out.println(name + \u0026#34;来取钱， 余额不足！\u0026#34;); } } } package com.showguan.ThreadSafeDemo; public class DrawThread extends Thread{ private Account acc; public DrawThread(Account acc, String name) { super(name); this.acc = acc; } @Override public void run() { acc.drawMoney(10000.0); } } public class Demo1 { public static void main(String[] args) { Account acc = new Account(\u0026#34;ICBC-10101\u0026#34;, 10000); new DrawThread(acc, \u0026#34;小红\u0026#34;).start(); new DrawThread(acc, \u0026#34;小明\u0026#34;).start(); /**输出结果 * 小红来取钱10000.0成功！ * 小明来取钱， 余额不足！ * 小红取钱之后，余额剩余: 0.0 */ } } 线程同步的常见方案 加锁：每次只允许一个线程加锁，加锁后才能进入访问，访问完毕后自动解锁，然后其他线程才能再加锁进来 (1) 同步代码块 作用：把访问共享资源的核心代码给上锁，依次保证线程安全。\n原理：每次只允许一个线程加锁后进入，执行完毕后自动结果，其他线程才可以进来执行。\n注意事项：\n对于当前同时执行的线程来说，同步锁必须同一把（同一个对象），否则会出bug 锁对象的使用规范：\n建议使用共享资源作为锁对象，对于实例方法建议使用**this**作为锁对象 对于静态方法建议使用字节码（类名.class）对象作为锁对象 public void drawMoney(double money) { String name = Thread.currentThread().getName(); synchronized (this) { if(this.money\u0026gt;=money){ System.out.println(name + \u0026#34;来取钱\u0026#34; + money + \u0026#34;成功！\u0026#34;); this.money -= money; System.out.println(name + \u0026#34;取钱之后，余额剩余: \u0026#34; + this.money); }else{ System.out.println(name + \u0026#34;来取钱， 余额不足！\u0026#34;); } } } public static void test(){ synchronized(Account.class){ } } (2) 同步方法 使用synchronized修饰方法\npublic synchronized void drawMoney(double money) { String name = Thread.currentThread().getName(); if(this.money\u0026gt;=money){ System.out.println(name + \u0026#34;来取钱\u0026#34; + money + \u0026#34;成功！\u0026#34;); this.money -= money; System.out.println(name + \u0026#34;取钱之后，余额剩余: \u0026#34; + this.money); }else{ System.out.println(name + \u0026#34;来取钱， 余额不足！\u0026#34;); } } 同步方法底层原理\n同步方法其实底层也是有隐式对象的， 只是锁的范围是整个方法代码 同样，如果是实例方法：同步方法默认用this作为锁对象；如果是静态方法：同步方法默认用类名.class作为锁对象 (3) Lock锁 private final Lock lk = new ReentrantLock(); public void drawMoney(double money) { String name = Thread.currentThread().getName(); try { lk.lock(); if(this.money\u0026gt;=money){ System.out.println(name + \u0026#34;来取钱\u0026#34; + money + \u0026#34;成功！\u0026#34;); this.money -= money; System.out.println(name + \u0026#34;取钱之后，余额剩余: \u0026#34; + this.money); }else{ System.out.println(name + \u0026#34;来取钱， 余额不足！\u0026#34;); } } catch (Exception e) { e.printStackTrace(); } finally { lk.unlock(); } } 线程间通信 /** * 这个程序演示了使用 wait() 和 notify() 方法来实现多线程间的消息传递和同步。 * * 主要知识点： * 1. wait() 方法：使当前线程等待并释放所占锁，直到另一个线程调用 notify() 方法或 notifyAll() 方法来唤醒它。 * 2. notify() 方法：唤醒正在等待的单个线程。 * 3. notifyAll() 方法：唤醒正在等待的所有线程。 * 4. 生产者-消费者模型：多个生产者线程向共享资源中生产物品，多个消费者线程从共享资源中消费物品。 * 5. 使用 synchronized 关键字来确保线程安全，避免多个线程同时访问共享资源引起的数据不一致性问题。 * */ package com.showguan.ThreadMessageDemo; import java.util.ArrayList; import java.util.List; public class Desk { private List\u0026lt;String\u0026gt; list = new ArrayList\u0026lt;\u0026gt;(); /** * 生产食物的方法 */ public synchronized void put() { try { String name = Thread.currentThread().getName(); // 如果桌子上没有食物，则生产一个食物 if (list.size() == 0) { list.add(name + \u0026#34;做的肉包子\u0026#34;); System.out.println(name + \u0026#34;做了一个肉包子\u0026#34;); Thread.sleep(2000); // 模拟制作时间 this.notifyAll(); // 唤醒所有等待线程 this.wait(); // 等待被唤醒 } else { this.notifyAll(); // 唤醒所有等待线程 this.wait(); // 等待被唤醒 } } catch (Exception e) { e.printStackTrace(); } } /** * 消费食物的方法 */ public synchronized void get() { try { String name = Thread.currentThread().getName(); // 如果桌子上有食物，则消费一个食物 if (list.size() == 1) { System.out.println(name + \u0026#34;吃了\u0026#34; + list.get(0)); list.clear(); // 清空桌子上的食物 Thread.sleep(1000); // 模拟吃的时间 this.notifyAll(); // 唤醒所有等待线程 this.wait(); // 等待被唤醒 } else { this.notifyAll(); // 唤醒所有等待线程 this.wait(); // 等待被唤醒 } } catch (Exception e) { e.printStackTrace(); } } } 线程池 线程池就是一个可以复用线程的技术 ThreadPoolExecutor构造器\npublic ThreadPoolExecutor(int corePoolSize, int maximumPoolSize, long keepAliveTime, TimeUnit unit, BlockingQueue\u0026lt;Runnable\u0026gt; workQueue) 参数一：corePoolSize：指定线程池的核心线程的数量 参数二：maximumPoolSize：指定线程池的最大线程数量 参数三：keepAliveTime：指定临时线程的存活时间 参数四：unit:指定临时线程存活的时间单位（秒，分，时，天） 参数五：workQueue：指定线程池的任务队列 参数六：threadFactory：指定线程池的线程工厂 参数七：handler：指定线程池的任务拒绝策略（线程都在忙，任务队列也满了的时候，新任务来了该怎么处理） 注意事项\n临时线程什么时候创建？ 新任务提交时发现核心线程都在忙，任务队列也满了，并且还可以创建临时线程，此时才会创建临时线程 什么时候会开始拒绝新任务？ 核心线程和临时线程都在忙，任务队列也满了，新的任务过来的时候才会开始拒绝新任务 新任务拒绝策略 策略 解释 ThreadPoolExecutor.AbortPolicy 当任务添加到线程池中被拒绝时，抛出RejectedExecutionException异常。（默认策略） ThreadPoolExecutor.DiscardPolicy 丢弃任务，但是不抛出异常，不推荐 ThreadPoolExecutor.DiscardOldestPolicy 抛弃队列中等待最久的任务，然后把当前任务加入队列中 ThreadPoolExecutor.CallerRunsPolicy 由主线程负责调用任务的run()方法从而绕过线程池直接执行 ExecutorService的常用方法 方法、描述 说明 execute(Runnable command) 执行Runnable任务 submit(Callable\u0026lt;T\u0026gt; task) 执行Callable任务，返回未来任务对象，用于获取线程返回的结果 shutdown() 等全部任务执行完毕后，再关闭线程池！ List\u0026lt;Runnable\u0026gt; shutdownNow() 立刻关闭线程池，停止正在执行的任务，并返回队列中未执行的任务 执行Runnable任务 import java.util.concurrent.*; public class Main { public static void main(String[] args) { // 创建线程池 // 使用 ThreadPoolExecutor 构造方法自定义线程池 ExecutorService pool = new ThreadPoolExecutor( 3, // 核心线程数 5, // 最大线程数 8, // 线程空闲时间 TimeUnit.SECONDS, // 时间单位 new ArrayBlockingQueue\u0026lt;\u0026gt;(4), // 工作队列 Executors.defaultThreadFactory(), // 线程工厂， 用于创建新线程的实例。 new ThreadPoolExecutor.CallerRunsPolicy() // 拒绝策略 ); // 创建任务 Runnable target = new MyRunnable(); // 提交任务给线程池执行 pool.execute(target); // 使用核心线程执行任务 pool.execute(target); // 使用核心线程执行任务 pool.execute(target); // 使用核心线程执行任务 pool.execute(target); // 复用前面的核心线程执行任务 pool.execute(target); // 复用前面的核心线程执行任务 pool.execute(target); // 复用前面的核心线程执行任务 pool.execute(target); // 复用前面的核心线程执行任务 pool.execute(target); // 使用临时线程执行任务 pool.execute(target); // 使用临时线程执行任务 pool.execute(target); // 执行任务被拒绝（拒绝策略决定） pool.execute(target); // 执行任务被拒绝（拒绝策略决定） // 关闭线程池 // pool.shutdown(); // pool.shutdownNow(); } } // 自定义任务 class MyRunnable implements Runnable { @Override public void run() { // 任务逻辑 } } 执行Callable任务 import java.util.concurrent.*; public class Main { public static void main(String[] args) throws ExecutionException, InterruptedException { // 创建线程池 ExecutorService pool = new ThreadPoolExecutor( 3, // 核心线程数 5, // 最大线程数 8, // 线程空闲时间 TimeUnit.SECONDS, // 时间单位 new ArrayBlockingQueue\u0026lt;\u0026gt;(4), // 工作队列 Executors.defaultThreadFactory(), // 线程工厂 new ThreadPoolExecutor.CallerRunsPolicy() // 拒绝策略 ); // 提交可调用任务给线程池执行 Future\u0026lt;String\u0026gt; f1 = pool.submit(new MyCallable(100)); // 提交任务并获取 Future 对象 Future\u0026lt;String\u0026gt; f2 = pool.submit(new MyCallable(200)); // 提交任务并获取 Future 对象 Future\u0026lt;String\u0026gt; f3 = pool.submit(new MyCallable(300)); // 提交任务并获取 Future 对象 Future\u0026lt;String\u0026gt; f4 = pool.submit(new MyCallable(400)); // 提交任务并获取 Future 对象 // 获取任务执行结果并输出 System.out.println(f1.get()); // 阻塞等待任务执行完成，并获取结果 System.out.println(f2.get()); // 阻塞等待任务执行完成，并获取结果 System.out.println(f3.get()); // 阻塞等待任务执行完成，并获取结果 System.out.println(f4.get()); // 阻塞等待任务执行完成，并获取结果 // 关闭线程池 pool.shutdown(); } } // 自定义可调用任务 class MyCallable implements Callable\u0026lt;String\u0026gt; { private int value; public MyCallable(int value) { this.value = value; } @Override public String call() throws Exception { // 任务逻辑 return \u0026#34;Result: \u0026#34; + value; } } Executors 是一个线程池的工具类，提供里很多静态方法用于返回不同特点的线程池对象 Executors使用可能存在的陷进\n大型并发系统环境中使用Executors如果不注意可能会出现系统风险 【强制】线程池不允许使用 Executors 去创建，而是通过 ThreadPoolExecutor 的方式，这 样的处理方式让写的同学更加明确线程池的运行规则，规避资源耗尽的风险。 说明：Executors 返回的线程池对象的弊端如下： 1） FixedThreadPool 和 SingleThreadPool： 允许的请求队列长度为 Integer.MAX_VALUE，可能会堆积大量的请求，从而导致 OOM(OutOfMemoryError)。 2） CachedThreadPool： 允许的创建线程数量为 Integer.MAX_VALUE，可能会创建大量的线程，从而导致 OOM。 并发、并行 进程\n正在运行的程序（软件）就是一个独立的进程 线程是属于进程的，一个进程中可以同时运行多个线程 进程中的多个线程其实是并发和并行执行的 并发的含义\n进程中的线程是由CPU负责调度执行的，但CPU能同时处理线程的数量有限，为了保证全部线程都能往前执行， CPU会轮询为系统的每个线程服务，由于CPU切换的速度很快，给我们的感觉这些线程在同时执行，这就是并发 并行的理解\n在同一个时刻上，同时有多个线程在被CPU调度执行 线程的生命周期 线程的6种状态总结 状态名称 说明 NEW(新建) 线程刚被创建，但是并未启动 Runnable(可运行) 线程已经调用了start()， 等待CPU调度 Blocked(被阻塞) 线程在执行的时候未竞争到锁对象，则该线程进入Blocked状态 Waiting(等待) 一个线程进入Waiting状态，另一个线程需要Notify或者notifyAll才能够唤醒。 Timed Waiting (计时等待) 同Waiting状态类似，有几个方法（sleep， wait）有超时参数，调用他们将进入Timed Waiting状态 Terminated (被终止) 因为run方法正常退出而死亡，或者因为没有捕获的异常终止了run方法而死亡. 悲观锁、乐观锁原理 悲观锁：一上来就加锁，没有安全感，每次只能一个线程进入访问完毕后，再解锁，线程安全，性能较差 乐观锁：一开始不上锁，认为是没有问题的，大家一起跑，等要出现线程安全问题的时候才开始控制。线程安全，性能较好 CAS算法 package com.showguan.ExtendDemo; import java.util.concurrent.atomic.AtomicInteger; /** * 这个程序演示了乐观锁的使用。 * * 乐观锁是一种并发控制机制，它假设对数据的读取操作不会造成数据冲突，因此不需要对数据进行加锁操作。 * 相反，它在更新数据时检查是否有其他线程已经修改了数据，如果没有则进行更新，如果有则进行相应的处理，比如重试或者放弃更新。 * * 在这个程序中，我们比较了两种实现方式： * 1. 使用 synchronized 关键字实现的悲观锁（MyRunnable 类） * 2. 使用 AtomicInteger 实现的乐观锁（MyRunnable2 类） * * MyRunnable 类中使用了 synchronized 关键字来保证多线程环境下对 count 变量的安全访问，它是一种悲观锁的实现方式， * 每个线程在访问 count 变量时都需要获得对象锁，因此只有一个线程能够执行临界区代码，其他线程需要等待释放锁才能执行。 * * MyRunnable2 类中使用了 AtomicInteger 来实现乐观锁。AtomicInteger 提供了一种原子性的更新操作，保证了在多线程环境下的安全访问。 * 在这种实现方式中，线程不需要获取锁，而是直接通过原子性的操作来更新 count 变量，因此可以实现更高的并发性能。 * * 在实际应用中，选择合适的锁机制取决于具体的场景和性能需求。如果对数据的更新操作比较频繁，且竞争不是很激烈，可以选择乐观锁来提升性能； * 如果竞争比较激烈，或者对数据的一致性要求较高，则可以选择悲观锁来保证数据的正确性。 */ public class Demo1 { public static void main(String[] args) { // Runnable target = new MyRunnable(); // for (int i = 1; i \u0026lt;= 100; i++) { // new Thread(target).start(); // } Runnable target = new MyRunnable2(); for (int i = 1; i \u0026lt;= 100; i++) { new Thread(target).start(); } } } package com.showguan.ExtendDemo; /** * 实现了 Runnable 接口的类，使用 synchronized 关键字实现的悲观锁。 */ public class MyRunnable implements Runnable{ private int count; @Override public void run() { synchronized (this) { for (int i = 1; i \u0026lt;= 100; i++) { // System.out.println(this); System.out.println(Thread.currentThread().getName() + \u0026#34; Count: \u0026#34; + (++count)); } } } } package com.showguan.ExtendDemo; import java.util.concurrent.atomic.AtomicInteger; /** * 实现了 Runnable 接口的类，使用 AtomicInteger 实现的乐观锁。 */ public class MyRunnable2 implements Runnable{ private AtomicInteger count = new AtomicInteger(); @Override public void run() { for (int i = 1; i \u0026lt;= 100; i++) { // System.out.println(this); System.out.println(Thread.currentThread().getName() + \u0026#34; Count: \u0026#34; + (count.incrementAndGet())); } } } 案例 package com.showguan.Test; import java.util.ArrayList; import java.util.List; import java.util.Random; public class Demo1 { public static void main(String[] args) throws InterruptedException { // 创建礼物列表 List\u0026lt;String\u0026gt; gift = new ArrayList\u0026lt;\u0026gt;(); // 定义礼物名称数组 String[] names = {\u0026#34;口红\u0026#34;, \u0026#34;爱马仕\u0026#34;, \u0026#34;iphone\u0026#34;, \u0026#34;手表\u0026#34;, \u0026#34;mac\u0026#34;}; // 随机数生成器 Random r = new Random(); // 循环添加礼物到列表中 for (int i = 1; i \u0026lt;= 1000; i++) { gift.add(names[r.nextInt(names.length)] + \u0026#34; \u0026#34; + (i+1)); // 在礼物列表中添加随机选取的礼物 } System.out.println(gift); // 打印礼物列表 System.out.println(\u0026#34;-------------\u0026#34;); // 创建两个发送线程，分别代表小红和小明 SendThread xh = new SendThread(gift, \u0026#34;小红\u0026#34;); xh.start(); SendThread xm = new SendThread(gift, \u0026#34;小明\u0026#34;); xm.start(); // 等待两个发送线程结束 xm.join(); xh.join(); // 打印两个发送线程发送的礼物数量 System.out.println(\u0026#34;小明发出了：\u0026#34; + xm.getCount()); System.out.println(\u0026#34;小红发出了：\u0026#34; + xh.getCount()); } } package com.showguan.Test; import java.util.List; import java.util.Random; public class SendThread extends Thread { private List\u0026lt;String\u0026gt; gift; // 礼物列表 private int count; // 发送的礼物数量 // 构造方法 public SendThread(List\u0026lt;String\u0026gt; gift, String name) { super(name); // 调用父类构造方法，设置线程名 this.gift = gift; // 初始化礼物列表 } @Override public void run() { Random r = new Random(); // 随机数生成器 String name = Thread.currentThread().getName(); // 获取当前线程名 while (true) { synchronized (gift){ // 同步块，确保礼物列表的线程安全 if(gift.size()\u0026lt;10){ // 当礼物列表数量小于10时，结束循环 break; } String rs = gift.remove(r.nextInt(gift.size())); // 从礼物列表中随机选择一个礼物，并移除 System.out.println(name + \u0026#34; 发出了礼品： \u0026#34; + rs); // 打印发送的礼物信息 count++; // 记录发送的礼物数量 } } } // 获取发送的礼物数量 public int getCount() { return count; } // 设置发送的礼物数量 public void setCount(int count) { this.count = count; } } ","permalink":"https://kennems.github.io/zh/posts/tech/java20%E5%A4%A9%E9%80%9F%E6%88%90%E8%BF%9B%E9%98%B6%E8%AF%BE%E7%A8%8B4/","summary":"Java20天速成——进阶课程(4) 特殊文件 properties, xml 为什么要用这些特殊文件？ 存储多个用户的：用户名， 密码， 家乡， 性别 日志技术 把程序运行的信息，记","title":"Java20天速成——进阶课程(4)"},{"content":"Java20天速成——进阶课程(3) 文件操作 File对象 常用方法 public static void main(String[] args) { // 创建File对象，表示文件test.txt的绝对路径 File f1 = new File(\u0026#34;D:/JAVA/JavaSeProMax/file-io-app/src/com/showguan/FileDemo/test.txt\u0026#34;); // 创建File对象，表示文件夹JavaSeProMax的绝对路径 File f2 = new File(\u0026#34;D:/JAVA\u0026#34;); // 创建File对象，表示不存在的文件路径t.txt File f3 = new File(\u0026#34;D:/JAVA/t.txt\u0026#34;); // 输出文件f1的长度（字节数） System.out.println(f1.length()); // 输出文件夹f2的长度，由于f2表示文件夹，而不是文件，因此返回值没有意义 System.out.println(f2.length()); // 输出文件f3的长度，由于文件路径不存在，因此返回0 System.out.println(f3.length()); // 检查文件f3是否存在，返回false，因为文件路径不存在 System.out.println(f3.exists()); // 创建File对象，表示相对路径下的文件test.txt // 相对路径默认从当前工程的根目录开始寻找，因此文件路径不存在 File f4 = new File(\u0026#34;file-io-app\\\\src\\\\com\\\\showguan\\\\FileDemo\\\\test.txt\u0026#34;); // 检查文件f4是否存在，返回false，因为文件路径不存在 System.out.println(f4.exists()); // 输出文件f4的长度，由于文件路径不存在，因此返回0 System.out.println(f4.length()); } public static void main(String[] args) { // 创建File对象，表示相对路径下的文件test.txt File f1 = new File(\u0026#34;file-io-app\\\\src\\\\com\\\\showguan\\\\FileDemo\\\\test.txt\u0026#34;); // 创建File对象，表示文件夹file-io-app的路径 File f2 = new File(\u0026#34;file-io-app\u0026#34;); // 检查文件f1是否存在，返回true，因为文件路径存在 System.out.println(f1.exists()); // 检查f1是否表示一个文件，返回true System.out.println(f1.isFile()); // 检查f1是否表示一个文件夹，返回false System.out.println(f1.isDirectory()); // 检查f2是否表示一个文件夹，返回true System.out.println(f2.isDirectory()); // 获取文件f1的名称，输出test.txt System.out.println(f1.getName()); // 获取文件f1的长度（字节数） System.out.println(f1.length()); // 获取文件f1最后修改时间 long time = f1.lastModified(); // 格式化最后修改时间并输出 SimpleDateFormat sdf = new SimpleDateFormat(\u0026#34;yyyy/MM/dd HH:mm:ss\u0026#34;); System.out.println(sdf.format(time)); // 获取文件f1的路径（创建时使用的路径），输出相对路径file-io-app\\src\\com\\showguan\\FileDemo\\test.txt System.out.println(f1.getPath()); // 获取文件f1的绝对路径，输出完整的绝对路径 System.out.println(f1.getAbsolutePath()); } 创建文件、目录 import java.io.File; import java.io.IOException; public static void main(String[] args) throws IOException { // 创建File对象，表示新文件test2.txt的路径 File f1 = new File(\u0026#34;file-io-app\\\\src\\\\com\\\\showguan\\\\FileDemo\\\\test2.txt\u0026#34;); // 创建新文件test2.txt，如果文件不存在则创建并返回true，否则返回false System.out.println(f1.createNewFile()); // 创建File对象，表示新文件夹aaa的路径 File f2 = new File(\u0026#34;file-io-app\\\\src\\\\com\\\\showguan\\\\FileDemo\\\\aaa\u0026#34;); // 创建新文件夹aaa，如果文件夹不存在则创建并返回true，否则返回false System.out.println(f2.mkdir()); // 创建File对象，表示新文件夹路径a\\b\\c File f3 = new File(\u0026#34;file-io-app\\\\src\\\\com\\\\showguan\\\\FileDemo\\\\a\\\\b\\\\c\u0026#34;); // 创建新文件夹路径a\\b\\c，如果路径中的文件夹不存在则递归创建，创建成功返回true，否则返回false System.out.println(f3.mkdirs()); // 删除文件test2.txt，删除成功返回true，否则返回false System.out.println(f1.delete()); // 删除文件夹a，由于文件夹非空，因此删除失败返回false File f4 = new File(\u0026#34;file-io-app\\\\src\\\\com\\\\showguan\\\\FileDemo\\\\a\u0026#34;); System.out.println(f4.delete()); } public static void main(String[] args) { // 遍历方法，只能遍历一级文件 File f1 = new File(\u0026#34;D:\\\\JAVA\u0026#34;); // 获取D:\\JAVA目录下的所有一级文件名 String[] names = f1.list(); // 遍历打印所有一级文件名 for (String name : names) { System.out.println(name); } // 获取D:\\JAVA目录下的所有一级文件对象 File f2 = new File(\u0026#34;D:\\\\JAVA\u0026#34;); // 获取D:\\JAVA目录下的所有一级文件对象 File[] files = f2.listFiles(); // 遍历打印所有一级文件对象的绝对路径 for (File file : files) { System.out.println(file.getAbsoluteFile()); } // 尝试获取不存在的目录的一级文件对象，返回null File f3 = new File(\u0026#34;D:\\\\JAVA1\u0026#34;); System.out.println(f3.listFiles()); // null // 尝试获取非文件夹的一级文件对象，返回null File f4 = new File(\u0026#34;D:\\\\JAVA\\\\test1\u0026#34;); // 因为f4代表的路径不是文件夹，因此listFiles()返回null File[] files4 = f4.listFiles(); System.out.println(Arrays.toString(files4)); // null } 递归查找 public static void main(String[] args) throws IOException { searchFile(new File(\u0026#34;D:\\\\文档\u0026#34;), \u0026#34;23暑期青训营笔记\u0026#34;); // 调用搜索文件的方法 } /** * 递归搜索指定目录下的文件，并打印找到的文件的绝对路径，并使用系统默认程序打开该文件。 * @param dir 要搜索的目录 * @param fileName 要搜索的文件名 * @throws IOException 如果发生I/O错误 */ public static void searchFile(File dir, String fileName) throws IOException { // 如果目录为空、不存在或者是文件，则直接返回 if(dir==null || !dir.exists() || dir.isFile()){ return ; } // 获取目录下的所有文件和子目录 File[] files = dir.listFiles(); // 如果目录下存在文件 if(files!=null \u0026amp;\u0026amp; files.length\u0026gt;0){ // 遍历目录下的所有文件和子目录 for (File file : files) { // 如果是文件 if(file.isFile()){ // 判断文件名是否包含指定的文件名 if(file.getName().contains(fileName)){ System.out.println(\u0026#34;找到了！\u0026#34; + file.getAbsoluteFile()); // 打印找到的文件的绝对路径 Runtime runtime = Runtime.getRuntime(); runtime.exec(file.getAbsolutePath()); // 使用系统默认程序打开该文件 return; // 找到文件后直接返回 } }else{ // 如果是目录，则递归调用搜索文件的方法 searchFile(file, fileName); } } } } 递归删除 public static void main(String[] args) throws IOException { File file = new File(\u0026#34;D:\\\\JAVA\\\\test1\\\\test\u0026#34;); // 要删除的目录的路径 deleteDir(file); // 调用删除目录的方法 } /** * 递归删除目录及其所有子目录和文件。 * @param dir 要删除的目录 */ public static void deleteDir(File dir){ // 如果目录为空或者不存在，则直接返回 if(dir==null || !dir.exists()){ return ; } // 如果是文件，则直接删除并返回 if(dir.isFile()){ dir.delete(); return; } // 获取目录下的所有文件和子目录 File[] files = dir.listFiles(); // 如果目录为空，则直接返回 if(files==null){ return; } // 遍历目录下的所有文件和子目录 for (File file : files) { if(file.isFile()){ // 如果是文件，则直接删除 file.delete(); } deleteDir(file); // 递归删除子目录 } dir.delete(); // 删除当前目录 } 字符集 UTF-32\n每个字符占4个字节，存储空间太大，没有普及 UTF-8\n是Unicode字符集的一种编码方案，采取可变长编码方案，共分为四个长度区：一个字节，两个字节，三个字节，四个字节 英文字符，数字等只占一个字节（兼容标准ASCII编码），汉字字符占用3个字节。 ASCII字符集：只有英文、数字、符号等，占1个字节 GBK字符集：汉字占2两个字节，英文，数字占1个字节 UTF-8字符集：汉字占3个字节，英文，数字占1个字节 import java.io.UnsupportedEncodingException; import java.util.Arrays; public static void main(String[] args) throws UnsupportedEncodingException { String data = \u0026#34;a啊a\u0026#34;; // 使用默认字符集（通常是UTF-8）将字符串转换为字节数组 byte[] bytes = data.getBytes(); System.out.println(Arrays.toString(bytes)); // 使用指定字符集（例如GBK）将字符串转换为字节数组 byte[] bytes1 = data.getBytes(\u0026#34;GBK\u0026#34;); System.out.println(Arrays.toString(bytes1)); // 将字节数组转换为字符串，使用默认字符集进行解码 String s = new String(bytes); System.out.println(s); // 将字节数组转换为字符串，使用指定字符集进行解码 String s1 = new String(bytes1, \u0026#34;GBK\u0026#34;); System.out.println(s1); } IO流 按流的方向分为\n输入流 输出流 按流中数据的最小单位，分为：\n字节流 适合操作所有类型的文件 比如：音频，视频，图片，文本文件的复制，转移等 字符流 适合操作纯文本文件 比如：读写txt, java文件等 FileInputStream(文件字节输入流) 作用：以内存为基准，可以把磁盘文件中的数据以字节的形式读入到内存中去 public static void main(String[] args) throws IOException { // 用多态的形式创建文件输入流 InputStream is = new FileInputStream(\u0026#34;file-io-app\\\\src\\\\com\\\\showguan\\\\ByteStreamDemo\\\\test.txt\u0026#34;); int b; // 读取文件内容，直到遇到文件末尾(-1) while((b = is.read()) != -1){ System.out.print((char) b); // 将读取到的字节转换为字符并打印到控制台 } is.close(); // 关闭文件输入流 } public static void main(String[] args) throws IOException { InputStream is = new FileInputStream(\u0026#34;file-io-app\\\\src\\\\com\\\\showguan\\\\ByteStreamDemo\\\\test.txt\u0026#34;); // 创建文件输入流 byte[] buffer = new byte[3]; // 创建缓冲区 int len1 = is.read(buffer); // 从文件中读取字节到缓冲区中 System.out.println(\u0026#34;当前读取的长度:\u0026#34; + len1); // 打印当前读取的长度 String s = new String(buffer); // 将缓冲区中的字节转换为字符串 System.out.println(s); // 打印字符串 } 文件字节输入流：一次读完全部字节\n方式一：定义一个字节数组与被读取的文件大小一样大，然后使用该字节数组，一次读完文件的全部字节。\n方法二：Java官方为InputStream提供了readAllBytes()方法， 可以直接把文件的全部字节读取到一个字节数组中返回。\npublic static void main(String[] args) throws IOException { // 从文件读取数据的两种方法：使用 InputStream 读取和使用 readAllBytes() 方法读取 // 方法一：使用 InputStream 读取文件数据 InputStream is = new FileInputStream(\u0026#34;file-io-app\\\\src\\\\com\\\\showguan\\\\ByteStreamDemo\\\\test.txt\u0026#34;); // 创建文件输入流 File f = new File(\u0026#34;file-io-app\\\\src\\\\com\\\\showguan\\\\ByteStreamDemo\\\\test.txt\u0026#34;); // 创建文件对象 long size = f.length(); // 获取文件大小 byte[] buffer = new byte[(int) size]; // 创建字节数组，用于存储文件内容，长度为文件大小（需要将 long 类型强制转换为 int 类型） int len = is.read(buffer); // 读取文件内容到字节数组，返回实际读取的字节数 System.out.println(new String(buffer)); // 将字节数组转换为字符串并打印输出 System.out.println(size); // 打印文件大小 System.out.println(len); // 打印实际读取的字节数 // 方法二：使用 readAllBytes() 方法读取文件数据 InputStream is1 = new FileInputStream(\u0026#34;file-io-app\\\\src\\\\com\\\\showguan\\\\ByteStreamDemo\\\\test.txt\u0026#34;); // 创建新的文件输入流 byte[] buffer1 = is1.readAllBytes(); // 使用 readAllBytes() 方法读取文件内容到字节数组 System.out.println(new String(buffer1)); // 将字节数组转换为字符串并打印输出 is.close(); // 关闭文件输入流 } FileOutputStream(文件字节输出流) 作用：以内存为基准，把内存中的数据以字节的形式写出到文件中去 public static void main(String[] args) throws IOException { // 创建文件输出流，指定文件路径，并设置为追加模式（true） FileOutputStream os = new FileOutputStream(\u0026#34;file-io-app\\\\src\\\\com\\\\showguan\\\\ByteStreamDemo\\\\test2.txt\u0026#34;, true); os.write(97); // 向文件中写入一个字节 os.write(\u0026#39;a\u0026#39;); // 向文件中写入一个字符 byte[] bytes = \u0026#34;今天是20240419\u0026#34;.getBytes(); // 将字符串转换为字节数组 // 向文件中写入字节数组的一部分内容 os.write(bytes, 0, 15); // 从字节数组的索引0开始，写入长度为15的字节数据 os.write(\u0026#34;\\r\\n\u0026#34;.getBytes()); // 向文件中写入换行符 os.close(); // 关闭文件输出流 } 文件复制 public class FileCopyDemo { /** * 程序入口点，复制一个文件的内容到另一个文件。 * @param args 命令行参数 * @throws IOException 如果发生I/O错误 */ public static void main(String[] args) throws IOException { InputStream is = new FileInputStream(\u0026#34;file-io-app\\\\src\\\\com\\\\showguan\\\\ByteStreamDemo\\\\test.jpg\u0026#34;); // 创建文件输入流，读取源文件 OutputStream os = new FileOutputStream(\u0026#34;D:\\\\JAVA\\\\test1\\\\img2.jpg\u0026#34;); // 创建文件输出流，写入目标文件 byte[] buffer = new byte[1024]; // 创建缓冲区 int len; // 定义变量用于保存读取的字节数 // 循环读取源文件内容，并写入目标文件 while((len = is.read(buffer)) != -1){ os.write(buffer, 0, len); // 将缓冲区中的字节写入目标文件 } os.close(); // 关闭文件输出流 is.close(); // 关闭文件输入流 System.out.println(\u0026#34;复制完成！\u0026#34;); // 打印复制完成的消息 } } 释放资源的方式 try-catch-finally finally代码区的特点：无论try中的程序是否正常执行了， 还是出现了异常，最后都一定会执行finally区， 除非JVM终止 作用：一般用于在程序执行完成后进行资源的释放操作(专业级做法) public static void main(String[] args) { // 声明输入和输出流对象为null，以确保在try块中可以访问这些对象 InputStream is = null; OutputStream os = null; try{ // 故意产生的异常，用于演示异常捕捉 System.out.println(10/0); // 创建一个FileInputStream来读取文件 is = new FileInputStream(\u0026#34;file-io-app\\\\src\\\\com\\\\showguan\\\\ResourceDemo\\\\test.txt\u0026#34;); // 创建一个FileOutputStream来写入文件 os = new FileOutputStream(\u0026#34;file-io-app\\\\src\\\\com\\\\showguan\\\\ResourceDemo\\\\test1.txt\u0026#34;); System.out.println(10/0); // 创建一个字节数组用于暂存从文件读取的数据 byte[] buffer = new byte[1024]; int len; // 循环读取并写入文件，直到文件结束 while((len=is.read(buffer))!=-1){ os.write(buffer, 0, len); } System.out.println(\u0026#34;复制完成！\u0026#34;); }catch (IOException e){ // 捕捉并处理IO异常 e.printStackTrace(); }finally { // 在finally块中释放资源，确保无论是否有异常发生，资源都被释放 try { // 关闭输出流资源 if(os!=null) os.close(); } catch (IOException e) { throw new RuntimeException(e); } try { // 关闭输入流资源 if(is!=null) is.close(); } catch (IOException e) { throw new RuntimeException(e); } } } try-with-resource public static void main(String[] args) { // 使用try-with-resources语法，自动关闭输入流和输出流 try ( InputStream is = new FileInputStream(\u0026#34;file-io-app\\\\src\\\\com\\\\showguan\\\\ResourceDemo\\\\test.txt\u0026#34;); // 创建文件输入流，读取源文件 OutputStream os = new FileOutputStream(\u0026#34;file-io-app\\\\src\\\\com\\\\showguan\\\\ResourceDemo\\\\test1.txt\u0026#34;); // 创建文件输出流，写入目标文件 ) { byte[] buffer = new byte[1024]; // 创建缓冲区 int len; // 定义变量用于保存读取的字节数 // 循环读取源文件内容，并写入目标文件 while ((len = is.read(buffer)) != -1) { os.write(buffer, 0, len); // 将缓冲区中的字节写入目标文件 } System.out.println(\u0026#34;复制完成！\u0026#34;); // 打印复制完成的消息 } catch (Exception e) { // 捕获可能发生的异常 e.printStackTrace(); // 打印异常信息 } } 注意：()里面只能放置资源对象，资源都会实现AutoCloseable接口\n资源用完之后，会自动调用close方法。\nIO字符流 FileReader public static void main(String[] args) throws FileNotFoundException { // 使用try-with-resources语法，自动关闭字符流 try ( Reader fr = new FileReader(\u0026#34;file-io-app\\\\src\\\\com\\\\showguan\\\\ResourceDemo\\\\test.txt\u0026#34;); // 创建字符输入流，读取文件 ) { // int c; // while((c=fr.read())!=-1){ // System.out.println((char) c); // } char[] buffer = new char[3]; // 创建缓冲区 int len; // 定义变量用于保存读取的字符数 // 循环读取文件内容，并打印到控制台 while((len=fr.read(buffer))!=-1){ System.out.print(new String(buffer, 0, len)); // 将缓冲区中的字符转换为字符串并打印 } } catch (Exception e) { // 捕获可能发生的异常 e.printStackTrace(); // 打印异常信息 } } FileWriter public static void main(String[] args) { // 使用try-with-resources语法，自动关闭字符流 try ( FileWriter fw = new FileWriter(\u0026#34;file-io-app\\\\src\\\\com\\\\showguan\\\\CharStreamDemo\\\\test.txt\u0026#34;, true); // 创建字符输出流，写入文件 ){ fw.write(\u0026#34;\\r\\n\u0026#34;); // 向文件中写入换行符 fw.write(\u0026#39;a\u0026#39;); // 向文件中写入字符 fw.write(\u0026#34;\\r\\n\u0026#34;); // 向文件中写入换行符 fw.write(98); // 向文件中写入字符对应的ASCII码 fw.write(\u0026#39;英\u0026#39;); // 向文件中写入字符 fw.write(\u0026#34;\\r\\n\u0026#34;); // 向文件中写入换行符 fw.write(\u0026#34;\\r\\n\u0026#34;); // 向文件中写入换行符 fw.write(\u0026#34;我是的话\u0026#34;); // 向文件中写入字符串 fw.write(\u0026#34;\\r\\n\u0026#34;); // 向文件中写入换行符 fw.write(\u0026#34;fw.write\u0026#34;); // 向文件中写入字符串 char[] buffer = {\u0026#39;黑\u0026#39;, \u0026#39;马\u0026#39;, \u0026#39;a\u0026#39;}; // 创建字符数组 fw.write(buffer); // 向文件中写入字符数组的内容 fw.write(buffer, 0, 2); // 向文件中写入字符数组的一部分内容 } catch (Exception e) { // 捕获可能发生的异常 e.printStackTrace(); // 打印异常信息 } } flush() public static void main(String[] args) throws IOException { Writer fw = new FileWriter(\u0026#34;file-io-app\\\\src\\\\com\\\\showguan\\\\CharStreamDemo\\\\test1.txt\u0026#34;); // 创建字符输出流，写入文件 fw.write(\u0026#39;a\u0026#39;); // 向文件中写入字符 \u0026#39;a\u0026#39; fw.write(\u0026#39;b\u0026#39;); // 向文件中写入字符 \u0026#39;b\u0026#39; fw.write(\u0026#39;c\u0026#39;); // 向文件中写入字符 \u0026#39;c\u0026#39; fw.flush(); // 手动刷新缓冲区，将缓冲区中的数据写入文件 fw.write(\u0026#39;a\u0026#39;); // 向文件中写入字符 \u0026#39;a\u0026#39; fw.close(); // 关闭字符输出流，会自动刷新 } 缓冲流 缓冲流：提高流读写数据的性能\n字节缓冲流 原理：字节缓冲输入流自带了8KB缓冲池，字节缓冲输出流也自带了8KB缓冲池 public static void main(String[] args) throws IOException { // 使用缓冲流进行文件复制操作 File f = new File(\u0026#34;file-io-app\\\\src\\\\com\\\\showguan\\\\BufferedStream\\\\test1.txt\u0026#34;); // 创建要复制到的新文件 f.createNewFile(); // 如果文件不存在，则创建新文件 try ( // 创建文件输入流和缓冲输入流，用于读取原始文件内容 InputStream is = new FileInputStream(\u0026#34;file-io-app\\\\src\\\\com\\\\showguan\\\\BufferedStream\\\\test.txt\u0026#34;); InputStream bis = new BufferedInputStream(is, 8192 * 2); // 使用 BufferedInputStream 进行缓冲 // 创建文件输出流和缓冲输出流，用于写入复制后的内容到新文件 OutputStream os = new FileOutputStream(\u0026#34;file-io-app\\\\src\\\\com\\\\showguan\\\\BufferedStream\\\\test1.txt\u0026#34;); OutputStream bos = new BufferedOutputStream(os, 8192 * 2); // 使用 BufferedOutputStream 进行缓冲 ) { byte[] buffer = new byte[1024]; // 创建字节数组作为缓冲区 int len; while ((len = bis.read(buffer)) != -1) { // 循环读取原文件内容到缓冲区 bos.write(buffer, 0, len); // 将缓冲区的内容写入到新文件中 System.out.println(\u0026#34;复制完成\u0026#34;); // 输出提示信息，表示复制完成 } } catch (Exception e) { e.printStackTrace(); // 打印异常信息 } } 字符缓冲流 输入流 import java.io.*; public class Main { public static void main(String[] args) { // 两种方式读取文件内容并逐行打印： try ( Reader fr = new FileReader(\u0026#34;file-io-app\\\\src\\\\com\\\\showguan\\\\BufferedStream\\\\test.txt\u0026#34;); // 创建 FileReader 对象以打开文件输入流 BufferedReader br = new BufferedReader(fr); // 创建 BufferedReader 对象，并将 FileReader 对象传递给它，用于缓冲读取操作 ) { // 普通方式 // char[] buffer = new char[3]; // int len; // while((len=br.read(buffer))!=-1){ // System.out.println(new String(buffer, 0, len)); // } // 使用 readLine() 方法逐行读取文件内容，并将每行内容打印输出 String line; while ((line = br.readLine()) != null) { System.out.println(line); // 打印每行内容 } } catch (Exception e) { e.printStackTrace(); // 打印异常信息 } } } 输出流 public static void main(String[] args) throws IOException { // 从一个文件读取数据，排序后写入到另一个文件 File f = new File(\u0026#34;file-io-app\\\\src\\\\com\\\\showguan\\\\BufferedStream\\\\test3.txt\u0026#34;); f.createNewFile(); // 如果文件不存在，则创建新文件 try ( // 创建 BufferedReader 读取原文件内容，创建 BufferedWriter 写入到新文件 BufferedReader br = new BufferedReader(new FileReader(\u0026#34;file-io-app\\\\src\\\\com\\\\showguan\\\\BufferedStream\\\\test2.txt\u0026#34;)); BufferedWriter bw = new BufferedWriter(new FileWriter(\u0026#34;file-io-app\\\\src\\\\com\\\\showguan\\\\BufferedStream\\\\test3.txt\u0026#34;)); ) { List\u0026lt;String\u0026gt; data = new ArrayList\u0026lt;\u0026gt;(); // 创建 List 用于存储文件内容 String line; while ((line = br.readLine()) != null) { // 逐行读取原文件内容并添加到 List 中 data.add(line); } Collections.sort(data); // 对 List 中的数据进行排序 for (String ln : data) { // 遍历排序后的数据 System.out.println(ln); // 打印每行内容 bw.write(ln); // 将每行内容写入到新文件 bw.newLine(); // 写入换行符 } } catch (Exception e) { e.printStackTrace(); // 打印异常信息 } } 不同流之间的性能差异 public class Main { public static final String SRC_FILE = \u0026#34;D:\\\\JAVA\\\\test1\\\\video.mp4\u0026#34;; public static final String DEST_FILE = \u0026#34;D:\\\\JAVA\\\\Test\\\\t\u0026#34;; public static void main(String[] args) { // try { // File f = new File(DEST_FILE + \u0026#34;\u0026#34;); // f.createNewFile(); // } catch (Exception e) { // e.printStackTrace(); // } // copy1(); copy2(); // copy3(); copy4(); } public static void copy1() { // 使用一个一个字节的方式复制文件 long startTime = System.currentTimeMillis(); try ( InputStream is = new FileInputStream(SRC_FILE); OutputStream os = new FileOutputStream(DEST_FILE + \u0026#34;1.mp4\u0026#34;); ) { int b; while ((b = is.read()) != -1) { os.write(b); } } catch (Exception e) { e.printStackTrace(); } long endTime = System.currentTimeMillis(); System.out.println(\u0026#34;一个一个字节流的形式耗时:\u0026#34; + (endTime-startTime) + \u0026#34;ms\u0026#34;); } public static void copy2() { // 使用字节数组的方式复制文件 long startTime = System.currentTimeMillis(); try ( InputStream is = new FileInputStream(SRC_FILE); OutputStream os = new FileOutputStream(DEST_FILE + \u0026#34;2.mp4\u0026#34;); ) { int len; byte[] buffer = new byte[1024]; while ((len = is.read(buffer)) != -1) { os.write(buffer, 0, len); } } catch (Exception e) { e.printStackTrace(); } long endTime = System.currentTimeMillis(); System.out.println(\u0026#34;1kb字节流的形式耗时:\u0026#34; + (endTime-startTime)+ \u0026#34;ms\u0026#34;); //1kb字节流的形式耗时:141 } public static void copy3() { // 使用缓冲流一个一个字节的方式复制文件 long startTime = System.currentTimeMillis(); try ( FileInputStream is = new FileInputStream(SRC_FILE); BufferedInputStream bis = new BufferedInputStream(is); FileOutputStream os = new FileOutputStream(DEST_FILE + \u0026#34;3.mp4\u0026#34;); BufferedOutputStream bos = new BufferedOutputStream(os); ) { int b; while ((b = bis.read()) != -1) { bos.write(b); } } catch (Exception e) { e.printStackTrace(); } long endTime = System.currentTimeMillis(); System.out.println(\u0026#34;缓冲流使用一个一个字节复制耗时:\u0026#34; + (endTime-startTime)+ \u0026#34;ms\u0026#34;); } public static void copy4() { // 使用缓冲流字节数组的方式复制文件 long startTime = System.currentTimeMillis(); try ( FileInputStream is = new FileInputStream(SRC_FILE); BufferedInputStream bis = new BufferedInputStream(is); FileOutputStream os = new FileOutputStream(DEST_FILE + \u0026#34;4.mp4\u0026#34;); BufferedOutputStream bos = new BufferedOutputStream(os); ) { byte[] buffer = new byte[1024]; int len; while ((len = bis.read(buffer)) != -1) { bos.write(buffer, 0, len); } } catch (Exception e) { e.printStackTrace(); } long endTime = System.currentTimeMillis(); System.out.println(\u0026#34;缓冲流使用字节数组复制耗时:\u0026#34; + (endTime-startTime) + \u0026#34;ms\u0026#34;); //缓冲流使用字节数组复制耗时:45 } } 转换流 字符输入转换流 public static void main(String[] args) { try ( InputStream is = new FileInputStream((\u0026#34;file-io-app\\\\src\\\\com\\\\showguan\\\\BufferedStream\\\\test2.txt\u0026#34;)); // 创建文件输入流 Reader isr = new InputStreamReader(is, \u0026#34;GBK\u0026#34;); // 创建 InputStreamReader 对象，指定字符编码为 GBK BufferedReader br = new BufferedReader(isr); // 创建 BufferedReader 对象，用于缓冲读取操作 ) { // 使用 BufferedReader 逐行读取文件内容，并打印输出 String line; while ((line = br.readLine()) != null) { System.out.println(line); } } catch (Exception e) { e.printStackTrace(); // 打印异常信息 } } 字符输出转换流 public static void main(String[] args) { try( OutputStream os = new FileOutputStream(\u0026#34;file-io-app\\\\src\\\\com\\\\showguan\\\\BufferedStream\\\\test6.txt\u0026#34;,true); // 创建文件输出流，指定追加模式为 true Writer osw = new OutputStreamWriter(os, \u0026#34;GBK\u0026#34;); // 创建 OutputStreamWriter 对象，指定字符编码为 GBK BufferedWriter bw = new BufferedWriter(osw); // 创建 BufferedWriter 对象，用于缓冲写入操作 ){ bw.write(\u0026#34;美好\u0026#34;); // 写入字符串到文件 bw.write(\u0026#34;真美好\u0026#34;); // 再次写入字符串到文件 } catch (Exception e) { e.printStackTrace(); // 打印异常信息 } } PrintStream/PrintWriter(打印流) 作用：打印流可以实现更方便， 更高效的打印数据出去，能实现答应什么出去就是什么 PrintStream public static void main(String[] args) { // 使用 PrintStream 向文件写入内容，并指定字符编码为 GBK try ( // 创建 PrintStream 对象，指定字符编码为 GBK PrintStream ps = new PrintStream(\u0026#34;file-io-app\\\\src\\\\com\\\\showguan\\\\PrintDemo\\\\test.txt\u0026#34;, Charset.forName(\u0026#34;GBK\u0026#34;)); ) { // 使用 println 方法写入字符和字符串 ps.println(\u0026#39;3\u0026#39;); ps.println(\u0026#39;a\u0026#39;); ps.println(\u0026#34;你好啊\u0026#34;); // 使用 write 方法写入字符 ps.write(\u0026#39;z\u0026#39;); } catch (Exception e) { e.printStackTrace(); // 打印异常信息 } } PrintWriter public static void main(String[] args) { // 使用 PrintWriter 向文件写入内容，并指定字符编码为 GBK try ( // 创建 PrintWriter 对象，指定字符编码为 GBK PrintWriter pw = new PrintWriter(\u0026#34;file-io-app\\\\src\\\\com\\\\showguan\\\\PrintDemo\\\\test.txt\u0026#34;, \u0026#34;GBK\u0026#34;); // 创建 PrintWriter 对象，通过 OutputStreamWriter 包装 FileOutputStream，并指定字符编码为 GBK PrintWriter pw1 = new PrintWriter(new OutputStreamWriter(new FileOutputStream(\u0026#34;file-io-app\\\\src\\\\com\\\\showguan\\\\PrintDemo\\\\test.txt\u0026#34;, true), \u0026#34;GBK\u0026#34;)); ) { // 使用 println 方法写入字符和字符串 pw.println(\u0026#39;3\u0026#39;); pw.println(\u0026#39;a\u0026#39;); pw.println(\u0026#34;你好啊\u0026#34;); // 使用 write 方法写入字符和字符串 pw.write(\u0026#39;z\u0026#39;); pw.write(\u0026#34;abcdefghijklim\u0026#34;); } catch (Exception e) { e.printStackTrace(); // 打印异常信息 } } 对比：\n打印数据的功能上是一模一样的：都是使用方便，性能高效（核心优势） PrintStream继承自字节输出流OutputStream， 因此支持写字节数据的方法 PrintWriter继承自字符输出流Writer， 因此支持写字符数据出去 输出重定向 public static void main(String[] args) { // 将输出重定向到文件 System.out.println(\u0026#34;你好\u0026#34;); // 在控制台打印输出 System.out.println(\u0026#34;志在千里\u0026#34;); // 在控制台打印输出 try ( // 创建 PrintStream 对象，将输出重定向到文件 PrintStream ps = new PrintStream(\u0026#34;file-io-app\\\\src\\\\com\\\\showguan\\\\PrintDemo\\\\test.txt\u0026#34;); ) { System.setOut(ps); // 将标准输出流重定向到 PrintStream 对象 System.out.println(\u0026#34;烈士暮年\u0026#34;); // 将输出重定向到文件中 } catch (FileNotFoundException e) { throw new RuntimeException(e); } } 数据流 数据输出流 public static void main(String[] args) { // 使用 DataOutputStream 写入不同类型的数据到文件 try ( // 创建 DataOutputStream 对象，用于写入数据到文件 DataOutputStream dos = new DataOutputStream(new FileOutputStream(\u0026#34;file-io-app\\\\src\\\\com\\\\showguan\\\\DataStreamDemo\\\\test.txt\u0026#34;)); ){ // 写入不同类型的数据到文件 dos.write(91); // 写入一个字节 dos.writeInt(10); // 写入一个整数 dos.writeDouble(99.8); // 写入一个双精度浮点数 dos.writeBoolean(true); // 写入一个布尔值 dos.writeUTF(\u0026#34;999黑马程序员\u0026#34;); // 写入一个 UTF-8 编码的字符串 } catch (Exception e) { e.printStackTrace(); // 打印异常信息 } } 数据输入流 public static void main(String[] args) { // 使用 DataInputStream 读取不同类型的数据 try ( // 创建 DataInputStream 对象，用于读取数据 DataInputStream dis = new DataInputStream(new FileInputStream(\u0026#34;file-io-app\\\\src\\\\com\\\\showguan\\\\DataStreamDemo\\\\test.txt\u0026#34;)); ) { // 依次读取不同类型的数据并打印输出 int b = dis.read(); System.out.println(b); int i = dis.readInt(); System.out.println(i); double d = dis.readDouble(); System.out.println(d); boolean bool = dis.readBoolean(); System.out.println(bool); String rs = dis.readUTF(); System.out.println(rs); } catch (Exception e) { e.printStackTrace(); // 打印异常信息 } } 序列化流 ObjectOutputStream/ObjectInputStream对象字节输出流\n可以把Java对象进行序列化：把java对象存入到文件中去 序列化 //User public class User implements Serializable { private String loginName; private String userName; private int age; private transient String passWord; } public static void main(String[] args) { // 使用 ObjectOutputStream 将对象序列化到文件 try ( // 创建 ObjectOutputStream 对象，用于将对象序列化到文件 ObjectOutputStream oos = new ObjectOutputStream(new FileOutputStream(\u0026#34;file-io-app\\\\src\\\\com\\\\showguan\\\\ObjectStreamDemo\\\\test1.txt\u0026#34;)); ) { // 创建 User 对象并初始化 User u = new User(\u0026#34;admin\u0026#34;, \u0026#34;K\u0026#34;, 18, \u0026#34;1919\u0026#34;); // 打印 User 对象的字符串表示 System.out.println(u.toString()); // 将 User 对象序列化到文件 oos.writeObject(u); System.out.println(\u0026#34;序列化成功！\u0026#34;); // 打印序列化成功消息 } catch (IOException e) { throw new RuntimeException(e); // 抛出运行时异常并打印异常信息 } } 反序列化 public static void main(String[] args) { // 使用 ObjectInputStream 从文件反序列化对象 try ( // 创建 ObjectInputStream 对象，用于从文件读取对象并反序列化 ObjectInputStream ois = new ObjectInputStream(new FileInputStream(\u0026#34;file-io-app\\\\src\\\\com\\\\showguan\\\\ObjectStreamDemo\\\\test1.txt\u0026#34;)); ){ // 从文件中读取对象并强制转换为 User 类型 User u = (User) ois.readObject(); // 打印反序列化得到的 User 对象的字符串表示 System.out.println(u.toString()); } catch (Exception e) { e.printStackTrace(); // 打印异常信息 } } 如何序列化多个对象？\n用一个ArrayList集合存储多个对象， 然后直接对集合进行序列化即可（ArrayList集合已经实现了序列化接口）\n序列化：\npublic static void main(String[] args) { try ( ObjectOutputStream oos = new ObjectOutputStream(new FileOutputStream(\u0026#34;file-io-app\\\\src\\\\com\\\\showguan\\\\ObjectStreamDemo\\\\test1.txt\u0026#34;)); ) { List\u0026lt;User\u0026gt; users = new ArrayList\u0026lt;\u0026gt;(); for (int i = 0; i \u0026lt; 100; i++) { User u = new User(\u0026#34;admin\u0026#34; + i, \u0026#34;K\u0026#34; + i, 18, \u0026#34;1919\u0026#34; + i); users.add(u); } // 使用循环逐个打印每个用户对象的字符串表示 for (User user : users) { System.out.println(user.toString()); } oos.writeObject(users); System.out.println(\u0026#34;序列化成功！\u0026#34;); } catch (IOException e) { throw new RuntimeException(e); } } 反序列化\npublic static void main(String[] args) { try ( ObjectInputStream ois = new ObjectInputStream(new FileInputStream(\u0026#34;file-io-app\\\\src\\\\com\\\\showguan\\\\ObjectStreamDemo\\\\test1.txt\u0026#34;)); ){ List\u0026lt;User\u0026gt; users = (ArrayList\u0026lt;User\u0026gt;) ois.readObject(); users.forEach( user -\u0026gt; { System.out.print(user.getUserName() + \u0026#34; \u0026#34;); System.out.print(user.getLoginName() + \u0026#34; \u0026#34;); System.out.print(user.getAge() + \u0026#34; \u0026#34;); System.out.print(user.getPassWord() + \u0026#34; \u0026#34;); }); } catch (Exception e) { e.printStackTrace(); } } IO框架 框架\n解决某类问题，编写的一套类、接口等，可以理解成一个半成品，大多框架都是第三方研发的 好处：在框架的基础上开发，可以得到优秀的软件架构，并能提高开发效率 IO框架\n封装了Java提供的对文件、数据进行操作的代码，对外提供了更简单的方式来对文件进行操作，对数据进行读写。 框架的导入：(Commons-IO)\n在项目中创建一个文件夹 ：lib 将xxx.jar文件复制到lib文件夹 在jar文件夹上点击右键，选择Add as Library 在类中导包使用 使用Commons-IO public static void main(String[] args) throws IOException { // 复制文件 FileUtils.copyFile(new File(\u0026#34;D:\\\\JAVA\\\\Test\\\\t3.mp4\u0026#34;), new File(\u0026#34;file-io-app\\\\src\\\\com\\\\showguan\\\\CommonsIODemo\\\\VideoTest.mp4\u0026#34;)); // 复制目录及其内容 FileUtils.copyDirectory(new File(\u0026#34;D:\\\\JAVA\\\\test1\u0026#34;), new File(\u0026#34;file-io-app\\\\src\\\\com\\\\showguan\\\\CommonsIODemo\\\\test\\\\t\u0026#34;)); // 删除目录及其内容 FileUtils.deleteDirectory(new File(\u0026#34;file-io-app\\\\src\\\\com\\\\showguan\\\\CommonsIODemo\\\\test\\\\t\u0026#34;)); // 读取文件内容为字符串 String rs = FileUtils.readFileToString(new File(\u0026#34;file-io-app\\\\src\\\\com\\\\showguan\\\\CommonsIODemo\\\\test1.txt\u0026#34;)); System.out.println(rs); // 向文件写入字符串数据，追加到文件末尾 FileUtils.writeStringToFile(new File(\u0026#34;file-io-app\\\\src\\\\com\\\\showguan\\\\CommonsIODemo\\\\test.txt\u0026#34;), \u0026#34;data\u0026#34;, true); } Files也能做到同样的效果，但是功能不够强大。\npublic static void main(String[] args) throws IOException { // 复制文件 Files.copy(Path.of(\u0026#34;file-io-app\\\\src\\\\com\\\\showguan\\\\CommonsIODemo\\\\test.txt\u0026#34;), Path.of(\u0026#34;file-io-app\\\\src\\\\com\\\\showguan\\\\CommonsIODemo\\\\test2.txt\u0026#34;)); } ","permalink":"https://kennems.github.io/zh/posts/tech/java20%E5%A4%A9%E9%80%9F%E6%88%90%E8%BF%9B%E9%98%B6%E8%AF%BE%E7%A8%8B3/","summary":"Java20天速成——进阶课程(3) 文件操作 File对象 常用方法 public static void main(String[] args) { // 创建File对象，表示文件test.txt的绝对路径 File f1 = new File(\u0026#34;D:/JAVA/JavaSeProMax/file-io-app/src/com/showguan/FileDemo/test.txt\u0026#34;);","title":"Java20天速成——进阶课程(3)"},{"content":"LeetCode笔记 目标：2500分\nHOT100 301. 删除无效的括号 题目大意：\n给你一个由若干括号和字母组成的字符串 s ，删除最小数量的无效括号，使得输入的字符串有效。\n返回所有可能的结果。答案可以按 任意顺序 返回。\n回溯 实现思路：\n统计无效括号数量：\n首先遍历字符串s，统计左括号和右括号的数量l和r，其中l表示未匹配的左括号数量，r表示需要删除的右括号数量。 回溯算法：\n编写回溯算法来尝试删除不同位置的括号，使得字符串有效。 回溯过程中需要注意以下情况： 已经匹配的括号数量ln和rn，以及当前位置i。 遍历字符串s的每个字符，当遇到重复的字符时跳过，以避免重复结果。 如果当前字符为左括号并且ln不为0，则递归调用删除当前左括号的情况，ln减一，否则继续。 如果当前字符为右括号并且rn不为0，则递归调用删除当前右括号的情况，rn减一，否则继续。 检查字符串有效性：\n编写辅助函数check来检查字符串是否有效，即左右括号数量是否匹配。 返回结果：\n将所有有效的字符串结果添加到结果列表ret中，并返回。 class Solution: def removeInvalidParentheses(self, s: str) -\u0026gt; List[str]: l, r = 0, 0 ret = [] n = len(s) for c in s: if c==\u0026#39;(\u0026#39;: l+=1 elif c==\u0026#39;)\u0026#39;: if l==0: r+=1 else: l-=1 def check(st): cnt=0 for c in st: if c==\u0026#39;(\u0026#39;: cnt+=1 elif c==\u0026#39;)\u0026#39;: cnt-=1 if cnt\u0026lt;0: return False return (cnt==0) def backtrace(st, start, ln, rn): if ln==0 and rn==0 and check(st): ret.append(st[:]) return for i in range(start, len(st)): if i\u0026gt;start and st[i]==st[i-1]: continue if ln+rn\u0026gt;n-1-i+1: break if ln and st[i]==\u0026#39;(\u0026#39;: backtrace(st[:i]+st[i+1:], i, ln-1, rn) elif rn and st[i]==\u0026#39;)\u0026#39;: backtrace(st[:i]+st[i+1:], i, ln, rn-1) backtrace(s, 0, l, r) return ret 广搜 这个实现使用了广度优先搜索（BFS）的思路来解决问题。\nBFS搜索：\n使用一个集合cur来存储当前层的所有字符串，初始时将输入的字符串s加入集合cur中。 在每一轮循环中，遍历当前集合cur中的所有字符串，如果其中有字符串是有效的，则将其加入结果列表ret中。 如果结果列表ret不为空，则跳出循环，表示已经找到了所有有效的字符串。 如果结果列表ret为空，则需要继续进行下一轮搜索，将当前集合cur中的每个字符串，通过删除一个括号的方式，生成所有可能的下一层字符串，加入到集合nxt中。 更新当前集合cur为nxt，继续下一轮搜索。 检查字符串有效性：\n定义一个辅助函数check，用于检查字符串是否有效。 遍历字符串中的每个字符，遇到左括号时增加计数器cnt，遇到右括号时如果cnt为0则返回False（表示右括号没有匹配的左括号），否则减少cnt。 最终判断cnt是否为0，如果为0表示字符串有效。 返回结果：\n返回结果列表ret，其中存储了所有有效的字符串。 class Solution: def removeInvalidParentheses(self, s: str) -\u0026gt; List[str]: ret = [] def check(st): cnt=0 for c in st: if c==\u0026#39;(\u0026#39;: cnt+=1 elif c==\u0026#39;)\u0026#39;: if cnt==0: return False cnt-=1 return cnt==0 cur = set([s]) while True: for st in cur: if check(st): ret.append(st) if len(ret): break nxt = set() for st in cur: for i in range(len(st)): if i\u0026gt;0 and st[i]==st[i-1]: continue if st[i]==\u0026#39;(\u0026#39; or st[i]==\u0026#39;)\u0026#39;: nxt.add(st[:i]+st[i+1:]) cur = nxt return ret 297. 二叉树的序列化与反序列化 不止第一次遇到了。\n题目大意：序列化是将一个数据结构或对象转换为连续的比特位的操作，从而可以存储在文件或内存中，并且通过网络传输到另一个计算机环境中。本题要求设计一个算法来实现二叉树的序列化和反序列化，即将二叉树转换为字符串并将字符串转换回原始的二叉树结构。\n实现思路：\n序列化：使用递归将二叉树转换为字符串，根节点值与左右子树序列化结果之间使用空格分隔，空节点用 \u0026lsquo;#\u0026rsquo; 表示。 反序列化：使用递归将字符串转换为二叉树。首先定义一个辅助函数 DerWork()，用于递归构建二叉树。在该函数中，按照前序遍历的顺序，依次提取字符串中的节点值，并根据节点值构建二叉树节点。如果节点值为 \u0026lsquo;#\u0026rsquo;，表示空节点，返回 None。否则，创建节点并递归构建其左右子树。 在反序列化过程中，使用一个全局变量 self.s 来记录当前待处理的字符串，每次递归处理后，将字符串中已经处理过的部分剔除，继续处理剩余部分。 最终返回根节点即可。 # Definition for a binary tree node. # class TreeNode(object): # def __init__(self, x): # self.val = x # self.left = None # self.right = None class Codec: def serialize(self, root): \u0026#34;\u0026#34;\u0026#34;Encodes a tree to a single string. :type root: TreeNode :rtype: str \u0026#34;\u0026#34;\u0026#34; if not root: return \u0026#39;#\u0026#39; return str(root.val)+\u0026#39; \u0026#39;+self.serialize(root.left)+\u0026#39; \u0026#39;+self.serialize(root.right) def deserialize(self, data): \u0026#34;\u0026#34;\u0026#34;Decodes your encoded data to tree. :type data: str :rtype: TreeNode \u0026#34;\u0026#34;\u0026#34; self.s = data return self.DerWork() def DerWork(self): if len(self.s)==0: return None try: idx = self.s.index(\u0026#39; \u0026#39;) except: idx = -1 node = self.s if idx==-1 else self.s[:idx] self.s = \u0026#39;\u0026#39; if idx==-1 else self.s[idx+1:] if node==\u0026#39;#\u0026#39;: return None t = TreeNode(int(node)) t.left = self.DerWork() t.right = self.DerWork() return t # Your Codec object will be instantiated and called as such: # ser = Codec() # deser = Codec() # ans = deser.deserialize(ser.serialize(root)) 84. 柱状图中最大的矩形 题目大意：给定 n 个非负整数，表示柱状图中各个柱子的高度。每个柱子彼此相邻，且宽度为 1。求在该柱状图中，能够勾勒出的矩形的最大面积。\n实现思路：\n使用单调栈解决问题。创建两个数组 l 和 r，分别记录每个柱子向左和向右第一个比其高度小的柱子的索引位置。 初始化一个空栈 stk。 遍历柱子的高度列表 heights： 若栈不为空且当前柱子的高度小于栈顶柱子的高度，则将栈顶元素弹出，并更新栈顶元素对应的 r 值为当前柱子的索引。 若栈为空或者当前柱子的高度大于栈顶柱子的高度，则将当前柱子的索引入栈。 在更新 r 值的同时，若栈不为空，则更新当前柱子的 l 值为栈顶元素的索引。 遍历完成后，对于每个柱子 i，计算以该柱子为高度的矩形面积为 (r[i] - l[i] - 1) * heights[i]，取最大值即为所求的最大矩形面积。 若柱状图为空，则返回 0。 class Solution: def largestRectangleArea(self, heights: List[int]) -\u0026gt; int: n=len(heights) l, r = [-1]*(n+5), [n]*(n+5) stk = list() for i in range(n): while stk and heights[stk[-1]]\u0026gt;=heights[i]: r[stk[-1]]=i stk.pop() if stk: l[i]=stk[-1] stk.append(i) return max( (r[i]-l[i]-1)*heights[i] for i in range(n) ) if n\u0026gt;0 else 0 85. 最大矩形 题目大意：给定一个仅包含 0 和 1、大小为 rows x cols 的二维二进制矩阵，找出只包含 1 的最大矩形，并返回其面积。\n实现思路：\n将问题转化为矩形最大面积问题。 定义变量 area 用于记录最大矩形的面积。 创建二维数组 left，用于记录每个位置 (i, j) 左侧连续 1 的个数。 遍历二维矩阵，初始化 left 数组： 若当前位置为 \u0026lsquo;1\u0026rsquo;，则 left[i][j] 等于 left[i][j-1] + 1，否则为 0。 遍历矩阵的每一列，对于每一列 j，使用单调栈来计算以当前列为底边的最大矩形的面积： 初始化一个空栈 stk。 定义两个数组 up 和 down，分别记录当前位置上方第一个小于等于其高度的位置和下方第一个小于等于其高度的位置。 遍历矩阵的每一行 i，进行以下操作： 当栈不为空且栈顶位置对应的 left 值大于等于当前位置的 left 值时，弹出栈顶位置，并更新 down 值。 如果栈为空，则当前位置的 up 值为 -1，否则为栈顶位置。 将当前行索引入栈。 在计算当前列的矩形面积时，height 为 down[i] - up[i] - 1，宽度为 left[i][j]，计算当前列的最大面积并更新 area。 返回最大面积 area。 class Solution: def maximalRectangle(self, matrix: List[List[str]]) -\u0026gt; int: # 转化为矩形最大面积问题 n, m = len(matrix), len(matrix[0]) area = 0 left = [[0]*m for _ in range(n)] for i in range(n): for j in range(m): if matrix[i][j]==\u0026#39;1\u0026#39;: left[i][j] += left[i][j-1]+1 if j else 1 for j in range(m): stk = [] up, down = [-1]*n, [n]*n for i in range(n): #行 while stk and left[ stk[-1] ][j]\u0026gt;=left[i][j]: down[stk[-1]] = i stk.pop() up[i] = stk[-1] if stk else -1 stk.append(i) for i in range(n): height = down[i]-up[i]-1 area = max(area, height*left[i][j]) return area 76. 最小覆盖子串 题目大意：给定字符串 s 和字符串 t，返回 s 中涵盖 t 所有字符的最小子串。如果 s 中不存在涵盖 t 所有字符的子串，则返回空字符串 \u0026ldquo;\u0026quot;。\n注意：\n对于 t 中重复字符，子字符串中该字符数量必须不少于 t 中该字符数量。\n如果 s 中存在这样的子串，保证它是唯一的答案。\n实现思路：\n使用双指针滑动窗口解决问题。 初始化 need 字典，用于记录字符串 t 中每个字符的出现次数。 初始化 needCnt 为 t 的长度 m，表示还需要的字符数量。 初始化左指针 left 为 0，并初始化结果变量 res 为一个长度为 n 的区间，初始值为 (0, n)。 遍历字符串 t，统计每个字符的出现次数并存储在 need 字典中。 遍历字符串 s，使用右指针 right 遍历每个字符： 若当前字符在 t 中出现，则 needCnt 减 1。 更新 need 字典中当前字符的出现次数。 若 needCnt 为 0，表示当前窗口包含了 t 中所有字符，进入内部循环： 移动左指针 left，直到当前窗口不再满足条件（即 need 字典中某个字符的出现次数大于 0）。 更新结果变量 res。 恢复左指针 left 和 needCnt。 返回结果字符串，若结果区间超出 s 的范围，则返回空字符串。 class Solution: def minWindow(self, s: str, t: str) -\u0026gt; str: n, m = len(s), len(t) need = defaultdict(int) needCnt = m left = 0 res = (0, n) for ch in t: need[ch]+=1 for right, ch in enumerate(s): if need[ch]\u0026gt;0: needCnt-=1 need[ch]-=1 if needCnt==0: while need[s[left]]!=0: need[s[left]]+=1 left+=1 if right-left \u0026lt; res[1]-res[0]: res = (left, right) need[s[left]]+=1 needCnt+=1 left+=1 return \u0026#39;\u0026#39; if res[1]\u0026gt;n-1 else s[res[0]:res[1]+1] 312. 戳气球 题意：给定n个数字num[0~n-1],每次戳破一个气球可以获得nums[i-1]*nums[i]*nums[i+1]个硬币，最两旁默认为1，问最终获得的最大硬币数量。 思路：区间DP，逆向思维, 思考如何放气球能使硬币最大，f[i][j]代表开区间i~j可以获得的最大硬币， 先枚举小区间，再枚举大区间，枚举区间内每个数字，状态转移有：f[i][j] = max(f[i][j], f[i][k]+f[k][j]+nums[i]*nums[k]*nums[j])。最终输出f[0][n+1] class Solution: def maxCoins(self, nums: List[int]) -\u0026gt; int: n = len(nums) nums = [1]+nums+[1] f = [[0]*(n+5) for _ in range(n+5)] # 开区间 (left, right) 区间内能获得的最大硬币 for l in range(2,n+2): # len:2~n+1 for i in range(n+1-l+1): # left:0~n+1-len j=i+l # right = left + len for k in range(i+1, j): # 开区间(i,j) 即[i+1, j-1] f[i][j] = max(f[i][j], f[i][k]+f[k][j]+nums[i]*nums[k]*nums[j]) return f[0][n+1] 301. 删除无效的括号 题目大意：给定一个由字母和括号组成的字符串s，要求删除最小数量的括号，使得字符串成为有效的括号组合，并返回所有可能的结果。\n实现思路：\n首先定义一个辅助函数check(st)，用于检查字符串st是否为有效的括号组合。遍历字符串中的每个字符，维护一个计数器cnt，遇到左括号增加计数，遇到右括号减少计数，若出现cnt为负数，或者遍历结束后cnt不为0，则说明括号不匹配，返回False，否则返回True。\n初始化一个空列表ret，用于存储结果。\n初始化一个集合cur，初始时将输入字符串s作为唯一元素加入其中。\n使用while循环，直到找到符合条件的结果为止：\n遍历集合cur中的每个字符串，检查其是否为有效括号组合，若是则将其加入结果列表ret。\n若结果列表ret不为空，则说明已找到符合条件的结果，结束循环。\n否则，初始化一个空集合nxt，用于存储下一轮迭代的候选字符串集合。\n遍历集合cur中的每个字符串，对于每个字符串，尝试删除一个字符（括号），生成新的字符串，并将其加入nxt中。\n更新cur为nxt，继续下一轮迭代。\n返回结果列表ret。\nclass Solution: def removeInvalidParentheses(self, s: str) -\u0026gt; List[str]: ret = [] def check(st): cnt=0 for c in st: if c==\u0026#39;(\u0026#39;: cnt+=1 elif c==\u0026#39;)\u0026#39;: if cnt==0: return False cnt-=1 return cnt==0 cur = set([s]) while True: for st in cur: if check(st): ret.append(st) if len(ret): break nxt = set() for st in cur: for i in range(len(st)): if i\u0026gt;0 and st[i]==st[i-1]: continue if st[i]==\u0026#39;(\u0026#39; or st[i]==\u0026#39;)\u0026#39;: nxt.add(st[:i]+st[i+1:]) cur = nxt return ret 11. 盛最多水的容器 题目大意：给定一个长度为n的整数数组height，数组中的每个元素代表一条垂直线的高度。找出其中的两条线，使得它们与x轴构成的容器可以容纳最多的水。\n实现思路：使用双指针法。初始化左指针l指向数组的起始位置，右指针r指向数组的末尾位置。设置变量ret用于记录当前最大容量，初始化为0。在每一轮循环中，计算当前容器的容量，即min(height[l], height[r])乘以r和l之间的距离，更新ret。然后根据指针所指向的高度的大小，移动指针，如果height[l]\u0026lt;height[r]，则移动左指针l向右一步，否则移动右指针r向左一步。直到左右指针相遇，循环结束，返回ret即可。\n正确性证明： 对于左右端点 $ l, r$， 两点之间的距离为$len = r-l+1-1$(因为两个点之间算一段，所以长度要减一)，$ ret = (r-l)*min(height[l], height[r])$,假设 $height[l]\u0026lt;height[r]$, 对于左端点，其作为柱子能容纳的最多的水的数量已经为最大值，任意的 $l\u0026lt;x\u0026lt;r$ 作为右端点一定比$r$做端点更差，所以可以排除左端点$l$，计算下一点即$l+1$。从左右端点开始，对于每次排除的点，已经找到这个端点可能的最大值， 所以可以保证结果的正确性。 class Solution: def maxArea(self, height: List[int]) -\u0026gt; int: l, r = 0, len(height)-1 ret = 0 while l\u0026lt;r: ret = max( ret, (r-l)*min(height[l], height[r]) ) if height[l]\u0026lt;height[r]: l+=1 elif height[l]\u0026gt;height[r]: r-=1 else: l+=1 r-=1 return ret 647. 回文子串 题目大意：给定一个字符串s，统计并返回该字符串中回文子串的数目。回文字符串是指正着读和倒过来读一样的字符串。子字符串是字符串中的由连续字符组成的一个序列。即使是由相同字符组成的不同开始位置或结束位置的子串，也会被视作不同的子串。\n实现思路：遍历字符串s的所有可能的中心位置，对于每个中心位置，向两边扩展，判断是否是回文串。在扩展的过程中，每当发现一个回文子串，就将计数器加1。最终返回计数器的值即可。\nclass Solution: def countSubstrings(self, s: str) -\u0026gt; int: n = len(s) ans = 0 for i in range(2*n - 1): l, r = i//2, i//2 + (i\u0026amp;1) while l\u0026gt;=0 and r\u0026lt;n and s[l]==s[r]: l-=1; r+=1 ans+=1 return ans 93. 复原 IP 地址 题目大意：给定一个只包含数字的字符串s，表示一个IP地址，要求返回所有可能的有效IP地址，即每个IP地址由四个整数组成（每个整数位于0到255之间，且不能含有前导0），整数之间用\u0026rsquo;.\u0026lsquo;分隔。不能重新排序或删除s中的任何数字，可以按任何顺序返回答案。\n实现思路：使用深度优先搜索（DFS）算法，递归地搜索所有可能的IP地址组合。在搜索过程中，首先确定每个整数的范围，然后遍历可能的数字组合，逐步构建IP地址。递归的终止条件是已经找到了四个整数并且已经遍历完了整个字符串s。\nclass Solution: def restoreIpAddresses(self, s: str) -\u0026gt; List[str]: n = len(s) res, addr = [], [\u0026#39;0\u0026#39;]*4 def dfs(i, start): if i==4 or start==n: if i==4 and start==n: res.append(\u0026#39;.\u0026#39;.join(addr)) return if s[start]==\u0026#39;0\u0026#39;: addr[i] = \u0026#39;0\u0026#39; dfs(i+1, start+1) return num = 0 for end in range(start, n): num = num*10 + int(s[end]) if num in range(256): addr[i] = str(num) dfs(i+1, end+1) dfs(0, 0) return res 538. 把二叉搜索树转换为累加树 题目大意：给定一个二叉搜索树的根节点，需要将其转换为累加树，即每个节点的新值等于原树中大于或等于该节点值的节点值之和。\nclass Solution: def convertBST(self, root: Optional[TreeNode]) -\u0026gt; Optional[TreeNode]: s = 0 def dfs(r): nonlocal s if not r: return 0 dfs(r.right) s += r.val r.val = s dfs(r.left) dfs(root) return root 实现思路：**(Morris 遍历)**从根节点开始，采用反向中序遍历（右-根-左）的方式进行遍历。利用一个变量 s 记录累加和，初始值为 0。对于每个节点，首先判断其是否存在右子节点，如果不存在，则将其值加上累加和并更新累加和，然后将当前节点指向其左子节点；如果存在右子节点，则找到其中序遍历的后继节点，即右子树中最左边的节点。如果后继节点的左子节点为空，说明还未处理过该节点，则将后继节点的左子节点指向当前节点，并将当前节点指向其右子节点；如果后继节点的左子节点为当前节点，则说明已经处理过该节点，则将后继节点的左子节点置为空，将当前节点的值加上累加和并更新累加和，并将当前节点指向其左子节点。最后返回根节点。\nclass Solution: def convertBST(self, root: Optional[TreeNode]) -\u0026gt; Optional[TreeNode]: def getSucc(node): succ = node.right while succ.left and succ.left!=node: succ = succ.left return succ newRoot = root s = 0 while root: if not root.right: s += root.val root.val = s root = root.left else: succ = getSucc(root) if not succ.left: succ.left = root root = root.right else: succ.left = None s += root.val root.val = s root = root.left return newRoot 15. 三数之和 题目大意：给定一个整数数组 nums，判断是否存在三元组 [nums[i], nums[j], nums[k]] 满足 i != j、i != k 且 j != k，同时还满足 nums[i] + nums[j] + nums[k] == 0。返回所有满足条件的不重复的三元组。\n实现思路：首先对数组 nums 进行排序。然后遍历数组，对于每个元素 nums[i]，设定两个指针 l 和 r 分别指向 i+1 和数组末尾。在 l 和 r 之间寻找和为 0 的两个数。具体地，如果当前元素与前一个元素相同，跳过；如果当前元素与 l+1 处的元素相同，跳过；在 l 和 r 之间利用双指针的方式找到满足条件的两个数，如果找到了满足条件的三元组，则添加到结果中。最后返回结果列表 res。\nclass Solution: def threeSum(self, nums: List[int]) -\u0026gt; List[List[int]]: n = len(nums) nums.sort() res = [] for i in range(n): l = i r = n-1 if i and nums[i]==nums[i-1]: continue for m in range(l+1, n): if m\u0026gt;l+1 and nums[m]==nums[m-1]: continue while r\u0026gt;m and nums[r]+nums[m]+nums[l]\u0026gt;0: r-=1 if m==r: break if nums[r]+nums[m]+nums[l]==0: res.append([nums[l], nums[m], nums[r]]) return res 实现思路：首先，利用 Counter 函数统计每个数出现的次数，并检查是否有 0 出现至少三次，如果是则将 [0, 0, 0] 添加到结果中。然后，对不重复的数进行排序。遍历排序后的数，对于每个数 num，如果 num 不等于 0 且 num 出现次数大于 1 且 -num*2 也在 Counter 中，则将 [num, num, -num*2] 添加到结果中。然后，在负数部分，利用双指针的方式寻找满足条件的两个数。最后返回结果列表 res。\nclass Solution: def threeSum(self, nums: List[int]) -\u0026gt; List[List[int]]: res = [] c = Counter(nums) if 0 in c and c[0] \u0026gt;= 3: res.append([0,0,0]) no_repeat_nums = sorted(c.keys()) for i,num in enumerate(no_repeat_nums): if num != 0 and c[num] \u0026gt; 1 and -num*2 in c: res.append([num,num,-num*2]) if num \u0026lt; 0: for num3 in no_repeat_nums[ bisect_left(no_repeat_nums,((-num+1)/2)) : bisect_right(no_repeat_nums,-num*2-1) ]: num2 = -num-num3 if num2 in c: res.append([num,num2,num3]) return res 494. 目标和 题目大意：给定一个非负整数数组 nums 和一个目标整数 target，通过给数组中的每个整数前添加 \u0026lsquo;+\u0026rsquo; 或 \u0026lsquo;-\u0026rsquo;，然后串联起来构造表达式，返回可以构造的表达式数目，使其运算结果等于目标数。\n记忆化搜索 实现思路：这个问题可以转化为一个背包问题。我们可以将问题转化为在数组中选取一些数，使得它们的和等于 target。定义一个递归函数 dfs(i, s)，表示在数组 nums 中考虑第 i 个数，使得目前的和为 s 的表达式数目。递归的终止条件是遍历完所有数，如果 s 等于 0，表示找到了一种构造方式，返回 1，否则返回 0。递归过程中，如果 s 小于当前数 nums[i]，说明无法选取当前数，直接跳过；否则，递归考虑选取当前数和不选取当前数两种情况。利用缓存装饰器 @cache 可以将重复计算的结果进行缓存，提高计算效率。最后返回 dfs(0, target) 即可得到结果。\nclass Solution: def findTargetSumWays(self, nums: List[int], target: int) -\u0026gt; int: target += sum(nums) if target\u0026lt;0 or target\u0026amp;1: return 0 target//=2 @cache def dfs(i, s): if i==len(nums): return 1 if s==0 else 0 if s\u0026lt;nums[i]: return dfs(i+1, s) else: return dfs(i+1, s) + dfs(i+1, s-nums[i]) return dfs(0, target) 动态规划 实现思路：这里采用动态规划来解决。首先将目标数 target 加上数组 nums 的总和，如果总和为负数或者是奇数，则无法通过调整符号得到目标数，直接返回 0。否则，将目标数除以 2，然后定义一个二维数组 f，其中 f[i][j] 表示在考虑前 i 个数时，构造和为 j 的表达式的数目。初始化 f[0][0] = 1。然后，遍历数组 nums，并且更新 f[i][j]。当 j 小于当前数 nums[i-1] 时，表示无法选取当前数，则 f[i][j] 等于上一个状态的值；当 j 大于等于当前数 nums[i-1] 时，可以选择加上或减去当前数，则 f[i][j] 等于上一个状态加上不选取当前数的值以及上一个状态加上选取当前数的值。最后返回 f[n][target]，其中 n 是数组 nums 的长度。\nclass Solution: def findTargetSumWays(self, nums: List[int], target: int) -\u0026gt; int: target+=sum(nums) if target\u0026lt;0 or target%2: return 0 target//=2 n = len(nums) f = [[0]*(target+1) for _ in range(n+1)] f[0][0] = 1 for i in range(1, n+1): for j in range(target+1): if j\u0026lt;nums[i-1]: f[i][j] = f[i-1][j] else: f[i][j] = f[i-1][j] + f[i-1][j-nums[i-1]] return f[n][target] 581. 最短无序连续子数组 题目大意：给定一个整数数组 nums，找出一个连续子数组，使得对该子数组进行升序排序后，整个数组都变为升序排序。要求找出符合题意的最短子数组，并输出其长度。\n实现思路：使用两个指针left和right，初始化为-1，遍历数组nums。首先，从左到右找到第一个无序的元素，即当前元素小于前面已遍历过的最大元素，此时更新right指针为当前位置i；然后，从右到左找到第一个无序的元素，即当前元素大于后面已遍历过的最小元素，此时更新left指针为当前位置n-i-1。最终返回right-left+1即为最短无序连续子数组的长度。\nclass Solution: def findUnsortedSubarray(self, nums: List[int]) -\u0026gt; int: n = len(nums) ma, right = -inf, -1 mi, left = inf, -1 for i in range(n): if ma\u0026gt;nums[i]: right = i else: ma = nums[i] if mi\u0026lt;nums[n-i-1]: left = n-i-1 else: mi = nums[n-i-1] return 0 if right==-1 else right-left+1 416. 分割等和子集 题目大意：给定一个非空数组 nums，数组中只包含正整数。要求判断是否能将该数组分割成两个子集，使得这两个子集的元素和相等。\n实现思路：\n首先计算数组 nums 的总和 s。 如果总和 s 为奇数，那么无法分割成两个和相等的子集，直接返回 False。 如果数组中的最大值大于总和的一半，则无法分割成两个和相等的子集，直接返回 False。 初始化一个大小为总和一半加一的布尔数组 f，f[i] 表示是否存在子集的和为 i。 将 f[0] 初始化为 True，表示子集的和为 0。 遍历数组 nums，对于每个正整数 num，从总和一半开始向前遍历，更新数组 f，如果 f[j-num] 为 True，则说明存在一个子集的和为 j-num，加上当前的 num 后，和为 j，因此 f[j] 也为 True。 最终返回 f[s//2]，表示是否存在一个子集的和为总和一半，即是否能分割成两个和相等的子集。 class Solution: def canPartition(self, nums: List[int]) -\u0026gt; bool: s = sum(nums) if s\u0026amp;1: return False ma = max(nums) t = s//2 if ma\u0026gt;t: return False n = len(nums) f = [False]*(t+1) f[0] = True for i, num in enumerate(nums): for j in range(t, num-1, -1): f[j] |= f[j-num] return f[t] 394. 字符串解码 题目大意：给定一个经过编码的字符串，其中编码规则为k[encoded_string]，表示encoded_string中的内容重复k次。要求解码该字符串。\n实现思路：使用递归来解码字符串。遍历输入字符串，根据不同情况进行处理：\n若遇到数字，则累加数字直至遇到非数字字符。 若遇到字母，则直接加入当前解码的字符串中。 若遇到左括号\u0026rsquo;[\u0026rsquo;，则递归调用解码函数，处理括号内的内容，直至遇到右括号\u0026rsquo;]\u0026rsquo;。将括号内的解码结果乘以前面累积的数字，并加入当前解码的字符串中。 若遇到右括号\u0026rsquo;]\u0026rsquo;，则返回当前解码的字符串和当前索引。 返回最终解码结果。 class Solution: def decodeString(self, s: str) -\u0026gt; str: def decode(i, n): cur = \u0026#34;\u0026#34;; num = 0 while i\u0026lt;len(s): if s[i].isdigit(): num = num*10 + int(s[i]) elif s[i].isalpha(): cur += s[i] elif s[i] == \u0026#39;[\u0026#39;: ns, ni = decode(i+1, num) # next str, next index cur += ns; i = ni num = 0 elif s[i]==\u0026#39;]\u0026#39;: return cur*n, i i += 1 return cur*n, i res, _ = decode(0, 1) return res 72. 编辑距离 题目大意： 给定两个单词 word1 和 word2，求通过插入、删除或替换字符，将 word1 转换成 word2 所需的最少操作数。\n记忆化搜索 这段代码使用了递归的方式求解，其中 dfs 函数表示将 s 的前 i 个字符转换为 t 的前 j 个字符所需的最少操作数。递归的基本情况是当 i 小于 0 时，表示 s 已经遍历完，需要插入 t 的前 j+1 个字符；当 j 小于 0 时，表示 t 已经遍历完，需要删除 s 的前 i+1 个字符；当 s[i] 等于 t[j] 时，不需要额外操作，直接递归处理 i-1 和 j-1；当 s[i] 不等于 t[j] 时，可以选择插入、删除或替换操作，选择操作数最小的方案。递归的过程中利用了缓存装饰器 @cache 来提高效率。\nclass Solution: def minDistance(self, s: str, t: str) -\u0026gt; int: n, m = len(s), len(t) @cache def dfs(i, j): if i\u0026lt;0: return j+1 if j\u0026lt;0: return i+1 if s[i]==t[j]: return dfs(i-1, j-1) return min(dfs(i-1, j), dfs(i, j-1), dfs(i-1, j-1)) + 1 return dfs(n-1, m-1) 递推 实现思路： 可以使用动态规划来解决这个问题。定义一个二维数组 f，其中 f[i][j] 表示将 word1 的前 i 个字符转换为 word2 的前 j 个字符所需的最少操作数。初始时，f[i][0] 表示将 word1 的前 i 个字符全部删除，需要的操作数为 i，而 f[0][j] 表示将 word2 的前 j 个字符全部插入到 word1 中，需要的操作数为 j。 然后，根据动态规划的状态转移方程，逐步计算 f[i][j] 的值。若 word1[i] 等于 word2[j]，则 f[i][j] 等于 f[i-1][j-1]，即不需要额外操作；若不相等，则可以考虑插入、删除或替换操作，选择操作数最小的方案。最终，返回 f[n][m]，其中 n 和 m 分别为 word1 和 word2 的长度。\nclass Solution: def minDistance(self, s: str, t: str) -\u0026gt; int: n, m = len(s), len(t) f = [[0]*(m+1) for _ in range(n+1)] f[0] = list(range(m+1)) # f[0][j] = j for i in range(n): f[i+1][0] = i+1 for j in range(m): if s[i]==t[j]: f[i+1][j+1] = f[i][j] else: f[i+1][j+1] = min(f[i][j+1], f[i+1][j], f[i][j]) + 1 return f[n][m] 96. 不同的二叉搜索树 class Solution: def numTrees(self, n: int) -\u0026gt; int: f = [0]*(n+1) f[0] = 1; f[1] = 1 for i in range(2, n+1): for j in range(1, i+1): f[i] += f[i-j]*f[j-1] return f[n] 160. 相交链表 class Solution: def getIntersectionNode(self, headA: ListNode, headB: ListNode) -\u0026gt; Optional[ListNode]: l1, l2 = headA, headB while l1 != l2: l1 = headB if not l1 else l1.next l2 = headA if not l2 else l2.next return l1 31. 下一个排列 题目大意：给定一个整数数组，要求找出这个数组的下一个排列，即比当前排列大的下一个排列，如果不存在则返回字典序最小的排列。\n实现思路：要找到下一个排列，可以遵循以下步骤：\n从数组末尾开始，找到第一个相邻的两个数，满足 nums[i] \u0026lt; nums[i+1]。 如果找到了这样的一对数，说明当前排列还不是最大的排列，可以进行下一步操作。 在从右往左找到的第一个位置记为 i，再从数组末尾开始，找到第一个大于 nums[i] 的数，记为 j。 交换 nums[i] 和 nums[j]。 将从 i+1 位置开始到数组末尾的数逆序排列，以得到字典序最小的排列。 如果步骤1中没有找到相邻的两个数，则说明当前排列已经是最大的排列，直接将整个数组逆序排列即可。 class Solution: def nextPermutation(self, nums: List[int]) -\u0026gt; None: \u0026#34;\u0026#34;\u0026#34; Do not return anything, modify nums in-place instead. \u0026#34;\u0026#34;\u0026#34; n = len(nums) i = n-2 while i\u0026gt;=0 and nums[i] \u0026gt;= nums[i+1]: i-=1 if i\u0026gt;=0: j = n-1 while j\u0026gt;=i and nums[j] \u0026lt;= nums[i]: j-=1 nums[i], nums[j] = nums[j], nums[i] nums[i+1:] = reversed(nums[i+1:]) 33. 搜索旋转排序数组 题目大意： 给定一个按升序排列的整数数组 nums，数组中的值互不相同。该数组经过未知的某个下标旋转，即原本排在数组开头的一部分元素被移动到数组末尾。给定一个目标值 target，如果该目标值存在于旋转后的数组中，则返回其下标，否则返回 -1。要求设计一个时间复杂度为 O(log n) 的算法解决此问题。\n实现思路：\n使用二分查找算法来解决此问题，以满足 O(log n) 的时间复杂度要求。 初始化左右指针 l 和 r 分别指向数组的首尾元素。 在循环中，计算中间位置 mid，判断 nums[mid] 是否等于目标值 target，若是则直接返回 mid。 若 nums[0] \u0026lt;= nums[mid]，说明左半段是有序的，此时判断目标值是否在左半段范围内，若是则将右指针移到 mid-1，否则将左指针移到 mid+1。 若 nums[0] \u0026gt; nums[mid]，说明右半段是有序的，此时判断目标值是否在右半段范围内，若是则将左指针移到 mid+1，否则将右指针移到 mid-1。 若循环结束仍未找到目标值，则返回 -1。 class Solution: def search(self, nums: List[int], target: int) -\u0026gt; int: if not nums: return -1 n = len(nums) l, r = 0, n-1 while l\u0026lt;=r: mid = l+r\u0026gt;\u0026gt;1 if nums[mid]==target: return mid if nums[0]\u0026lt;=nums[mid]: if nums[0] \u0026lt;= target \u0026lt; nums[mid]: r = mid-1 else: l = mid+1 else: if nums[mid] \u0026lt; target \u0026lt;= nums[n-1]: l = mid+1 else: r = mid-1 return -1 19. 删除链表的倒数第 N 个结点 题目大意：给定一个链表，要求删除倒数第n个节点，并返回链表的头结点。\n实现思路：使用双指针，首先让第一个指针从头节点开始向后移动n步，然后同时移动第一个指针和第二个指针，直到第一个指针到达链表末尾。这样第二个指针所指的位置就是倒数第n个节点的前一个节点，然后进行删除操作即可。需要注意的是要考虑边界情况，比如链表长度为1，删除头节点等情况。\n# Definition for singly-linked list. # class ListNode: # def __init__(self, val=0, next=None): # self.val = val # self.next = next class Solution: def removeNthFromEnd(self, head: Optional[ListNode], n: int) -\u0026gt; Optional[ListNode]: if not head.next: return None p1 = head n-=1 while n: p1 = p1.next n-=1 pre = p2 = head while p1.next: p1 = p1.next pre = p2 p2 = p2.next if p2==head: head = head.next else: pre.next = pre.next.next return head 148. 排序链表 题目大意：给定一个链表的头结点head，要求将链表按升序排列，并返回排序后的链表。\n实现思路：\n使用归并排序的思想对链表进行排序。 编写递归函数sortFun(head, tail)，其中head表示当前待排序的子链表的头结点，tail表示当前待排序的子链表的尾结点的下一个结点（即尾结点的后继结点）。 在sortFun函数中，使用快慢指针找到当前待排序子链表的中间结点mid，并将链表分为两部分，左边部分由head到mid-1，右边部分由mid到tail-1。 递归调用sortFun函数对左右两部分进行排序，直至排序完成。 编写merge函数，将已经排好序的左右两部分链表进行合并，合并过程中按照结点的值大小进行比较，将较小的结点连接到结果链表中。 返回合并后的链表。 # Definition for singly-linked list. # class ListNode: # def __init__(self, val=0, next=None): # self.val = val # self.next = next class Solution: def sortList(self, head: Optional[ListNode]) -\u0026gt; Optional[ListNode]: def sortFun(head, tail): if not head: return head if head.next == tail: head.next = None return head slow = fast = head while fast != tail: fast = fast.next slow = slow.next if fast != tail: fast = fast.next mid = slow return merge(sortFun(head, mid), sortFun(mid, tail)) def merge(h1, h2): dummy = ListNode(-1) cur = dummy while h1 and h2: if h1.val\u0026lt;=h2.val: cur.next = h1 h1 = h1.next else: cur.next = h2 h2 = h2.next cur = cur.next if h1: cur.next = h1 if h2: cur.next = h2 return dummy.next return sortFun(head, None) 581. 最短无序连续子数组 题目大意：给定一个整数数组nums，找出一个连续子数组，使得对该子数组进行升序排序后，整个数组都变为升序排序。要求找出符合条件的最短子数组，并输出其长度。\n实现思路：\n首先初始化最大值mx为负无穷，最小值mn为正无穷，以及最短子数组的左右边界left和right分别为-1。 遍历数组nums，从左向右寻找右边界right，如果当前元素小于前面的最大值mx，则更新right为当前索引；否则更新最大值mx为当前元素。 同时，从右向左寻找左边界left，如果当前元素大于后面的最小值mn，则更新left为当前索引；否则更新最小值mn为当前元素。 最后返回右边界和左边界的差加1，即为最短子数组的长度。如果左边界仍为初始值-1，则返回0表示整个数组已经有序。 class Solution: def findUnsortedSubarray(self, nums: List[int]) -\u0026gt; int: n = len(nums) mx, right = -inf, -1 mn, left = inf, -1 for i in range(n): if mx\u0026gt;nums[i]: right = i else: mx = nums[i] if mn\u0026lt;nums[n-1-i]: left = n-1-i else: mn = nums[n-1-i] return 0 if left==-1 else right-left+1 线段树 729. 我的日程安排表 I 题目大意：这个题目是关于设计一个日程安排类 MyCalendar，它能够存储日程，并判断是否会有重复预订。日程以半开区间 [start, end) 表示，当两个日程时间有交叠时就会产生重复预订。 实现思路：\n使用线段树：\n我们可以使用线段树来表示时间段的预订情况。每个节点代表一个时间段，节点值表示这个时间段是否被预订。 对于每个节点，我们维护两个集合，self.tree 表示已经预订的节点，self.lazy 表示已经被标记为预订但尚未被更新的节点。 查询功能：\n当需要查询某个时间段是否被预订时，我们可以在线段树上进行查询。如果查询到某个节点被标记为已预订（包括被标记为预订但尚未更新的节点），则返回预订；否则返回未预订。 更新功能：\n当要预订某个时间段时，我们在线段树上进行更新操作。首先从根节点开始，递归地向下更新，将该时间段的节点标记为已预订，并将经过的节点加入 self.tree 中。 同时，如果该节点的两个子节点都被标记为已预订，则将该节点也标记为已预订，同时加入 self.lazy 中，表示其下的所有节点都已经被预订但尚未更新。 book 方法：\n在 book 方法中，首先判断要预订的时间段是否已经被预订，如果是，则返回 False；否则，调用 update 方法进行更新，并返回 True。 class MyCalendar: def __init__(self): self.tree = set() self.lazy = set() def query(self, start: int, end: int, l: int, r: int, idx: int) -\u0026gt; bool: if r \u0026lt; start or end \u0026lt; l: return False if idx in self.lazy: # 如果该区间已被预订，则直接返回 return True if start \u0026lt;= l and r \u0026lt;= end: return idx in self.tree mid = (l + r) // 2 return self.query(start, end, l, mid, 2 * idx) or \\ self.query(start, end, mid + 1, r, 2 * idx + 1) def update(self, start, end, l, r, idx): if start\u0026gt;r or end\u0026lt;l: return False if start\u0026lt;=l and r\u0026lt;=end: self.tree.add(idx) self.lazy.add(idx) else: mid = (l+r)\u0026gt;\u0026gt;1 self.update(start, end, l, mid, idx*2) self.update(start, end, mid+1, r, idx*2+1) self.tree.add(idx) if 2*idx in self.lazy and 2*idx+1 in self.lazy: self.lazy.add(idx) def book(self, start: int, end: int) -\u0026gt; bool: if self.query(start, end-1, 0, 10**9, 1): return False self.update(start, end-1, 0, 10**9, 1) return True 2286. 以组为单位订音乐会的门票 题目大意： 设计一个买票系统，针对音乐会的座位安排。音乐会总共有n排座位，每排有m个座椅。系统需要处理两种情况：\ngather(k, maxRow): 返回长度为2的数组，表示k个成员中第一个座位的排数和座位编号，这k位成员必须坐在同一排座位，且座位连续。如果无法安排座位，返回空数组。 scatter(k, maxRow): 如果组里所有k个成员不一定要坐在一起的前提下，都能在第0排到第maxRow排之间找到座位，返回true；否则返回false。这种情况下，每个成员都优先找排数最小，然后是座位编号最小的座位。 实现思路：\n对于gather(k, maxRow)，可以利用线段树来实现。 线段树节点维护最小值和总和，用于查找最小值以及查询总和。 使用二分查找确定符合条件的最小排数，并更新座位信息。 对于scatter(k, maxRow)，同样使用线段树来维护座位信息。 遍历排数，根据当前排的剩余座位数量和需求k进行判断。 若当前排剩余座位数足够，安排k个座位并返回true；若不足够，继续向下一排尝试。 class BookMyShow: def __init__(self, n: int, m: int): self.n, self.m = n, m N = 1 \u0026lt;\u0026lt; n.bit_length() + 1 self.mn = [0] * N # min self.sm = [0] * N # sum def modify(self, u, l, r, x, v): if l == r: self.mn[u] += v self.sm[u] += v else: mid = l + r \u0026gt;\u0026gt; 1 if x \u0026lt;= mid: self.modify(u \u0026lt;\u0026lt; 1, l, mid, x, v) else: self.modify(u \u0026lt;\u0026lt; 1 | 1, mid + 1, r, x, v) self.mn[u] = min(self.mn[u \u0026lt;\u0026lt; 1], self.mn[u \u0026lt;\u0026lt; 1 | 1]) self.sm[u] = self.sm[u \u0026lt;\u0026lt; 1] + self.sm[u \u0026lt;\u0026lt; 1 | 1] def query(self, u, l, r, ql, qr): if l \u0026gt;= ql and r \u0026lt;= qr: return self.sm[u] mid = l + r \u0026gt;\u0026gt; 1 res = 0 if ql \u0026lt;= mid: res = self.query(u \u0026lt;\u0026lt; 1, l, mid, ql, qr) if qr \u0026gt; mid: res += self.query(u \u0026lt;\u0026lt; 1 | 1, mid + 1, r, ql, qr) return res def index(self, u, l, r, qr, v): if self.mn[u] \u0026gt; v: return 0 if l == r: return l mid = l + r \u0026gt;\u0026gt; 1 if self.mn[u \u0026lt;\u0026lt; 1] \u0026lt;= v: return self.index(u \u0026lt;\u0026lt; 1, l, mid, qr, v) if qr \u0026gt; mid: return self.index(u \u0026lt;\u0026lt; 1 | 1, mid + 1, r, qr, v) return 0 def gather(self, k: int, maxRow: int) -\u0026gt; List[int]: i = self.index(1, 1, self.n, maxRow + 1, self.m - k) if i == 0: return [] col = self.query(1, 1, self.n, i, i) self.modify(1, 1, self.n, i, k) return [i - 1, col] def scatter(self, k: int, maxRow: int) -\u0026gt; bool: if self.m * (maxRow + 1) - self.query(1, 1, self.n, 1, maxRow + 1) \u0026lt; k: return False i = self.index(1, 1, self.n, maxRow + 1, self.m - 1) while True: rest = self.m - self.query(1, 1, self.n, i, i) if k \u0026lt;= rest: self.modify(1, 1, self.n, i, k) return True self.modify(1, 1, self.n, i, rest) k -= rest i += 1 其他题目 3031. 将单词恢复初始状态所需的最短时间 II Z函数 题目大意： 给定一个字符串 word 和一个整数 k，每秒需要执行两种操作：移除字符串 word 的前 k 个字符，并在字符串末尾添加 k 个任意字符。要求返回将 word 恢复到初始状态所需的最短时间。\n实现思路： 首先，我们可以利用 Z 函数（Z algorithm）来找到字符串的最长前缀后缀匹配长度。然后，我们可以利用 Z 函数的性质，将字符串分割成不同的前缀子串，找到满足条件的最小时间。\n具体步骤如下：\n初始化一个数组 z，用于存储字符串 s 的 Z 函数值。 使用双指针 l 和 r 来维护当前匹配的子串。 遍历字符串 s，计算 z[i] 的值，即以第 i 个字符为起始的最长前缀后缀匹配长度。 在每次遍历中，更新 l 和 r 的值，保持当前匹配的子串范围。 如果当前位置 i 能够满足条件：即 i 是 k 的倍数且 z[i] 等于剩余字符串的长度（n - i），则返回 i 除以 k。 若遍历完字符串后仍未找到满足条件的位置，则返回 (n - 1) 除以 k 再加 1，表示需要把剩余的字符串都移除并添加到末尾。 class Solution: def minimumTimeToInitialState(self, s: str, k: int) -\u0026gt; int: n = len(s) z = [0] * n l, r = 0, 0 for i in range(1, n): if i \u0026lt;= r and z[i - l] \u0026lt; r - i + 1: z[i] = z[i - l] else: z[i] = max(0, r - i + 1) while i + z[i] \u0026lt; n and s[z[i]] == s[i + z[i]]: z[i] += 1 if i + z[i] - 1 \u0026gt; r: l = i r = i + z[i] - 1 if i%k==0 and z[i] == n-i: return i//k return (n-1)//k+1 5. 最长回文子串马拉车算法 题意：求字符串内的最大回文串长度 思路：马拉车算法，由当前已知的最大回文串长度，我们可以由已知的回文串长度，推出其覆盖的点的最大回文串长度。如下图，p[i]位置的回文串长度可以由最长的回文串(以a为中心)得出，因为回文串两边是对称的，所以p[i] = p[c + c-i], 但是对于覆盖不到的部分，需要取下限r-i。 class Solution: # 推荐教学视频 ：https://www.bilibili.com/video/BV1Sx4y1k7jG/?spm_id_from=333.337.search-card.all.click\u0026amp;vd_source=a4a2b56f746715b34521bfb853094cf4 def longestPalindrome(self, s: str) -\u0026gt; str: s = \u0026#39;#\u0026#39; + \u0026#39;#\u0026#39;.join(list(s)) + \u0026#39;#\u0026#39; n = len(s) p = [0]*n #每个点的 最长回文字串 能到的 右侧位置 c, r = 0, 0 # 右边能到达最远的蘑菇的位置 和 其最右边能达到的位置 for i in range(n): if i\u0026lt;=r: p[i] = min(r-i, p[c + c-i]) # 由已知条件得到当前位置能达到的最大右侧距离( 需要取min(镜像位置的值, 当前最大蘑菇能覆盖到的最大值) ) while i+p[i]+1 \u0026lt; n and s[i-p[i]-1] == s[i+p[i]+1]: p[i]+=1 if p[i]+i \u0026gt; r: r = p[i] + i c = i ma = max(p) idx = p.index(ma) return s[idx-ma+1:idx+ma+1:2] Prompt 下面我给出一个题目，代码实现，和对题目的总结和实现思路， 你需要的是学习我是如何总结的，如果你看懂了则回复我你懂了, 不用回复别的\r\u0026#34;\u0026#34;\u0026#34;\r给你一个 n 个节点的树（也就是一个无环连通无向图），节点编号从 0 到 n - 1 ，且恰好有 n - 1 条边，每个节点有一个值。树的 根节点 为 0 号点。\r给你一个整数数组 nums 和一个二维数组 edges 来表示这棵树。nums[i] 表示第 i 个点的值，edges[j] = [uj, vj] 表示节点 uj 和节点 vj 在树中有一条边。\r当 gcd(x, y) == 1 ，我们称两个数 x 和 y 是 互质的 ，其中 gcd(x, y) 是 x 和 y 的 最大公约数 。\r从节点 i 到 根 最短路径上的点都是节点 i 的祖先节点。一个节点 不是 它自己的祖先节点。\r请你返回一个大小为 n 的数组 ans ，其中 ans[i]是离节点 i 最近的祖先节点且满足 nums[i] 和 nums[ans[i]] 是 互质的 ，如果不存在这样的祖先节点，ans[i] 为 -1 。\r示例 1：\r输入：nums = [2,3,3,2], edges = [[0,1],[1,2],[1,3]]\r输出：[-1,0,0,1]\r解释：上图中，每个节点的值在括号中表示。\r- 节点 0 没有互质祖先。\r- 节点 1 只有一个祖先节点 0 。它们的值是互质的（gcd(2,3) == 1）。\r- 节点 2 有两个祖先节点，分别是节点 1 和节点 0 。节点 1 的值与它的值不是互质的（gcd(3,3) == 3）但节点 0 的值是互质的(gcd(2,3) == 1)，所以节点 0 是最近的符合要求的祖先节点。\r- 节点 3 有两个祖先节点，分别是节点 1 和节点 0 。它与节点 1 互质（gcd(3,2) == 1），所以节点 1 是离它最近的符合要求的祖先节点。\r示例 2：\r输入：nums = [5,6,10,2,3,6,15], edges = [[0,1],[0,2],[1,3],[1,4],[2,5],[2,6]]\r输出：[-1,0,-1,0,0,0,-1]\r提示：\rnums.length == n\r1 \u0026lt;= nums[i] \u0026lt;= 50\r1 \u0026lt;= n \u0026lt;= 105\redges.length == n - 1\redges[j].length == 2\r0 \u0026lt;= uj, vj \u0026lt; n\ruj != vj\r代码实现：\rclass Solution:\rdef getCoprimes(self, nums: List[int], edges: List[List[int]]) -\u0026gt; List[int]:\rn = len(nums)\rg = [[]*n for _ in range(n)]\rret = [-1]*n\rstore = [[] for _ in range(51)]\rmem = [(-1, -1)]*(51) for i in range(1, 51):\rfor j in range(1, 51):\rif gcd(i, j)==1:\rstore[i].append(j)\rfor u, v in edges:\rg[u].append(v)\rg[v].append(u)\rdef dfs(u, last, level):\rret[u] = max(mem[i] for i in store[nums[u]])[1]\rtmp = mem[nums[u]]\rmem[nums[u]] = (level, u)\rfor son in g[u]:\rif son==last:\rcontinue\rdfs(son, u, level+1)\rmem[nums[u]] = tmp\rdfs(0, -1, 0)\rreturn ret\r\u0026#34;\u0026#34;\u0026#34; 好的，你现在需要做的是 ： 我给你其他题目，并给出已经AC的代码实现，你需要补充：1、题目大意 2、实现思路\r如果你已经了解了我的需求，请回复我懂了 ","permalink":"https://kennems.github.io/zh/posts/tech/leetcode%E7%AC%94%E8%AE%B0/","summary":"LeetCode笔记 目标：2500分 HOT100 301. 删除无效的括号 题目大意： 给你一个由若干括号和字母组成的字符串 s ，删除最小数量的无效括号，使得输入的字","title":" LeetCode笔记"},{"content":"Linux 快捷键：\nctrl + l 清空屏幕\nLinux文件系统 FHS3.0（File system Hierarchy Standard） / etc 配置文件 bin 必要命令 usr 二级目录 home 家目录 var 动态数据 VFS虚拟文件系统 内核层抽象出通用的文件系统接口\n支持文件、网络、特殊文件系统\n抽象对象：\n超级快：文件系统 目录项：文件路径 索引节点：具体文件 文件：进程打开的文件 属性分层结构\n一切皆文件\n数据盘挂载 fdisk -l inode ：存储数据的元数据\nLinux没有盘符的概念，只有一个根目录/，所有文件都在其下\n/\n根目录 层级关系 命令 通用格式：\ncommand [-options] [parameter] command ：命令本身 -options： [可选，非必填] 命令的一些选项，可以通过选项控制命令的行为细节 parameter： [可选，非必填]命令的参数，多数用于命令的指向目标等 语法中[]表示可选\nls ls [-a -l -h] [Linux路径] -a all 前面带.的文件使隐藏文件/文件夹，只有通过-a选项才能看到 -l 以列表（竖向排列） -h 表示以易于阅读的形式，列出文件大小，如K，M，G /home/用户名\n组合使用\ncd change directory\ncd [Linux路径] 不写参数回到用户的HOME目录下\n绝对路径 相对路径 . 表示当前目录\n.. 表示上一级目录\n~ 表示HOME目录\nmkdir 创建目录\nmkdir [-p] 路径 -p可选，创建多级不存在的目录时使用\ntouch 创建文件\ntouch 路径\ncat 查看内容\ncat 路径\nmore 查看内容，支持翻页，空格翻页，q退出\nmore 路径\ncp 可以用于复制文件\\文件夹\ncp [-r] 参数1 参数2 -r选项，可选，用于复制文件夹使用，表示递归 参数1，Linux路径，表示被复制的文件或文件夹 参数2，Linux路径，表示要复制去的地方 mv mv 参数1 参数2 可以用于改名\nrm 删除文件，文件夹\nrm [-r -f] 参数1 参数2 参数n -r， 删除文件夹 -f，force，强制删除（不会弹出提示信息） 普通用户删除内容不会弹出提示，只有root管理员用户删除内容会有提示 所以一般普通用户用不到-f 参数1，参数2， \u0026hellip;，参数n 表示要删除的文件或文件夹路径，按照空格隔开。 支持用通配符来模糊匹配\npwd Print Work Directory\ntree 树状目录\nwhich Linux命令本体就是一个个的二进制可执行文件\nwhich 命令 find find 起始路径 -name \u0026#34;被查找文件名\u0026#34; find 起始路径 -size + | -n[kMG] +, - 表示大于和小于 n表示大小数字 kMG表示大小单位，k表示kb,M表示MB，G表示GB grep 通过grep命令，从文件中通过关键字过滤文件行\ngrep [-n] 关键字 文件路径 选项 -n 可选，表示在结果中显示匹配的行的行号\n参数，关键字，必填，表示过滤的关键字，带有空格或其它特殊符号，建议使用“ ”将关键字包围起来\n参数，文件路径，必填，表示要过滤内容的文件路径，可作为内容输入端口\nwc wc [-c -m -l -w] 文件路径 选项， -c， 统计bytes数量 选项，-m，统计字符数量 选项，-l，统计行数 选项，-w，统计单词数量 参数，文件路径， 被统计的文件，可作为内容输入端口 默认行数、字数、字符数\n管道符 左 | 右。 将左边的结果作为右边的输入\necho 命令行内输出指定内容\n反引号` 在echo中，用``括起来表示命令信息\necho `pwd` 重定向符号 \u0026gt; 将左侧命令的结果，覆盖写入到符号右侧指定的文件中 \u0026gt;\u0026gt; 将左侧命令的结果，追加写入到符号右侧指定的文件中 tail tail [-f -num] 参数 参数，linux命令，表示被跟踪的文件路径 选项，-f，表示持续跟踪 选项，-num，表示尾部多少行，不填默认10行 awk 编写规则，根据输入的文本数据来执行特定的操作\n打印整行：\nawk \u0026#39;{print}\u0026#39; file.txt 这个命令将打印文件file.txt中的每一行。\n根据字段进行匹配和操作：\nawk \u0026#39;$1 == \u0026#34;pattern\u0026#34; {print $2}\u0026#39; file.txt 这个命令将打印文件file.txt中第一个字段为\u0026quot;pattern\u0026quot;的行的第二个字段。\n使用正则表达式进行匹配：\nawk \u0026#39;/pattern/ {print}\u0026#39; file.txt 这个命令将打印文件file.txt中包含\u0026quot;pattern\u0026quot;的每一行。\n计算字段的总和或平均值：\nawk \u0026#39;{sum+=$1} END {print \u0026#34;Sum:\u0026#34;, sum}\u0026#39; file.txt 这个命令将计算文件file.txt中第一个字段的总和，并在文件处理结束时打印出来。\n自定义字段分隔符：\nawk -F\u0026#39;,\u0026#39; \u0026#39;{print $1}\u0026#39; file.csv 这个命令将使用逗号作为字段分隔符，并打印文件file.csv中的每一行的第一个字段。\n使用内置函数：\nawk \u0026#39;{print toupper($1)}\u0026#39; file.txt 这个命令将将文件file.txt中的第一个字段转换为大写并打印出来。\n过滤并处理文件内容：\nawk \u0026#39;$3 \u0026gt; 10 {print $1, $2 * $3}\u0026#39; file.txt 这个命令将打印文件file.txt中第三个字段大于10的行的第一个和第二个字段的乘积。\n自定义输出格式：\nawk \u0026#39;{printf \u0026#34;%-10s %-5s\\n\u0026#34;, $1, $2}\u0026#39; file.txt 这个命令将按照指定的格式打印文件file.txt中的每一行的前两个字段。\nVim 命令模式 i : 在当前光标位置进入输入模式\na : 在当前光标位置 之后 进入输入模式\nI ： 在当前行的开头，进入输入模式\nA ： 在当前行的结尾，进入输入模式\no : 在当前行的下一行进入输入模式\nO ： 在当前行的上一行进入输入模式\n0 : 移动光标至开头\n$ : 移动给光标至行结尾\npageup : 向上翻页\npagedown : 向下翻页\n/ ： 进入搜索模式\nn : 向下继续搜索\nN : 向上继续搜索\ndd ： 删除光标所在的行\nndd : n是数字，表示删除当前光标向下n行\nyy : 复制当前行\nnyy ： 复制当前行和下面的n行\np : 粘贴复制的内容\nu : 撤销修改\nctrl + r ： 反向撤销修改\ngg ： 跳到首行\nG ： 跳到尾行\ndG : 从当前行开始，向下全部删除\ndgg ： 从当前行开始，向上全部删除\ndS : 从当前光标开始，删除到本行的结尾\nd0 ： 从当前光标开始，删除到本行的开头\n底线命令模式 : wq 保存并退出 q 仅退出\nq! 强制退出\n:w 仅保存\n:set nu 显示行号\n:set paste 设置粘贴模式\nLinux权限和用户 su su [-] [用户名] sudo 普通用户使用sudo使用root权限\n用户与用户组\n用户和用户组 groupadd 创建用户组 groupdel 用户组名 useradd [-g -d] 用户名 选项： -g指定用户的组，不指定-g，会创建同名组加入，指定-g需要组已经存在，如已存在同名组，必须使用-g。 选项： -d指定用户HOME路径，不指定，HOME目录默认在： /home/用户名 userdel [-r] 用户名 选项：-r，删除用户的HOME目录，不使用-r，删除目录时，HOME目录保留 id [用户名] 参数：用户名，被查看的用户，如果不提供则查看自身。 usermod -aG 用户组 用户名 将指定用户加入指定用户组 getent passwd\rgetent group 使用getent命令，可以查看当前系统内有那些命令\n七份信息：\n用户名 ： 密码（X） ： 用户ID ： 组ID ： 描述信息（无用） ： HOME目录 ： 执行终端（默认bash）\n查看权限管控信息 文件或文件夹的控制信息\n文件或文件夹所属用户\n文件或文件夹所属用户组\n第一个d表示文件夹 所属用户 所有用户组 所属其他用户 r代表读 文件夹表示可以查看文件夹内容 w代表写 文件夹表示可以在文件夹内：创建，删除，改名等操作 x代表可执行权限，针对文件表示可以将文件作为程序执行 针对文件夹，表示可以更改工作目录到此文件夹，即cd进入 chmod 修改文件或目录的权限。\nchmod u = rwx, g = rx, o = x hello.txt -R选项可以将文件夹以及文件夹内全部内容权限设置为：rwxrwxrwx\nchmod -R u=rwx, g=rwx, o=rwx hello.tx 使用数字序号\nchmod 751 hello.txt chown 更改文件或目录的所有者为指定的用户或用户组。\nchown [-R] [用户] [:] [用户组] 文件或文件夹 选项，-R，同chmod，对文件夹内全部内容应用相同规则 选项，用户，修改所属用户 选项，用户组，修改所属用户组 ： 用于分隔用户和用户组 普通用户无法使用，只能用root用户\nLinux使用操作 快捷键： ctrl + c 强制停止,退出当前命令输入 ctrl + d 退出账户的登录 history 查看历史输入的命令 !搜索历史命令，自动匹配，例如！py ctrl + a，跳到命令开头 ctrl + e，跳到命令结尾 ctrl + 键盘左键， 向左跳一个单词 ctrl + 键盘右键， 向右跳一个单词 ctrl + l 清空终端内容 clear 清空终端内容 软件安装 yum ： RPM软件管理器，用于自动化安装配置Linux软件，并可以自动解决依赖问题。\nyum [-y] [install | remove | search] 软件名称 -y 自动确认，无需手动确认安装或卸载过程 yum命令需要root权限，可以su切换到root，或使用sudo权限，yum命令需要联网\nUbuntu apt [-y] [install | remove | search] wget systemctl systemctl start | stop | status | enable | disable 服务名 NetworkManager, 主网络服务 newwork, 副网络服务 firewalld , 防火墙服务 sshd, ssh服务（FinalShell远程登录Linux使用的就是此服务） 除了内置的服务以外，部分第三方软件安装后也可以用systemctl进行控制\n软链接 在系统中创建软链接，可以将文件、文件夹链接到其他位置。类似快捷方式\nln -s 参数1 参数2 -s ，创建软链接 参数1 ： 被链接的文件或文件夹 参数2 ： 要链接去的目的地 日期，时区 date [-d] [+格式化字符串] -d按照给定的字符串显示日期，一般用于日期计算\n格式化字符串： 通过特定的字符串标记，来控制显示的日期格式\n%Y ， 年 %y,， 年份后两位数字（00，99） %M 月份 （01，12） %d 日(01,31) %H 小时（00，23） %M 分钟（00，59） %S 秒（00，59） %s 自1970-01-01 00:00:00到现在的秒数 使用-d支持的时间标记：(同样支持格式化字符串)\nyear 年 month 月 day 天 hour 小时 minute 分钟 second 秒 ntp 可以自动联网同步时间，也可以通过ntp -u ntp.aliyun.com 手动校准时间\nIP地址 DHCP : 动态获取IP地址，即每次重启设备后都会获取一次，可能导致IP地址频繁变更\n每一台联网的电脑都会有一个地址，用于和其他计算机进行通信，IP地址主要有两个版本，V4和V6版本\nIPv4的地址格式为a.b.c.d，其中abcd表示0~255的数字，如192.168.88.101\n通过ipconfig查看本机的IP地址。\n127.0.0.1表示本机\n0.0.0.0\n可以用于指代本机 可以在端口绑定中用来确定绑定关系 在一些IP地址中，表示所有IP的意思，如放行规则设置为0.0.0.0，表示允许任意IP访问 主机名 hostname 修改主机名\nhostnamectl set-hostname name 域名解析 ping 可以通过ping命令来检查指定的网络服务器是否是可联通的。\nping [-c num] ip或主机名 选项， -c，检查的次数，不适用-c选项，将无限次数持续检查 参数：ip或主机名，被检查的服务器的ip地址或主机名地址 wget 非交互式的文件下载器，可以在命令行内下载网络文件\nwget [-b] url 选项 ： -b ，后台下载，会将日志写入到当前工作目录的wget-log文件 参数：url，下载链接 curl 发送http网络请求，可用于下载文件，获取信息等\ncurl [-O] url 选项：-O，用于下载文件，当url是下载链接时，可以使用此选项保存文件 参数：url，要发起请求的网络地址 端口 端口，是设备与外界通讯交流的出入口，端口可以分为物理端口和虚拟端口\n物理端口：又可称之为接口，是可见的端口，如USB接口，RJ45网口，HDMI端口等 虚拟端口：是指计算机内部的端口，是不可见的，是用来操作系统和外部进行交互使用的 Linux支持65535个端口，分为3类进行使用：\n公认端口：1~1023，通常用于一些系统内置或知名程序的预留使用，如SSH服务的22端口，HTTPS服务的443端口，非特殊需要，不要占用这个范围的端口 注册端口：1024~49151，通常可以随意使用，用于松散的绑定一些程序/服务 动态端口：49152~65535，通常不会固定绑定程序，而是当程序对外进行网络链接时，用于临时使用。 进程管理 ps [-e -f] -e 显示出全部的进程 -f 以完全格式化的形式展示信息（展示全部信息） 一般来说，固定用法就是 ps -ef 列出全部进程的全部信息 UID ： 进程所属的用户ID\nPID ： 进程的进程号ID\nPPID ： 进程的父ID（启动此进程的其他进程）\nC ： 此进程的CPU占用率（百分比）\nSTIME ： 进程的启动时间\nTTY ： 启动此进程的终端序号，如果显示？，表示非终端启动\nTIME ： 进程启用CPU的时间\nCMD ： 进程对应的名称或启动路径和启动命令\n关闭进程 kill -9 进程ID -9, 表示强制关闭进程，不适用此选项会向进程发送信号要求其关闭，但是否关闭看进程自身的处理机制 主机状态 查看CPU，内存使用情况\ntop 第一行 ：\ntop ： 命令名称\n14：08 ：23 当前系统时间，up 6min：启动了六分钟\n2 users : 2个用户登录， load ：15分钟负载\n第二行：\nTasks : 175个进程 1 running : 1个子进程在运行\n174 sleeping : 174个进程睡眠，0个停止进程， 0个僵尸进程\n第三行：\n%Cpu(s) : CPU使用率，us：用户CPU使用率，sy ：系统CPU使用率，ni：高优先级进程占用CPU时间百分比，id：空闲CPU率，wa：IO等待CPU占用率，hi：CPU硬件中断率，si：CPU软件中断率，st：强制等待占用CPU率\n第四、五行\nKib Mem : 物理内存，total : 总量， free : 空闲， used ： 使用， buff/cache : buff和cache占用\nKibSwap : 虚拟内存（交换空间），total : 总量，free : 空闲，used：使用，buff/cache : buff和cache占用\nPID ： 进程ID USER ： 进程所属用户 PR ： 进程优先级，越小越好 NI ： 负值表示高优先级，正表示低优先级 VIRT ： 进程使用虚拟内存，单位KB RES ： 进程使用物理内存，单位KB SHR ： 进程使用共享内存， 单位KB S ： 进程状态(S休眠，R运行，Z僵死状态，N负数优先级，I空闲状态) %CPU ： 进程占用CPU率 %MEM： 进程占用内存率 TIME+ ： 进程使用CPU时间总计，单位10毫秒 COMMAND ： 进程的命令或名称或程序文件路径 -p : 只显示某个进程信息 -d : 设置刷新时间，默认为5s -c : 显示产生进程的完整命令，默认是进程名 -n : 制定刷新次数，比如 top -n 3 是新输出三次后退出 -b : 以非交互非全屏模式运行，以批次的方式执行top，一般配合-n制定输出几次统计信息，将输出重定向到制定文件，比如 top -b -n 3 \u0026gt; /tmp/top.tmp -i : 不显示任何闲置（idle）或无用的进程 -u ： 查找特定用户启动的进程 top以交互式运行：\nh ： 按下h键，会显示帮助画面 c ： 按下c键，会显示产生进程的完整命令，等同于-c参数 f ： 可以选择需要展示的项目 M ： 根据驻留内存大小（RES）排序 T ： 根据CPU使用百分比大小进行排序 T ： 根据时间/累计时间进行排序 E ： 切换顶部内存显示单位 e ： 切换进程内存显示单位 l ： 切换显示平均负载和启动时间信息 i ： 不显示闲置或无用的进程，等同于-i参数 t ： 切换显示CPU状态信息 m ： 切换显示内存信息 硬盘使用情况：\ndf -h -h， 以更加人性化的单位显示 磁盘信息监控：\niostat [-x] [num1] [num2] 网络状态监控：\n可以使用sar命令查看网络的相关统计 sar -n DEV num1 num2 -n 查看网络，DEV表示查看网络接口 num1 : 刷新间隔（不填就查看一次阶数）num2 : 查看次数（不填无限次数） 环境变量 环境变量是一组信息记录，类型是Key Value类型（名称=值），用于操作系统运行的时候记录关键信息\nenv 查看环境变量\n环境变量： PATH，通过$取出环境变量的值\n环境变量PATH会记录一组目录，目录之间用：隔开。记录的是命令的搜索路径。当执行命令会从记录中记录的目录中挨个搜索要执行的命令并执行\n可以通过这个项目的值，加入自定义的命令搜索路径\n如\nexport PATH = $PATH 修改环境变量\n临时生效 ： export 名称= 值 永久生效 针对用户 ： ~/bashrc文件中配置 针对全部用户 文件上传和下载 通过finalShell或者xshell 上传或下载，拖动\n压缩和解压 .tar 称之为tarball，对党文件，即简单的将文件组装到一个.tar的文件中，并没有太多文件体积的减少，仅仅是简单的封装 .gz，也常见为.tar.gz，gzip格式压缩文件，即使用gzip压缩算法将文件压缩到一个文件内，可以极大的减少压缩后的体积 tar [-c -v -x -f -z -C] 参数1 参数2 ... 参数N -c 创建压缩文件，用于压缩模式 -v 显示压缩，解压过程，用于查看进度 -x 解压模式 -f 要创建的文件，或者要解压的文件，-f选项必须在所有选项中位置处于最后一个 -z gzip模式，不适用-z就是普通的tarball模式 -C 选择解压的目的地，用于解压模式 zip [-r] 参数 -r 压缩文件夹使用 unzip unzip [-d] 参数\n-d 制定解压的目录 Mysql wget --no-check-certificate https: /dlcdn.apache.org/tomcat/tomcat10/v10.0.27/bin/apache-tomcat-10.0.27.tar.gz Redis ElasticSearch Tomcat Nginx RabbitMq ","permalink":"https://kennems.github.io/zh/posts/tech/linux/","summary":"Linux 快捷键： ctrl + l 清空屏幕 Linux文件系统 FHS3.0（File system Hierarchy Standard） / etc 配置文件 bin 必要命令 usr 二级目录 home 家目录 var 动态数据 VF","title":" Linux"},{"content":"每日一题（202404） 2009. 使数组连续的最少操作数 题意：给定一个可能有重复元素的数组，可以修改数组中值为任意其他值，问使数组连续的最小操作数。\n思路：由于只能改动元素，所以最后的元素个数不变，去重后，枚举每个值作为左端点，则右端点为nums[i]+n-1, 用双指针计算在区间内的元素个数即为可以保留的数字，其他数字修改元素值填满空隙即可。\nclass Solution: def minOperations(self, nums: List[int]) -\u0026gt; int: n = len(nums) nums = sorted(set(nums)) j, ans = 0, 0 for i in range(len(nums)): right = nums[i]+ n-1 if len(nums)-1 - i + 1 \u0026lt;= ans: break while j\u0026lt;len(nums) and nums[j]\u0026lt;=right: j+=1 ans = max(ans, j-i) return n-ans 1600. 王位继承顺序 题意：国王继承次序按嫡长子次序，实现ThroneInheritance(string kingName)初始化,void birth(string parentName, string childName) 出生，void death(string name)人死亡，string[] getInheritanceOrder() 返回 除去 死亡人员的当前继承顺序列表。\n思路：类似树形结构，国王先继承，之后是国王的长子，之后是长子的长子， 如果不存在则为国王的次子以此类推， 所以可以用defaultdict()存储每个的儿子情况，然后查询时，先将自己入结果列表，然后是第一个儿子\u0026hellip;；并记录每个人的存活情况，排除掉已经死掉的人。\nclass ThroneInheritance: def __init__(self, kingName: str): self.son = defaultdict(list) self.die = set() self.king = kingName def birth(self, parentName: str, childName: str) -\u0026gt; None: self.son[parentName].append(childName) def death(self, name: str) -\u0026gt; None: self.die.add(name) def getInheritanceOrder(self) -\u0026gt; List[str]: ret = [] def dfs(root): if root not in self.die: ret.append(root) for child in self.son[root]: dfs(child) dfs(self.king) return ret 1483. 树节点的第 K 个祖先 题意：给定n个点(0~n-1)每个点的父亲节点，快速查询每个节点的第k个祖宗节点。\n思路：LCA倍增原理，$ancestor[j][i] = ancestor[ ancestor[j][i-1] ][i-1]$ 节点j的第$2^i$个祖宗节点为节点第$2^{i-1}$个祖宗的第$2^{i-1}$个祖宗，即$2^{i-1}*2$个祖宗节点， 所以先预处理好每个节点的各个二进制位上的祖宗节点是谁，之后分解二进制位据可以得知任意第k个祖宗节点是谁。\nclass TreeAncestor: def __init__(self, n: int, parent: List[int]): self.level = 16 self.ancestor = [[-1]*self.level for _ in range(n)] for i in range(1, n): self.ancestor[i][0] = parent[i] for i in range(1, self.level): for j in range(1, n): if self.ancestor[j][i-1]!=-1: self.ancestor[j][i] = self.ancestor[ self.ancestor[j][i-1] ][i-1] def getKthAncestor(self, node: int, k: int) -\u0026gt; int: while k: t = k\u0026amp;-k k -= t t = t.bit_length()-1 node = self.ancestor[node][t] if node==-1: return -1 return node 面试题 08.12. 八皇后 题目大意：\n这道题目是经典的八皇后问题的扩展，需要设计一个算法来打印 N 皇后在 N × N 棋盘上的各种摆法，其中每个皇后都不在同一行、同一列，也不在任何对角线上。\n实现思路：\n回溯算法：\n使用回溯算法来尝试所有可能的皇后摆放方式。 从第一行开始，依次尝试每一列放置皇后，然后继续递归地尝试下一行的放置，直到所有行都放置完毕。 在递归过程中，通过检查每个位置的列、主对角线和副对角线是否已经存在皇后来确定是否可以放置皇后。 生成棋盘：\n当确定了一种合法的皇后摆放方式时，将其转换为棋盘的形式，并将其添加到结果列表中。 对于每行中皇后的位置，用 \u0026lsquo;Q\u0026rsquo; 表示，其他位置用 \u0026lsquo;.\u0026rsquo; 表示。 辅助函数：\nsolve: 递归函数，尝试在每行放置皇后。 generate: 将合法的皇后摆放方式转换为棋盘形式并添加到结果列表中。 剪枝优化：\n使用位运算来表示列、主对角线和副对角线的占用情况，可以快速判断某个位置是否可以放置皇后，从而提高效率。 在每次递归时，利用位运算进行剪枝，排除不可能的位置。 class Solution: def solveNQueens(self, n: int) -\u0026gt; List[List[str]]: def generate(): board = [] for r in range(n): c = pos[r] row[c] = \u0026#39;Q\u0026#39; board.append(\u0026#34;\u0026#34;.join(row)) row[c] = \u0026#39;.\u0026#39; ret.append(board) def solve(row, column, diag1, diag2): if row==n: generate() else: avail = ( (1\u0026lt;\u0026lt;n)-1) \u0026amp; ( ~(column|diag1|diag2) ) while avail: colPos = avail\u0026amp;(-avail) avail -= colPos colNum = bin(colPos-1).count(\u0026#34;1\u0026#34;) pos[row]=colNum solve(row+1, column|colPos, (diag1|colPos)\u0026lt;\u0026lt;1, (diag2|colPos)\u0026gt;\u0026gt;1) pos = [0]*n ret = [] row = [\u0026#39;.\u0026#39;]*n solve(0, 0, 0, 0) return ret 1702. 修改后的最大二进制字符串 题意：给定一个二进制字符串00-\u0026gt;10, 10-\u0026gt;01问任意次操作后能达到的最大二进制字符串。\n思路：构造，根据条件推过程，10-\u0026gt;01可以看作后面的0浮到前面，所有的0聚到一起可以变成10串，所以最后至多只有一个0。根据构造来做，统计第一个0的位置和0的个数，最后构造出最后的0的位置；双指针来做：遇到0时找到后面第一个0的位置，将其浮到旁边，并换成10。\n构造：\nclass Solution: def maximumBinaryString(self, binary: str) -\u0026gt; str: cnt = binary.count(\u0026#39;0\u0026#39;) if cnt\u0026lt;=1: return binary n = len(binary) ans = [\u0026#39;1\u0026#39;]*n index = binary.index(\u0026#39;0\u0026#39;) ans[index+cnt-1]=\u0026#39;0\u0026#39; return \u0026#39;\u0026#39;.join(ans) 双指针：\nclass Solution: def maximumBinaryString(self, binary: str) -\u0026gt; str: n = len(binary) s = list(binary) j = 0 for i in range(n): if s[i]==\u0026#39;0\u0026#39;: while j\u0026lt;=i or (j\u0026lt;n and s[j]==\u0026#39;1\u0026#39;): j+=1 if j\u0026lt;n: s[i], s[j], s[i+1] = \u0026#39;1\u0026#39;, \u0026#39;1\u0026#39;, \u0026#39;0\u0026#39; return \u0026#39;\u0026#39;.join(s) 24. 两两交换链表中的节点 题意：给定一个链表，分别两个一组交换相对位置。\n思路：链表交换next指针操作，prev-\u0026gt;A-\u0026gt;B-\u0026gt;C变成prev-\u0026gt;B-\u0026gt;A-\u0026gt;C，一共要变三条边。需要记录前面的点，后面的点。\nclass Solution: def swapPairs(self, head: Optional[ListNode]) -\u0026gt; Optional[ListNode]: dummy = head prev = None while head and head.next: tmp = head.next.next #A-\u0026gt;B 变成 B-\u0026gt;A nxt = head.next #nxt是B, head是A nxt.next = head head.next = tmp if prev: prev.next = nxt prev = nxt.next #是头节点(即没有前面的点)的时候不需要这一步 if dummy==head: dummy = nxt prev = nxt.next head = tmp return dummy 25. K 个一组翻转链表 题意：每隔k个数字翻转链表。\n思路：链表交换指针操作。\n# Definition for singly-linked list. # class ListNode: # def __init__(self, val=0, next=None): # self.val = val # self.next = next class Solution: def reverseKGroup(self, head: Optional[ListNode], k: int) -\u0026gt; Optional[ListNode]: def reverse(head, tail): # A-\u0026gt;B-\u0026gt;C 变成 C-\u0026gt;B-\u0026gt;A cur = tail.next dummy = head while cur != tail: nxt = dummy.next dummy.next = cur cur = dummy dummy = nxt return tail, head # 原来的tail和head位置没变，但中间点的指向关系变了 hair = ListNode(-1) # 伪头节点 hair.next = head pre = hair while head: tail = pre for i in range(k): # 走过k个点 tail = tail.next if not tail: return hair.next head, tail = reverse(head, tail) pre.next = head # pre-\u0026gt;C pre = tail # pre变成尾节点 head = tail.next # 头节点变成当前尾节点的下个一个节点 return hair.next 1766. 互质树 题意：给定一棵树0~n-1共n个节点， 每个节点有一个值，返回每个节点的 最近的 与自己互质的(gcd(a,b)=1) 祖宗节点的编号。值的范围为[1,50] 思路：DFS， 遍历一遍树，维护一个祖宗节点的列表，判断当前节点与祖宗节点的互质关系。但朴素的将所有的祖宗节点都加入列表中，到深层的子节点时会遍历整个列表，会超时。由于值的范围最大为50，所以可以先预处理50范围以内的互质关系，对于每个节点，只需要判断祖宗节点里面有没有这些互质的数即可，但是需要的是最近的祖宗节点，所以还要添加一个深度信息，这样才能保证在相同值的祖宗节点中选择离自己最近的祖宗节点。 class Solution: def getCoprimes(self, nums: List[int], edges: List[List[int]]) -\u0026gt; List[int]: n = len(nums) g = [[]*n for _ in range(n)] ret = [-1]*n store = [[] for _ in range(51)] mem = [(-1, -1)]*(51) for i in range(1, 51): for j in range(1, 51): if gcd(i, j)==1: store[i].append(j) for u, v in edges: g[u].append(v) g[v].append(u) def dfs(u, last, level): ret[u] = max(mem[i] for i in store[nums[u]])[1] tmp = mem[nums[u]] mem[nums[u]] = (level, u) for son in g[u]: if son==last: continue dfs(son, u, level+1) mem[nums[u]] = tmp dfs(0, -1, 0) return ret 924. 尽量减少恶意软件的传播 题目大意：给定一个由n个节点组成的网络，用n x n个邻接矩阵图graph表示。节点之间存在直接连接当且仅当graph[i][j] = 1。一些节点initial最初被恶意软件感染，如果两个节点直接连接且至少一个节点被感染，则两个节点都将被感染。移除一个节点后，返回使得整个网络中感染恶意软件的最终节点数最小的节点，若有多个节点满足条件，则返回索引最小的节点。\n实现思路：首先使用并查集将节点分组，然后计算每个分组的大小和其中感染节点的数量。遍历initial列表，找到使得其所在分组中只有一个感染节点且分组大小最大的节点，返回其索引。\nclass Solution: def minMalwareSpread(self, g: List[List[int]], initial: List[int]) -\u0026gt; int: n, m = len(g), len(initial) f = [i for i in range(n)] size = [1 for _ in range(n)] # 连通块内的点数 num = [0 for _ in range(n)] # 连通块内的感染点数 for x in initial: num[x]=1 def find(x): if f[x] != x: f[x] = find(f[x]) return f[x] for i in range(n): for j in range(i+1, n): if g[i][j]: fi, fj = find(i), find(j) if fi!=fj: f[fi] = fj num[fj] += num[fi] size[fj] += size[fi] ma = -1 initial.sort() idx = initial[0] for x in initial: if num[find(x)]==1 and size[find(x)]\u0026gt;ma: ma = size[find(x)] idx = x return idx 928. 尽量减少恶意软件的传播 II 题目大意：给定一个由n个节点组成的网络，用n x n个邻接矩阵graph表示。节点之间存在直接连接当且仅当graph[i][j] = 1。一些节点initial最初被恶意软件感染，如果两个节点直接连接且至少一个节点被感染，则两个节点都将被感染。移除一个节点及其连接后，返回移除后能使整个网络中感染恶意软件的最终节点数最小的节点，若有多个节点满足条件，则返回索引最小的节点。\n实现思路：首先通过并查集将不在initial中的节点进行合并，然后计算每个initial节点的直接感染节点数。最后选择使得感染节点数最小且索引最小的initial节点返回。\nclass Solution: def minMalwareSpread(self, g: List[List[int]], initial: List[int]) -\u0026gt; int: n = len(g) def find(x): if f[x] != x: f[x] = find(f[x]) return f[x] f = [i for i in range(n)] source = [[] for _ in range(n)] cnt = [0]*n init = [0]*n for i in initial: init[i] = 1 for i in range(n): if init[i]: continue for j in range(n): if init[j] or not g[i][j]: continue fi, fj = find(i), find(j) if fi!=fj: f[fi] = fj for x in initial: infected = [0]*n for j in range(n): if not g[x][j] or init[j] or infected[find(j)]: continue infected[find(j)] = 1 for j in range(n): if infected[j]: source[j].append(x) for i in range(n): if len(source[i])==1: root = source[i][0] for j in range(n): if find(i)==find(j): # 是一个连通块 cnt[root]+=1 idx = initial[0] for x in initial: if cnt[x]\u0026gt;cnt[idx] or (cnt[x]==cnt[idx] and x\u0026lt;idx): idx = x return idx 2007. 从双倍数组中还原原数组 题目大意：给定一个数组 changed，通过以下方式构造原始数组 original：将 changed 中的每个元素乘以2，并将结果随机打乱，然后返回原始数组 original。如果无法构造原始数组，则返回空数组。\n实现思路：首先判断数组 changed 的长度是否为偶数，如果不是偶数，则无法构造原始数组，直接返回空数组。接着使用一个字典记录数组 changed 中各个元素的出现次数。然后遍历数组 changed，对于每个元素 i，判断是否存在 i 的两倍的元素，若存在，则将 i 和其两倍的元素都从字典中减去一个，并将 i 加入结果数组中。最后判断结果数组的长度是否达到了原始数组的一半，如果达到了则返回结果数组的前一半，否则返回空数组。\nclass Solution: def findOriginalArray(self, changed: List[int]) -\u0026gt; List[int]: n = len(changed) if n\u0026amp;1: return [] d = defaultdict(int) res = [] cnt = 0 changed.sort() for i in changed: d[i]+=1 for i in changed: if not d[i]: continue x = i*2 if i==x: # 0*2 = 0 d[x]-=1 if d[x]: d[x]-=1 # 匹配成功 cnt+=1 res.append(i) else: if d[x]: d[x]-=1 # 匹配成功 d[i]-=1 cnt+=1 res.append(i) if cnt\u0026gt;=n//2: return res[:n//2] return [] 实现思路：首先使用 Counter 统计数组 changed 中各个元素的出现次数。然后将字典中键为 0 的元素（如果存在）弹出，因为原始数组中不可能有 0。接着判断字典中键为 0 的元素出现次数是否为偶数，如果不是偶数则无法构造原始数组，直接返回空数组。然后初始化一个由 0 组成的数组 ans，长度为 cnt_0 的一半。接下来遍历字典中的键值对，对于每个键 x，判断是否存在其一半的键值对，并将 x 加入结果数组 ans 中相应次数。最后返回结果数组 ans。\nclass Solution: def findOriginalArray(self, changed: List[int]) -\u0026gt; List[int]: cnt = Counter(changed) cnt_0 = cnt.pop(0, 0) if cnt_0\u0026amp;1: return [] ans = [0]*(cnt_0//2) for x in cnt: if x%2==0 and cnt[x//2]: continue while x in cnt: if cnt[2*x]\u0026lt;cnt[x]: return [] ans.extend([x]*(cnt[x])) if cnt[2*x]\u0026gt;cnt[x]: cnt[2*x]-=cnt[x] x*=2 else: x*=4 return ans 1883. 准时抵达会议现场的最小跳过休息次数 题目大意：题目给出了一组道路的长度和行驶速度，以及剩余可用时间。要求计算在给定的时间内，最少跳过休息次数，以准时抵达会议现场。\n实现思路：动态规划。使用二维数组dp[i][j]表示到达第i条路，跳过j次休息的最小距离。初始化dp数组，然后遍历每一条路，在遍历的过程中更新dp数组。最后检查是否有方案可以在规定时间内到达会议现场，如果有，返回跳过休息的最小次数，否则返回-1。\nclass Solution: def minSkips(self, dist: List[int], speed: int, hoursBefore: int) -\u0026gt; int: n = len(dist) if sum(dist) \u0026gt; hoursBefore * speed: return -1 dp = [[inf] * (n + 1) for _ in range(n + 1)] dp[0][0] = 0 for i in range(1, n): for j in range(i+1): # 到第i条路，跳过次数为j的最小距离 # 不跳过第 i 条路 dp[i][j] = min(dp[i][j], (dp[i-1][j] + dist[i-1] + speed -1)//speed*speed) # 跳过第 i 条路 if j: dp[i][j] = min(dp[i][j], dp[i - 1][j -1] + dist[i-1]) for j in range(n): # 可以跳0~n-1次(最后一条边不用跳) if dp[n-1][j]+dist[-1] \u0026lt;= hoursBefore * speed: return j return -1 39. 组合总和 题目大意 ：给定一个无重复元素的整数数组 candidates 和一个目标整数 target，找出 candidates 中可以使数字和为目标数 target 的所有不同组合，并以列表形式返回。可以无限制重复选择 candidates 中的同一个数字。\n实现思路 ：\n使用深度优先搜索（DFS）进行组合搜索。 定义一个辅助函数 dfs(i, s)，其中 i 表示当前遍历到的 candidates 数组的索引，s 表示当前已经选取的数字的和。 在 dfs 函数中，如果 s 大于等于 target 或者已经遍历到数组末尾，则进行以下判断： 如果 s 等于 target，则将当前的组合 ls 加入结果列表 ret 中。 如果 s 大于 target 或者已经遍历到数组末尾，则直接返回。 在 dfs 函数中，分别尝试两种情况： 不选择当前数字，继续向后搜索：dfs(i+1, s)。 选择当前数字，继续向后搜索：将当前数字加入组合 ls 中，更新 s，并递归调用 dfs(i, s+c[i])。 在递归调用之后，需要将当前选择的数字从组合 ls 中弹出，保证不影响后续搜索。 最终返回结果列表 ret。 class Solution: def combinationSum(self, c: List[int], t: int) -\u0026gt; List[List[int]]: n = len(c) ret, ls = [], [] def dfs(i, s): if s\u0026gt;=t or i==n: if s==t: ret.append(ls[:]) return dfs(i+1, s) ls.append(c[i]) dfs(i, s+c[i]) ls.pop() dfs(0, 0) return ret 216. 组合总和 III 题目大意：找出所有相加之和为n的k个数的组合，要求使用数字1到9，每个数字最多使用一次，返回所有可能的有效组合的列表。列表不能包含相同的组合两次，组合可以以任何顺序返回。\n实现思路：使用深度优先搜索（DFS）的方法，从1到9的数字中进行遍历，每次选择一个数字或不选择，直到满足条件为止。递归过程中，维护一个列表ls，记录当前已选数字的集合，如果当前集合的数字个数等于k且它们的和等于n，则将其加入结果列表ret中。\nclass Solution: def combinationSum3(self, k: int, n: int) -\u0026gt; List[List[int]]: ret, ls = [], [] def dfs(i, s, cnt): if i==10 or s\u0026gt;=n or cnt\u0026gt;=k: if s==n and cnt==k: ret.append(ls[:]) return dfs(i+1, s, cnt) ls.append(i) dfs(i+1, s+i, cnt+1) ls.pop() dfs(1, 0, 0) return ret 377. 组合总和 Ⅳ 题目大意：给定一个由不同整数组成的数组nums和一个目标整数target，要求从nums中找出总和为target的元素组合的个数。\n实现思路：这是一个典型的动态规划问题。使用递归+记忆化搜索（Memoization）的方法来解决。定义dfs函数，参数为当前的和s，函数返回当前和s能够组成的组合数目。递归的终止条件是当前和s大于等于目标target，则返回1（如果s等于target，则表示找到一种组合）。否则，遍历数组nums中的每个数，对每个数进行递归调用dfs(s+i)，累加得到的组合数目。使用cache装饰器对dfs函数进行记忆化搜索，避免重复计算。最终返回dfs(0)，即从初始和为0开始的组合数目。\nclass Solution: def combinationSum4(self, nums: List[int], target: int) -\u0026gt; int: @cache def dfs(s): if s\u0026gt;=target: if s==target: return 1 return 0 cnt = 0 for i in nums: cnt += dfs(s+i) return cnt return dfs(0) 1146. 快照数组 题目大意：实现一个支持快照的数组数据结构SnapshotArray，具体包括以下接口：\nSnapshotArray(length)：初始化一个与指定长度相等的类数组的数据结构，初始时每个元素都为0。 set(index, val)：将指定索引index处的元素设置为val。 snap()：获取该数组的快照，并返回快照的编号snap_id（快照号是调用snap()的总次数减去1）。 get(index, snap_id)：根据指定的snap_id选择快照，并返回该快照指定索引index的值。 实现思路：使用一个字典存储每个索引处的快照历史记录，键为索引，值为一个列表，列表中每个元素是一个元组，元组第一个值是快照的编号，第二个值是该快照对应索引的值。对于set操作，直接将快照编号和值添加到对应索引的列表中；对于snap操作，记录快照编号并返回；对于get操作，利用二分查找找到snap_id对应的快照，返回快照中该索引的值。\nclass SnapshotArray: def __init__(self, length: int): self.id = 0 self.arr = defaultdict(list) def set(self, index: int, val: int) -\u0026gt; None: self.arr[index].append((self.id, val)) def snap(self) -\u0026gt; int: self.id+=1 return self.id-1 def get(self, index: int, snap_id: int) -\u0026gt; int: # if not len(self.arr[index]): # return 0 # l, r = 0, len(self.arr[index])-1 # while l\u0026lt;r: # mid = (l+r+1)\u0026gt;\u0026gt;1 # if self.arr[index][mid][0] \u0026lt;= snap_id: # l = mid # else: # r = mid-1 # return self.arr[index][r][1] if self.arr[index][r][0] \u0026lt;= snap_id else 0 l = bisect.bisect_right(self.arr[index], (snap_id, inf)) - 1 return self.arr[index][l][1] if l\u0026gt;=0 else 0 857. 雇佣 K 名工人的最低成本 题目大意：给定一组工人，每个工人有工作质量和最低期望工资，现在要雇佣 k 名工人组成一个工资组。雇佣工人时，按照每名工人的工作质量与同组其他工人的工作质量的比例来支付工资，每名工人至少应得到其最低期望工资。求组成满足条件的付费群体所需的最小金额。\n实现思路：首先按照工资与工作质量的比例对工人进行排序，然后使用最小堆来维护一个大小为 k 的堆，堆中存放的是负的工作质量。初始化堆时，将前 k 名工人的质量放入堆中。计算当前堆中所有工人的总质量，并计算以当前工资标准下的总支付金额。然后遍历剩余的工人，每次将堆顶的质量弹出，加上新的工人的质量，计算新的总质量，并更新总支付金额。找出所有情况下的最小总支付金额即可。\nclass Solution: def mincostToHireWorkers(self, quality: List[int], wage: List[int], k: int) -\u0026gt; float: emp = sorted(zip(wage, quality), key = lambda e:e[0]/e[1]) h = [-q for _, q in emp[:k]] heapify(h) sum_q = -sum(h) ans = sum_q*(emp[k-1][0]/emp[k-1][1]) for w, q in emp[k:]: sum_q += heapreplace(h, -q) + q ans = min(ans, sum_q*w/q) return ans ","permalink":"https://kennems.github.io/zh/posts/tech/leetcode%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98202404/","summary":"每日一题（202404） 2009. 使数组连续的最少操作数 题意：给定一个可能有重复元素的数组，可以修改数组中值为任意其他值，问使数组连续的最小操作数。","title":"LeetCode每日一题（202404）"},{"content":"每日一题（202404） 2009. 使数组连续的最少操作数 题意：给定一个可能有重复元素的数组，可以修改数组中值为任意其他值，问使数组连续的最小操作数。\n思路：由于只能改动元素，所以最后的元素个数不变，去重后，枚举每个值作为左端点，则右端点为nums[i]+n-1, 用双指针计算在区间内的元素个数即为可以保留的数字，其他数字修改元素值填满空隙即可。\nclass Solution: def minOperations(self, nums: List[int]) -\u0026gt; int: n = len(nums) nums = sorted(set(nums)) j, ans = 0, 0 for i in range(len(nums)): right = nums[i]+ n-1 if len(nums)-1 - i + 1 \u0026lt;= ans: break while j\u0026lt;len(nums) and nums[j]\u0026lt;=right: j+=1 ans = max(ans, j-i) return n-ans 1600. 王位继承顺序 题意：国王继承次序按嫡长子次序，实现ThroneInheritance(string kingName)初始化,void birth(string parentName, string childName) 出生，void death(string name)人死亡，string[] getInheritanceOrder() 返回 除去 死亡人员的当前继承顺序列表。\n思路：类似树形结构，国王先继承，之后是国王的长子，之后是长子的长子， 如果不存在则为国王的次子以此类推， 所以可以用defaultdict()存储每个的儿子情况，然后查询时，先将自己入结果列表，然后是第一个儿子\u0026hellip;；并记录每个人的存活情况，排除掉已经死掉的人。\nclass ThroneInheritance: def __init__(self, kingName: str): self.son = defaultdict(list) self.die = set() self.king = kingName def birth(self, parentName: str, childName: str) -\u0026gt; None: self.son[parentName].append(childName) def death(self, name: str) -\u0026gt; None: self.die.add(name) def getInheritanceOrder(self) -\u0026gt; List[str]: ret = [] def dfs(root): if root not in self.die: ret.append(root) for child in self.son[root]: dfs(child) dfs(self.king) return ret 1483. 树节点的第 K 个祖先 题意：给定n个点(0~n-1)每个点的父亲节点，快速查询每个节点的第k个祖宗节点。\n思路：LCA倍增原理，$ancestor[j][i] = ancestor[ ancestor[j][i-1] ][i-1]$ 节点j的第$2^i$个祖宗节点为节点第$2^{i-1}$个祖宗的第$2^{i-1}$个祖宗，即$2^{i-1}*2$个祖宗节点， 所以先预处理好每个节点的各个二进制位上的祖宗节点是谁，之后分解二进制位据可以得知任意第k个祖宗节点是谁。\nclass TreeAncestor: def __init__(self, n: int, parent: List[int]): self.level = 16 self.ancestor = [[-1]*self.level for _ in range(n)] for i in range(1, n): self.ancestor[i][0] = parent[i] for i in range(1, self.level): for j in range(1, n): if self.ancestor[j][i-1]!=-1: self.ancestor[j][i] = self.ancestor[ self.ancestor[j][i-1] ][i-1] def getKthAncestor(self, node: int, k: int) -\u0026gt; int: while k: t = k\u0026amp;-k k -= t t = t.bit_length()-1 node = self.ancestor[node][t] if node==-1: return -1 return node 面试题 08.12. 八皇后 题目大意：\n这道题目是经典的八皇后问题的扩展，需要设计一个算法来打印 N 皇后在 N × N 棋盘上的各种摆法，其中每个皇后都不在同一行、同一列，也不在任何对角线上。\n实现思路：\n回溯算法：\n使用回溯算法来尝试所有可能的皇后摆放方式。 从第一行开始，依次尝试每一列放置皇后，然后继续递归地尝试下一行的放置，直到所有行都放置完毕。 在递归过程中，通过检查每个位置的列、主对角线和副对角线是否已经存在皇后来确定是否可以放置皇后。 生成棋盘：\n当确定了一种合法的皇后摆放方式时，将其转换为棋盘的形式，并将其添加到结果列表中。 对于每行中皇后的位置，用 \u0026lsquo;Q\u0026rsquo; 表示，其他位置用 \u0026lsquo;.\u0026rsquo; 表示。 辅助函数：\nsolve: 递归函数，尝试在每行放置皇后。 generate: 将合法的皇后摆放方式转换为棋盘形式并添加到结果列表中。 剪枝优化：\n使用位运算来表示列、主对角线和副对角线的占用情况，可以快速判断某个位置是否可以放置皇后，从而提高效率。 在每次递归时，利用位运算进行剪枝，排除不可能的位置。 class Solution: def solveNQueens(self, n: int) -\u0026gt; List[List[str]]: def generate(): board = [] for r in range(n): c = pos[r] row[c] = \u0026#39;Q\u0026#39; board.append(\u0026#34;\u0026#34;.join(row)) row[c] = \u0026#39;.\u0026#39; ret.append(board) def solve(row, column, diag1, diag2): if row==n: generate() else: avail = ( (1\u0026lt;\u0026lt;n)-1) \u0026amp; ( ~(column|diag1|diag2) ) while avail: colPos = avail\u0026amp;(-avail) avail -= colPos colNum = bin(colPos-1).count(\u0026#34;1\u0026#34;) pos[row]=colNum solve(row+1, column|colPos, (diag1|colPos)\u0026lt;\u0026lt;1, (diag2|colPos)\u0026gt;\u0026gt;1) pos = [0]*n ret = [] row = [\u0026#39;.\u0026#39;]*n solve(0, 0, 0, 0) return ret 1702. 修改后的最大二进制字符串 题意：给定一个二进制字符串00-\u0026gt;10, 10-\u0026gt;01问任意次操作后能达到的最大二进制字符串。\n思路：构造，根据条件推过程，10-\u0026gt;01可以看作后面的0浮到前面，所有的0聚到一起可以变成10串，所以最后至多只有一个0。根据构造来做，统计第一个0的位置和0的个数，最后构造出最后的0的位置；双指针来做：遇到0时找到后面第一个0的位置，将其浮到旁边，并换成10。\n构造：\nclass Solution: def maximumBinaryString(self, binary: str) -\u0026gt; str: cnt = binary.count(\u0026#39;0\u0026#39;) if cnt\u0026lt;=1: return binary n = len(binary) ans = [\u0026#39;1\u0026#39;]*n index = binary.index(\u0026#39;0\u0026#39;) ans[index+cnt-1]=\u0026#39;0\u0026#39; return \u0026#39;\u0026#39;.join(ans) 双指针：\nclass Solution: def maximumBinaryString(self, binary: str) -\u0026gt; str: n = len(binary) s = list(binary) j = 0 for i in range(n): if s[i]==\u0026#39;0\u0026#39;: while j\u0026lt;=i or (j\u0026lt;n and s[j]==\u0026#39;1\u0026#39;): j+=1 if j\u0026lt;n: s[i], s[j], s[i+1] = \u0026#39;1\u0026#39;, \u0026#39;1\u0026#39;, \u0026#39;0\u0026#39; return \u0026#39;\u0026#39;.join(s) 24. 两两交换链表中的节点 题意：给定一个链表，分别两个一组交换相对位置。\n思路：链表交换next指针操作，prev-\u0026gt;A-\u0026gt;B-\u0026gt;C变成prev-\u0026gt;B-\u0026gt;A-\u0026gt;C，一共要变三条边。需要记录前面的点，后面的点。\nclass Solution: def swapPairs(self, head: Optional[ListNode]) -\u0026gt; Optional[ListNode]: dummy = head prev = None while head and head.next: tmp = head.next.next #A-\u0026gt;B 变成 B-\u0026gt;A nxt = head.next #nxt是B, head是A nxt.next = head head.next = tmp if prev: prev.next = nxt prev = nxt.next #是头节点(即没有前面的点)的时候不需要这一步 if dummy==head: dummy = nxt prev = nxt.next head = tmp return dummy 25. K 个一组翻转链表 题意：每隔k个数字翻转链表。\n思路：链表交换指针操作。\n# Definition for singly-linked list. # class ListNode: # def __init__(self, val=0, next=None): # self.val = val # self.next = next class Solution: def reverseKGroup(self, head: Optional[ListNode], k: int) -\u0026gt; Optional[ListNode]: def reverse(head, tail): # A-\u0026gt;B-\u0026gt;C 变成 C-\u0026gt;B-\u0026gt;A cur = tail.next dummy = head while cur != tail: nxt = dummy.next dummy.next = cur cur = dummy dummy = nxt return tail, head # 原来的tail和head位置没变，但中间点的指向关系变了 hair = ListNode(-1) # 伪头节点 hair.next = head pre = hair while head: tail = pre for i in range(k): # 走过k个点 tail = tail.next if not tail: return hair.next head, tail = reverse(head, tail) pre.next = head # pre-\u0026gt;C pre = tail # pre变成尾节点 head = tail.next # 头节点变成当前尾节点的下个一个节点 return hair.next 1766. 互质树 题意：给定一棵树0~n-1共n个节点， 每个节点有一个值，返回每个节点的 最近的 与自己互质的(gcd(a,b)=1) 祖宗节点的编号。值的范围为[1,50] 思路：DFS， 遍历一遍树，维护一个祖宗节点的列表，判断当前节点与祖宗节点的互质关系。但朴素的将所有的祖宗节点都加入列表中，到深层的子节点时会遍历整个列表，会超时。由于值的范围最大为50，所以可以先预处理50范围以内的互质关系，对于每个节点，只需要判断祖宗节点里面有没有这些互质的数即可，但是需要的是最近的祖宗节点，所以还要添加一个深度信息，这样才能保证在相同值的祖宗节点中选择离自己最近的祖宗节点。 class Solution: def getCoprimes(self, nums: List[int], edges: List[List[int]]) -\u0026gt; List[int]: n = len(nums) g = [[]*n for _ in range(n)] ret = [-1]*n store = [[] for _ in range(51)] mem = [(-1, -1)]*(51) for i in range(1, 51): for j in range(1, 51): if gcd(i, j)==1: store[i].append(j) for u, v in edges: g[u].append(v) g[v].append(u) def dfs(u, last, level): ret[u] = max(mem[i] for i in store[nums[u]])[1] tmp = mem[nums[u]] mem[nums[u]] = (level, u) for son in g[u]: if son==last: continue dfs(son, u, level+1) mem[nums[u]] = tmp dfs(0, -1, 0) return ret 924. 尽量减少恶意软件的传播 题目大意：给定一个由n个节点组成的网络，用n x n个邻接矩阵图graph表示。节点之间存在直接连接当且仅当graph[i][j] = 1。一些节点initial最初被恶意软件感染，如果两个节点直接连接且至少一个节点被感染，则两个节点都将被感染。移除一个节点后，返回使得整个网络中感染恶意软件的最终节点数最小的节点，若有多个节点满足条件，则返回索引最小的节点。\n实现思路：首先使用并查集将节点分组，然后计算每个分组的大小和其中感染节点的数量。遍历initial列表，找到使得其所在分组中只有一个感染节点且分组大小最大的节点，返回其索引。\nclass Solution: def minMalwareSpread(self, g: List[List[int]], initial: List[int]) -\u0026gt; int: n, m = len(g), len(initial) f = [i for i in range(n)] size = [1 for _ in range(n)] # 连通块内的点数 num = [0 for _ in range(n)] # 连通块内的感染点数 for x in initial: num[x]=1 def find(x): if f[x] != x: f[x] = find(f[x]) return f[x] for i in range(n): for j in range(i+1, n): if g[i][j]: fi, fj = find(i), find(j) if fi!=fj: f[fi] = fj num[fj] += num[fi] size[fj] += size[fi] ma = -1 initial.sort() idx = initial[0] for x in initial: if num[find(x)]==1 and size[find(x)]\u0026gt;ma: ma = size[find(x)] idx = x return idx 928. 尽量减少恶意软件的传播 II 题目大意：给定一个由n个节点组成的网络，用n x n个邻接矩阵graph表示。节点之间存在直接连接当且仅当graph[i][j] = 1。一些节点initial最初被恶意软件感染，如果两个节点直接连接且至少一个节点被感染，则两个节点都将被感染。移除一个节点及其连接后，返回移除后能使整个网络中感染恶意软件的最终节点数最小的节点，若有多个节点满足条件，则返回索引最小的节点。\n实现思路：首先通过并查集将不在initial中的节点进行合并，然后计算每个initial节点的直接感染节点数。最后选择使得感染节点数最小且索引最小的initial节点返回。\nclass Solution: def minMalwareSpread(self, g: List[List[int]], initial: List[int]) -\u0026gt; int: n = len(g) def find(x): if f[x] != x: f[x] = find(f[x]) return f[x] f = [i for i in range(n)] source = [[] for _ in range(n)] cnt = [0]*n init = [0]*n for i in initial: init[i] = 1 for i in range(n): if init[i]: continue for j in range(n): if init[j] or not g[i][j]: continue fi, fj = find(i), find(j) if fi!=fj: f[fi] = fj for x in initial: infected = [0]*n for j in range(n): if not g[x][j] or init[j] or infected[find(j)]: continue infected[find(j)] = 1 for j in range(n): if infected[j]: source[j].append(x) for i in range(n): if len(source[i])==1: root = source[i][0] for j in range(n): if find(i)==find(j): # 是一个连通块 cnt[root]+=1 idx = initial[0] for x in initial: if cnt[x]\u0026gt;cnt[idx] or (cnt[x]==cnt[idx] and x\u0026lt;idx): idx = x return idx 2007. 从双倍数组中还原原数组 题目大意：给定一个数组 changed，通过以下方式构造原始数组 original：将 changed 中的每个元素乘以2，并将结果随机打乱，然后返回原始数组 original。如果无法构造原始数组，则返回空数组。\n实现思路：首先判断数组 changed 的长度是否为偶数，如果不是偶数，则无法构造原始数组，直接返回空数组。接着使用一个字典记录数组 changed 中各个元素的出现次数。然后遍历数组 changed，对于每个元素 i，判断是否存在 i 的两倍的元素，若存在，则将 i 和其两倍的元素都从字典中减去一个，并将 i 加入结果数组中。最后判断结果数组的长度是否达到了原始数组的一半，如果达到了则返回结果数组的前一半，否则返回空数组。\nclass Solution: def findOriginalArray(self, changed: List[int]) -\u0026gt; List[int]: n = len(changed) if n\u0026amp;1: return [] d = defaultdict(int) res = [] cnt = 0 changed.sort() for i in changed: d[i]+=1 for i in changed: if not d[i]: continue x = i*2 if i==x: # 0*2 = 0 d[x]-=1 if d[x]: d[x]-=1 # 匹配成功 cnt+=1 res.append(i) else: if d[x]: d[x]-=1 # 匹配成功 d[i]-=1 cnt+=1 res.append(i) if cnt\u0026gt;=n//2: return res[:n//2] return [] 实现思路：首先使用 Counter 统计数组 changed 中各个元素的出现次数。然后将字典中键为 0 的元素（如果存在）弹出，因为原始数组中不可能有 0。接着判断字典中键为 0 的元素出现次数是否为偶数，如果不是偶数则无法构造原始数组，直接返回空数组。然后初始化一个由 0 组成的数组 ans，长度为 cnt_0 的一半。接下来遍历字典中的键值对，对于每个键 x，判断是否存在其一半的键值对，并将 x 加入结果数组 ans 中相应次数。最后返回结果数组 ans。\nclass Solution: def findOriginalArray(self, changed: List[int]) -\u0026gt; List[int]: cnt = Counter(changed) cnt_0 = cnt.pop(0, 0) if cnt_0\u0026amp;1: return [] ans = [0]*(cnt_0//2) for x in cnt: if x%2==0 and cnt[x//2]: continue while x in cnt: if cnt[2*x]\u0026lt;cnt[x]: return [] ans.extend([x]*(cnt[x])) if cnt[2*x]\u0026gt;cnt[x]: cnt[2*x]-=cnt[x] x*=2 else: x*=4 return ans 1883. 准时抵达会议现场的最小跳过休息次数 题目大意：题目给出了一组道路的长度和行驶速度，以及剩余可用时间。要求计算在给定的时间内，最少跳过休息次数，以准时抵达会议现场。\n实现思路：动态规划。使用二维数组dp[i][j]表示到达第i条路，跳过j次休息的最小距离。初始化dp数组，然后遍历每一条路，在遍历的过程中更新dp数组。最后检查是否有方案可以在规定时间内到达会议现场，如果有，返回跳过休息的最小次数，否则返回-1。\nclass Solution: def minSkips(self, dist: List[int], speed: int, hoursBefore: int) -\u0026gt; int: n = len(dist) if sum(dist) \u0026gt; hoursBefore * speed: return -1 dp = [[inf] * (n + 1) for _ in range(n + 1)] dp[0][0] = 0 for i in range(1, n): for j in range(i+1): # 到第i条路，跳过次数为j的最小距离 # 不跳过第 i 条路 dp[i][j] = min(dp[i][j], (dp[i-1][j] + dist[i-1] + speed -1)//speed*speed) # 跳过第 i 条路 if j: dp[i][j] = min(dp[i][j], dp[i - 1][j -1] + dist[i-1]) for j in range(n): # 可以跳0~n-1次(最后一条边不用跳) if dp[n-1][j]+dist[-1] \u0026lt;= hoursBefore * speed: return j return -1 39. 组合总和 题目大意 ：给定一个无重复元素的整数数组 candidates 和一个目标整数 target，找出 candidates 中可以使数字和为目标数 target 的所有不同组合，并以列表形式返回。可以无限制重复选择 candidates 中的同一个数字。\n实现思路 ：\n使用深度优先搜索（DFS）进行组合搜索。 定义一个辅助函数 dfs(i, s)，其中 i 表示当前遍历到的 candidates 数组的索引，s 表示当前已经选取的数字的和。 在 dfs 函数中，如果 s 大于等于 target 或者已经遍历到数组末尾，则进行以下判断： 如果 s 等于 target，则将当前的组合 ls 加入结果列表 ret 中。 如果 s 大于 target 或者已经遍历到数组末尾，则直接返回。 在 dfs 函数中，分别尝试两种情况： 不选择当前数字，继续向后搜索：dfs(i+1, s)。 选择当前数字，继续向后搜索：将当前数字加入组合 ls 中，更新 s，并递归调用 dfs(i, s+c[i])。 在递归调用之后，需要将当前选择的数字从组合 ls 中弹出，保证不影响后续搜索。 最终返回结果列表 ret。 class Solution: def combinationSum(self, c: List[int], t: int) -\u0026gt; List[List[int]]: n = len(c) ret, ls = [], [] def dfs(i, s): if s\u0026gt;=t or i==n: if s==t: ret.append(ls[:]) return dfs(i+1, s) ls.append(c[i]) dfs(i, s+c[i]) ls.pop() dfs(0, 0) return ret 216. 组合总和 III 题目大意：找出所有相加之和为n的k个数的组合，要求使用数字1到9，每个数字最多使用一次，返回所有可能的有效组合的列表。列表不能包含相同的组合两次，组合可以以任何顺序返回。\n实现思路：使用深度优先搜索（DFS）的方法，从1到9的数字中进行遍历，每次选择一个数字或不选择，直到满足条件为止。递归过程中，维护一个列表ls，记录当前已选数字的集合，如果当前集合的数字个数等于k且它们的和等于n，则将其加入结果列表ret中。\nclass Solution: def combinationSum3(self, k: int, n: int) -\u0026gt; List[List[int]]: ret, ls = [], [] def dfs(i, s, cnt): if i==10 or s\u0026gt;=n or cnt\u0026gt;=k: if s==n and cnt==k: ret.append(ls[:]) return dfs(i+1, s, cnt) ls.append(i) dfs(i+1, s+i, cnt+1) ls.pop() dfs(1, 0, 0) return ret 377. 组合总和 Ⅳ 题目大意：给定一个由不同整数组成的数组nums和一个目标整数target，要求从nums中找出总和为target的元素组合的个数。\n实现思路：这是一个典型的动态规划问题。使用递归+记忆化搜索（Memoization）的方法来解决。定义dfs函数，参数为当前的和s，函数返回当前和s能够组成的组合数目。递归的终止条件是当前和s大于等于目标target，则返回1（如果s等于target，则表示找到一种组合）。否则，遍历数组nums中的每个数，对每个数进行递归调用dfs(s+i)，累加得到的组合数目。使用cache装饰器对dfs函数进行记忆化搜索，避免重复计算。最终返回dfs(0)，即从初始和为0开始的组合数目。\nclass Solution: def combinationSum4(self, nums: List[int], target: int) -\u0026gt; int: @cache def dfs(s): if s\u0026gt;=target: if s==target: return 1 return 0 cnt = 0 for i in nums: cnt += dfs(s+i) return cnt return dfs(0) ","permalink":"https://kennems.github.io/zh/posts/tech/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98202404/","summary":"每日一题（202404） 2009. 使数组连续的最少操作数 题意：给定一个可能有重复元素的数组，可以修改数组中值为任意其他值，问使数组连续的最小操作数。","title":"LeetCode每日一题（202404）"},{"content":"剑指Offer 数据流中的中位数 用两个堆模拟， 左边大顶堆，右边小顶堆，则两个堆顶是最中间的数字。\n添加数字时：\n如果输入的是第奇数个（比如第一个，则N初始化为0，插入后N为1，代表一共有一个数字），则先插入大顶堆，然后把堆顶插入小顶堆。保证小顶堆的任意一个值都比大顶堆大。 同样，如果输入的是第偶数个（第二个），则先插入小顶堆，然后将小顶堆最小值插入大顶堆。同样是保证小顶堆的任意一个值都比大顶堆大。 至于先插入哪一个堆是没有关系的，只要保证交替插入不同的堆即可，并且要确保边界问题（比如在奇数个元素的的中位数， 只有一个数据时应返回先插入的堆顶值， 否则堆为空会报错）。\nimport heapq as hp class Solution: heapl = [] # 大根堆 heapr = [] # 小根堆 N = 0 def insert(self, num): \u0026#34;\u0026#34;\u0026#34; :type num: int :rtype: void \u0026#34;\u0026#34;\u0026#34; if self.N % 2 ==0: hp.heappush(self.heapl, -num) hp.heappush(self.heapr, -hp.heappop(self.heapl)) else: hp.heappush(self.heapr, num) hp.heappush(self.heapl, -hp.heappop(self.heapr)) self.N += 1 def getMedian(self): \u0026#34;\u0026#34;\u0026#34; :rtype: float \u0026#34;\u0026#34;\u0026#34; if self.N %2==0: return (-self.heapl[0]+self.heapr[0])/2.0 else: return self.heapr[0]*1.0 字符流中第一个只出现一次的字符 import collections class Solution: d = collections.defaultdict(int) q = collections.deque() def firstAppearingOnce(self): \u0026#34;\u0026#34;\u0026#34; :rtype: str \u0026#34;\u0026#34;\u0026#34; return \u0026#39;#\u0026#39; if not self.q else self.q[0] def insert(self, char): \u0026#34;\u0026#34;\u0026#34; :type char: str :rtype: void \u0026#34;\u0026#34;\u0026#34; self.d[char]+=1 self.q.append(char) while self.q and self.d[self.q[0]]\u0026gt;1: self.q.popleft() 最长不含重复字符的子字符串 class Solution: def longestSubstringWithoutDuplication(self, s): \u0026#34;\u0026#34;\u0026#34; :type s: str :rtype: int \u0026#34;\u0026#34;\u0026#34; char_index = {} # 存储字符的最近出现位置 ans = 0 start = 0 for i, char in enumerate(s): if char in char_index and char_index[char] \u0026gt;= start: start = char_index[char] + 1 char_index[char] = i ans = max(ans, i - start + 1) return ans 骰子的点数 线性DP ：\n注意点： 算法先从最简单的方法想起，DP先用二维想，实现完之后再优化。\n因为每次计算状态时会修改$ j-1, j-2, j-3, j-4, j-5, j-6$, 而$j+1$会计算 $j+1-1=j, j+1-2=j-1, \u0026hellip; j-1$会计算$j-1-1=j-2,j-1-2=j-3,\u0026hellip;$没有单调性，所以不能优化第一维空间\nclass Solution(object): def numberOfDice(self, n): \u0026#34;\u0026#34;\u0026#34; :type n: int :rtype: List[int] \u0026#34;\u0026#34;\u0026#34; N = 6*n+10 f = [[0]*N for _ in range(N)] f[0][0]=1 for i in range(1,n+1): for j in range(1,n*6+1): for k in range(1,min(j, 6)+1): f[i][j] += f[i-1][j-k] return f[n][1*n:6*n+1] 数组中数值和下标相等的元素 class Solution(object): def getNumberSameAsIndex(self, nums): \u0026#34;\u0026#34;\u0026#34; :type nums: List[int] :rtype: int \u0026#34;\u0026#34;\u0026#34; l, r = 0, len(nums)-1 while l\u0026lt;r: mid = l+r+1\u0026gt;\u0026gt;1 if nums[mid]\u0026gt;mid: r=mid-1 elif nums[mid]\u0026lt;mid: l=mid else: return mid break return l if nums[l]==l else -1 复杂链表的复刻 class Solution(object): def copyRandomList(self, head): hash = {} hash[None] = None cloneHead = ListNode(-1) cur = cloneHead while head: if head not in hash: hash[head] = ListNode(head.val) if head.random not in hash: hash[head.random] = ListNode(head.random.val) cur.next = hash[head] cur = cur.next cur.random = hash[head.random] head = head.next return cloneHead.next 矩阵中的路径 class Solution(object): def hasPath(self, matrix, string): if not matrix or not(matrix[0]): return False dx = [1, 0, -1, 0] dy = [0, 1, 0, -1] def dfs(x, y, idx): if matrix[x][y]!=string[idx]: return False if idx==len(string)-1: return True for h,v in zip(dx, dy): xx, yy = x+h, y+v if xx\u0026lt;0 or xx\u0026gt;=len(matrix) or yy\u0026lt;0 or yy\u0026gt;=len(matrix[0]): continue memo = matrix[x][y] matrix[x][y] = \u0026#39;#\u0026#39; if dfs(xx,yy,idx+1): return True matrix[x][y] = memo return False for i in range(len(matrix)): for j in range(len(matrix[0])): if matrix[i][j]==string[0]: if dfs(i,j,0): return True return False 正则表达式匹配 DP:\nclass Solution(object): def isMatch(self, s, p): \u0026#34;\u0026#34;\u0026#34; :type s: str :type p: str :rtype: bool \u0026#34;\u0026#34;\u0026#34; n, m = len(s), len(p) s, p = \u0026#39; \u0026#39;+s, \u0026#39; \u0026#39;+p f = [[False]*(m+1) for _ in range(n+1)] f[0][0] = True for i in range(2,m+1): if p[i]==\u0026#39;*\u0026#39;: f[0][i] = f[0][i-2] for i in range(1,n+1): for j in range(1,m+1): if s[i]==p[j] or p[j]==\u0026#39;.\u0026#39;: f[i][j] = f[i-1][j-1] elif p[j]==\u0026#39;*\u0026#39;: if s[i]==p[j-1] or p[j-1]==\u0026#39;.\u0026#39;: f[i][j] = f[i-1][j] f[i][j] |= f[i][j-2] return f[n][m] LCR 168. 丑数 题目大意：给定一个整数 $n$，找出并返回第 $n$ 个丑数。丑数是只包含质因数$ 2$、$3$ 和/或 5 的正整数，$1$ 是丑数。\n实现思路：\n初始化一个数组 $f$，用于存储前$ n$ 个丑数，初始化 $f[1] = 1$。 初始化三个指针 $i2$、$i3$、$i5$，分别表示下一个丑数是通过乘以$2、3、5$得到的。 初始化三个变量 $n2、n3、n5$，分别表示通过指针 $i2、i3、i5$ 得到的下一个丑数的候选值。 从第$ 2 $个丑数开始遍历到第 $n $个丑数： 计算下一个丑数的候选值：$n2=f[i2]*2$，$n3=f[i3]*3$，$n5=f[i5]*5$。 将下一个丑数更新为三个候选值中的最小值：$f[i]=min(n2,n3,n5)$。 如果最小值等于 $n2$，则指针 $i2$ 往后移动一位；如果最小值等于 $n3$，则指针 $i3$ 往后移动一位；如果最小值等于 $n5$，则指针 i5 往后移动一位。 遍历结束后，返回第 $n$ 个丑数$ f[n]$。 class Solution: def nthUglyNumber(self, n: int) -\u0026gt; int: if n\u0026lt;=6: return n f=[0 for _ in range(n+1)] f[1]=1 i2,i3,i5,n2,n3,n5=1,1,1,0,0,0 for i in range(2,n+1): n2,n3,n5=f[i2]*2,f[i3]*3,f[i5]*5 f[i]=min(n2,n3,n5) if f[i]==n2: i2+=1 if f[i]==n3: i3+=1 if f[i]==n5: i5+=1 return f[n] ","permalink":"https://kennems.github.io/zh/posts/tech/%E5%89%91%E6%8C%87offer/","summary":"剑指Offer 数据流中的中位数 用两个堆模拟， 左边大顶堆，右边小顶堆，则两个堆顶是最中间的数字。 添加数字时： 如果输入的是第奇数个（比如第一个，","title":"剑指Offer"},{"content":"Java20天速成——进阶课程(2) 正则表达式 符号 含义 举例 [] 匹配方括号内的任一字符 [abc] ^ 匹配除指定字符外的任意字符 [^abc] \u0026amp;\u0026amp; 匹配两个字符集的交集，需作为整体出现 [a-z\u0026amp;\u0026amp;m-p] . 匹配除换行符外的任意字符 a.b （匹配 \u0026ldquo;a\u0026rdquo; 后接任意字符，再接 \u0026ldquo;b\u0026rdquo;） \\ 转义字符，用于匹配特殊字符 \\\\d \\\\d 匹配数字 0-9 \\\\d+ \\\\D 匹配非数字字符 \\\\D+ \\\\s 匹配空白字符 \\s匹配空格、制表符、换行符等等 \\\\S 匹配非空白字符 \\\\S+ （匹配非空白字符序列） \\\\w 匹配单词字符 [a-zA-Z_0-9] \\\\W 匹配非单词字符 [^\\w] * 匹配前面的元素零次或多次，即可有可无 a*b （匹配 \u0026ldquo;b\u0026rdquo;、\u0026ldquo;ab\u0026rdquo;、\u0026ldquo;aab\u0026rdquo;、等等） ? 匹配前面的元素零次或一次，即可有可无 colou?r （匹配 \u0026ldquo;color\u0026rdquo; 或 \u0026ldquo;colour\u0026rdquo;） () 分组，将其中的字符视为一个单元 a(bc)+ \\f 匹配换页符 \\f | `|` | 或，用于匹配多个模式中的任意一个 | `ab\\|AB` | public static void method1() { // 给定的字符串包含了电话号码和邮箱地址的信息 String data = \u0026#34; 来黑马程序员学习Java，\\n\u0026#34; + \u0026#34; 电话：1866668888，18699997777\\n\u0026#34; + \u0026#34; 或者联系邮箱：boniu@itcast.cn，\\n\u0026#34; + \u0026#34; 座机电话：01036517895，010-98951256\\n\u0026#34; + \u0026#34; 邮箱：bozai@itcast.cn，\\n\u0026#34; + \u0026#34; 邮箱：dlei0009@163.com，\\n\u0026#34; + \u0026#34; 热线电话：400-618-9090 ，400-618-4000，4006184000，4006189090\u0026#34;; // 定义正则表达式来匹配电话号码和邮箱地址 String regex = \u0026#34;(1[3-9]\\\\d{9})|\u0026#34; + \u0026#34;(0\\\\d{2,9}-?\\\\d{7,18})|\u0026#34; // 匹配固定电话号码，包括区号和分机号 + \u0026#34;(\\\\w{2,}@\\\\w{2,20}(\\\\.\\\\w{2,10}){1,2})|\u0026#34; // 匹配邮箱地址 + \u0026#34;(400-?\\\\d{3,7}-?\\\\d{3,7})\u0026#34;; // 匹配400电话号码，包括可能的分机号 // 编译正则表达式 Pattern pattern = Pattern.compile(regex); // 创建匹配器对象 Matcher matcher = pattern.matcher(data); // 循环查找匹配项并打印 while(matcher.find()){ String res = matcher.group(); // 获取匹配到的字符串 System.out.println(res); } } String s1 = \u0026#34;古力娜扎ai8888迪丽热巴999aa5566马尔扎哈fbbfsfs42425卡尔扎巴\u0026#34;; System.out.println(s1.replaceAll(\u0026#34;\\\\w+\u0026#34;, \u0026#34;-\u0026#34;)); String s2 = \u0026#34;我我我喜欢编编编编编编编编编编编编程程程\u0026#34;; System.out.println(s2.replaceAll(\u0026#34;(.)\\\\1+\u0026#34;, \u0026#34;$1\u0026#34;)); String s3 = \u0026#34;古力娜扎ai8888迪丽热巴999aa5566马尔扎哈fbbfsfs42425卡尔扎巴\u0026#34;; String[] names = s3.split(\u0026#34;\\\\w+\u0026#34;); System.out.println(Arrays.toString(names)); 异常 Error： 代表的系统级别错误（属于严重问题）， 也就是说系统一旦出现问题，sun公司会把这些问题封装成Error对象给出了，即Error是Sun公司自己用的，而不是给程序员用的\nException：异常，它代表的才是程序可能出现的错误，所以通常会用Exception以及它的子类来封装程序出现的错误\n运行时异常：RuntimeException及其子类，编译阶段不会出现错误提醒，运行时出现的异常（数组索引越界异常） 编译时异常：编译阶段就会出现的错误提醒。（日期解析异常） 自定义异常 运行时异常 package com.showguan.Exception; // 自定义运行时异常类，用于表示年龄不合法的情况 public class AgeIllegalRuntimeException extends RuntimeException { // 默认构造函数 public AgeIllegalRuntimeException() { } // 带有消息参数的构造函数，用于传递异常信息 public AgeIllegalRuntimeException(String message) { super(message); } } public class Main { // 保存年龄的方法，如果年龄不合法则抛出自定义的运行时异常 public static void saveAge(int age) { if (age \u0026gt; 0 \u0026amp;\u0026amp; age \u0026lt; 150) { System.out.println(\u0026#34;年龄合法\u0026#34;); } else { throw new AgeIllegalRuntimeException(\u0026#34;/age is illegal, your age is \u0026#34; + age); } } public static void main(String[] args) { try { // 调用保存年龄的方法，传入一个不合法的年龄值 saveAge(-1); System.out.println(\u0026#34;底层执行成功了\u0026#34;); } catch (Exception e) { // 捕获自定义的异常并打印异常信息 e.printStackTrace(); System.out.println(\u0026#34;底层出现了异常\u0026#34;); } } } 编译时异常 package com.showguan.Exception; // 自定义异常类，继承自Exception类，用于表示年龄不合法的情况 public class AgeIllegalException extends Exception { // 默认构造函数 public AgeIllegalException() { } // 带有消息参数的构造函数，用于传递异常信息 public AgeIllegalException(String message) { super(message); } } public class Main { // 保存年龄的方法，如果年龄不合法则抛出自定义的受检查异常 public static void saveAge2(int age) throws AgeIllegalException { if (age \u0026gt; 0 \u0026amp;\u0026amp; age \u0026lt; 150) { System.out.println(\u0026#34;年龄合法\u0026#34;); } else { throw new AgeIllegalException(\u0026#34;/age is illegal, your age is \u0026#34; + age); } } public static void main(String[] args) { try { // 调用保存年龄的方法，传入一个合法的年龄值 saveAge2(1); System.out.println(\u0026#34;底层执行成功了\u0026#34;); } catch (Exception e) { // 捕获自定义的异常并打印异常信息 e.printStackTrace(); System.out.println(\u0026#34;底层出现了异常\u0026#34;); } } } public class Demo2 { public static void main(String[] args) { try { // 调用test1方法，该方法声明了可能抛出ParseException和FileNotFoundException异常 test1(); } catch (ParseException e) { // 捕获ParseException异常，并输出错误提示信息 System.out.println(\u0026#34;日期格式错误，请检查日期格式\u0026#34;); // 抛出一个新的RuntimeException异常，将原始异常作为其cause throw new RuntimeException(e); } catch (FileNotFoundException e) { // 捕获FileNotFoundException异常，并输出错误提示信息 System.out.println(\u0026#34;指定文件夹内没有该文件，请检查文件路径\u0026#34;); // 抛出一个新的RuntimeException异常，将原始异常作为其cause throw new RuntimeException(e); } } // test1方法声明了可能抛出ParseException和FileNotFoundException异常 public static void test1() throws ParseException, FileNotFoundException { // 创建SimpleDateFormat对象，用于解析日期字符串 SimpleDateFormat sdf = new SimpleDateFormat(\u0026#34;yyyy-MM-dd HH:mm:ss\u0026#34;); // 解析日期字符串，如果日期格式不正确会抛出ParseException异常 Date d = sdf.parse(\u0026#34;2077-09-23 10:34:22\u0026#34;); System.out.println(d); // 调用test2方法，该方法声明了可能抛出FileNotFoundException异常 test2(); } // test2方法声明了可能抛出FileNotFoundException异常 public static void test2() throws FileNotFoundException { // 创建FileInputStream对象，如果指定文件不存在会抛出FileNotFoundException异常 InputStream is = new FileInputStream(\u0026#34;D:/Java.txt\u0026#34;); } } package com.showguan.Exception; import java.io.FileInputStream; import java.io.FileNotFoundException; import java.io.InputStream; import java.text.ParseException; import java.text.SimpleDateFormat; import java.util.Date; public class Demo3 { public static void main(String[] args) { try { // 调用test1方法，该方法声明了可能抛出Exception异常 test1(); } catch (Exception e) { // 捕获Exception异常，并输出错误提示信息 System.out.println(\u0026#34;操作有误\u0026#34;); // 抛出一个新的RuntimeException异常，将原始异常作为其cause throw new RuntimeException(e); } } // test1方法声明了可能抛出Exception异常 public static void test1() throws Exception { // 创建SimpleDateFormat对象，用于解析日期字符串 SimpleDateFormat sdf = new SimpleDateFormat(\u0026#34;yyyy-MM-dd HH:mm:ss\u0026#34;); // 解析日期字符串，如果日期格式不正确会抛出ParseException异常 Date d = sdf.parse(\u0026#34;2077-09-23 10:34:22\u0026#34;); System.out.println(d); // 调用test2方法，该方法声明了可能抛出Exception异常 test2(); } // test2方法声明了可能抛出Exception异常 public static void test2() throws Exception { // 创建FileInputStream对象，如果指定文件不存在会抛出FileNotFoundException异常 InputStream is = new FileInputStream(\u0026#34;D:/Java.txt\u0026#34;); } } 集合 Collection集合特点：\nList系列集合：添加的元素是有序、可重复、有索引的。\nArrayList, LinkedList：有序、可重复、有索引 Set系列集合：添加的元素是无序、不重复、无索引\nHashSet: 无序、不重复、无索引 LinkedHashSet: 有序、不重复、无索引 TreeSet : 按照大小默认升序排列、不重复、无索引 Collection import java.util.ArrayList; import java.util.Arrays; import java.util.Collection; public class Main { public static void main(String[] args) { // 创建一个ArrayList对象，并向其中添加元素 Collection\u0026lt;String\u0026gt; c = new ArrayList\u0026lt;\u0026gt;(); c.add(\u0026#34;java1\u0026#34;); c.add(\u0026#34;java2\u0026#34;); c.add(\u0026#34;java3\u0026#34;); c.add(\u0026#34;java1\u0026#34;); // 可以添加重复元素 System.out.println(c); // 输出集合中的所有元素 // 清空集合中的所有元素 // c.clear(); System.out.println(c); // 判断集合是否为空 System.out.println(c.isEmpty()); // 获取集合中元素的个数 System.out.println(c.size()); // 判断集合是否包含指定元素 System.out.println(c.contains(\u0026#34;java1\u0026#34;)); // 移除集合中的指定元素 c.remove(\u0026#34;java1\u0026#34;); System.out.println(c); // 将集合转换为数组 Object[] arr = c.toArray(); System.out.println(Arrays.toString(arr)); // 将集合转换为指定类型的数组 String[] arr2 = c.toArray(new String[c.size()]); System.out.println(Arrays.toString(arr2)); // 创建另一个集合，并将其元素全部添加到当前集合中 Collection\u0026lt;String\u0026gt; c2 = new ArrayList\u0026lt;\u0026gt;(); c2.add(\u0026#34;Java8\u0026#34;); c2.add(\u0026#34;java9\u0026#34;); c.addAll(c2); System.out.println(c); } } 迭代器 import java.util.ArrayList; import java.util.Collection; import java.util.function.Consumer; public class Main { public static void main(String[] args) { // 创建一个 ArrayList 集合对象 Collection\u0026lt;String\u0026gt; c = new ArrayList\u0026lt;\u0026gt;(); // 向集合中添加元素 c.add(\u0026#34;Kennem\u0026#34;); c.add(\u0026#34;999\u0026#34;); c.add(\u0026#34;show\u0026#34;); // 使用 forEach 方法遍历集合，传统方式 c.forEach(new Consumer\u0026lt;String\u0026gt;() { @Override public void accept(String s) { System.out.println(s); } }); // 使用 Lambda 表达式遍历集合，Lambda 参数类型推断 c.forEach((String s) -\u0026gt; { System.out.println(s); }); // 使用 Lambda 表达式遍历集合，简化参数类型 c.forEach((String s) -\u0026gt; System.out.println(s)); // 使用方法引用遍历集合，等同于 Lambda 表达式 System.out::println c.forEach( System.out::println ) ; } } public class Main { public static void main(String[] args) { // 创建一个 Movie 类型的集合对象 Collection\u0026lt;Movie\u0026gt; movies = new ArrayList\u0026lt;\u0026gt;(); // 向集合中添加 Movie 对象 movies.add(new Movie(\u0026#34;《阿甘正传》\u0026#34;, 9.5, \u0026#34;汤姆\u0026#34;)); // 打印集合内容 System.out.println(movies); // 使用增强型 for 循环遍历集合中的 Movie 对象 for (Movie movie : movies) { // 获取电影名称并打印 System.out.println(movie.getName()); // 获取电影评分并打印 System.out.println(movie.getScore()); // 获取主演名称并打印 System.out.println(movie.getActor()); } } } List() ArrayList() 添加元素：add(E e) 和 add(int index, E element)\n删除元素：remove(int index) 和 remove(Object o)\n获取元素：get(int index)\n修改元素：set(int index, E element)\n检查元素是否存在：contains(Object o)\n获取列表大小：size()\n获取元素位置：indexOf(Object o) 和 lastIndexOf(Object o)\n遍历列表：使用 for-each 循环和 Iterator\n转换为数组：toArray()\n获取子列表：subList(int fromIndex, int toIndex)\n清空列表：clear()\n判断列表是否为空：isEmpty()\nimport java.util.ArrayList; import java.util.List; public class Main { public static void main(String[] args) { // 创建一个 ArrayList 对象 ls List\u0026lt;String\u0026gt; ls = new ArrayList\u0026lt;\u0026gt;(); // 向 ls 中添加元素 ls.add(\u0026#34;Kennem\u0026#34;); ls.add(\u0026#34;K\u0026#34;); ls.add(\u0026#34;至尊宝\u0026#34;); ls.add(\u0026#34;牛夫人\u0026#34;); // 打印 ls 的内容 System.out.println(\u0026#34;Initial list: \u0026#34; + ls); // 在索引位置 2 插入元素 \u0026#34;紫霞仙子\u0026#34; ls.add(2, \u0026#34;紫霞仙子\u0026#34;); System.out.println(\u0026#34;After adding \u0026#39;紫霞仙子\u0026#39; at index 2: \u0026#34; + ls); // 移除索引位置 2 处的元素并打印移除的元素 System.out.println(\u0026#34;Removed element: \u0026#34; + ls.remove(2)); System.out.println(\u0026#34;After removal: \u0026#34; + ls); // 获取索引位置 2 处的元素并打印 System.out.println(\u0026#34;Element at index 2: \u0026#34; + ls.get(2)); // 将索引位置 1 处的元素修改为 \u0026#34;牛魔王\u0026#34;，并打印被替换掉的元素 System.out.println(\u0026#34;Replaced element: \u0026#34; + ls.set(1, \u0026#34;牛魔王\u0026#34;)); System.out.println(\u0026#34;After setting \u0026#39;牛魔王\u0026#39; at index 1: \u0026#34; + ls); // 检查列表中是否包含某个元素 System.out.println(\u0026#34;Contains \u0026#39;至尊宝\u0026#39;: \u0026#34; + ls.contains(\u0026#34;至尊宝\u0026#34;)); System.out.println(\u0026#34;Contains \u0026#39;紫霞仙子\u0026#39;: \u0026#34; + ls.contains(\u0026#34;紫霞仙子\u0026#34;)); // 获取列表大小 System.out.println(\u0026#34;List size: \u0026#34; + ls.size()); // 获取某个元素的索引 System.out.println(\u0026#34;Index of \u0026#39;牛魔王\u0026#39;: \u0026#34; + ls.indexOf(\u0026#34;牛魔王\u0026#34;)); System.out.println(\u0026#34;Index of \u0026#39;至尊宝\u0026#39;: \u0026#34; + ls.indexOf(\u0026#34;至尊宝\u0026#34;)); // 遍历列表 System.out.println(\u0026#34;List elements:\u0026#34;); for (String element : ls) { System.out.println(element); } // 转换为数组 Object[] array = ls.toArray(); System.out.println(\u0026#34;Array elements:\u0026#34;); for (Object obj : array) { System.out.println(obj); } // 获取子列表 List\u0026lt;String\u0026gt; subList = ls.subList(1, 3); System.out.println(\u0026#34;Sublist (from index 1 to 3): \u0026#34; + subList); // 使用迭代器遍历列表 System.out.println(\u0026#34;List elements using iterator:\u0026#34;); for (var iterator = ls.iterator(); iterator.hasNext();) { System.out.println(iterator.next()); } // 清空列表 ls.clear(); System.out.println(\u0026#34;Is list empty after clear? \u0026#34; + ls.isEmpty()); } } LinkedList() 添加元素：add(E e) 和 add(int index, E element)\n删除元素：remove(int index) 和 remove(Object o)\n获取元素：get(int index)\n修改元素：set(int index, E element)\n检查元素是否存在：contains(Object o)\n获取列表大小：size()\n获取元素位置：indexOf(Object o) 和 lastIndexOf(Object o)\n遍历列表：使用 for-each 循环和 Iterator\n转换为数组：toArray()\n获取子列表：subList(int fromIndex, int toIndex)\n清空列表：clear()\n判断列表是否为空：isEmpty()\n特有方法：addFirst(E e)，addLast(E e)，getFirst()，getLast()，removeFirst()，removeLast()\nimport java.util.LinkedList; import java.util.Iterator; public class LinkedListExample { public static void main(String[] args) { LinkedList\u0026lt;String\u0026gt; list = new LinkedList\u0026lt;\u0026gt;(); // 添加元素 list.add(\u0026#34;element1\u0026#34;); list.add(\u0026#34;element2\u0026#34;); list.add(1, \u0026#34;element1.5\u0026#34;); list.addFirst(\u0026#34;firstElement\u0026#34;); list.addLast(\u0026#34;lastElement\u0026#34;); // 访问元素 System.out.println(\u0026#34;First element: \u0026#34; + list.getFirst()); System.out.println(\u0026#34;Last element: \u0026#34; + list.getLast()); System.out.println(\u0026#34;Element at index 1: \u0026#34; + list.get(1)); // 删除元素 list.remove(1); list.remove(\u0026#34;element1\u0026#34;); list.removeFirst(); list.removeLast(); // 替换元素 list.set(1, \u0026#34;newElement\u0026#34;); // 检查元素是否存在 System.out.println(\u0026#34;Contains \u0026#39;element2\u0026#39;: \u0026#34; + list.contains(\u0026#34;element2\u0026#34;)); // 获取列表大小 System.out.println(\u0026#34;List size: \u0026#34; + list.size()); // 遍历列表 System.out.println(\u0026#34;Elements in the list:\u0026#34;); for (String element : list) { System.out.println(element); } // 转换为数组 Object[] array = list.toArray(); System.out.println(\u0026#34;Array: \u0026#34;); for (Object obj : array) { System.out.println(obj); } // 获取子列表 List\u0026lt;String\u0026gt; subList = list.subList(0, 1); System.out.println(\u0026#34;Sublist: \u0026#34; + subList); // 清空列表 list.clear(); System.out.println(\u0026#34;Is list empty? \u0026#34; + list.isEmpty()); } } LinkedList()特有方法 import java.util.LinkedList; public class LinkedListExample { public static void main(String[] args) { LinkedList\u0026lt;String\u0026gt; linkedList = new LinkedList\u0026lt;\u0026gt;(); // 添加元素到开头和末尾 linkedList.addFirst(\u0026#34;firstElement\u0026#34;); linkedList.addLast(\u0026#34;lastElement\u0026#34;); System.out.println(\u0026#34;After adding elements to first and last: \u0026#34; + linkedList); // 获取第一个和最后一个元素 System.out.println(\u0026#34;First element: \u0026#34; + linkedList.getFirst()); System.out.println(\u0026#34;Last element: \u0026#34; + linkedList.getLast()); // 删除第一个和最后一个元素 System.out.println(\u0026#34;Removed first element: \u0026#34; + linkedList.removeFirst()); System.out.println(\u0026#34;Removed last element: \u0026#34; + linkedList.removeLast()); System.out.println(\u0026#34;After removing first and last elements: \u0026#34; + linkedList); // 栈操作 linkedList.push(\u0026#34;stackElement\u0026#34;); System.out.println(\u0026#34;After push: \u0026#34; + linkedList); System.out.println(\u0026#34;Popped element: \u0026#34; + linkedList.pop()); System.out.println(\u0026#34;After pop: \u0026#34; + linkedList); // 添加元素到队列两端 linkedList.offerFirst(\u0026#34;offerFirstElement\u0026#34;); linkedList.offerLast(\u0026#34;offerLastElement\u0026#34;); System.out.println(\u0026#34;After offering elements: \u0026#34; + linkedList); // 获取并移除队列两端的元素 System.out.println(\u0026#34;Polled first element: \u0026#34; + linkedList.pollFirst()); System.out.println(\u0026#34;Polled last element: \u0026#34; + linkedList.pollLast()); System.out.println(\u0026#34;After polling elements: \u0026#34; + linkedList); } } ArrayList() 和 LinkedList() 区别 ArrayList 和 LinkedList 都实现了 List 接口，因此有许多相同的方法。\nLinkedList 还实现了 Deque 接口，因此有许多特有的方法，这些方法在 ArrayList 中不存在。\nArrayList 在随机访问性能上优于 LinkedList，而 LinkedList 在频繁插入和删除操作时表现更优。\nSet() HashSet() 哈希值\n就是一个int类型的数值，Java中每个对象都有一个哈希值 Java中的所有对象，都可以调用Object类提供的hashCode方法，返回该对象自己的哈希值 哈希表\nJDK 8之前， 基于数组+链表\n创建一个默认长度为16的数组，默认加载因子为0.75， 数组名为table 使用元素的哈希值对数组长度求余计算出应存入的位置 判断当前位置是否为null， 如果是null直接存入 如果不为null， 表示有元素，则调用equals方法比较 若相等则不存入，否则存入 JDK 8之前，新元素存入数组，占老元素位置，老元素挂下面 JDK 8开始之后， 新元素直接挂在老元素下面 JDK 8开始之后，哈希表中引入了红黑树，进一步提高了操作数据的性能\n树：\n二叉树中，任意节点的度\u0026lt;=2\n度：每一个节点的子节点数量 树高：树的总层数 根节点：最顶层的节点 二叉查找树（二叉排序树）\n规则：小的存左边，大的存右边，一样的不存\n平衡二叉树：左右子树的高度差不超过1\n红黑树：可以自平衡的二叉树, 是一种增删改查性能都相对较好的结构\n从JDK8开始，当链表的长度超过8，且数组长度\u0026gt;=64时，自动将链表转成红黑树\npublic static void main(String[] args) { // 创建一个 HashSet 对象，用于存储整数数据 Set\u0026lt;Integer\u0026gt; set = new HashSet\u0026lt;\u0026gt;(); // 往 HashSet 中添加整数元素 // HashSet 会自动去重，不会存储重复的元素 set.add(999); // 添加整数 999 set.add(999); // 添加重复的整数 999，但由于 HashSet 不允许重复元素，此次添加无效 set.add(777); // 添加整数 777 // 打印 HashSet 中的元素 // 输出结果：[777, 999] // HashSet 中的元素无序，并且已经去重了，只保留了一个 999 System.out.println(set); } LinkedHashSet public static void main(String[] args) { // 创建一个 LinkedHashSet 对象，用于存储整数数据，并保持元素的插入顺序 Set\u0026lt;Integer\u0026gt; set = new LinkedHashSet\u0026lt;\u0026gt;(); // 往 LinkedHashSet 中添加整数元素 // LinkedHashSet 会保持元素的插入顺序，并且会自动去重，不会存储重复的元素 // 添加顺序：999, 000, 777, 888 // 由于 LinkedHashSet 会保持插入顺序，因此打印时也会按照添加顺序输出 set.add(999); set.add(000); // 注意：整数 000 在打印时会自动去掉前导零，变成 0 set.add(777); set.add(888); set.add(999); // 重复元素不会被添加进 LinkedHashSet // 打印 LinkedHashSet 中的元素 // 输出结果：[999, 0, 777, 888] // LinkedHashSet 中的元素按照插入顺序排列，并且去重了 System.out.println(set); } TreeSet() 基于红黑树实现排序，\npublic static void main(String[] args) { // 创建一个 TreeSet 对象，用于存储整数数据，并按照自然顺序进行排序 Set\u0026lt;Integer\u0026gt; set = new TreeSet\u0026lt;\u0026gt;(); // 往 TreeSet 中添加整数元素 // TreeSet 会自动去重，不会存储重复的元素 // 添加顺序：999, 000, 777, 888 // 由于 TreeSet 是有序的，它会根据自然顺序（从小到大）对元素进行排序 set.add(999); set.add(000); // 注意：整数 000 在打印时会自动去掉前导零，变成 0 set.add(777); set.add(888); set.add(999); // 重复元素不会被添加进 TreeSet // 打印 TreeSet 中的元素 // 输出结果：[0, 777, 888, 999] // TreeSet 中的元素已经按照自然顺序排好序，并且去重了 System.out.println(set); } 对于自定义对象，确保存储的值相同就重复，重写hashCode方法\n@Override public int hashCode() { return Objects.hash(name, age, height);//只要内容一样，哈希值就相同 } 自定义排序规则： TreeSet集合存储自定义类型的对象时， 必须指定排序规则，支持如下两种方式来指定比较规则 方式一\n让自定义的类（如学生类）实现Comparable接口，重写里面的compareTo方法来执行比较规则 @Override public int compareTo(Student o) { return this.age - o.age; } 方式二\n通过调用TreeSet集合有参数构造器，可以设置Comparator对象（比较器对象，用于指定比较规则。） // 就近选择自己自带的比较器进行比较 // Set\u0026lt;Student\u0026gt; students = new TreeSet\u0026lt;\u0026gt;(new Comparator\u0026lt;Student\u0026gt;() { // @Override // public int compare(Student o1, Student o2) { // return Double.compare(o1.getHeight(), o2.getHeight()); // } // }); Set\u0026lt;Student\u0026gt; students = new TreeSet\u0026lt;\u0026gt;( (o1, o2) -\u0026gt; Double.compare(o1.getHeight(), o2.getHeight())); 集合的并发修改异常 public static void main(String[] args) { // 创建一个字符串列表 List\u0026lt;String\u0026gt; list = new ArrayList\u0026lt;\u0026gt;(); list.add(\u0026#34;小李子\u0026#34;); list.add(\u0026#34;利玛窦\u0026#34;); list.add(\u0026#34;胡风云\u0026#34;); list.add(\u0026#34;胡面上\u0026#34;); list.add(\u0026#34;胡椒粉\u0026#34;); list.add(\u0026#34;kennem\u0026#34;); list.add(\u0026#34;百事快\u0026#34;); System.out.println(list); // 使用迭代器遍历列表并移除包含特定字符的元素 Iterator\u0026lt;String\u0026gt; it = list.iterator(); while (it.hasNext()) { String name = it.next(); if (name.contains(\u0026#34;胡\u0026#34;)) { it.remove(); // 解决集合的并发修改异常 } } System.out.println(list); // 使用普通for循环遍历列表并移除包含特定字符的元素 // 通过维护索引，避免并发修改异常 /* for (int i = 0; i \u0026lt; list.size(); i++) { String name = list.get(i); if (name.contains(\u0026#34;胡\u0026#34;)) { list.remove(name); i--; // 解决集合的并发修改异常 } } System.out.println(list); */ // 使用增强for循环遍历列表并移除包含特定字符的元素 // 不推荐，会导致ConcurrentModificationException异常 /* for (String s : list) { if (s.contains(\u0026#34;胡\u0026#34;)) { list.remove(s); } } System.out.println(list); */ } 可变参数 public static void main(String[] args) { // 调用test方法，传入单个整数参数 test(1); // 调用test方法，传入单个整数参数 test(10); // 调用test方法，传入多个整数参数，其中最后一个参数为可变参数 test(100, 10, 0); // 调用test方法，传入一个整数参数和一个整数数组参数 test(1, new int[] {1, 2, 4, 4, 3, 3, 3, 3, 4, 3}); } // 1. 一个形参列表中，只能有一个可变参数 // 2. 可变参数必须放在形参列表的最后面 public static void test(int age, int...nums){ // 打印可变参数数组 System.out.println(Arrays.toString(nums)); // 打印可变参数数组的长度 System.out.println(nums.length); // 打印分隔线 System.out.println(\u0026#34;----------\u0026#34;); } Collections public static void main(String[] args) { // 创建一个字符串列表 List\u0026lt;String\u0026gt; names = new ArrayList\u0026lt;\u0026gt;(); // 向列表中添加元素 Collections.addAll(names, \u0026#34;Kennem\u0026#34;, \u0026#34;张一\u0026#34;,\u0026#34;李三\u0026#34;,\u0026#34;王六\u0026#34;); // 打印列表内容 System.out.println(names); // 打乱列表中元素的顺序 Collections.shuffle(names); // 打印打乱后的列表内容 System.out.println(names); // 创建一个整数列表 List\u0026lt;Integer\u0026gt; list = new ArrayList\u0026lt;\u0026gt;(); // 向列表中添加元素 list.add(3); list.add(4); list.add(1); // 对列表中的元素进行排序 Collections.sort(list); // 打印排序后的列表内容 System.out.println(list); // 创建一个学生对象列表 List\u0026lt;Student\u0026gt; students = new ArrayList\u0026lt;\u0026gt;(); // 创建学生对象并添加到列表中 Student s1 = new Student(\u0026#34;至尊宝\u0026#34;, 21, 181.9); Student s2 = new Student(\u0026#34;蜘蛛精\u0026#34;, 21, 188); Student s3 = new Student(\u0026#34;牛魔王\u0026#34;, 20, 165.3); Student s4 = new Student(\u0026#34;蝎子精\u0026#34;, 20, 165.3); Student s5 = new Student(\u0026#34;葫芦娃\u0026#34;, 20, 165.3); Student s6 = new Student(\u0026#34;至尊宝\u0026#34;, 21, 181); students.add(s1); students.add(s2); students.add(s3); students.add(s4); students.add(s5); students.add(s6); // 打印学生列表内容 System.out.println(students); // 使用Lambda表达式对学生列表按身高进行排序 Collections.sort(students, (o1, o2) -\u0026gt; Double.compare(o1.getHeight(), o2.getHeight())); // 打印按身高排序后的学生列表内容 System.out.println(students); } Map HashMap ：无序、不重复、无索引；（用的最多） LinkedHashMap：由键决定的特点：有序，不重复，无索引 TreeMap:按照大小默认升序排序，不重复，无索引 public static void main(String[] args) { // 创建一个HashMap对象 Map\u0026lt;String, Integer\u0026gt; map = new HashMap\u0026lt;\u0026gt;(); // 向map中添加键值对 map.put(\u0026#34;手表\u0026#34;, 100); map.put(\u0026#34;手机\u0026#34;, 20); map.put(\u0026#34;Java\u0026#34;, 120); map.put(null, null); // 允许键和值为null // 打印map的内容 System.out.println(map); // 获取map的大小 System.out.println(map.size()); // 清空map // map.clear(); // 打印清空后的map System.out.println(map); // 判断map是否为空 System.out.println(map.isEmpty()); // 获取指定键对应的值 System.out.println(map.get(\u0026#34;手机\u0026#34;)); // 获取一个不存在的键对应的值 System.out.println(map.get(\u0026#34;666\u0026#34;)); // 移除指定键对应的键值对，并返回对应的值 System.out.println(map.remove(\u0026#34;手机\u0026#34;)); // 判断map中是否包含指定的键 System.out.println(map.containsKey(\u0026#34;手机\u0026#34;)); System.out.println(map.containsKey(\u0026#34;手机\u0026#34;)); // 获取map中所有的键，并存储到Set集合中 Set\u0026lt;String\u0026gt; keys = map.keySet(); System.out.println(keys); // 获取map中所有的值，并存储到Collection集合中 Collection\u0026lt;Integer\u0026gt; values = map.values(); System.out.println(values); // 创建另一个HashMap对象 Map\u0026lt;String, Integer\u0026gt; map1 = new HashMap\u0026lt;\u0026gt;(); map1.put(\u0026#34;Java1\u0026#34;, 100); map1.put(\u0026#34;Java2\u0026#34;, 200); map1.put(\u0026#34;Java3\u0026#34;, 300); // 创建另一个HashMap对象 Map\u0026lt;String, Integer\u0026gt; map2 = new HashMap\u0026lt;\u0026gt;(); map2.put(\u0026#34;Java3\u0026#34;, 400); map2.put(\u0026#34;Java4\u0026#34;, 500); // 打印map1和map2的内容 System.out.println(map1); System.out.println(map2); // 将map2中的键值对全部添加到map1中 map1.putAll(map2); // 打印合并后的map1 System.out.println(map1); } 遍历Map public class Main { public static void main(String[] args) { // 创建一个HashMap对象，键为String类型，值为Double类型 Map\u0026lt;String, Double\u0026gt; map = new HashMap\u0026lt;\u0026gt;(); // 向map中添加键值对 map.put(\u0026#34;蜘蛛精\u0026#34;, 167.2); // 如果键已存在，则覆盖原有值 map.put(\u0026#34;蜘蛛精\u0026#34;, 169.2); map.put(\u0026#34;至尊宝\u0026#34;, 164.2); map.put(\u0026#34;牛魔王\u0026#34;, 187.2); // 获取map中所有的键，并存储在Set集合中 Set\u0026lt;String\u0026gt; keys = map.keySet(); // 打印所有的键 System.out.println(keys); // 遍历Set集合，获取每个键对应的值，并打印键值对 for (String key : keys) { double value = map.get(key); System.out.println(key + \u0026#34; \u0026#34; + map.get(key)); } } } entry遍历方式 // 获取map中所有的键值对，并存储在Set集合中 Set\u0026lt;Map.Entry\u0026lt;String, Double\u0026gt;\u0026gt; entries = map.entrySet(); // 遍历Set集合，获取每个键值对，并打印键值对 for (Map.Entry\u0026lt;String, Double\u0026gt; entry : entries) { String key = entry.getKey(); double value = entry.getValue(); System.out.println(key + \u0026#34;-----\u0026gt;\u0026#34; + value); } forEach方式遍历\n// 使用forEach方法遍历map，打印每个键值对 map.forEach((k, v) -\u0026gt; { System.out.println(k + \u0026#34;---\u0026gt;\u0026#34; + v); }); LinkedHashMap 类似LinkedHashSet(), 而且LinkedHashSet()底层使用的就是linkedHashMap()\npublic static void main(String[] args) { // 创建一个LinkedHashMap对象，键为Student类型，值为Integer类型 Map\u0026lt;Student, Integer\u0026gt; lmap = new LinkedHashMap\u0026lt;\u0026gt;(); // 向lmap中添加键值对，其中键为Student对象，值为Integer对象 // 注意：Student类需要正确实现equals()和hashCode()方法以确保对象的唯一性 lmap.put(new Student(\u0026#34;Ken\u0026#34;, 25, 150), 100); lmap.put(new Student(\u0026#34;Mary\u0026#34;, 23, 182), 123300); lmap.put(new Student(\u0026#34;Bob\u0026#34;, 21, 1180), 12300); lmap.put(new Student(\u0026#34;Paul\u0026#34;, 22, 130), 12); lmap.put(new Student(\u0026#34;Sam\u0026#34;, 15, 280), 120); lmap.put(new Student(\u0026#34;Ken\u0026#34;, 25, 150), 10); // 注意：与第一个Ken对象相同，但是值不同 // 使用forEach方法遍历lmap，打印每个键值对 lmap.forEach((k, v) -\u0026gt; { System.out.println(k + \u0026#34; \u0026#34; + v); }); } 重写equals方法可以去除重复值\n@Override public boolean equals(Object o) { if (this == o) return true; if (o == null || getClass() != o.getClass()) return false; Student student = (Student) o; return age == student.age \u0026amp;\u0026amp; Double.compare(height, student.height) == 0 \u0026amp;\u0026amp; Objects.equals(name, student.name); } TreeMap 比较规则用重写Comparable接口，或者重写Comparator方法\npublic static void main(String[] args) { // 创建一个TreeMap对象，键为Student类型，值为Integer类型 // 在构造TreeMap对象时，传入一个Comparator对象，用于按照学生身高进行排序 Map\u0026lt;Student, Integer\u0026gt; tmap = new TreeMap\u0026lt;\u0026gt;((o1, o2) -\u0026gt; Double.compare(o1.getHeight(), o2.getHeight())); // 向tmap中添加键值对，其中键为Student对象，值为Integer对象 // 注意：Student类需要正确实现equals()和hashCode()方法以确保对象的唯一性 tmap.put(new Student(\u0026#34;Ken\u0026#34;, 25, 150), 100); tmap.put(new Student(\u0026#34;Mary\u0026#34;, 23, 182), 123300); tmap.put(new Student(\u0026#34;Bob\u0026#34;, 21, 1180), 12300); tmap.put(new Student(\u0026#34;Paul\u0026#34;, 22, 130), 12); tmap.put(new Student(\u0026#34;Sam\u0026#34;, 15, 280), 120); tmap.put(new Student(\u0026#34;Ken\u0026#34;, 25, 150), 10); // 与第一个Ken对象相同，但是值不同 // 使用forEach方法遍历tmap，打印每个键值对 tmap.forEach((k, v) -\u0026gt; { System.out.println(k + \u0026#34; \u0026#34; + v); }); } 重写Comparable中的compareTo方法\n@Override public int compareTo(Student o) { return this.age - o.age; } 集合的嵌套 public static void main(String[] args) { // 创建一个HashMap对象，键为String类型，值为List\u0026lt;String\u0026gt;类型 Map\u0026lt;String, List\u0026lt;String\u0026gt;\u0026gt; map = new HashMap\u0026lt;\u0026gt;(); // 创建第一个城市列表，存储江苏省的城市信息 List\u0026lt;String\u0026gt; cities1 = new ArrayList\u0026lt;\u0026gt;(); // 使用Collections.addAll方法向cities1中添加多个元素 Collections.addAll(cities1, \u0026#34;南京市\u0026#34;, \u0026#34;扬州市\u0026#34;, \u0026#34;苏州市\u0026#34;, \u0026#34;无锡市\u0026#34;, \u0026#34;常州市\u0026#34;); // 将键值对添加到map中，键为\u0026#34;江苏省\u0026#34;，值为cities1列表 map.put(\u0026#34;江苏省\u0026#34;, cities1); // 创建第二个城市列表，存储湖北省的城市信息 List\u0026lt;String\u0026gt; cities2 = new ArrayList\u0026lt;\u0026gt;(); Collections.addAll(cities2, \u0026#34;武汉市\u0026#34;, \u0026#34;孝感市\u0026#34;, \u0026#34;十堰市\u0026#34;, \u0026#34;宜昌市\u0026#34;, \u0026#34;鄂州市\u0026#34;); map.put(\u0026#34;湖北省\u0026#34;, cities2); // 打印整个map System.out.println(map); // 打印湖北省对应的城市列表 System.out.println(map.get(\u0026#34;湖北省\u0026#34;)); // 使用增强for循环遍历第二个城市列表，打印其中的城市信息 for (String s : cities2) { System.out.println(s); } // 使用forEach方法遍历map，打印每个省份及其对应的城市列表 map.forEach((k, v) -\u0026gt; System.out.println(k + \u0026#34;---\u0026gt;\u0026#34; + v)); } Stream import java.util.ArrayList; import java.util.Collections; import java.util.List; import java.util.stream.Collectors; public class Main { public static void main(String[] args) { // 创建一个字符串列表 List\u0026lt;String\u0026gt; names = new ArrayList\u0026lt;\u0026gt;(); // 向列表中添加多个元素 Collections.addAll(names, \u0026#34;张某\u0026#34;, \u0026#34;张五一\u0026#34;, \u0026#34;张无忌\u0026#34;, \u0026#34;张三丰\u0026#34;, \u0026#34;Kennem\u0026#34;); // 打印列表中的所有元素 System.out.println(names); // 创建一个新的列表，用于存储以\u0026#34;张\u0026#34;开头且长度为3的字符串 List\u0026lt;String\u0026gt; list = new ArrayList\u0026lt;\u0026gt;(); // 使用增强for循环遍历原始列表 for (String name : names) { // 如果字符串以\u0026#34;张\u0026#34;开头且长度为3，则添加到新列表中 if (name.startsWith(\u0026#34;张\u0026#34;) \u0026amp;\u0026amp; name.length() == 3) { list.add(name); } } // 打印新列表中的元素 System.out.println(list); // 使用流进行筛选，获取以\u0026#34;张\u0026#34;开头且长度为3的字符串，然后收集到新的列表中 List\u0026lt;String\u0026gt; list2 = names.stream() .filter(s -\u0026gt; s.startsWith(\u0026#34;张\u0026#34;)) // 筛选以\u0026#34;张\u0026#34;开头的字符串 .filter(a -\u0026gt; a.length() == 3) // 筛选长度为3的字符串 .collect(Collectors.toList()); // 收集到新的列表中 // 打印新列表中的元素 System.out.println(list2); } } ArrayList, HashSet, Map的Stream流 public static void main(String[] args) { // 创建一个字符串列表 List\u0026lt;String\u0026gt; names = new ArrayList\u0026lt;\u0026gt;(); // 向列表中添加多个元素 Collections.addAll(names, \u0026#34;张三丰\u0026#34;, \u0026#34;张某人\u0026#34;, \u0026#34;张某某\u0026#34;, \u0026#34;张某\u0026#34;, \u0026#34;张某某人\u0026#34;); // 创建一个流，并对其中包含\u0026#34;某\u0026#34;的元素进行筛选并打印 Stream\u0026lt;String\u0026gt; stream1 = names.stream(); stream1.filter(s -\u0026gt; s.contains(\u0026#34;某\u0026#34;)).forEach(System.out::println); // 创建一个HashSet集合，并将多个元素添加到其中 Set\u0026lt;String\u0026gt; set = new HashSet\u0026lt;\u0026gt;(); Collections.addAll(set, \u0026#34;张三丰\u0026#34;, \u0026#34;张某人\u0026#34;, \u0026#34;张某某\u0026#34;, \u0026#34;张某\u0026#34;, \u0026#34;张某某人\u0026#34;); // 创建一个流，并对其中包含\u0026#34;某\u0026#34;的元素进行筛选并打印 Stream\u0026lt;String\u0026gt; stream2 = set.stream(); stream2.filter(s -\u0026gt; s.contains(\u0026#34;某\u0026#34;)).forEach(System.out::println); // 创建一个HashMap对象，并向其中添加键值对 Map\u0026lt;String, Double\u0026gt; map = new HashMap\u0026lt;\u0026gt;(); map.put(\u0026#34;张某\u0026#34;, 165.3); map.put(\u0026#34;Kennem\u0026#34;, 181.2); map.put(\u0026#34;Karl\u0026#34;, 180.1); // 获取map中所有值的集合 Collection\u0026lt;Double\u0026gt; values = map.values(); // 创建一个流，并对其中包含\u0026#34;某\u0026#34;的键值对进行筛选并打印 Set\u0026lt;Map.Entry\u0026lt;String, Double\u0026gt;\u0026gt; entries = map.entrySet(); Stream\u0026lt;Map.Entry\u0026lt;String, Double\u0026gt;\u0026gt; stream3 = entries.stream(); stream3.filter(e -\u0026gt; e.getKey().contains(\u0026#34;某\u0026#34;)) .forEach(e -\u0026gt; System.out.println(e.getKey() + \u0026#34;--\u0026gt;\u0026#34; + e.getValue())); // 创建一个字符串数组，并将多个元素添加到其中 String[] names2 = {\u0026#34;张某人\u0026#34;, \u0026#34;东方不败\u0026#34;}; // 使用Arrays.stream方法创建一个流，并对其中的元素进行打印 Stream\u0026lt;String\u0026gt; stream4 = Arrays.stream(names2); stream4.forEach(System.out::println); // 使用Stream.of方法创建一个流，并对其中的元素进行打印 Stream\u0026lt;String\u0026gt; names21 = Stream.of(names2); names21.forEach(System.out::println); } 排序以及筛选 public static void main(String[] args) { // 创建一个Double类型的列表，存储考试成绩 List\u0026lt;Double\u0026gt; scores = new ArrayList\u0026lt;\u0026gt;(); Collections.addAll(scores, 88.5, 89.5, 90.0, 12.0, 1.0); // 使用流对考试成绩进行筛选，只打印及格的成绩 scores.stream().filter(s -\u0026gt; s \u0026gt;= 60) .forEach(System.out::println); System.out.println(\u0026#34;---------------\u0026#34;); // 创建一个Student对象的列表，存储学生信息 List\u0026lt;Student\u0026gt; students = new ArrayList\u0026lt;\u0026gt;(); // 创建多个Student对象，并添加到列表中 Student s1 = new Student(\u0026#34;至尊宝\u0026#34;, 21, 181.2); Student s2 = new Student(\u0026#34;蜘蛛精\u0026#34;, 21, 181.3); Student s3 = new Student(\u0026#34;牛魔王\u0026#34;, 20, 165.3); Student s4 = new Student(\u0026#34;蝎子精\u0026#34;, 20, 165.2); Student s5 = new Student(\u0026#34;蜘蛛精\u0026#34;, 22, 181.3); Collections.addAll(students, s1, s2, s3, s4, s5); // 使用流对学生信息进行筛选和排序，并打印结果 students.stream().filter(s -\u0026gt; s.getAge() \u0026gt;= 10 \u0026amp;\u0026amp; s.getAge() \u0026lt;= 30) .sorted((o1, o2) -\u0026gt; o2.getAge() - o1.getAge()) .forEach(System.out::println); System.out.println(\u0026#34;--------------\u0026#34;); // 使用流对学生信息按身高进行排序，并打印身高最高的前三名学生 students.stream().sorted(((o1, o2) -\u0026gt; Double.compare(o2.getHeight(), o1.getHeight()))) .limit(3) .forEach(System.out::println); System.out.println(\u0026#34;---------------\u0026#34;); // 使用流对学生信息按身高进行排序，并打印身高最低的两名学生 students.stream().sorted(((o1, o2) -\u0026gt; Double.compare(o2.getHeight(), o1.getHeight()))) .skip(students.size() - 2) .forEach(System.out::println); System.out.println(\u0026#34;-----------------\u0026#34;); // 使用流对学生信息进行筛选，找出身高大于168的学生，并打印他们的姓名（去重） students.stream() .filter(s -\u0026gt; s.getHeight() \u0026gt; 168) .map(Student::getName) .distinct() .forEach(System.out::println); // 使用Stream.concat方法将两个流合并，然后打印合并后的结果 Stream\u0026lt;Student\u0026gt; s11 = Stream.of(s1, s2); Stream\u0026lt;Student\u0026gt; s12 = Stream.of(s3, s4); Stream\u0026lt;Student\u0026gt; concat = Stream.concat(s11, s12); concat.forEach(System.out::println); } Stream终结方法 public static void main(String[] args) { // 创建学生列表 List\u0026lt;Student\u0026gt; students = new ArrayList\u0026lt;\u0026gt;(); // 创建学生对象并添加到列表中 Student s1 = new Student(\u0026#34;至尊宝\u0026#34;, 21, 181.2); Student s2 = new Student(\u0026#34;蜘蛛精\u0026#34;, 21, 181.3); Student s3 = new Student(\u0026#34;牛魔王\u0026#34;, 20, 165.3); Student s4 = new Student(\u0026#34;蝎子精\u0026#34;, 20, 165.2); Student s5 = new Student(\u0026#34;蜘蛛精\u0026#34;, 21, 181.3); Collections.addAll(students, s1, s2, s3, s4, s5); // 使用流过滤身高大于168的学生，并将结果收集到列表中 List\u0026lt;Student\u0026gt; res1 = students.stream() .filter(s -\u0026gt; s.getHeight() \u0026gt; 168) .collect(Collectors.toList()); System.out.println(res1); // 使用流过滤身高大于168的学生，并将结果收集到集合中 Set\u0026lt;Student\u0026gt; res2 = students.stream() .filter(s -\u0026gt; s.getHeight() \u0026gt; 168) .collect(Collectors.toSet()); System.out.println(res2); // 使用流过滤身高大于168的学生，去除重复的学生对象，并将姓名和身高映射到Map中 Map\u0026lt;String, Double\u0026gt; res3 = students.stream() .filter(s -\u0026gt; s.getHeight() \u0026gt; 168) .distinct() .collect(Collectors.toMap(a -\u0026gt; a.getName(), a -\u0026gt; a.getHeight())); System.out.println(res3); // 使用流过滤身高大于168的学生，去除重复的学生对象，并将结果转换为对象数组 Object[] res4 = students.stream() .filter(s -\u0026gt; s.getHeight() \u0026gt; 168) .distinct() .toArray(); System.out.println(Arrays.toString(res4)); // 使用流过滤身高大于168的学生，去除重复的学生对象，并将结果转换为指定长度的学生数组 Student[] res5 = students.stream() .filter(s -\u0026gt; s.getHeight() \u0026gt; 168) .distinct() .toArray(len -\u0026gt; new Student[len]); System.out.println(Arrays.toString(res5)); } 总结程序的知识点，并将知识点写到程序注释中去 ","permalink":"https://kennems.github.io/zh/posts/tech/java20%E5%A4%A9%E9%80%9F%E6%88%90%E8%BF%9B%E9%98%B6%E8%AF%BE%E7%A8%8B2/","summary":"Java20天速成——进阶课程(2) 正则表达式 符号 含义 举例 [] 匹配方括号内的任一字符 [abc] ^ 匹配除指定字符外的任意字符 [^abc] \u0026amp;\u0026amp; 匹配两个字符集的交集，需","title":"Java20天速成——进阶课程(2)"},{"content":"LeetCode第 393 场周赛 第三题3116. 单面值组合的第 K 小金额 题目大意： 给定一个整数数组coins表示不同面额的硬币，另给定一个整数k。你有无限量的每种面额的硬币，但是，你不能组合使用不同面额的硬币。要求返回使用这些硬币能制造的第kth小金额。\n实现思路：\n首先，对于给定的硬币数组，我们需要求出它们的所有可能的组合方式。 使用位运算来枚举所有的组合方式，对于数组中的每个硬币，分别考虑选取和不选取两种情况，通过位运算将这两种情况枚举出来。 对于每种组合方式，计算其对应的最小公倍数（LCM）作为该组合的金额。 根据组合的奇偶性，将金额的正负号记录下来，并存储在列表ls中。 利用二分查找来求解第kth小的金额，通过不断调整左右边界，直到找到满足条件的金额。 返回最终找到的金额作为结果。 这种方法利用了位运算和二分查找的思想，可以在较短的时间内求解出结果。\nclass Solution: def findKthSmallest(self, coins: List[int], k: int) -\u0026gt; int: n = len(coins) ls = [] for i in range(1, 1\u0026lt;\u0026lt;n): Lcm = 1 for j, x in enumerate(coins): if i\u0026gt;\u0026gt;j \u0026amp; 1: Lcm = lcm(Lcm, x) ls.append((1, Lcm)) if i.bit_count()\u0026amp;1 else ls.append((-1, Lcm)) l, r = 1, int(5e10) while l\u0026lt;r: mid = l+r\u0026gt;\u0026gt;1 cnt = 0 for sign, val in ls: cnt += sign*(mid//val) if cnt\u0026gt;=k: r = mid else: l = mid+1 return l 第四题3117. 划分数组得到最小的值之和 题目大意： 给定两个数组nums和andValues，长度分别为n和m。数组的值等于该数组的最后一个元素。需要将nums划分为m个不相交的连续子数组，对于第ith个子数组[li, ri]，子数组元素的按位AND运算结果等于andValues[i]。返回将nums划分为m个子数组所能得到的可能的最小子数组值之和。如果无法完成这样的划分，则返回-1。\n实现思路：\n使用动态规划来解决此问题，具体来说，可以采用递归加记忆化搜索的方法。 定义dfs函数用于递归求解，其中i表示当前处理到nums的第i个元素，j表示当前处理到andValues的第j个元素，k表示当前子数组的按位AND运算结果。 在dfs函数中，首先进行边界条件的判断，如果i等于n，表示nums已经处理完毕，则返回0（如果j等于m）或者正无穷（如果j不等于m）。 然后，对当前nums[i]进行按位AND运算，并更新k的值。如果更新后的k小于andValues[j]，则返回正无穷。 如果更新后的k等于andValues[j]，则递归调用dfs函数继续处理下一个元素，同时更新i和j，并将k重置为-1。递归调用的结果加上nums[i]的值即为当前划分情况的子数组值之和。 最后，返回所有划分情况中的最小值作为答案，如果答案为正无穷，则返回-1。 这种方法利用了递归和记忆化搜索的思想，避免了重复计算，提高了效率。\nclass Solution: def minimumValueSum(self, nums: List[int], andValues: List[int]) -\u0026gt; int: n = len(nums) m = len(andValues) @cache def dfs(i, j, k): if i==n: return 0 if j==m else inf if j==m: return inf k\u0026amp;=nums[i] if k\u0026lt;andValues[j]: return inf res = dfs(i+1, j, k) if k==andValues[j]: res = min(res, dfs(i+1, j+1, -1)+nums[i]) return res ans = dfs(0, 0, -1) return ans if ans\u0026lt;inf else -1 ","permalink":"https://kennems.github.io/zh/posts/tech/leetcode%E7%AC%AC-393-%E5%9C%BA%E5%91%A8%E8%B5%9B/","summary":"LeetCode第 393 场周赛 第三题3116. 单面值组合的第 K 小金额 题目大意： 给定一个整数数组coins表示不同面额的硬币，另给定一个整数k。你","title":"LeetCode周赛240414"},{"content":"进阶课程(1) OOP static 静态， 可以修饰成员变量，成员方法 成员变量按照有无static修饰，分为两种 类变量 ： 有static修饰，属于类，在计算机里只有一份，会被类的全部对象共享 实例变量（对象的变量）：无static修饰，属于每个对象 // 类变量推荐赋值方式 Student.name = \u0026#34;Java\u0026#34;; // 不推荐赋值方式 Student s1 = new Student(); s1.name = \u0026#34;True Java\u0026#34;; Student s2 = new Student(); s2.name = \u0026#34;False Java\u0026#34;; System.out.println(s2.name); //False Java System.out.println(Student.name); //False Java // 成员变量 s1.age = 25; s2.age = 15; System.out.println(s1.age); //25 System.out.println(s2.age); //15 //User类 public static int number; public User(){ number+=1; //类中访问自己的变量可以不写 User(). } //Test类 public static void main(String[] args) { User u1 = new User(); User u2 = new User(); User u3 = new User(); System.out.println(User.number); //3 } 类方法：有static修饰的成员方法，属于类。 实例方法：无static修饰的成员方法，属于对象 //Student double score; public static void printHelloWorld(){ System.out.println(\u0026#34;Hello World\u0026#34;); System.out.println(\u0026#34;Hello World\u0026#34;); } public void printPass(){ System.out.println(\u0026#34;成绩：\u0026#34; + (score \u0026gt;= 60 ? \u0026#34;及格\u0026#34; : \u0026#34;不及格\u0026#34;)); } //Test Student.printHelloWorld();//Hello World Hello World Student s = new Student(); s.score = 100; s.printPass(); //成绩：及格 类方法的常见应用案例 类方法最常见的应用场景是做工具类 工具类：工具类中的方法都是一些类方法，每个方法都是用来完成一个功能的，工具类是给开发人员共同使用的\n可以提高代码复用性：调用方便，提高了开发效率\n使用类方法、实例方法时的几点注意事项\n类方法中可以直接访问类的成员，不可以直接访问实例成员 实例方法中既可以直接访问类成员，也可以直接访问实例成员 实例方法中可以出现this关键字，类方法中不可以出现this关键字 代码块 静态代码块 格式 ： static{ } 特点：类加载时自动执行，由于类只会加载一次，所以静态代码块只会执行一次 作用：完成类的初始化，例如：对类变量的初始化赋值 实例代码块： 格式：{ } 特点：每次创建对象时，执行实例代码块，并在构造器前执行 作用：和构造器一样，都是用来完成对象的初始化的，例如：对实例变量进行初始化赋值 单例设计模式 设计模式（Design pattern） 就是解决问题的最优解。\n单例设计模式：确保一个类只有一个对象\n饿汉式单例类\n把类的构造器私有 定义一个类变量记为类的一个对象 定义一个类方法，返回对象 public class A { private static A a = new A(); private A(){ } public static A getObject(){ return a; } } 继承 继承的好处：减少重复代码的编写\npublic class people { private String name; public String getName(){ return this.name; } public void setName(String name){ this.name = name; } } public class teacher extends people{ private String skill; public String getSkill() { return skill; } public void setSkill(String skill) { this.skill = skill; } public void printInfo(){ System.out.println(getName() + \u0026#34;具备的技能 ： \u0026#34; + skill); } } public class Test { public static void main(String[] args) { teacher t1 = new teacher(); t1.setName(\u0026#34;Kennem\u0026#34;); t1.setSkill(\u0026#34;Java\u0026#34;); System.out.println(t1.getName()); //Kennem System.out.println(t1.getSkill()); //Java t1.printInfo(); //Kennem具备的技能 ： Java } } 继承的注意事项：\n权限修饰符 单继承，Object类 方法重写 子类中访问其他成员的特点 子类构造器的特点 注意事项的小结 修饰符 本类中 同一个包下的其他类继承 任意包下的子类继承 任意包下的任何类继承 private ✓ 缺省 ✓ ✓ protected ✓ ✓ ✓ public ✓ ✓ ✓ ✓ 注意：用protected修饰，只能在子类中访问，而不是子类的对象访问\n单继承 Java不支持多继承，支持多层继承\nObject类 Object类是任何类的父类。\n方法重写 重写注意事项\n使用Override注解\n@Override public void print(){ System.out.println(\u0026#34;88888888\u0026#34;); } @Override public void print2(){ System.out.println(\u0026#34;8\u0026#34;); } 子类复写父类方法时，访问权限必须大于或者等于父类该方法的权限（publc -\u0026gt; protected -\u0026gt; 缺省）\n重写的方法返回值类型，必须与被重写方法的返回值类型一致，或者范围更小\n私有方法、静态方法不能被重写\n声明不变，重新实现\ntoString()方法重写\n@Override public String toString() { return \u0026#34;Student{\u0026#34; + \u0026#34;name=\u0026#39;\u0026#34; + name + \u0026#39;\\\u0026#39;\u0026#39; + \u0026#34;, age=\u0026#34; + age + \u0026#39;}\u0026#39;; } 子列构造器的特点：\n子类的全部构造器，都会先调用父类的构造器，再执行自己的构造器。 子类构造器是符合实现调用父类构造器的： 默认情况下，子类全部构造器的第一行都是super()（默认都有），它会调用父类的无参数构造器。 如果父类没有无参数构造器，则我们必须再子类构造器的第一行手写super(...)， 指定去调用父类的有参数构造器。 class Student extends People{ private String skill; public Student(String name, int age, String skill){ super(name, age); //调用父类的有参构造器 父类中name和age构造器 this.skill = skill; } public String getSkill() { return skill; } public void setSkill(String skill) { this.skill = skill; } } 补充知识：this(...)调用兄弟构造器\n任意类的构造器中，是可以通过this(...)去调用该类的其他构造器的。 this(...) 和 super(...) 使用时的注意事项 this(...)、super(...)都只能放在构造器的第一行，因此，有了this(...)就不能写super(...)了，反之亦然 public Boy(String name, int age) { this(name, age, \u0026#34;黑马程序员\u0026#34;); } public Boy(String name, int age, String schoolName) { this.name = name; this.age = age; this.schoolName = schoolName; } 多态 多态是在继承/实现情况下的一种现象，表现为：对象多态，行为多态。\n在多态形式下，右边对象是解耦合的，更偏于扩展和维护。 public class People { public String name = \u0026#34;我是人\u0026#34;; public void run(){ System.out.println(\u0026#34;人可以跑\u0026#34;); } } public class Student extends People{ public String name = \u0026#34;我是学生\u0026#34;; @Override public void run() { System.out.println(\u0026#34;学生跑得很快！\u0026#34;); } public void test(){ System.out.println(\u0026#34;学生要考试...\u0026#34;); } } public class Teacher extends People{ public String name = \u0026#34;我是老师\u0026#34;; @Override public void run() { System.out.println(\u0026#34;老师跑的气喘吁吁！\u0026#34;); } } public class Test { public static void main(String[] args) { People p = new People(); System.out.println(p.name); People p1 = new Student(); System.out.println(p1.name); p1.run(); //编译看父类， 运行看子类 People p2 = new Teacher(); System.out.println(p2.name); p2.run(); } } if(p instanceof Student){ Student s = (Student) p; s.test(); }else if(p instanceof Teacher){ Teacher t = (Teacher) p; t.work(); } public class People { public String name = \u0026#34;我是人\u0026#34;; public void run(){ System.out.println(\u0026#34;人可以跑\u0026#34;); } } public class Student extends People { public String name = \u0026#34;我是学生\u0026#34;; @Override public void run() { System.out.println(\u0026#34;学生跑得很快！\u0026#34;); } public void test(){ System.out.println(\u0026#34;学生要考试\u0026#34;); } } public class Teacher extends People { public String name = \u0026#34;我是老师\u0026#34;; @Override public void run() { System.out.println(\u0026#34;老师跑的气喘吁吁！\u0026#34;); } public void work(){ System.out.println(\u0026#34;老师要上班\u0026#34;); } } final final关键字是最终的意思，可以修饰（类， 方法， 变量） 修饰类：该类被成为最终类，特点是不能被继承了 修饰方法：该方法被称为最终方法，特点是不能被重写了 修饰变量：该变量只能被赋值一次 public class Test { // 3.常量，建议名称全部大写，多个单词下划线连接 public static final String CURRENT_NAME = \u0026#34;Kennem\u0026#34;; public static void main(String[] args) { // final double pi = 3.14; //pi = 3.1; 报错，final修饰的变量不能修改 final int[] arr = {11, 22, 33}; arr[1] = 13; // 4.final修饰的地址不能变，但地址内的内容可以变 } } final class A{ // 1.final 修饰类，类不能被继承了 } // 2.final 修饰方法，方法不能被重写了 class C{ public final void test(){ } } class D extends C{ } 常量 使用了static final修饰的成员变量被称为常量\n作用：通常用于记录系统的配置信息\n使用常量记录系统配置信息的优势，执行原理\n代码可读性更好，可维护性也更好 程序编译后，常量会被\u0026quot;宏替换\u0026quot;；出现常量的地方全部会被替换成其记住的字面量，这样可以保证使用常量和直接用字面量的性能是一样的。 抽象类 public abstract class A { private String name; public static String schoolName; public abstract void run(); } public class B extends A{ @Override public void run() { System.out.println(\u0026#34;run\u0026#34;); } } 抽象类的好处：\n父类知道每个子类都要做某个行为，但每个子类要做的情况不一样，父类就定义成抽象方法，交给子类去重写实现，我们设计这样的抽象类，就是为了更好的支持多态。 抽象类可以制作模板类\n模板类 public abstract class People { public abstract String write(); public final void WriteOn(){ System.out.println(\u0026#34;\\t\\t今天是2023/04/14\u0026#34;); System.out.println(\u0026#34;\\t身份:\u0026#34;); System.out.println(write()); System.out.println(\u0026#34;以上就是我发表的内容\u0026#34;); System.out.println(\u0026#34;\\t\\t感谢大家！\u0026#34;); } } public class Teacher extends People { @Override public String write() { //只用重写每个类中需要不同实现的方法即可 return \u0026#34;我是老师，这里是老师类\u0026#34;; } } public class Student extends People { @Override public String write() { return \u0026#34;我是学生，这里是学生类\u0026#34;; } } public class Test { public static void main(String[] args) { Teacher t = new Teacher(); t.WriteOn(); Student s = new Student(); s.WriteOn(); } } 建议使用final关键字修饰模板类\n模板方法是给对象直接使用的不能被修改 一旦子类重写了模板方法，模板方法就失效了 接口 Java提供了一个关键字interface public class Test { public static void main(String[] args) { Driver d = new A(); d.drive(); } } class A extends Student implements Driver, Singer{ @Override public void drive() { } @Override public void sing() { } } class Student{ } interface Driver{ void drive(); } interface Singer{ void sing(); } 接口的好处：\n可以解决类单继承的问题，通过接口， 可以让一个类有一个继承父类的同时，还可以去找多个接口去拓展自己的功能 因为通过接口可以显性的知道你是谁 一个类可以实现多个接口，同样，一个接口也可以被多个类实现，这样的好处是我们的程序可以面向接口编程了，这样程序员就可以很方便的灵活切换各种业务实现了。 接口的综合案例:\n使用接口(StudentOperator)之后，在不同的继承接口的类(StudentOperatorImpl1, StudentOperatorImpl2)里面编写不同的程序，用接口对象实现操作时，仅需要改变不同的实现类即可。\n接口的其他方法 public class Student { private String name; private char sex; private int score; public Student() { } } public interface StudentOperator { void printInfo(ArrayList\u0026lt;Student\u0026gt; students); void printAverageScore(ArrayList\u0026lt;Student\u0026gt; students); } public class StudentOperatorImpl1 implements StudentOperator{ @Override public void printInfo(ArrayList\u0026lt;Student\u0026gt; students) { System.out.println(\u0026#34;==全班全部信息如下==\u0026#34;); for (int i = 0; i \u0026lt; students.size(); i++) { Student s = students.get(i); System.out.println(\u0026#34;姓名为 ： \u0026#34; + s.getName() + \u0026#34;, 性别为 ： \u0026#34; + s.getSex() + \u0026#34;, 得分为 ： \u0026#34; + s.getScore()); } System.out.println(\u0026#34;-------------------\u0026#34;); } @Override public void printAverageScore(ArrayList\u0026lt;Student\u0026gt; students) { double total = 0; for (int i = 0; i \u0026lt; students.size(); i++) { Student s = students.get(i); total += s.getScore(); } System.out.println(\u0026#34;班级平均分为 ： \u0026#34; + (total/(students.size()))); } } public class StudentOperatorImpl2 implements StudentOperator{ @Override public void printInfo(ArrayList\u0026lt;Student\u0026gt; students) { System.out.println(\u0026#34;==全班全部信息如下==\u0026#34;); int count1 = 0; for (int i = 0; i \u0026lt; students.size(); i++) { Student s = students.get(i); System.out.println(\u0026#34;姓名为 ： \u0026#34; + s.getName() + \u0026#34;, 性别为 ： \u0026#34; + s.getSex() + \u0026#34;, 得分为 ： \u0026#34; + s.getScore()); if(s.getSex()==\u0026#39;男\u0026#39;){ count1+=1; } } System.out.println(\u0026#34;男生人数为 ： \u0026#34; + count1 + \u0026#34;, 女生人数为 ： \u0026#34; + (students.size()-count1)); System.out.println(\u0026#34;班级总人数为 : \u0026#34; + (students.size())); System.out.println(\u0026#34;-------------------\u0026#34;); } @Override public void printAverageScore(ArrayList\u0026lt;Student\u0026gt; students) { double total = 0; double max = students.get(0).getScore(); double min = students.get(0).getScore(); for (int i = 0; i \u0026lt; students.size(); i++) { Student s = students.get(i); total += s.getScore(); if(s.getScore()\u0026gt;max){ max = s.getScore(); } else if(s.getScore()\u0026lt;min){ min = s.getScore(); } } System.out.println(\u0026#34;学生的最高分为 ： \u0026#34; + max + \u0026#34;, 学生的最低分为\u0026#34; + min); System.out.println(\u0026#34;去除最低分和最高分后，班级平均分为 ： \u0026#34; + (total/(students.size()))); } } public class ClassManagement { private ArrayList\u0026lt;Student\u0026gt; students = new ArrayList\u0026lt;\u0026gt;(); StudentOperator so = new StudentOperatorImpl2(); public ClassManagement() { students.add(new Student(\u0026#34;小明\u0026#34;, \u0026#39;男\u0026#39;, 99)); students.add(new Student(\u0026#34;小黄\u0026#34;, \u0026#39;女\u0026#39;, 100)); students.add(new Student(\u0026#34;小白\u0026#34;, \u0026#39;男\u0026#39;, 94)); students.add(new Student(\u0026#34;小亮\u0026#34;, \u0026#39;女\u0026#39;, 90)); } public void printInfo(){ so.printInfo(students); } public void printScore(){ so.printAverageScore(students); } } public class Test { public static void main(String[] args) { ClassManagement cm = new ClassManagement(); cm.printInfo(); cm.printScore(); } } 接口的其他方法：\n/** 1. 默认方法：必须使用 default 修饰，默认会被 public 修饰 * */ default void test1(){ System.out.println(\u0026#34;===默认方法===\u0026#34;); test2(); } /** 2. 私有方法：必须使用 private 修饰，（JDK9开始支持） * 实例方法对象的方法 */ private void test2(){ System.out.println(\u0026#34;===私有方法===\u0026#34;); } /** * 3. 静态方法，必须使用 static 修饰，默认会被 public 修饰 */ public static void test3(){ System.out.println(\u0026#34;===静态方法===\u0026#34;); } 接口的多继承 一个接口可以同时继承多个接口\n一个接口继承多个接口，如果多个接口中存在方法名冲突，则此时不支持多继承\ninterface I{ void test1(); } interface J{ void test1(); } interface C implements I, J{ //报错 } 一个类实现多个接口，如果多个接口存在方法名冲突，则此时不支持多实现\ninterface I{ void test1(); } interface J{ void test1(); } class C implements I, J{ //报错 } 一个类继承了父类，又实现了接口，父类中和接口中有同名的默认方法，实现类会优先使用父类的\nclass Fu{ public void run(){ System.out.println(\u0026#34;===父类的run方法执行了\u0026#34;); } } interface IT{ default void run(){ System.out.println(\u0026#34;===接口IT中的run方法执行了\u0026#34;); } } class Zi extends Fu implements IT{ } public class Demo2 { public static void main(String[] args) { Zi zi = new Zi(); zi.run(); //===父类的run方法执行了 } } 一个类实现多个接口，多个接口中存在同名的默认方法，可以不冲突， 这个类重写该方法即可\ninterface I{ void test1(); } interface J{ void test1(); } //interface C implements I, J{ //报错 // //} class C implements I, J{ @Override public void test1() { } //重写后不会报错 } 内部类 成员内部类 public class Outer { private String outerName; private int age=88; public static int outerNumber; public class Inner{ private String name; public static int number; // JDK16才开始支持 private int age=99; public void test(){ } public void test2(){ System.out.println(outerName); System.out.println(outerNumber); int age = 66; System.out.println(age); System.out.println(this.age); System.out.println(Outer.this.age); } public Inner() { System.out.println(\u0026#34;Inner has been created.\u0026#34;); } public String getName() { return name; } public void setName(String name) { this.name = name; } public static int getNumber() { return number; } public static void setNumber(int number) { Inner.number = number; } } } public static void main(String[] args) { Outer.Inner in = new Outer().new Inner(); in.test2(); /** * Inner has been created. * null * 0 * 66 * 99 * 88 */ } 静态内部类 可以直接访问外部类的静态变量，而不能访问外部类的实例变量\npublic class StaticInner { private String name; // 实例变量，只能由外部对象来访问 public static int age; // 静态变量，可以由类名直接访问 // 静态内部类 public static class Inner { // 在静态内部类中访问外部类的静态变量是合法的 public void test() { System.out.println(age); // 无法在静态内部类中直接访问外部类的实例变量，会导致编译错误 //System.out.println(name); } } } 局部内部类：定义在方法，代码块，构造器中。\n匿名内部类 创建一个类的实例的一种方式，同时定义并实现该类。\npublic class Demo1 { public static void main(String[] args) { Animal cat = new Animal(){ //cat类可以不用单另新创建，实现的同时定义该类即可 @Override public void cry() { System.out.println(\u0026#34;猫喵喵喵的叫~~\u0026#34;); } }; cat.cry(); } } // 用抽象方法实现匿名内部类 abstract class Animal{ public abstract void cry(); } public class Demo2 { public static void main(String[] args) { go(new Swimming() { @Override public void swim() { System.out.println(\u0026#34;狗游的很快！\u0026#34;); } }); } public static void go(Swimming s){ System.out.println(\u0026#34;===GO====\u0026#34;); s.swim(); } } // 用接口实现匿名内部类 interface Swimming{ void swim(); } public class Demo3 { public static void main(String[] args) { JFrame win = new JFrame(\u0026#34;登录界面\u0026#34;); JPanel panel = new JPanel(); win.add(panel); JButton btn = new JButton(\u0026#34;登录\u0026#34;); panel.add(btn); //匿名内部类的实际使用场景 btn.addActionListener(new ActionListener() { @Override public void actionPerformed(ActionEvent e) { JOptionPane.showConfirmDialog(win, \u0026#34;你点击了登录按钮\u0026#34;); } }); win.setSize(400, 800); win.setLocationRelativeTo(null); win.setDefaultCloseOperation(WindowConstants.EXIT_ON_CLOSE); win.setVisible(true); } } 枚举 枚举是一种特殊的类\n枚举类的第一行，只能写一些合法的标识符（名称）， 多个名称用逗号隔开 这些名称，本质是常量，每个常量都会记住枚举类的一个对象 public enum A { X, Y, Z; private String name; public String getName() { return name; } public void setName(String name) { this.name = name; } } public class Test { public static void main(String[] args) { A a1 = A.X; System.out.println(a1); //X A a2 = A.Y; A[] as = A.values(); System.out.println(as); //[Lcom.showguan.Enum.A;@3b07d329 A a3 = A.valueOf(\u0026#34;Z\u0026#34;); System.out.println(a3); //Z System.out.println(a3.ordinal()); //2 次序 } } 枚举类的特点：\n枚举类的第一行只能罗列一些名称，这些名称都是常量，并且每个常量记住的都是枚举类的一个对象 枚举都是最终类，不可以被继承 枚举类中，从第二行开始，可以定义类的其他各种成员 编译器为枚举类新增了几个方法，并且枚举类都是继承 ：java.lang.Enum类的，从enum类也会继承到一些方法 枚举的实际作用：\npublic enum Constant2 { BOY, GIRL; } public static void check(Constant2 sex) { switch (sex) { case BOY: System.out.println(\u0026#34;你是个男孩！\u0026#34;); break; case GIRL: System.out.println(\u0026#34;你是个女孩！\u0026#34;); break; } } public static void main(String[] args) { check(Constant2.BOY); } 泛型 定义类，接口，方法时，同时声明一个或者多个类型变量（如\u0026lt;E\u0026gt;)，成为泛型类，泛型接口，泛型方法，它们统称为泛型。 public class Test { public static void main(String[] args) { ArrayList list = new ArrayList(); list.add(\u0026#34;Java1\u0026#34;); list.add(\u0026#34;Java2\u0026#34;); list.add(\u0026#34;Java3\u0026#34;); list.add(new Cat()); for (int i = 0; i \u0026lt; list.size(); i++) { // Object o = list.get(i); // String s = (String) list.get(i); //报错 Cat()对象时Object类型，不能转换成String类型 // System.out.println(s); } ArrayList\u0026lt;String\u0026gt; list2 = new ArrayList(); //泛型为String list2.add(\u0026#34;Java1\u0026#34;); list2.add(\u0026#34;Java2\u0026#34;); list2.add(\u0026#34;Java3\u0026#34;); // list2.add(new Cat()); //在编译阶段就限制添加对象的类型 ArrayList\u0026lt;Cat\u0026gt; list3 = new ArrayList(); //泛型为Cat() } } 拓展:\npublic class MyArrayList\u0026lt;E, T\u0026gt; //可以多个类型 public class MyArrayList\u0026lt;E, T extends Animal\u0026gt; //指定类型需要继承某个类 泛型接口 public interface Data\u0026lt;E\u0026gt;{ void get(E e); ArrayList\u0026lt;E\u0026gt; getName(String name); } public class TeacherData implements Data\u0026lt;Teacher\u0026gt;{ //指定泛型类型后，重写的方法都会自动换成该类型 @Override public void get(Teacher teacher) { } @Override public ArrayList\u0026lt;Teacher\u0026gt; getName(String name) { return null; } } 使用通配符 ?\npublic static void main(String[] args) { System.out.println(test(\u0026#34;Java\u0026#34;)); Dog d = test(new Dog()); ArrayList\u0026lt;Car\u0026gt; cars = new ArrayList\u0026lt;\u0026gt;(); cars.add(new Car()); cars.add(new Car()); cars.add(new Car()); go(cars); ArrayList\u0026lt;BMW\u0026gt; bmws = new ArrayList\u0026lt;\u0026gt;(); bmws.add(new BMW()); bmws.add(new BMW()); bmws.add(new BMW()); bmws.add(new BMW()); go(bmws); ArrayList\u0026lt;BENZ\u0026gt; benzs = new ArrayList\u0026lt;\u0026gt;(); benzs.add(new BENZ()); benzs.add(new BENZ()); benzs.add(new BENZ()); go(benzs); } public static \u0026lt;T\u0026gt; T test(T t){ return t; } public static void go(ArrayList\u0026lt;? extends Car\u0026gt; cars){ } } API toString()方法和equals() @Override public String toString() { return \u0026#34;Student{\u0026#34; + \u0026#34;name=\u0026#39;\u0026#34; + name + \u0026#39;\\\u0026#39;\u0026#39; + \u0026#34;, age=\u0026#34; + age + \u0026#39;}\u0026#39;; } @Override public boolean equals(Object o) { if (this == o) return true; if (o == null || getClass() != o.getClass()) return false; Student student = (Student) o; return age == student.age \u0026amp;\u0026amp; Objects.equals(name, student.name); } clone() public static void main(String[] args) throws CloneNotSupportedException { Student s1 = new Student(\u0026#34;Kennem\u0026#34;, 21, new double[]{0.0}); System.out.println(s1.toString()); System.out.println(s1.getName()); System.out.println(s1.getAge()); System.out.println(s1); System.out.println(s1.getClass()); System.out.println(s1.getScores()); /** * Student{name=\u0026#39;Kennem\u0026#39;, age=21} * Kennem * 21 * Student{name=\u0026#39;Kennem\u0026#39;, age=21} * class com.showguan.APIObject.Student * [D@27d6c5e0 */ Student s2 = new Student(\u0026#34;Kennem\u0026#34;, 21, new double[]{0.0}); System.out.println(s1.equals(s2)); //true Student s3 = (Student) s1.clone(); System.out.println(s3.getName()); System.out.println(s3.getAge()); System.out.println(s3); System.out.println(s3.getClass()); System.out.println(s3.getScores()); /** * Kennem * 21 * Student{name=\u0026#39;Kennem\u0026#39;, age=21} * class com.showguan.APIObject.Student * [D@4f3f5b24 */ } @Override protected Object clone() throws CloneNotSupportedException { Student tmp = (Student) super.clone(); tmp.scores = tmp.scores.clone(); return tmp; } Objects.\npublic static void main(String[] args) { String s1 = \u0026#34;Java\u0026#34;; String s2 = null; System.out.println(s1.equals(s2)); // System.out.println(s2.equals(s1)); //空指针异常 System.out.println(Objects.equals(s1, s2)); //防止空指针异常 System.out.println(Objects.isNull(s1)); //false System.out.println(Objects.nonNull(s1)); //true System.out.println(Objects.isNull(s2)); //true System.out.println(Objects.nonNull(s2)); //false } 包装类 public static void main(String[] args) { Integer a = Integer.valueOf(12); Integer b = 12; int c = b; ArrayList\u0026lt;Integer\u0026gt; arr = new ArrayList\u0026lt;\u0026gt;(); arr.add(12); arr.add(10); arr.get(1); Integer d = 25; String s1 = Integer.toString(d); System.out.println(s1); String s2 = d.toString(); String s3 = d + \u0026#34;\u0026#34;; System.out.println(s2); System.out.println(s3); String s4 = \u0026#34;29\u0026#34;; // int age = Integer.parseInt(s4); int age = Integer.valueOf(s4); System.out.println(age); String s5 = \u0026#34;99.9\u0026#34;; // double score = Double.parseDouble(s5); double score = Double.valueOf(s5); System.out.println(score+0.1); } StringBuilder 适合多次拼接，修改\npublic static void main(String[] args) { StringBuilder s = new StringBuilder(); s.append(\u0026#34;Java\u0026#34;); s.append(\u0026#34;666\u0026#34;).append(\u0026#34;888\u0026#34;).append(\u0026#34;999\u0026#34;); System.out.println(s); s.reverse(); System.out.println(s); System.out.println(s.length()); String ss = s.toString(); System.out.println(ss); /** * Java666888999 * 999888666avaJ * 13 * 999888666avaJ */ } StringBuffer方法和StringBuilder类似，但是是线程安全的，而StringBuilder是线程不安全的\nStringJoiner StringJoiner sj = new StringJoiner(\u0026#34;,\u0026#34;, \u0026#34;[\u0026#34;, \u0026#34;]\u0026#34;); sj.add(\u0026#34;1\u0026#34;); sj.add(\u0026#34;2\u0026#34;); sj.add(\u0026#34;3\u0026#34;); sj.add(\u0026#34;4\u0026#34;); System.out.println(sj); System public class Main { public static void main(String[] args) { // 主函数入口 // 以下代码块被注释掉，使用 System.exit(0) 可以立即终止程序的执行 // System.exit(0); // 打印分隔线 System.out.println(\u0026#34;----------------\u0026#34;); // 以下代码块被注释掉，用于打印当前时间的毫秒表示 // System.out.println(System.currentTimeMillis()); // 记录程序开始时间 long t1 = System.currentTimeMillis(); // 初始化一个空字符串 String s = \u0026#34;\u0026#34;; // 循环将字符串\u0026#34;abc\u0026#34;追加到字符串s中，重复200000次 for (int i = 0; i \u0026lt; 200000; i++) { s += \u0026#34;abc\u0026#34;; } // 记录程序结束时间 long t2 = System.currentTimeMillis(); // 计算程序执行时间并将结果以秒为单位打印出来 System.out.println((t2 - t1) / 1000.0 + \u0026#34;s\u0026#34;); //4.656s } } BigDecimal public class Main { public static void main(String[] args) { // 主函数入口 // 使用双精度浮点数进行运算 double a = 0.1; double b = 0.2; double c = a + b; // 直接相加 System.out.println(c); // 输出结果 // 使用 BigDecimal 类进行精确运算 BigDecimal a1 = BigDecimal.valueOf(a); // 将双精度浮点数转换为 BigDecimal 类型 BigDecimal b1 = BigDecimal.valueOf(b); // 使用 BigDecimal 的 multiply 方法进行乘法运算 BigDecimal c1 = a1.multiply(b1); System.out.println(c1); // 输出结果 // 使用 BigDecimal 的 add 方法进行加法运算 BigDecimal c2 = a1.add(b1); System.out.println(c2); // 输出结果 // 使用 BigDecimal 的 subtract 方法进行减法运算 BigDecimal c3 = a1.subtract(b1); System.out.println(c3); // 输出结果 // 使用 BigDecimal 的 divide 方法进行除法运算 BigDecimal c4 = a1.divide(b1); System.out.println(c4); // 输出结果 // 使用 BigDecimal 进行除法运算，并设置精确度和舍入模式 BigDecimal i = BigDecimal.valueOf(0.1); BigDecimal j = BigDecimal.valueOf(0.3); BigDecimal k = i.divide(j, 2, RoundingMode.HALF_UP); // 设置精确度为2位小数，采用四舍五入模式 System.out.println(k); // 输出结果，0.33 } } Date parse方法和format方法\nimport java.text.ParseException; import java.text.SimpleDateFormat; import java.util.Date; public class DateFormatExample { public static void main(String[] args) { // 创建一个日期对象 Date d = new Date(); // 定义日期格式 SimpleDateFormat sdf = new SimpleDateFormat(\u0026#34;yyyy年MM月dd日 HH:mm:ss EEE a\u0026#34;); // 格式化当前日期并输出 String rs = sdf.format(d); System.out.println(\u0026#34;当前日期格式化输出: \u0026#34; + rs); // 再次格式化当前日期并输出（可以省略此步骤，仅为展示） String rs2 = sdf.format(d); System.out.println(\u0026#34;再次格式化当前日期: \u0026#34; + rs2); // 将字符串解析为日期对象 String dateStr = \u0026#34;2022-12-12 12:12:11\u0026#34;; SimpleDateFormat sdf2 = new SimpleDateFormat(\u0026#34;yyyy-MM-dd HH:mm:ss\u0026#34;); try { Date d2 = sdf2.parse(dateStr); System.out.println(\u0026#34;解析后的日期: \u0026#34; + d2); } catch (ParseException e) { e.printStackTrace(); } } } public static void main(String[] args) throws ParseException { String start = \u0026#34;2024年12月12日 00:00:00\u0026#34;; String end = \u0026#34;2024年12月12日 00:10:00\u0026#34;; String xj = \u0026#34;2024年12月12日 00:01:18\u0026#34;; String xp = \u0026#34;2024年12月12日 00:10:57\u0026#34;; SimpleDateFormat sdf = new SimpleDateFormat(\u0026#34;yyyy年MM月dd日 HH:mm:ss\u0026#34;); Date startDt = sdf.parse(start); Date endDt = sdf.parse(end); Date xjDt = sdf.parse(xj); Date xpDt = sdf.parse(xp); long startTime = startDt.getTime(); long endTime = endDt.getTime(); long xjTime = xjDt.getTime(); long xpTime = xpDt.getTime(); if(xjTime\u0026gt;=startTime \u0026amp;\u0026amp; xjTime\u0026lt;=endTime){ System.out.println(\u0026#34;小贾你秒杀成功了\u0026#34;); }else{ System.out.println(\u0026#34;小贾你秒杀失败了\u0026#34;); } if(xpTime\u0026gt;=startTime \u0026amp;\u0026amp; xpTime\u0026lt;=endTime){ System.out.println(\u0026#34;小皮你秒杀成功了\u0026#34;); }else{ System.out.println(\u0026#34;小皮你秒杀失败了\u0026#34;); } } Calendar public class Main { public static void main(String[] args) { // 获取当前日期和时间的 Calendar 对象 Calendar now = Calendar.getInstance(); System.out.println(\u0026#34;当前日期和时间：\u0026#34; + now); // 获取当前年份 int year = now.get(Calendar.YEAR); System.out.println(\u0026#34;当前年份：\u0026#34; + year); // 获取一年中的第几天 int days = now.get(Calendar.DAY_OF_YEAR); System.out.println(\u0026#34;一年中的第几天：\u0026#34; + days); // 获取Date对象 Date d = now.getTime(); System.out.println(\u0026#34;Date对象：\u0026#34; + d); // 获取时间戳 long time = now.getTimeInMillis(); System.out.println(\u0026#34;时间戳：\u0026#34; + time); // 设置月份为4月，日期为4月1日 now.set(Calendar.MONTH, Calendar.APRIL); now.set(Calendar.DAY_OF_MONTH, 1); System.out.println(\u0026#34;设置后的日期：\u0026#34; + now.getTime()); // 获取设置后的日期 Date d1 = now.getTime(); System.out.println(\u0026#34;设置后的Date对象：\u0026#34; + d1); // 增加105天 now.add(Calendar.DAY_OF_YEAR, 105); Date d2 = now.getTime(); System.out.println(\u0026#34;增加105天后的日期：\u0026#34; + d2); } } JDK之后新增的时间\n设计更合理，功能丰富，使用更方便 都是不可变对象，修改后会返回新的实践对象，不会丢失最开始的时间 线程安全 能精确到毫秒、纳秒 LocalDate， LocalTime, LocalDateTime LocalDate public static void main(String[] args) { // 获取当前日期 LocalDate ld = LocalDate.now(); System.out.println(ld); // 获取日期的年、月、日、年中的第几天、星期几等信息 int year = ld.getYear(); int month = ld.getMonthValue(); int day = ld.getDayOfMonth(); int dayOfYear = ld.getDayOfYear(); int dayOfWeek = ld.getDayOfWeek().getValue(); System.out.println(year); System.out.println(month); System.out.println(day); System.out.println(dayOfYear); System.out.println(dayOfWeek); // 使用 with 方法设置日期的年、月 LocalDate ld2 = ld.withYear(2077); LocalDate ld3 = ld.withMonth(11); System.out.println(ld2); System.out.println(ld3); // 使用 plus 方法增加日期的天数、月数 LocalDate ld4 = ld.plusDays(2); LocalDate ld5 = ld.plusMonths(3); // 使用 minus 方法减少日期的天数、月数 LocalDate ld6 = ld.minusDays(10); LocalDate ld7 = ld.minusMonths(2); // 使用 of 方法创建指定日期的 LocalDate 对象 LocalDate ld8 = LocalDate.of(2077, 12, 12); // 使用 equals、isAfter、isBefore 方法比较日期 System.out.println(ld5.equals(ld6)); System.out.println(ld5.isAfter(ld6)); System.out.println(ld5.isBefore(ld6)); } LocalTime public static void main(String[] args) { // 0、获取本地时间对象 LocalTime lt = LocalTime.now(); // 获取当前时间 System.out.println(lt); // 1、获取时间中的信息 int hour = lt.getHour(); // 获取小时 int minute = lt.getMinute(); // 获取分钟 int second = lt.getSecond(); // 获取秒 int nano = lt.getNano(); // 获取纳秒 // 2、修改时间：withHour、withMinute、withSecond、withNano LocalTime lt3 = lt.withHour(10); // 设置小时为10 LocalTime lt4 = lt.withMinute(10); // 设置分钟为10 LocalTime lt5 = lt.withSecond(10); // 设置秒为10 LocalTime lt6 = lt.withNano(10); // 设置纳秒为10 // 3、加多少：plusHours、plusMinutes、plusSeconds、plusNanos LocalTime lt7 = lt.plusHours(10); // 增加10小时 LocalTime lt8 = lt.plusMinutes(10); // 增加10分钟 LocalTime lt9 = lt.plusSeconds(10); // 增加10秒 LocalTime lt10 = lt.plusNanos(10); // 增加10纳秒 // 4、减多少：minusHours、minusMinutes、minusSeconds、minusNanos LocalTime lt11 = lt.minusHours(10); // 减少10小时 LocalTime lt12 = lt.minusMinutes(10); // 减少10分钟 LocalTime lt13 = lt.minusSeconds(10); // 减少10秒 LocalTime lt14 = lt.minusNanos(10); // 减少10纳秒 // 5、获取指定时间的LocalTime对象： // public static LocalTime of(int hour, int minute, int second) LocalTime lt15 = LocalTime.of(12, 12, 12); // 创建指定时间的LocalTime对象 LocalTime lt16 = LocalTime.of(12, 12, 12); // 创建指定时间的LocalTime对象 // 6、判断2个时间对象，是否相等，在前还是在后： equals isBefore isAfter System.out.println(lt15.equals(lt16)); // 判断两个时间是否相等 System.out.println(lt15.isAfter(lt)); // 判断lt15是否在lt之后 System.out.println(lt15.isBefore(lt)); // 判断lt15是否在lt之前 } LocalDateTime public static void main(String[] args) { // 获取当前日期和时间 LocalDateTime ldt = LocalDateTime.now(); System.out.println(\u0026#34;当前日期和时间：\u0026#34; + ldt); // 获取日期和时间中的信息 int year = ldt.getYear(); // 年份 int month = ldt.getMonthValue(); // 月份 int day = ldt.getDayOfMonth(); // 日 int hour = ldt.getHour(); // 小时 int minute = ldt.getMinute(); // 分钟 int second = ldt.getSecond(); // 秒 int nano = ldt.getNano(); // 纳秒 System.out.println(\u0026#34;年份：\u0026#34; + year); System.out.println(\u0026#34;月份：\u0026#34; + month); System.out.println(\u0026#34;日：\u0026#34; + day); System.out.println(\u0026#34;小时：\u0026#34; + hour); System.out.println(\u0026#34;分钟：\u0026#34; + minute); System.out.println(\u0026#34;秒：\u0026#34; + second); System.out.println(\u0026#34;纳秒：\u0026#34; + nano); // 设置日期和时间 LocalDateTime ldt2 = ldt.withYear(2025) .withMonth(6) .withDayOfMonth(15) .withHour(18) .withMinute(30) .withSecond(0) .withNano(0); System.out.println(\u0026#34;修改后的日期和时间：\u0026#34; + ldt2); // 增加和减少日期和时间 LocalDateTime ldt3 = ldt.plusDays(10) .plusHours(2) .minusMinutes(15); System.out.println(\u0026#34;增加和减少后的日期和时间：\u0026#34; + ldt3); // 创建指定日期和时间的 LocalDateTime 对象 LocalDateTime ldt4 = LocalDateTime.of(2030, 12, 31, 23, 59, 59); System.out.println(\u0026#34;指定日期和时间：\u0026#34; + ldt4); // 判断两个 LocalDateTime 对象的关系 System.out.println(\u0026#34;当前日期和时间是否在指定日期和时间之后：\u0026#34; + ldt.isAfter(ldt4)); System.out.println(\u0026#34;当前日期和时间是否在指定日期和时间之前：\u0026#34; + ldt.isBefore(ldt4)); } Arrays 对于自定义对象的排序：\n@Override public int compareTo(Student o) { // if(this.age \u0026gt; o.age){ //左边大，正整数 // return 1; // } // else if(this.age \u0026lt; o.age){ //右边大， 负整数 // return -1; // } // return 0; //相等 0 return o.age-this.age; } @Override public String toString() { return \u0026#34;Student{\u0026#34; + \u0026#34;name=\u0026#39;\u0026#34; + name + \u0026#39;\\\u0026#39;\u0026#39; + \u0026#34;, height=\u0026#34; + height + \u0026#34;, age=\u0026#34; + age + \u0026#39;}\u0026#39;; } Student[] students = new Student[4]; students[0] = new Student(\u0026#34;Kenn\u0026#34;, 180, 21); students[1] = new Student(\u0026#34;ken\u0026#34;, 181, 22); students[2] = new Student(\u0026#34;ken\u0026#34;, 189, 22); students[3] = new Student(\u0026#34;k\u0026#34;, 168, 20); Arrays.sort(students); System.out.println(Arrays.toString(students)); Arrays.sort(students, new Comparator\u0026lt;Student\u0026gt;() { @Override public int compare(Student o1, Student o2) { return Integer.compare(o1.getAge(), o2.getAge()); } }); Lambda表达式 Lambda表达式只能简化函数式接口的匿名内部类！\n函数式接口：\n有且仅有一个抽象方法的接口 注意：将来见到的大部分函数式接口，上面都可能会有一个@FunctionalInterface的注解，有该注解的接口必定是函数式接口 // Arrays.sort(students, new Comparator\u0026lt;Student\u0026gt;() { // @Override // public int compare(Student o1, Student o2) { // return Integer.compare(o1.getAge(), o2.getAge()); // } // }); // Arrays.sort(students, (Student o1, Student o2) -\u0026gt;{ // return Double.compare(o1.getHeight(), o2.getHeight()); // }); Arrays.sort(students, (o1, o2) -\u0026gt; { return Double.compare(o1.getHeight(), o2.getHeight()); }); Arrays.sort(students, (o1, o2) -\u0026gt; Double.compare(o1.getHeight(), o2.getHeight())); // Arrays.setAll(prices, new IntToDoubleFunction() { // @Override // public double applyAsDouble(int value) { // return prices[value]*0.8; // } // }); // Arrays.setAll(prices, (int value) -\u0026gt; { // return prices[value]*0.8; // }); // Arrays.setAll(prices, value -\u0026gt; { // return prices[value]*0.8; // }); Arrays.setAll(prices, value -\u0026gt; prices[value]*0.8); 方法引用 方法引用是Java 8引入的一种简洁语法，允许我们使用现有的方法定义来创建Lambda表达式。这种方式使得代码更简洁、易读。方法引用可以看作是Lambda表达式的简化形式，主要用于增强代码的可读性和可维护性。\n静态方法的引用 静态方法引用用于引用类的静态方法。在这个例子中，我们引用了CompareByAge类的静态方法comparByAge。\n// CompareByAge.java public class CompareByAge { public static int comparByAge(Student o1, Student o2) { return o1.getAge() - o2.getAge(); } } // Test.java Student[] students = ... // 假设已经初始化的学生数组 // 使用Lambda表达式排序 Arrays.sort(students, (o1, o2) -\u0026gt; CompareByAge.comparByAge(o1, o2)); // 使用方法引用排序，与上面的作用相同 Arrays.sort(students, CompareByAge::comparByAge); 说明：通过使用CompareByAge::comparByAge方法引用，我们可以简化Lambda表达式。\n实例方法引用 实例方法引用用于引用某个特定对象的实例方法。在这个例子中，我们引用了CompareByHeight类的实例方法comparebyHeight。\npublic class CompareByHeight { public int comparebyHeight(Student o1, Student o2) { return (int) (o2.getHeight() - o1.getHeight()); } } // Test.java CompareByHeight cmpH = new CompareByHeight(); Student[] students = ... // 假设已经初始化的学生数组 // 使用Lambda表达式排序 Arrays.sort(students, (o1, o2) -\u0026gt; cmpH.comparebyHeight(o1, o2)); // 使用方法引用排序，与上面的作用相同 Arrays.sort(students, cmpH::comparebyHeight); 说明：通过使用cmpH::comparebyHeight方法引用，我们可以简化Lambda表达式。\n特定类型的方法引用 特定类型的方法引用用于引用某个特定类型的实例方法。在这个例子中，我们引用了String类的实例方法compareToIgnoreCase。\nString[] names = ... // 假设已经初始化的字符串数组 // 使用Lambda表达式排序 Arrays.sort(names, (o1, o2) -\u0026gt; o1.compareToIgnoreCase(o2)); // 使用方法引用排序，与上面的作用相同 Arrays.sort(names, String::compareToIgnoreCase); 说明：通过使用String::compareToIgnoreCase方法引用，我们可以简化Lambda表达式。\n构造器引用 构造器引用用于引用类的构造方法。在这个例子中，我们引用了Car类的构造方法。\npublic class Car { private String name; private double price; public Car(String name, double price) { this.name = name; this.price = price; } // 省略getter和setter方法 } @FunctionalInterface interface CreateCar { Car create(String name, double price); } // Test.java // 使用匿名内部类 CreateCar cc1 = new CreateCar() { @Override public Car create(String name, double price) { return new Car(name, price); } }; // 使用Lambda表达式 CreateCar cc2 = (name, price) -\u0026gt; new Car(name, price); // 使用构造器引用 CreateCar cc3 = Car::new; 说明：通过使用Car::new构造器引用，我们可以简化Lambda表达式。\n总结 方法引用和构造器引用使得代码更简洁易读。以下是四种常见的引用方式：\n静态方法引用：ClassName::staticMethodName 实例方法引用：instance::instanceMethodName 特定类型的方法引用：ClassName::instanceMethodName 构造器引用：ClassName::new 引用方式减少了样板代码，增强了代码的可读性和可维护性。\n综合案例 Hospital ","permalink":"https://kennems.github.io/zh/posts/tech/java20%E5%A4%A9%E9%80%9F%E6%88%90%E8%BF%9B%E9%98%B6%E8%AF%BE%E7%A8%8B1/","summary":"进阶课程(1) OOP static 静态， 可以修饰成员变量，成员方法 成员变量按照有无static修饰，分为两种 类变量 ： 有static修饰，属于类，在计算机里只","title":"Java20天速成——进阶课程(1)"},{"content":"JAVA 20天速成 有志者事竟成\n没有完完全全的投入，检测，学习是学不到东西的。\n自欺欺人，眼高手低是绝对没有任何作用的。\nJAVA背景信息 JAVA是一门高级编程语言。\n属于ORACLE公司\nJAVA之父——詹姆斯·高斯林\nJAVA主要做互联网系统的开发\n主要技术平台：JAVASE， JAVAEE， JAVAME\nJDK的发展史 Java Development Kit 开发者工具包\n当前使用更多的是JDK-8，JDK-11\n教学只用JDK-17\n技术类网站 ： 安装路径下不要包含中文和空格\n所有的开发工具最好安装到统一目录\n电脑内JAVA安装路径：\nF:\\Java\\jdk17 C:\\Program Files\\Java\\jdk1.8.0_311\njavac.exe : 编译工具 java.exe : 执行工具\n常用命令\ncls： 清屏 退回到盘符根目录 ： cd\\ 先切换盘符在切换目录 Java 程序要经历的步骤：\n编写、编译（javac), 运行(java) Java代码编写有什么基本要求？\n文件名称和后缀必须是java结尾 文件名称必须与代码的类名称一致 必须使用英文模式下的符号 javac .\\HelloWorld.java\rjava HelloWorld public class Main{ public static void main(String[] args){ System.out.println(\u0026#34;Hello World!\u0026#34;); } } JDK11开始支持java直接运行源代码文件\nJDK 组成 JRE（Java Runtime Environment）：Java的运行环境\nJVM（Java Vitual Machine）：Java虚拟机， 真正运行java程序的地方。\n核心类库：Java自己写好的程序，给程序员调用的\n开发工具：java, javac\nJDK（Java Development Kit）：Java开发工具包（包括上面所有）。\nJava的跨平台、工作原理\n一次编译，处处可用 Path环境变量：用于记住程序路径，方便在命令行窗口的任意目录启动程序\nIDEA管理JAVA程序的结构\nproject（项目，工程） module（模块） package（包） class（类） IDEA快捷键\nmain/psvm sout\nctrl + D 复制当前行到下一行\nctrl + Y 删除所在行，建议用ctrl + x\nctrl + alt + L 格式化代码\nALT + SHIFT + ⬆ | ⬇ 上下移动当前代码\nctrl + /, ctrl + shift + / 对代码进行注释\nIDEA常用操作：\n删除类文件 修改类名称 修改模块 导入模块 方法1：\n注：生成imi文件\nmvn idea:module 方法2：\n复制代码到project目录， 之后再导入， 否则只是相关导入，修改module内容会修改源代码\n删除模块 打开工程 关闭工程 JAVA基础语法 1、注释 // 单行注释 /* 多行注释 */ /** 文档注释 * 目标： */ 2、变量 变量就是内存中的一块区域。\n// 二进制表示，前缀 0b 表示二进制 int a1 = 0b01100001; System.out.println(a1); // 输出：97 // 十进制表示 int a2 = 97; System.out.println(a2); // 输出：97 // 八进制表示，前缀 0 表示八进制 int a3 = 0141; System.out.println(a3); // 输出：97 // 十六进制表示，前缀 0x 表示十六进制 int a4 = 0xFA; System.out.println(a4); // 输出：250 // 声明并初始化不同类型的变量 byte a = 10; // byte类型，表示范围为 -128 到 127 short b = 8888; // short类型，表示范围为 -32768 到 32767 int c = 130; // int类型，表示范围为 -2147483648 到 2147483647 long d = 9393939393993L; // long类型，需要在结尾加上L或l，表示范围为 -9223372036854775808 到 9223372036854775807 // 输出不同类型的整数变量 System.out.println(a); // 输出：10 System.out.println(b); // 输出：130 System.out.println(c); // 输出：9393939393993 System.out.println(d); // 输出：8888 // 浮点数类型 float e = 2.17F; // float类型，需要在结尾加上F或f double f = 3.141592657; // double类型，默认为double，可以不加任何标识 // 输出浮点数变量 System.out.println(e); // 输出：2.17 System.out.println(f); // 输出：3.141592657 // 字符类型 char ch = \u0026#39;c\u0026#39;; // char类型，表示单个字符 System.out.println(ch); // 输出：c // 布尔类型 boolean flag = false; // boolean类型，表示true或false System.out.println(flag); // 输出：false // 字符串类型 String st = \u0026#34;string\u0026#34;; // String类型，表示字符串 System.out.println(st); // 输出：string 类型转换 byte a = 10; // 声明并初始化byte类型变量a int b = a; // 将byte类型的变量a赋值给int类型的变量b，发生拓宽转换 System.out.println(b); // 输出：10 int c = 100; // 声明并初始化int类型变量c double d = c; // 将int类型的变量c赋值给double类型的变量d，发生拓宽转换 System.out.println(d); // 输出：100.0 char e = \u0026#39;b\u0026#39;; // 声明并初始化char类型变量e int f = e; // 将char类型的变量e赋值给int类型的变量f，发生拓宽转换 System.out.println(f); // 输出：98（字符\u0026#39;b\u0026#39;对应的ASCII码值） byte a = 10; // 声明并初始化byte类型变量a short b = 20; // 声明并初始化short类型变量b int c = 30; // 声明并初始化int类型变量c long d = 40; // 声明并初始化long类型变量d // 对a、b、c、d进行加法运算，结果存储在long类型变量res1中 long res1 = a + b + c + d; System.out.println(res1); // 输出：100 // 对a、b进行加法运算，并将1.0（double类型）相加，结果存储在double类型变量res2中 double res2 = a + b + 1.0; System.out.println(res2); // 输出：31.0 // 对a、b进行加法运算，结果存储在int类型变量res3中 int res3 = a + b; System.out.println(res3); // 输出：30 byte a1 = 10; // 声明并初始化byte类型变量a1 byte a2 = 20; // 声明并初始化byte类型变量a2 // 对a1、a2进行加法运算，由于byte类型相加可能溢出，因此结果存储在int类型变量res4中 int res4 = a1 + a2; // 进行运算时a1和a2自动转换成int类型，然后相加 System.out.println(res4); // 输出：30 强制类型转换 int a = 1111111; char b = (char) a; // 快捷键， ALT+ENTER System.out.println(b); double c = 99.8; int d = (int) c; // 丢掉小数部分 System.out.println(d); 3、运算符 使用+符号做连接符的情况 int a = 10; // 声明并初始化整数变量a // 使用字符串连接符将字符串 \u0026#34;abc\u0026#34; 和整数变量a 连接起来并打印 System.out.println(\u0026#34;abc\u0026#34; + a); // 输出：\u0026#34;abc10\u0026#34; // 打印整数变量a 加 5 的结果 System.out.println(a + 5); // 输出：15 // 将字符串 \u0026#34;abc\u0026#34;、整数变量a 和字符 \u0026#39;a\u0026#39; 连接起来并打印 System.out.println(\u0026#34;abc\u0026#34; + a + \u0026#39;a\u0026#39;); // 输出：\u0026#34;abc10a\u0026#34; // 将字符 \u0026#39;a\u0026#39; 的ASCII码值（97）和整数变量a 相加，再将结果与字符串 \u0026#34;abc\u0026#34; 连接起来并打印 // 注：字符 \u0026#39;a\u0026#39; 的ASCII码值被当作整数参与运算，然后再将结果转换为字符 System.out.println(\u0026#39;a\u0026#39; + a + \u0026#34;abc\u0026#34;); // 输出：\u0026#34;107abc\u0026#34; // 初始化变量n和m分别为3和5 int n = 3, m = 5; // 计算res的值 // ++m: 先自增m，m变成6，然后返回6 // --m: 先自减m，m变成5，然后返回5 // m--: 先返回m的值5，然后再自减m，m变成4 // ++n: 先自增n，n变成4，然后返回4 // n--: 先返回n的值4，然后再自减n，n变成3 // 计算：6 - 5 + 5 - 4 + 4 + 3 = 9 int res = ++m - --m + m-- - ++n + n-- + 3; System.out.println(res); // 输出res的值 System.out.println(n); // 输出n的值，此时n为3 System.out.println(m); // 输出m的值，此时m为4 // 初始化变量c和d分别为10和5 int c = 10, d = 5; // 计算res2的值 // c++: 先返回c的值10，然后再自增c，c变成11 // ++c: 先自增c，c变成12，然后返回12 // --d: 先自减d，d变成4，然后返回4 // ++d: 先自增d，d变成5，然后返回5 // 计算：10 + 12 - 4 - 5 + 1 + c--，其中c此时为12，然后再自减c，c变成11 // 计算：10 + 12 - 4 - 5 + 1 + 12 = 26 int res2 = c++ + ++c - --d - ++d + 1 + c--; System.out.println(res2); // 输出res2的值 System.out.println(c); // 输出c的值，此时c为11 System.out.println(d); // 输出d的值，此时d为5 逻辑运算 // 定义变量 double size = 9.8; // size的值为9.8 double storage = 16; // storage的值为16 // 第一组条件判断 System.out.println(\u0026#34;original \u0026#34; + storage); // 使用按位与运算符\u0026#34;\u0026amp;\u0026#34;，即使第一个条件不满足，storage也会自增 boolean res11 = size \u0026lt; 8 \u0026amp; storage++ \u0026gt;= 16; // false System.out.println(res11); // 输出false System.out.println(storage); // 输出17.0，因为storage在条件判断之后自增了 // 使用逻辑与运算符\u0026#34;\u0026amp;\u0026amp;\u0026#34;，若第一个条件不满足，则不会执行第二个条件，storage不会自增 boolean res12 = size \u0026lt; 8 \u0026amp;\u0026amp; storage++ \u0026gt;= 16; // false System.out.println(res12); // 输出false System.out.println(storage); // 输出17.0，因为storage没有自增 // 第二组条件判断 System.out.println(\u0026#34;-------------------\u0026#34;); System.out.println(\u0026#34;original \u0026#34; + storage); // 使用按位或运算符\u0026#34;|\u0026#34;，即使第一个条件满足，storage也会自增 boolean res21 = size \u0026gt;= 8 | storage++ \u0026gt;= 8; // true System.out.println(res21); // 输出true System.out.println(storage); // 输出18.0，因为storage在条件判断之后自增了 // 使用逻辑或运算符\u0026#34;||\u0026#34;，若第一个条件满足，则不会执行第二个条件，storage不会自增 boolean res22 = size \u0026gt;= 8 || storage++ \u0026gt;= 16; // true System.out.println(res22); // 输出true System.out.println(storage); // 输出18.0，因为storage没有自增 System.out.println(\u0026#34;-------------------\u0026#34;); // 其他操作 // 使用逻辑非运算符\u0026#34;!\u0026#34;，对true取反，结果为false System.out.println((!true)); // 输出false // 使用按位异或运算符\u0026#34;^\u0026#34;，对两个数的二进制进行异或操作，结果为0 System.out.println((1^1)); // 输出0 int grade = 10; // 定义成绩变量为10 // 使用三元运算符判断成绩是否合格 String res = grade \u0026gt;= 60 ? \u0026#34;成绩合格\u0026#34; : \u0026#34;成绩不合格\u0026#34;; System.out.println(res); // 输出 \u0026#34;成绩不合格\u0026#34;，因为grade的值为10，小于60 // 第一条逻辑表达式 System.out.println(10 \u0026gt; 3 || 10 \u0026gt; 3 \u0026amp;\u0026amp; 10 \u0026lt; 3); // 输出true // 逻辑运算符\u0026#34;\u0026amp;\u0026amp;\u0026#34;的优先级高于\u0026#34;||\u0026#34;，所以先执行10 \u0026gt; 3 \u0026amp;\u0026amp; 10 \u0026lt; 3，结果为false，然后执行10 \u0026gt; 3 || false，结果为true。 // 第二条逻辑表达式 System.out.println((10 \u0026gt; 3 || 10 \u0026gt; 3) \u0026amp;\u0026amp; 10 \u0026lt; 3); // 输出false // 加了括号后，先执行括号内的10 \u0026gt; 3 || 10 \u0026gt; 3，结果为true，然后与10 \u0026lt; 3进行逻辑与运算，结果为false。 输入 // 1. 创建Scanner对象sc，用于从System.in（即标准输入流，通常为控制台）读取用户输入 Scanner sc = new Scanner(System.in); // 2. 输出提示信息，要求用户输入年龄 System.out.println(\u0026#34;Please input your age:\u0026#34;); // 3. 使用Scanner对象sc读取用户输入的整数型年龄，并将其存储在变量age中 int age = sc.nextInt(); // 4. 根据用户输入的年龄计算其出生年份（假设当前为2024年），然后输出结果 System.out.println(\u0026#34;Your birth year is :\u0026#34; + (2024 - age)); // 5. 输出提示信息，要求用户输入姓名 System.out.println(\u0026#34;Please input your name:\u0026#34;); // 6. 使用Scanner对象sc读取用户输入的字符串型姓名，并将其存储在变量name中 String name = sc.next(); // 7. 重复输出用户出生年份（与步骤4相同，此处可能是代码冗余或笔误） System.out.println(\u0026#34;Your birth year is :\u0026#34; + (2024 - age)); // 8. 输出欢迎信息，包含用户输入的姓名 System.out.println(\u0026#34;Welcome: \u0026#34; + name); switch注意事项：\n表达式类型只能是byte, short, int, char, JDK5开始支持枚举， JDK7开始支持String，不支持double，float, long。 case给出的值不允许重复，且只能是字面量，不能是变量 正常使用时需要写break， 否则会出现穿透现象 switch 技巧：运用穿透性合并同样结果的分支。\npublic class SwitchExample { public static void main(String[] args) { int day = 2; String dayType; switch (day) { case 1: case 2: case 3: case 4: case 5: dayType = \u0026#34;工作日\u0026#34;; break; case 6: case 7: dayType = \u0026#34;周末\u0026#34;; break; default: dayType = \u0026#34;无效的日子\u0026#34;; break; } System.out.println(\u0026#34;今天是: \u0026#34; + dayType); } } while\n// 创建一个Random对象用于生成随机数 Random random = new Random(); // 生成1到100之间的随机数作为幸运数字 int luckNumber = random.nextInt(100) + 1; // 创建一个Scanner对象用于接收用户的输入 Scanner sc = new Scanner(System.in); // 提示用户输入猜测的数字 System.out.println(\u0026#34;请输入你猜的数字\u0026#34;); // 循环，直到用户猜中为止 while (true) { // 获取用户输入的猜测数字 int guessNumber = sc.nextInt(); // 判断用户输入的数字与幸运数字的关系，并给出相应提示 if (guessNumber == luckNumber) { // 如果猜中了，输出恭喜信息，并结束循环 System.out.println(\u0026#34;恭喜你，你中了100元大奖\u0026#34;); break; } else if (guessNumber \u0026gt; luckNumber) { // 如果猜的数字太大，提示用户数字太大 System.out.println(\u0026#34;你猜的数字太大了\u0026#34;); } else { // 如果猜的数字太小，提示用户数字太小 System.out.println(\u0026#34;你猜的数字太小了\u0026#34;); } } 数组 //1.标准写法 // 初始化整型数组ages，包含5个元素，分别为10, 20, 30, 40, 50 int[] ages = new int[]{ 10, 20, 30, 40, 50 }; // 初始化双精度浮点型数组scores，包含5个元素，分别为99.9, 88.8, 77.7, 66.6, 55.5 double[] scores = new double[]{ 99.9, 88.8, 77.7, 66.6, 55.5 }; // 输出整型数组ages的引用地址 System.out.println(ages); // 输出双精度浮点型数组scores的引用地址 //2.简化写法 // 使用简化语法初始化整型数组ages2，包含5个元素，分别为10, 20, 30, 40, 50 int[] ages2 = { 10, 20, 30, 40, 50 }; // 使用简化语法初始化双精度浮点型数组scores2，包含5个元素，分别为99.9, 88.8, 77.7, 66.6, 55.5 //3.写法三 int age3[] = new int[10]; Java 内存分配 方法区\n栈\n堆\n本地方法栈\n程序计数器\nint a = 20; int[] arr = new int[3]; 以上两行代码的执行原理：\na是变量，直接放在栈中，a变量中存储的数据就是20这个值 new int[3]是创建一个数组对象，会在堆内存中开辟区存储3个整数 arr是变量，在栈中，arr中存储的是数组对象在堆内存中地址值 Java小案例——双色球 package com.show.test; import java.util.Random; import java.util.Scanner; public class Test4 { public static void main(String[] args) { System.out.println(1); int[] userNumber = userChooseNumber(); // 用户选择号码 int[] luckNumer = createLuckNumber(); // 创建幸运号码 check(userNumber, luckNumer); // 检查用户选择的号码与幸运号码的匹配情况 } // 用户选择号码的方法 public static int[] userChooseNumber() { System.out.println(\u0026#34;Welcome to this select ball system!\u0026#34;); // 欢迎语 int[] numbers = new int[6]; // 存储用户选择的号码数组 Scanner sc = new Scanner(System.in); for (int i = 0; i \u0026lt; 5; i++) { System.out.println(\u0026#34;Please input your No.\u0026#34; + (i + 1) + \u0026#34; ball\u0026#34;); // 提示用户输入号码 while (true) { int n = sc.nextInt(); // 接收用户输入的号码 if (n \u0026lt; 1 || n \u0026gt; 33) { // 判断号码是否在有效范围内 System.out.println(\u0026#34;Your number not in the available zone: [1,33], Please input again\u0026#34;); } else { if (exist(numbers, n)) { // 判断号码是否已经被选择 System.out.println(\u0026#34;Current number has been chosen, Please input again\u0026#34;); } else { numbers[i] = n; // 将号码存入数组 break; } } } System.out.println(\u0026#34;Your input number is :\u0026#34; + numbers[i]); // 输出用户输入的号码 } System.out.println(\u0026#34;Input your last number\u0026#34;); while (true) { int n = sc.nextInt(); if (n \u0026lt; 1 || n \u0026gt; 16) { System.out.println(\u0026#34;Your number is not available, Please input the number between 1 and 16\u0026#34;); } else { numbers[5] = n; // 存储最后一个号码 break; } } System.out.println(\u0026#34;Blow is your input numbers\u0026#34;); printArray(numbers); // 打印用户选择的号码 return numbers; } // 判断数字是否已存在于数组中的方法 public static boolean exist(int[] arr, int x) { for (int i = 0; i \u0026lt; arr.length; i++) { if (arr[i] == x) { return true; } } return false; } // 打印数组的方法 public static void printArray(int[] arr) { for (int i = 0; i \u0026lt; arr.length; i++) { System.out.print(arr[i] + \u0026#34; \u0026#34;); } System.out.println(); } // 创建幸运号码的方法 public static int[] createLuckNumber() { int[] numbers = new int[6]; // 存储幸运号码数组 Random r = new Random(); for (int i = 0; i \u0026lt; 5; i++) { while (true) { int n = r.nextInt(33) + 1; // 生成随机号码 if (exist(numbers, n)) { continue; } else { numbers[i] = n; // 将号码存入数组 break; } } } int n = r.nextInt(16) + 1; numbers[5] = n; // 存储最后一个号码（蓝球） System.out.println(\u0026#34;Blow is the LuckNumber!\u0026#34;); // 输出幸运号码 printArray(numbers); // 打印幸运号码 return numbers; } // 检查用户选择的号码与幸运号码的匹配情况 public static void check(int[] arr1, int[] arr2) { int redCount = 0, blueCount = 0; // 红球匹配数、蓝球匹配数初始化为0 for (int i = 0; i \u0026lt; arr1.length - 1; i++) { if (arr1[i] == arr2[i]) { // 判断红球是否匹配 redCount += 1; } } if (arr1[5] == arr2[5]) { // 判断蓝球是否匹配 blueCount += 1; } // 输出命中的红球数量和蓝球数量 System.out.println(\u0026#34;您命中的红球数量是：\u0026#34; + redCount); System.out.println(\u0026#34;您命中的蓝球数量是：\u0026#34; + blueCount); // 根据命中情况输出不同的中奖信息 if (redCount == 6 \u0026amp;\u0026amp; blueCount == 1) { System.out.println(\u0026#34;恭喜您，中奖1000万，可以开始享受人生了~~~\u0026#34;); } else if (redCount == 6 \u0026amp;\u0026amp; blueCount == 0) { System.out.println(\u0026#34;恭喜您，中奖500万，可以稍微开始享受人生了~~~\u0026#34;); } else if (redCount == 5 \u0026amp;\u0026amp; blueCount == 1) { System.out.println(\u0026#34;恭喜您，中奖3000元，可以出去吃顿小龙虾了~\u0026#34;); } else if (redCount == 5 \u0026amp;\u0026amp; blueCount == 0 || redCount == 4 \u0026amp;\u0026amp; blueCount == 1) { System.out.println(\u0026#34;恭喜您，中了小奖：200元~\u0026#34;); } else if (redCount == 4 \u0026amp;\u0026amp; blueCount == 0 || redCount == 3 \u0026amp;\u0026amp; blueCount == 1) { System.out.println(\u0026#34;中了10元~\u0026#34;); } else if (redCount \u0026lt; 3 \u0026amp;\u0026amp; blueCount == 1) { System.out.println(\u0026#34;中了5元~\u0026#34;); } else { System.out.println(\u0026#34;感谢您对福利事业做出的巨大贡献~~~\u0026#34;); } } } 面向对象 对象就是一张表。\nthis的执行原理 this：就是一个变量，可以用在方法中，来拿到当前对象。\nthis主要用来\npublic class PrintThis { public void printThis(){ System.out.println(this); } } public class Test1 { public static void main(String[] args) { PrintThis t = new PrintThis(); t.printThis();//com.show.thisDemo.PrintThis@3b07d329 System.out.println(t); //com.show.thisDemo.PrintThis@3b07d329 } } public class Student1 { int score; public void check(int score){ if(this.score\u0026gt;score){ System.out.println(\u0026#34;Congratulations!\u0026#34;); }else{ System.out.println(\u0026#34;What\u0026#39;s the pity!\u0026#34;); } } } public static void main(String[] args) { Student1 s1 = new Student1(); s1.score = 10; s1.check(100); } 构造器需要注意的问题 不写无参数构造器时，编译器会自动生成一个无参数构造器 而写了有参数构造器之后，就不会自动生成无参数构造器了， 需要手动写上。 封装 就是用类设计对象处理某一个事物的数据时，应该把要处理的数据，以及处理这些数据的方法，设计到一个对象中去 合理隐藏，合理暴露（get, set方法）\n实例JavaBean 实体类：一种特殊的类\nMovie package com.show.ObjectDemo; public class Movie { // 私有属性 private int id; // 电影ID private String name; // 电影名称 private double price; // 电影票价 private double score; // 电影评分 private String director; // 导演 private String actor; // 主演 private String info; // 电影信息 // 无参构造方法 public Movie() { } // 带参构造方法 public Movie(int id, String name, double price, double score, String director, String actor, String info) { this.id = id; this.name = name; this.price = price; this.score = score; this.director = director; this.actor = actor; this.info = info; } // Getter和Setter方法 public int getId() { return id; } public void setId(int id) { this.id = id; } public String getName() { return name; } public void setName(String name) { this.name = name; } public double getPrice() { return price; } public void setPrice(double price) { this.price = price; } public double getScore() { return score; } public void setScore(double score) { this.score = score; } public String getDirector() { return director; } public void setDirector(String director) { this.director = director; } public String getActor() { return actor; } public void setActor(String actor) { this.actor = actor; } public String getInfo() { return info; } public void setInfo(String info) { this.info = info; } } MovieOperator package com.show.ObjectDemo; public class MovieOperator { // 电影数组 private Movie[] movies; // 构造方法 public MovieOperator(Movie[] movies) { this.movies = movies; } // 打印所有电影信息 public void printAllMovies() { System.out.println(\u0026#34;系统全部电影信息如下————————————————————————————\u0026#34;); for (int i = 0; i \u0026lt; movies.length; i++) { Movie m = movies[i]; System.out.println(\u0026#34;编号：—————————————\u0026#34; + m.getId()); System.out.println(\u0026#34;电影名：—————————————\u0026#34; + m.getName()); System.out.println(\u0026#34;价格：—————————————\u0026#34; + m.getPrice()); System.out.println(\u0026#34;-----------------------\u0026#34;); } } // 根据ID查询电影信息 public void searchMovieById(int id) { for (int i = 0; i \u0026lt; movies.length; i++) { Movie m = movies[i]; if (id == m.getId()) { System.out.println(\u0026#34;存在该电影！\u0026#34;); System.out.println(\u0026#34;编号：—————————————\u0026#34; + m.getId()); System.out.println(\u0026#34;电影名：—————————————\u0026#34; + m.getName()); System.out.println(\u0026#34;价格：—————————————\u0026#34; + m.getPrice()); System.out.println(\u0026#34;导演：—————————————\u0026#34; + m.getDirector()); System.out.println(\u0026#34;演员：—————————————\u0026#34; + m.getActor()); System.out.println(\u0026#34;评分：—————————————\u0026#34; + m.getScore()); System.out.println(\u0026#34;其他信息：—————————————\u0026#34; + m.getInfo()); return; } } System.out.println(\u0026#34;不存在该电影\u0026#34;); } } Test package com.show.ObjectDemo; import java.util.Scanner; public class Test { public static void main(String[] args) { // 创建Movie对象数组，存储电影信息 Movie[] movies = new Movie[4]; movies[0] = new Movie(1, \u0026#34;水门桥\u0026#34;, 38.9, 9.8, \u0026#34;徐克\u0026#34;, \u0026#34;吴京\u0026#34;, \u0026#34;12万人想看\u0026#34;); movies[1] = new Movie(2, \u0026#34;出拳吧\u0026#34;, 39, 7.8, \u0026#34;唐晓白\u0026#34;, \u0026#34;田雨\u0026#34;, \u0026#34;3.5万人想看\u0026#34;); movies[2] = new Movie(3, \u0026#34;月球陨落\u0026#34;, 42, 7.9, \u0026#34;罗兰\u0026#34;, \u0026#34;贝瑞\u0026#34;, \u0026#34;17.9万人想看\u0026#34;); movies[3] = new Movie(4, \u0026#34;一点就到家\u0026#34;, 35, 8.7, \u0026#34;许宏宇\u0026#34;, \u0026#34;刘昊然\u0026#34;, \u0026#34;10.8万人想看\u0026#34;); // 创建MovieOperator对象，用于操作Movie数组 MovieOperator movieOperator = new MovieOperator(movies); System.out.println(\u0026#34;在这里，你可以查询关于最新的电影信息！\u0026#34;); Scanner sc = new Scanner(System.in); while (true) { System.out.println(\u0026#34;输入1查看所有电影信息\u0026#34;); System.out.println(\u0026#34;输入2可以查询某个特定电影的详细信息\u0026#34;); int cmd = sc.nextInt(); switch (cmd) { case 1: movieOperator.printAllMovies(); // 打印所有电影信息 break; case 2: System.out.println(\u0026#34;请输入你需要查询的电影ID\u0026#34;); int id = sc.nextInt(); movieOperator.searchMovieById(id); // 根据ID查询电影信息 break; default: System.out.println(\u0026#34;非法命令，请重新输入\u0026#34;); } } } } 成员变量和局部变量 成员变量：类中， 方法外， 有默认值， 存于堆内存中， 属于整个对象， 与对象同生共死\n局部变量：常见于方法中，无默认值，需要初始化， 存于栈内存中， 属于所属大括号中， 方法调用而生，结束而亡\nAPI 注意事项 同一个包下的程序，可以直接访问 访问其他包下的程序，必须导包才可以访问 自己的程序中调用Java提供的程序，也需要先导包才可以使用 注意Java.lang包下的程序是不需要导包， 可以直接使用 访问多个其他包下的程序，在这些程序名一样的情况下，默认只能只能导入一个程序，另外一个程序必须带包名和类名来访问。 Demo d = new Demo(); d.print(); Demo1 d1 = new Demo1(); d1.print(); com.show.pkgDemo3.Demo1 d2 = new com.show.pkgDemo3.Demo1(); d2.print(); String String name = \u0026#34;Java\u0026#34;; System.out.println(name); String rs1 = new String(); System.out.println(rs1); String rs2 = new String(\u0026#34;NewStringJava\u0026#34;); System.out.println(rs2); String 是不可变的 只要是\u0026quot;...\u0026quot;的方式写出的字符串对象，会存储到字符串常量池中，且相同内容的字符只会存储一份 而new String创建字符串对象时，每次都会new出来一个新对象，放在堆内存中。 String s1 = \u0026#34;abc\u0026#34;; String s2 = \u0026#34;abc\u0026#34;; System.out.println(s1==s2); //true char[] ch = {\u0026#39;1\u0026#39;, \u0026#39;2\u0026#39;, \u0026#39;3\u0026#39;}; String s3 = new String(ch); String s4 = new String(ch); System.out.println(s3==s4); //false String s5 = new String(\u0026#34;abc\u0026#34;); // 实际创建了两个对象，一个在字符串常量池当中 // 另一个在堆内存中 String s6 = \u0026#34;abc\u0026#34;; // 实际创建了0个对象，因为\u0026#34;abc\u0026#34;已经在常量池当中了 System.out.println(s5==s6); //false String s7 = \u0026#34;abc\u0026#34;; String s8 = \u0026#34;a\u0026#34;+\u0026#39;b\u0026#39;+\u0026#34;c\u0026#34;; //编译器会自动处理 System.out.println(s7==s8); //true String s9 = \u0026#34;abc\u0026#34;; String s10 = \u0026#34;ab\u0026#34;; String s11 = s10 + \u0026#34;c\u0026#34;; //而对于变量则不会自动处理 System.out.println(s9==s11); //false ArrayList ArrayList\u0026lt;String\u0026gt; list = new ArrayList\u0026lt;\u0026gt;(); list.add(\u0026#34;heima\u0026#34;); list.add(\u0026#34;Java\u0026#34;); list.add(\u0026#34;爪洼\u0026#34;); System.out.println(list);//[heima, Java, 爪洼] list.add(1, \u0026#34;JAVAJAVA\u0026#34;); System.out.println(list); //[heima, JAVAJAVA, Java, 爪洼] System.out.println(list.get(1));//JAVAJAVA System.out.println(list.size());//4 System.out.println(list.remove(1));//JAVAJAVA System.out.println(list.remove(\u0026#34;Java\u0026#34;)); //true 默认删除第一个出现的元素 System.out.println(list);//[heima, 爪洼] System.out.println(list.set(1, \u0026#34;ZhuaWa\u0026#34;));//爪洼 System.out.println(list);//[heima, ZhuaWa] 综合实践项目——ATM Account package com.showguan; public class Account { private int userId; private String userName; private String cardId; private char sex; private String possword; private double money; private double limit; public int getUserId() { return userId; } public void setUserId(int userId) { this.userId = userId; } public String getUserName() { return userName + (this.sex == \u0026#39;男\u0026#39; ? \u0026#34;先生\u0026#34; : \u0026#34;女士\u0026#34;); } public void setUserName(String userName) { this.userName = userName; } public char getSex() { return sex; } public void setSex(char sex) { this.sex = sex; } public String getPossword() { return possword; } public void setPossword(String possword) { this.possword = possword; } public double getMoney() { return money; } public void setMoney(double money) { this.money = money; } public double getLimit() { return limit; } public void setLimit(double limit) { this.limit = limit; } public String getCardId() { return cardId; } public void setCardId(String cardId) { this.cardId = cardId; } } ATM package com.showguan; import java.util.ArrayList; import java.util.Random; import java.util.Scanner; public class ATM { private ArrayList\u0026lt;Account\u0026gt; accounts = new ArrayList\u0026lt;\u0026gt;(); private Account loginAcc; private Scanner sc = new Scanner(System.in); public void start() { /** * 启动ATM系统，展示欢迎界面 */ while (true) { System.out.println(\u0026#34;欢迎您进入ATM系统！\u0026#34;); System.out.println(\u0026#34;1. 用户登录\u0026#34;); System.out.println(\u0026#34;2. 用户开户\u0026#34;); System.out.println(\u0026#34;请输入你需要进行的操作：\u0026#34;); String command = sc.next(); switch (command) { case \u0026#34;1\u0026#34;: login(); break; case \u0026#34;2\u0026#34;: createAccount(); break; default: System.out.println(\u0026#34;你输入的操作有误，请重新书输入！\u0026#34;); System.out.println(); break; } } } private void createAccount() { System.out.println(\u0026#34;===系统开户操作===\u0026#34;); Account acc = new Account(); System.out.println(\u0026#34;请输入用户名\u0026#34;); String name = sc.next(); acc.setUserName(name); while (true) { System.out.println(\u0026#34;请输入性别：\u0026#34;); char sex = sc.next().charAt(0); if (sex == \u0026#39;男\u0026#39; || sex == \u0026#39;女\u0026#39;) { acc.setSex(sex); break; } else { System.out.println(\u0026#34;你输入的性别有误！请重新输入\u0026#34;); } } while (true) { System.out.println(\u0026#34;请输入您的账户密码：\u0026#34;); String password = sc.next(); System.out.println(\u0026#34;请输入您的确认密码：\u0026#34;); String confirmPassword = sc.next(); if (password.equals(confirmPassword)) { acc.setPossword(password); System.out.println(\u0026#34;密码设置成功！\u0026#34;); break; } else { System.out.println(\u0026#34;两次密码不一致，请重新设置密码！\u0026#34;); } } System.out.println(\u0026#34;请输入您的取现最大额度\u0026#34;); double limit = sc.nextDouble(); acc.setLimit(limit); String cardId = createCardId(); acc.setCardId(cardId); accounts.add(acc); System.out.println(\u0026#34;恭喜你！\u0026#34; + acc.getUserName() + \u0026#34;开户完成, 您的卡号是:\u0026#34; + acc.getCardId()); } private String createCardId() { while (true) { String cardId = \u0026#34;\u0026#34;; Random r = new Random(); for (int i = 0; i \u0026lt; 8; i++) { int data = r.nextInt(10); cardId += data; } Account acc = getAccountByCardID(cardId); if (acc == null) { return cardId; } } } private Account getAccountByCardID(String cardId) { for (int i = 0; i \u0026lt; accounts.size(); i++) { Account acc = accounts.get(i); if (acc.getCardId().equals(cardId)) { return acc; } } return null; } private void login() { System.out.println(\u0026#34;===系统登录===\u0026#34;); if (accounts.size() == 0) { System.out.println(\u0026#34;当前系统内还没有任何账户，请先创建账户再来登录！\u0026#34;); return; } System.out.println(\u0026#34;请输入您的卡号\u0026#34;); String cardId = sc.next(); Account acc = getAccountByCardID(cardId); if (acc == null) { System.out.println(\u0026#34;用户不存在\u0026#34;); } else { while (true) { System.out.println(\u0026#34;请输入用户密码\u0026#34;); String passWord = sc.next(); if (passWord.equals(acc.getPossword())) { System.out.println(\u0026#34;登陆成功！\u0026#34;); loginAcc = acc; showUerCommand(); break; } else { System.out.println(\u0026#34;密码错误！请重新输入\u0026#34;); } } } } private void showUerCommand() { while (true) { System.out.println(loginAcc.getUserName() + \u0026#34;您可以进行如下操作\u0026#34;); System.out.println(\u0026#34;1. 查询账户\u0026#34;); System.out.println(\u0026#34;2. 存款\u0026#34;); System.out.println(\u0026#34;3. 取款\u0026#34;); System.out.println(\u0026#34;4. 转账\u0026#34;); System.out.println(\u0026#34;5. 修改密码\u0026#34;); System.out.println(\u0026#34;6. 退出\u0026#34;); System.out.println(\u0026#34;7. 注销当前账户\u0026#34;); System.out.println(\u0026#34;请选择您要进行的操作：\u0026#34;); String command = sc.next(); switch (command) { case \u0026#34;1\u0026#34;: showloginAccount(); break; case \u0026#34;2\u0026#34;: depositMoney(); break; case \u0026#34;3\u0026#34;: withDrawMoney(); break; case \u0026#34;4\u0026#34;: transferMoney(); break; case \u0026#34;5\u0026#34;: updatePassword(); return; case \u0026#34;6\u0026#34;: System.out.println(\u0026#34;用户\u0026#34; + loginAcc.getUserName() + \u0026#34;成功退出系统！\u0026#34;); return; case \u0026#34;7\u0026#34;: if (deleteAccount()) { return; } break; default: break; } } } private void updatePassword() { System.out.println(\u0026#34;===账号密码修改操作===\u0026#34;); while (true) { System.out.println(\u0026#34;请输入当前账户密码\u0026#34;); String password = sc.next(); if (loginAcc.getPossword().equals(password)) { while (true) { System.out.println(\u0026#34;请输入你要修改为的新密码：\u0026#34;); String newPassword = sc.next(); System.out.println(\u0026#34;请重复你需要修改为的密码：\u0026#34;); String confirmNewPassword = sc.next(); if (newPassword.equals(confirmNewPassword)) { System.out.println(\u0026#34;密码修改成功\u0026#34;); loginAcc.setPossword(newPassword); return; } System.out.println(\u0026#34;两次密码不一致， 请重新输入\u0026#34;); } } else { System.out.println(\u0026#34;您当前输入的密码错误！\u0026#34;); } } } private boolean deleteAccount() { System.out.println(\u0026#34;===销户操作===\u0026#34;); System.out.println(\u0026#34;确定要销户吗？y/n\u0026#34;); String command = sc.next(); switch (command) { case \u0026#34;y\u0026#34;: if (loginAcc.getMoney() == 0) { accounts.remove(loginAcc); System.out.println(\u0026#34;销户成功\u0026#34;); return true; } else { System.out.println(\u0026#34;账户下余额不为0， 不允许销户\u0026#34;); } break; } return false; } private void transferMoney() { System.out.println(\u0026#34;===用户转账===\u0026#34;); if (accounts.size() \u0026lt; 2) { System.out.println(\u0026#34;系统内只有您一个账户，无法转账\u0026#34;); return; } if (loginAcc.getMoney() \u0026lt; 0) { System.out.println(\u0026#34;您自己都没钱了，就别转了吧！\u0026#34;); return; } while (true) { System.out.println(\u0026#34;请您输入对方的卡号:\u0026#34;); String receiveCardID = sc.next(); Account acc = getAccountByCardID(receiveCardID); if (acc == null) { System.out.println(\u0026#34;您输入的卡号不存在！\u0026#34;); } else { String receiveName = \u0026#34;*\u0026#34; + acc.getUserName().substring(1); System.out.println(\u0026#34;请您输入【\u0026#34; + receiveName + \u0026#34;】姓氏\u0026#34;); System.out.println(receiveName); String firstName = sc.next(); if (acc.getUserName().startsWith(firstName)) { System.out.println(\u0026#34;姓氏验证成功！\u0026#34;); while (true) { System.out.println(); System.out.println(\u0026#34;请您输入转让给对方的金额:\u0026#34;); double transfermoney = sc.nextDouble(); if (loginAcc.getMoney() \u0026gt;= transfermoney) { System.out.println(\u0026#34;转账成功！\u0026#34;); loginAcc.setMoney(loginAcc.getMoney() - transfermoney); acc.setMoney(acc.getMoney() + transfermoney); return; } else { System.out.println(\u0026#34;余额不足，无法转账！！最多可转\u0026#34; + loginAcc.getMoney()); } } } else { System.out.println(\u0026#34;对不起， 您认证的姓氏有问题！\u0026#34;); } } } } private void withDrawMoney() { System.out.println(\u0026#34;===取钱操作===\u0026#34;); if (loginAcc.getMoney() \u0026lt; 100) { System.out.println(\u0026#34;您的账户余额不足100元，不允许取钱\u0026#34;); return; } while (true) { System.out.println(\u0026#34;请您输入取款金额：\u0026#34;); double drawMoney = sc.nextDouble(); if (loginAcc.getMoney() \u0026gt;= drawMoney) { if (drawMoney \u0026gt; loginAcc.getLimit()) { System.out.println(\u0026#34;取款金额大于限定额度， 您当前的限定额度为:\u0026#34; + loginAcc.getLimit()); break; } else { loginAcc.setMoney(loginAcc.getMoney() - drawMoney); System.out.println(\u0026#34;取款成功， 取款金额为\u0026#34; + drawMoney + \u0026#34;账户内剩余余额:\u0026#34; + loginAcc.getMoney()); return; } } else { System.out.println(\u0026#34;余额不足， 您当前的账户余额是：\u0026#34; + loginAcc.getMoney()); } } } private void showloginAccount() { System.out.println(\u0026#34;===当前您的账户信息如下===\u0026#34;); System.out.println(\u0026#34;用户名: \u0026#34; + loginAcc.getUserName()); System.out.println(\u0026#34;性别: \u0026#34; + loginAcc.getSex()); System.out.println(\u0026#34;卡号: \u0026#34; + loginAcc.getCardId()); System.out.println(\u0026#34;余额: \u0026#34; + loginAcc.getMoney()); System.out.println(\u0026#34;取现最大额度: \u0026#34; + loginAcc.getLimit()); } private void depositMoney() { System.out.println(\u0026#34;==存款操作==\u0026#34;); System.out.println(\u0026#34;请输入你要存款的金额\u0026#34;); double money = sc.nextDouble(); loginAcc.setMoney(loginAcc.getMoney() + money); System.out.println(\u0026#34;恭喜您\u0026#34; + \u0026#34;存款：\u0026#34; + money + \u0026#34;存款后余额:\u0026#34; + loginAcc.getMoney()); } } Test package com.showguan; public class Test { public static void main(String[] args) { ATM atm = new ATM(); atm.start(); } } ","permalink":"https://kennems.github.io/zh/posts/tech/java20%E5%A4%A9%E9%80%9F%E6%88%90%E5%9F%BA%E7%A1%80%E8%AF%BE%E7%A8%8B/","summary":"JAVA 20天速成 有志者事竟成 没有完完全全的投入，检测，学习是学不到东西的。 自欺欺人，眼高手低是绝对没有任何作用的。 JAVA背景信息 JAVA是一门","title":"Java20天速成——基础课程"},{"content":"算法笔记（二）——数据结构(Python实现) 数据结构 单链表 N = int(1e5+10) e=[0]*N ne=[0]*N head=-1 idx=1 def insert(x): global idx, head e[idx]=x ne[idx]=head head=idx idx+=1 def add(k, x): global idx e[idx]=x ne[idx]=ne[k] ne[k]=idx idx+=1 def remove(k): global idx, head if k==0: head = ne[head] else: ne[k]=ne[ne[k]] n = int(input()) for _ in range(n): s = input().split() op=s[0] if op==\u0026#39;H\u0026#39;: insert(int(s[1])) elif op==\u0026#39;I\u0026#39;: add(int(s[1]), int(s[2])) else: remove(int(s[1])) i=head while i!=-1: print(e[i], end=\u0026#39; \u0026#39;) i=ne[i] 双链表 N = int(1e5+10) e=[0]*N l=[0]*N r=[0]*N idx=0 def init(): global idx r[2]=1 l[1]=2 idx=3 def insert(k, x): global idx e[idx]=x l[idx]=k r[idx]=r[k] l[r[k]]=idx r[k]=idx idx+=1 def remove(k): l[r[k]]=l[k] r[l[k]]=r[k] init() m=int(input()) for _ in range(m): s=input().split() if s[0]==\u0026#39;L\u0026#39;: x=int(s[1]) insert(2,x) elif s[0]==\u0026#39;R\u0026#39;: x=int(s[1]) insert(l[1],x) elif s[0]==\u0026#39;D\u0026#39;: k=int(s[1])+2 remove(k) elif s[0]==\u0026#39;IL\u0026#39;: k=int(s[1])+2 x=int(s[2]) insert(l[k],x) elif s[0]==\u0026#39;IR\u0026#39;: k=int(s[1])+2 x=int(s[2]) insert(k,x) i=2 while i!=0: if i==2 or i==1: i=r[i] continue print(e[i],end=\u0026#34; \u0026#34;) i=r[i] 栈 N = int(1e5+10) # 假设N的值为100 stk = [0] * N tt = 0 # 向栈顶插入一个数 tt += 1 stk[tt] = x # 从栈顶弹出一个数 tt -= 1 # 栈顶的值 stk[tt] # 判断栈是否为空 if tt \u0026gt; 0: pass 队列 N = 100 # 假设N的值为100 q = [0] * N hh = 0 tt = -1 # 向队尾插入一个数 tt += 1 q[tt] = x # 从队头弹出一个数 hh += 1 # 队头的值 q[hh] # 判断队列是否为空 if hh \u0026lt;= tt: pass N = 100 # 假设N的值为100 q = [0] * N hh = 0 tt = 0 # 向队尾插入一个数 q[tt] = x tt += 1 if tt == N: tt = 0 # 从队头弹出一个数 hh += 1 if hh == N: hh = 0 # 队头的值 q[hh] # 判断队列是否为空 if hh != tt: pass 单调栈 tt = 0 stk = [0] * (n + 1) for i in range(1, n + 1): while tt and check(stk[tt], i): tt -= 1 stk[tt + 1] = i tt += 1 单调队列 n = 10 # 假设n的值为10 hh = 0 tt = -1 q = [0] * n for i in range(n): while hh \u0026lt;= tt and check_out(q[hh]): hh += 1 while hh \u0026lt;= tt and check(q[tt], i): tt -= 1 q[tt + 1] = i tt += 1 N = int(1e6+10) q=[0 for _ in range(N)] n,k=map(int, input().split()) a=[0]+[int(x) for x in input().split()] hh,tt=0,-1 for i in range(1,n+1): if hh\u0026lt;=tt and i-q[hh]+1\u0026gt;k: hh+=1 while hh\u0026lt;=tt and a[q[tt]] \u0026gt;= a[i]: tt-=1 tt+=1 q[tt]=i if i \u0026gt;= k: print(a[q[hh]], end=\u0026#34; \u0026#34;) print() hh,tt=0,-1 for i in range(1,n+1): if hh\u0026lt;=tt and i-q[hh]+1\u0026gt;k: hh+=1 while hh\u0026lt;=tt and a[q[tt]] \u0026lt;= a[i]: tt-=1 tt+=1 q[tt]=i if i\u0026gt;=k: print(a[q[hh]], end=\u0026#34; \u0026#34;) KMP m = len(p) # 假设p为模板串，长度为m n = len(s) # 假设s为模式串，长度为n ne = [0] * (m + 1) # 初始化ne数组 # 求Next数组 j = 0 for i in range(2, m + 1): while j and p[i] != p[j + 1]: j = ne[j] if p[i] == p[j + 1]: j += 1 ne[i] = j # 匹配 j = 0 for i in range(1, n + 1): while j and s[i] != p[j + 1]: j = ne[j] if s[i] == p[j + 1]: j += 1 if j == m: j = ne[j] # 匹配成功后的逻辑 n = int(input()) p = \u0026#39; \u0026#39; + input() m = int(input()) s = \u0026#39; \u0026#39; + input() ne = [0]*(n+1) j = 0 for i in range(2, n+1): while j and p[i]!=p[j+1]: j = ne[j] if p[i]==p[j+1]: j += 1 ne[i] = j j = 0 res = [] for i in range(1, m+1): while j and s[i]!=p[j+1]: j = ne[j] if s[i]==p[j+1]: j += 1 if j==n: res.append(i-j) j = ne[j] print(*res, sep=\u0026#39; \u0026#39;) Z函数 def z_function(s): n = len(s) z = [0] * n l, r = 0, 0 for i in range(1, n): if i \u0026lt;= r and z[i - l] \u0026lt; r - i + 1: z[i] = z[i - l] else: z[i] = max(0, r - i + 1) while i + z[i] \u0026lt; n and s[z[i]] == s[i + z[i]]: z[i] += 1 if i + z[i] - 1 \u0026gt; r: l = i r = i + z[i] - 1 return z Tire N = 100010 son = [[0] * 26 for _ in range(N)] cnt = [0] * N idx = 0 # 0号点既是根节点，又是空节点 # son[][]存储树中每个节点的子节点 # cnt[]存储以每个节点结尾的单词数量 # 插入一个字符串 def insert(s): global idx p = 0 for i in range(len(s)): u = ord(s[i]) - ord(\u0026#39;a\u0026#39;) if not son[p][u]: idx += 1 son[p][u] = idx p = son[p][u] cnt[p] += 1 # 查询字符串出现的次数 def query(s): p = 0 for i in range(len(s)): u = ord(s[i]) - ord(\u0026#39;a\u0026#39;) if not son[p][u]: return 0 p = son[p][u] return cnt[p] 马拉车（字符串回文串算法） class Solution: # 推荐教学视频 ：https://www.bilibili.com/video/BV1Sx4y1k7jG/?spm_id_from=333.337.search-card.all.click\u0026amp;vd_source=a4a2b56f746715b34521bfb853094cf4 def longestPalindrome(self, s: str) -\u0026gt; str: s = \u0026#39;#\u0026#39; + \u0026#39;#\u0026#39;.join(list(s)) + \u0026#39;#\u0026#39; n = len(s) p = [0]*n #每个点的 最长回文字串 能到的 两侧长度 c, r = 0, 0 # 右边能到达最远的蘑菇的位置 和 其最右边能达到的位置 for i in range(n): if i\u0026lt;=r: p[i] = min(r-i, p[c + c-i]) # 由已知条件得到当前位置能达到的最大右侧距离( 需要取min(镜像位置的值, 当前最大蘑菇能覆盖到的最大值) ) while i+p[i]+1 \u0026lt; n and s[i-p[i]-1] == s[i+p[i]+1]: p[i]+=1 if p[i]+i \u0026gt; r: r = p[i] + i c = i ma = max(p) idx = p.index(ma) return s[idx-ma+1:idx+ma+1:2] 并查集 N = 1000005 # 假设N的值为1000005 p = [0] * N # 初始化p数组 # 返回x的祖宗节点 def find(x): if p[x] != x: p[x] = find(p[x]) return p[x] \u0026#39;\u0026#39;\u0026#39; 非递归写法 def find(x): while p[x]!=x: p[x] = p[p[x]] x = p[x] return x \u0026#39;\u0026#39;\u0026#39; # 初始化，假定节点编号是1~n for i in range(1, n + 1): p[i] = i # 合并a和b所在的两个集合 p[find(a)] = find(b) 维护size信息\n# Python中没有类似于C++的数组声明方式，我们直接使用列表来代替 p = [i for i in range(N)] size = [1] * N # 返回x的祖宗节点 def find(x): if p[x] != x: p[x] = find(p[x]) return p[x] # 初始化，假定节点编号是1~n n = N # 假设n是提前定义好的 for i in range(1, n + 1): p[i] = i size[i] = 1 # 合并a和b所在的两个集合 p[find(a)] = find(b) size[b] += size[a] 维护到祖宗节点距离的并查集\n# Python中没有类似于C++的数组声明方式，我们直接使用列表来代替 p = [i for i in range(N)] d = [0] * N # 返回x的祖宗节点 def find(x): if p[x] != x: u = find(p[x]) d[x] += d[p[x]] p[x] = u return p[x] # 初始化，假定节点编号是1~n n = N # 假设n是提前定义好的 for i in range(1, n + 1): p[i] = i d[i] = 0 # 合并a和b所在的两个集合 p[find(a)] = find(b) d[find(a)] = distance # 根据具体问题，初始化find(a)的偏移量 题目大意\nAlice 和 Bob 玩了一个古老的格子游戏。游戏在一个 n×n 的点阵上进行，玩家轮流在相邻的点之间画线，分别是红边和蓝边。玩家在画出一条封闭的圈（面积不限）时游戏结束，该玩家获胜。题目要求判断游戏在第几步结束（即画出封闭圈），若 m 步之后也没有结束，则输出 \u0026ldquo;draw\u0026rdquo;。 实现思路\n输入与初始化：读取输入的点阵大小 n 和已画的 m 条边。初始化一个数组 p 作为并查集，p[i] 表示点 i 的父节点。 并查集的查找函数：定义一个 find 函数用于查找点的根节点，同时进行路径压缩以优化查找效率。 处理每条边： ​ 将二维坐标转换为一维标识。 ​ 根据边的方向（向右或向下）计算出连接的两个点。 ​ 使用并查集查找这两个点的根节点，判断它们是否属于同一个集合。如果是同一个集合，则说明形成了封闭圈，输出当前步骤并结束程序。 ​ 如果不属于同一个集合，则将两个点合并。 输出结果：如果遍历完所有边后仍未形成封闭圈，则输出 \u0026ldquo;draw\u0026rdquo;。 from sys import stdin input = lambda:stdin.readline().strip() def find(x): while p[x] != x: p[x] = p[p[x]] x = p[x] return x n, m = map(int, input().split()) p = [i for i in range(n*n+1)] for i in range(1, m+1): x, y, op = input().split() x, y = map(int, (x, y)) a = (x-1)*n + y - 1 if op==\u0026#39;D\u0026#39;: b = x*n + y - 1 else: b = (x-1)*n + y pa, pb = find(a), find(b) if pa == pb: print(i) exit() p[pa] = pb print(\u0026#39;draw\u0026#39;) 堆 # h[N] 存储堆中的值, h[1]是堆顶，x的左儿子是2x, 右儿子是2x + 1 # ph pos[k] 存储第k个插入的点在堆中的位置 # hp ord[k] 存储堆中下标是k的点是第几个插入的 N = 1000005 # 假设N的值为1000005 h = [0] * N # 初始化h数组 ph = [0] * N # 初始化ph数组 hp = [0] * N # 初始化hp数组 size = 0 # 初始化size为0 # 交换两个点，及其映射关系 def heap_swap(a, b): ph[hp[a]], ph[hp[b]] = ph[hp[b]], ph[hp[a]] hp[a], hp[b] = hp[b], hp[a] h[a], h[b] = h[b], h[a] def down(u): t = u if u * 2 \u0026lt;= size and h[u * 2] \u0026lt; h[t]: t = u * 2 if u * 2 + 1 \u0026lt;= size and h[u * 2 + 1] \u0026lt; h[t]: t = u * 2 + 1 if u != t: heap_swap(u, t) down(t) def up(u): while u // 2 and h[u] \u0026lt; h[u // 2]: heap_swap(u, u // 2) u \u0026gt;\u0026gt;= 1 # O(n)建堆 for i in range(n // 2, 0, -1): down(i) def add_element(x): global size size += 1 h[size] = x ph[size] = size hp[size] = size up(size) def get_heap_top(): return h[1] def delete_element(k): global size heap_swap(k, size) size -= 1 down(k) up(k) def update_element(k, x): h[k] = x down(k) up(k) # 添加元素 add_element(x) # 堆顶元素 heap_top = get_heap_top() # 删除第size个节点 delete_element(1) # 删除第k个节点 delete_element(k) # 将第k个元素赋值为x update_element(k, x) import sys from heapq import * input = lambda:sys.stdin.readline().strip() n = int(input()) cnt = 1 d = dict() h = [] for i in range(n): op = input().split() if op[0]==\u0026#39;I\u0026#39;: v = int(op[1]) heappush(h, v) d[cnt] = v; cnt+=1 elif op[0]==\u0026#39;D\u0026#39;: k = int(op[1]) if d[k]==0: continue v = d[k]; d[k]=0 h.remove(v) heapify(h) elif op[0]==\u0026#39;C\u0026#39;: k = int(op[1]) x = int(op[2]) if d[k]==0: continue v = d[k]; d[k]=x h.remove(v) heapify(h) heappush(h, x) elif op[0]==\u0026#39;DM\u0026#39;: heappop(h) elif op[0]==\u0026#39;PM\u0026#39;: print(h[0]) 动态中位数 import sys from heapq import * input = lambda:sys.stdin.readline().strip() p = int(input()) for _ in range(p): id, m = map(int, input().split()) print(id, (m+1)//2) cnt1, cnt2 = 0, 0 hl, hu = [], [] while m: a = list(map(int, input().split())) m -= len(a) for i in range(len(a)): if len(hl)==0 or len(hl)==len(hu): heappush(hu, -a[i]) tmp = -heappop(hu) heappush(hl, tmp) else: heappush(hl, a[i]) tmp = heappop(hl) heappush(hu, -tmp) cnt1+=1 if cnt1\u0026amp;1: print(hl[0], end=\u0026#34; \u0026#34;) cnt2+=1 if cnt2%10==0 and m!=0: print() print() 哈希 (1)拉链法 N = 1000005 # 假设N的值为1000005 h = [-1] * N # 初始化h数组为-1 e = [0] * N # 初始化e数组 ne = [0] * N # 初始化ne数组 idx = 0 # 初始化idx为0 # 向哈希表中插入一个数 def insert(x): k = (x % N + N) % N e[idx] = x ne[idx] = h[k] h[k] = idx idx += 1 # 在哈希表中查询某个数是否存在 def find(x): k = (x % N + N) % N i = h[k] while i != -1: if e[i] == x: return True i = ne[i] return False N = 100003 e, ne, h = [0]*N, [0]*N, [-1]*N idx = 0 def insert(x): global idx k = (x%N + N)%N e[idx] = x ne[idx] = h[k] h[k] = idx idx+=1 def query(x): k = (x%N + N)%N i = h[k] while i!=-1: if e[i]==x: return True i = ne[i] return False n = int(input()) for i in range(n): s = input().split() op, k = s[0], int(s[1]) if op==\u0026#39;I\u0026#39;: insert(k) else: if query(k): print(\u0026#34;Yes\u0026#34;) else: print(\u0026#34;No\u0026#34;) (2) 开放寻址法 N = 1000005 # 假设N的值为1000005 h = [0] * N # 初始化h数组 # 如果x在哈希表中，返回x的下标；如果x不在哈希表中，返回x应该插入的位置 def find(x): t = (x % N + N) % N while h[t] != 0 and h[t] != x: t += 1 if t == N: t = 0 return t 字符串哈希 这段代码实现了字符串的哈希算法，用于快速计算子串的哈希值。下面我来解释一下：\n题目大意： 这段代码实现了字符串哈希算法，可以用于快速计算给定字符串中任意子串的哈希值。\n实现思路：\n首先定义了两个数组 h 和 p，分别用于存储字符串的哈希值和幂次值。 对于字符串的每个位置，计算其对应的哈希值并存储在数组 h 中。同时计算幂次值并存储在数组 p 中。 字符串的哈希值由以下公式计算得到：$h[i] = h[i - 1] \\times P + \\text{ord}(str[i])$其中，$P$是一个预先定义的质数（例如 131 或 13331），$\\text{ord}(str[i])$ 表示字符串中第 $i$ 个字符的 ASCII 值。 计算子串 $str[l:r]$ 的哈希值时，使用以下公式：$ \\text{get}(l, r) = h[r] - h[l - 1] \\times p[r - l + 1] $其中，$h[r]$ 是子串起始位置到结束位置的哈希值，$h[l - 1]$ 是子串起始位置前一个位置的哈希值，$p[r - l + 1]$ 是子串长度对应的幂次值。 总体来说，这段代码实现了字符串哈希算法，用于快速计算给定字符串中任意子串的哈希值。\nh 数组存储了字符串的哈希值，即从字符串的起始位置到当前位置的子串的哈希值。 h[i] 表示字符串从第一个字符到第 i 个字符（包括第 i 个字符）的子串的哈希值。 p[i] 表示幂次值，即 $P^i$ 的值，其中 $P$ 是一个预先定义的质数。 p 数组存储了幂次值，用于计算子串的哈希值时使用。 import sys input = lambda:sys.stdin.readline().strip() mod = 1\u0026lt;\u0026lt;64 def get(l, r): return (h[r] - h[l-1]*p[r-l+1])%mod N = int(1e5) + 10 P = 131 p = [0]*N h = [0]*N n, m = map(int, input().split()) s = \u0026#39; \u0026#39; + input() p[0] = 1 for i in range(1, n+1): h[i] = (h[i-1]*P + ord(s[i]))%mod p[i] = (p[i-1]*P)%mod for i in range(m): l1, r1, l2, r2 = map(int, input().split()) if get(l1, r1) == get(l2, r2): print(\u0026#34;Yes\u0026#34;) else: print(\u0026#34;No\u0026#34;) 树状数组 楼兰图腾\nimport sys input=lambda:sys.stdin.readline() M = 200010 suml, sumg = 0, 0 tr = [0]*M n = int(input()) a = [0]+[int(_) for _ in input().split()] def lowbit(x): return x\u0026amp;-x def add(x,v): while x\u0026lt;M: tr[x]+=v x+=lowbit(x) def query(x): res = 0 while x: res+=tr[x] x-=lowbit(x) return res for i in range(1,n+1): y=a[i] lw = query(y-1) lwr = y-1-lw # the lower element on the right side gr = query(n)-query(y) grr = (n-y) - gr suml += (lw*lwr) sumg += (gr*grr) add(y,1) print(sumg, suml) 线段树 \\1265. 数星星 题目大意：给定一些星星的坐标，以平面直角坐标系表示，需要统计每个星星的等级，即在该星星左下方（含正左、正下）的星星数量。\n实现思路：\n使用线段树来维护每个星星的等级。 构建线段树，初始时所有节点值都为0。 读入每个星星的坐标，通过查询线段树统计该星星左边（含正左）的星星数量，即为该星星的等级。 更新线段树的值，将当前星星的横坐标位置对应的节点值加1。 统计每个等级的星星数量，输出结果。 import sys input = lambda:sys.stdin.readline() N = 15010 M = 32010 tr = [0]*(M*4) level = [0]*N def pushup(u): tr[u] = tr[u \u0026lt;\u0026lt; 1] + tr[u \u0026lt;\u0026lt; 1 | 1] def build(u, l, r): if l == r: tr[u] = 0 else: mid = (l + r) \u0026gt;\u0026gt; 1 build(u \u0026lt;\u0026lt; 1, l, mid) build(u \u0026lt;\u0026lt; 1 | 1, mid + 1, r) pushup(u) def query(u, l, r, ql, qr): if l \u0026gt;= ql and r \u0026lt;= qr: return tr[u] mid = (l + r) \u0026gt;\u0026gt; 1 if mid==l and mid==r: return 0 res = 0 if ql \u0026lt;= mid: res += query(u \u0026lt;\u0026lt; 1, l, mid, ql, qr) if qr \u0026gt; mid: res += query(u \u0026lt;\u0026lt; 1 | 1, mid + 1, r, ql, qr) return res def modify(u, x, l, r, val): if l == r: tr[u] += val else: mid = (l + r) \u0026gt;\u0026gt; 1 if x \u0026lt;= mid: modify(u \u0026lt;\u0026lt; 1, x, l, mid, val) else: modify(u \u0026lt;\u0026lt; 1 | 1, x, mid + 1, r, val) pushup(u) l, r = 0, 32000 build(1, l, r) n = int(input()) for i in range(n): x, _ = map(int, input().split()) t = query(1, l, r, 0, x) level[t]+=1 modify(1, x, l, r, 1) for i in range(n): print(level[i]) 最大数 import sys input = lambda:sys.stdin.readline().strip() m = int(2e5)+2 tr = [0]*(m*4) def pushup(u): tr[u] = max(tr[u\u0026lt;\u0026lt;1], tr[u\u0026lt;\u0026lt;1|1]) def modify(u, l, r, x, v): if l==r: tr[u] = v else: mid = l+r\u0026gt;\u0026gt;1 if x\u0026lt;=mid: modify(u\u0026lt;\u0026lt;1, l, mid, x, v) else: modify(u\u0026lt;\u0026lt;1|1, mid+1, r, x, v) pushup(u) def query(u, l, r, ql, qr): if l\u0026gt;=ql and r\u0026lt;=qr: return tr[u] if l==r: return 0 res = 0 mid = l+r\u0026gt;\u0026gt;1 if ql\u0026lt;=mid: res = query(u\u0026lt;\u0026lt;1, l, mid, ql, qr) if qr\u0026gt;mid: res = max(res, query(u\u0026lt;\u0026lt;1|1, mid+1, r, ql, qr)) return res m, p = map(int, input().split()) n, pre = 0, 0 for i in range(m): op, x = input().split() x = int(x) if op==\u0026#39;Q\u0026#39;: pre = query(1, 1, m, n-x+1, n) print(pre) else: n += 1 modify(1, 1, m, n, (x+pre)%p) \\243. 一个简单的整数问题2 import sys input = lambda:sys.stdin.readline().strip() N = int(1e5)+10 M = 1\u0026lt;\u0026lt;N.bit_length() + 1 tr = [0]*M add = [0]*M def pushup(u): tr[u] = tr[u\u0026lt;\u0026lt;1] + tr[u\u0026lt;\u0026lt;1|1] def pushdown(u, ln, rn): if add[u]: lazy(u\u0026lt;\u0026lt;1, add[u], ln) lazy(u\u0026lt;\u0026lt;1|1, add[u], rn) add[u] = 0 def lazy(u, v, n): tr[u] += v*n add[u] += v def build(u, l, r): if l==r: tr[u] = w[l] else: mid = l+r\u0026gt;\u0026gt;1 build(u\u0026lt;\u0026lt;1, l, mid) build(u\u0026lt;\u0026lt;1|1, mid+1, r) pushup(u) add[u] = 0 def modify(u, l, r, ml, mr, v): if l\u0026gt;=ml and r\u0026lt;=mr: lazy(u, v, r-l+1) else: mid = l+r\u0026gt;\u0026gt;1 pushdown(u, mid-l+1, r-mid) if ml \u0026lt;= mid: modify(u\u0026lt;\u0026lt;1, l, mid, ml, mr, v) if mr \u0026gt; mid: modify(u\u0026lt;\u0026lt;1|1, mid+1, r, ml, mr, v) pushup(u) def query(u, l, r, ql, qr): if l\u0026gt;=ql and r\u0026lt;=qr: return tr[u] mid = l+r\u0026gt;\u0026gt;1 pushdown(u, mid-l+1, r-mid) res = 0 if ql\u0026lt;=mid: res = query(u\u0026lt;\u0026lt;1, l, mid, ql, qr) if qr\u0026gt;mid: res += query(u\u0026lt;\u0026lt;1|1, mid+1, r, ql, qr) return res # 主程序开始 n, m = map(int, input().split()) # 输入节点数量n和操作数量m w = list(map(int, input().split())) # 输入节点的初始权值 build(1, 0, n-1) res = [] # 存储查询结果 while m: m -= 1 op, opt = input().split(maxsplit=1) if op == \u0026#39;Q\u0026#39;: l, r = map(int, opt.split()) l-=1; r-=1 res.append(str(query(1, 0, n-1, l, r))) # 查询区间和并将结果添加到res列表中 else: l, r, val = map(int, opt.split()) l-=1; r-=1 modify(1, 0, n-1, l, r, val) # 修改区间的值 print(\u0026#34;\\n\u0026#34;.join(res)) # 输出查询结果 维护序列 题目大意：给定一个长度为 n 的数列 𝑎𝑖，有三种操作：1. 格式1 t g c，将区间 [t, g] 内的数乘以 c；2. 格式2 t g c，将区间 [t, g] 内的数加上 c；3. 格式3 t g，求区间 [t, g] 内数的和，并输出结果模 p 的值。\n实现思路：\n使用线段树来维护区间和，每个节点保存区间内数的和。 对于每种操作，根据操作类型分别进行处理。 对于格式1和格式2，采用延迟标记来实现区间修改。对于格式3，采用递归的方式查询区间和。 实现具体的操作函数，包括建树、修改和查询。 循环读入每个操作并进行处理，最后输出查询结果。 import sys input = lambda: sys.stdin.readline().strip() N = int(1e5) + 1 M = 1 \u0026lt;\u0026lt; N.bit_length() + 1 tr = [0] * M add = [0] * M mul = [0] * M def lazy(u, n, ad, mu): tr[u] = (tr[u] * mu + n * ad) % p add[u] = (add[u] * mu + ad) % p mul[u] = (mul[u] * mu) % p def pushup(u): tr[u] = tr[u \u0026lt;\u0026lt; 1] + tr[u \u0026lt;\u0026lt; 1 | 1] def pushdown(u, ln, rn): if add[u] != 0 or mul[u] != -1: lazy(u \u0026lt;\u0026lt; 1, ln, add[u], mul[u]) lazy(u \u0026lt;\u0026lt; 1 | 1, rn, add[u], mul[u]) add[u] = 0 mul[u] = 1 def build(u, l, r): if l == r: tr[u] = w[l] else: mid = l + r \u0026gt;\u0026gt; 1 build(u \u0026lt;\u0026lt; 1, l, mid) build(u \u0026lt;\u0026lt; 1 | 1, mid + 1, r) pushup(u) add[u] = 0 mul[u] = 1 def modify(u, l, r, ml, mr, ad, mu): if l \u0026gt;= ml and r \u0026lt;= mr: lazy(u, r - l + 1, ad, mu) else: mid = l + r \u0026gt;\u0026gt; 1 pushdown(u, mid - l + 1, r - mid) if ml \u0026lt;= mid: modify(u \u0026lt;\u0026lt; 1, l, mid, ml, mr, ad, mu) if mr \u0026gt; mid: modify(u \u0026lt;\u0026lt; 1 | 1, mid + 1, r, ml, mr, ad, mu) pushup(u) def query(u, l, r, ql, qr): if l \u0026gt;= ql and r \u0026lt;= qr: return tr[u] mid = l + r \u0026gt;\u0026gt; 1 pushdown(u, mid - l + 1, r - mid) res = 0 if ql \u0026lt;= mid: res += query(u \u0026lt;\u0026lt; 1, l, mid, ql, qr) if qr \u0026gt; mid: res += query(u \u0026lt;\u0026lt; 1 | 1, mid + 1, r, ql, qr) return res % p n, p = map(int, input().split()) w = [0] + list(map(int, input().split())) m = int(input()) build(1, 1, n) res = [] for i in range(m): op, par = input().split(maxsplit=1) if op == \u0026#34;1\u0026#34;: l, r, mu = map(int, par.split()) modify(1, 1, n, l, r, 0, mu) elif op == \u0026#34;2\u0026#34;: l, r, ad = map(int, par.split()) modify(1, 1, n, l, r, ad, 1) else: l, r = map(int, par.split()) res.append(str(query(1, 1, n, l, r))) print(*res, sep=\u0026#34;\\n\u0026#34;) \\246. 区间最大公约数 from math import gcd from sys import stdin input = stdin.readline def pushup(u): tr[u] = tr[u\u0026lt;\u0026lt;1] + tr[u\u0026lt;\u0026lt;1|1] gd[u] = gcd(gd[u\u0026lt;\u0026lt;1], gd[u\u0026lt;\u0026lt;1|1]) def build(u, l, r): if l==r: tr[u] = gd[u] = arr[l]-arr[l-1] else: mid = l+r\u0026gt;\u0026gt;1 build(u\u0026lt;\u0026lt;1, l, mid) build(u\u0026lt;\u0026lt;1|1, mid+1, r) pushup(u) def modify(u, l, r, x, v): if l==r: tr[u] += v gd[u] += v else: mid = l+r\u0026gt;\u0026gt;1 if x\u0026lt;=mid: modify(u\u0026lt;\u0026lt;1, l, mid, x, v) else: modify(u\u0026lt;\u0026lt;1|1, mid+1, r, x, v) pushup(u) def query(u, l, r, ql, qr): if l\u0026gt;=ql and r\u0026lt;=qr: return (tr[u], gd[u]) mid = l+r\u0026gt;\u0026gt;1 a, b = [0, 0], [0, 0] if ql\u0026lt;=mid: a = query(u\u0026lt;\u0026lt;1, l, mid, ql, qr) if qr\u0026gt;mid: b = query(u\u0026lt;\u0026lt;1|1, mid+1, r, ql, qr) return (a[0]+b[0], gcd(a[1], b[1])) n, m = map(int, input().split()) arr = [0] + list(map(int, input().split())) M = 1\u0026lt;\u0026lt;n.bit_length() + 1 tr = [0]*M gd = [0]*M build(1, 1, n) res = [] for i in range(m): op, par = input().split(maxsplit=1) if op==\u0026#39;Q\u0026#39;: l, r = map(int, par.split()) ans = gcd(query(1, 1, n, 1, l)[0], query(1, 1, n, l+1, r)[1]) if l+1\u0026lt;=r else query(1, 1, n, 1, l)[0] res.append(str(ans)) else: l, r, v = map(int, par.split()) modify(1, 1, n, l, v) if r+1\u0026lt;=n: modify(1, 1, n, r+1, -v) print(*res, sep=\u0026#39;\\n\u0026#39;) 类实现线段树 # 定义树节点，l,r, val表示该节点记录的是区间[l, r]的最大值是val class Tree(): def __init__(self): self.l = 0 self.r = 0 self.lazy = 0 self.val = 0 # 二叉树是堆形式，可以用一维数组存储，注意数组长度要开4倍空间 tree = [Tree() for i in range(10*4)] # 建树，用cur\u0026lt;\u0026lt;1访问左子树，cur\u0026lt;\u0026lt;1|1访问右子树，位运算操作很方便 def build(cur, l, r): tree[cur].l, tree[cur].r, tree[cur].lazy, tree[cur].val = l, r, 0, 0 # 当l==r的时候结束递归 if l \u0026lt; r: mid = l + r \u0026gt;\u0026gt; 1 build(cur\u0026lt;\u0026lt;1, l, mid) build(cur\u0026lt;\u0026lt;1|1, mid+1, r) # 当子节点计算完成后，用子节点的值来更新自己的值 def pushup(cur): tree[cur].val = max(tree[cur\u0026lt;\u0026lt;1].val, tree[cur\u0026lt;\u0026lt;1|1].val) # 单点更新 def add(cur, x, v): if tree[cur].l == tree[cur].r: tree[cur].val += v else: mid = tree[cur].r + tree[cur].l \u0026gt;\u0026gt; 1 if x \u0026gt; mid: add(cur\u0026gt;\u0026gt;1|1, x, v) else: add(cur\u0026lt;\u0026lt;1, x, v) pushup(cur) # 将lazy标记向下传递一层 def pushdown(cur): if tree[cur].lazy: lazy = tree[cur].lazy tree[cur\u0026lt;\u0026lt;1].lazy += lazy tree[cur\u0026lt;\u0026lt;1|1].lazy += lazy tree[cur\u0026lt;\u0026lt;1].val += lazy tree[cur\u0026lt;\u0026lt;1|1].val += lazy tree[cur].lazy = 0 # 区间更新 def update(cur, l, r, v): if l \u0026lt;= tree[cur].l and tree[cur].r \u0026lt;= r: tree[cur].lazy += v tree[cur].val += v return if r \u0026lt; tree[cur].l or l \u0026gt; tree[cur].r: return if tree[cur].lazy: pushdown(cur) update(cur\u0026lt;\u0026lt;1, l, r, v) update(cur\u0026lt;\u0026lt;1|1, l, r, v) pushup(cur) # 区间查询 def query(cur, l, r): if l \u0026lt;= tree[cur].l and tree[cur].r \u0026lt;= r: return tree[cur].val if tree[cur].l \u0026gt; r or tree[cur].r \u0026lt; l: return 0 if tree[cur].lazy: pushdown(cur) return max(query(cur\u0026lt;\u0026lt;1, l, r), query(cur\u0026lt;\u0026lt;1|1)) # 测试 # ----- # --- # ------- # -- # -- build(1, 1, 10) update(1, 1, 5, 1) update(1, 7, 10, 1) update(1, 2, 8, 1) update(1, 3, 4, 1) update(1, 9, 10, 1) print(query(1, 1, 10)) def pushup(u): tr[u] = tr[u \u0026lt;\u0026lt; 1] + tr[u \u0026lt;\u0026lt; 1 | 1] def build(u, l, r): if l == r: tr[u] = 0 else: mid = (l + r) \u0026gt;\u0026gt; 1 build(u \u0026lt;\u0026lt; 1, l, mid) build(u \u0026lt;\u0026lt; 1 | 1, mid + 1, r) pushup(u) def query(u, l, r, ql, qr): if l \u0026gt;= ql and r \u0026lt;= qr: return tr[u] mid = (l + r) \u0026gt;\u0026gt; 1 if mid==l and mid==r: return 0 res = 0 if ql \u0026lt;= mid: res = query(u \u0026lt;\u0026lt; 1, l, mid, ql, qr) if qr \u0026gt; mid: res += query(u \u0026lt;\u0026lt; 1 | 1, mid + 1, r, ql, qr) return res def modify(u, x, l, r, val): if l == r: tr[u] += val else: mid = (l + r) \u0026gt;\u0026gt; 1 if x \u0026lt;= mid: modify(u \u0026lt;\u0026lt; 1, x, l, mid, val) else: modify(u \u0026lt;\u0026lt; 1 | 1, x, mid + 1, r, val) pushup(u) 搜索深入 池塘计数 import sys from collections import deque input = lambda:sys.stdin.readline().strip() N = int(1e3+10) M = N*N g = [0]*N cnt=0 vis = [ [False]*N for _ in range(N) ] def bfs(x, y): q=deque() q.append( (x,y) ) while q: tx, ty = q[0] q.popleft() for i in range(-1, 2): for j in range(-1, 2): if i==0 and j==0: continue xx, yy = tx+i, ty+j if xx\u0026lt;0 or xx\u0026gt;=n or yy\u0026lt;0 or yy\u0026gt;=m or vis[xx][yy] or g[xx][yy]==\u0026#39;.\u0026#39;: continue vis[xx][yy]=True q.append( (xx,yy) ) n, m = map(int, input().split()) for i in range(n): g[i]=input() for i in range(n): for j in range(m): if g[i][j]!=\u0026#39;W\u0026#39; or vis[i][j]: continue bfs(i, j) cnt+=1 print(cnt) 城堡问题 import sys from collections import deque input = lambda:sys.stdin.readline().strip() N = 55 g = [] vis = [[False]*N for _ in range(N)] area = 0 cnt=0 def bfs(x, y): vis[x][y]=True q = deque() q.append((x, y)) dx, dy = [0, -1, 0, 1], [-1, 0, 1, 0] ans=1 while q: tx, ty = q.popleft() for i in range(4): xx = tx+dx[i] yy = ty+dy[i] if xx\u0026lt;0 or xx\u0026gt;=n or yy\u0026lt;0 or yy\u0026gt;=m or vis[xx][yy]: continue if (g[tx][ty]\u0026gt;\u0026gt;i)\u0026amp;1: continue ans+=1 vis[xx][yy]=True q.append((xx,yy)) return ans n, m = map(int, input().split()) for _ in range(n): g.append(list(map(int, input().split()))) for i in range(n): for j in range(m): if vis[i][j]: continue area = max(area, bfs(i, j)) cnt+=1 print(cnt) print(area) 山峰和山谷 import sys from collections import deque N = 1010 g = [] vis = [[0]*N for _ in range(N)] pek, val = 0, 0 def bfs(x, y): global higher, lower vis[x][y]=True q = deque() q.append((x,y)) while q: tx,ty = q.popleft() for i in range(-1, 2): for j in range(-1, 2): if i==0 and j==0: continue xx, yy = tx+i, ty+j if xx\u0026lt;0 or xx\u0026gt;=n or yy\u0026lt;0 or yy\u0026gt;=n: continue if g[xx][yy]!=g[tx][ty]: if g[xx][yy]\u0026gt;g[tx][ty]: higher=True elif g[xx][yy]\u0026lt;g[tx][ty]: lower=True elif not vis[xx][yy]: vis[xx][yy]=True q.append((xx,yy)) higher, lower = False, False n = int(input()) for _ in range(n): g.append(list(map(int, input().split()))) # print(g) for i in range(n): for j in range(n): if vis[i][j]: continue higher, lower = False, False bfs(i, j) if not higher:pek+=1 if not lower:val+=1 print(pek, val) BFS P1038 [NOIP2003 提高组] 神经网络 题目大意：兰兰提出了一个神经网络模型，该模型可以表示为一个有向图，图中的节点称为神经元，节点之间的连接代表神经元之间的联系。神经元按照一定的顺序排列，构成整个神经网络。每个神经元都有一个状态和阈值，当神经元处于兴奋状态时，会向其他神经元传送信号。\n实现思路：\n首先，根据输入的网络结构信息，构建神经元之间的连接关系。使用字典g来表示神经元之间的连接关系，以及字典wei来表示连接神经元之间的边的权值。 然后，根据输入的初始状态和阈值信息，初始化神经元的状态。同时，记录输入层神经元的初始状态，如果神经元的状态不为0，则将其加入队列q中。 利用广度优先搜索（BFS）算法，遍历神经元，根据模型公式更新每个神经元的状态。同时，更新神经元的状态时，考虑到边的权值以及神经元的阈值。 最后，输出输出层神经元的状态。如果输出层神经元的最后状态均小于等于0，则输出\u0026quot;NULL\u0026quot;，否则按照编号从小到大顺序输出输出层神经元的状态。 from collections import deque, defaultdict maxn = 1e3 + 10 c = [0] * int(maxn) u = [0] * int(maxn) wei = defaultdict(lambda: defaultdict(int)) vis = [False] * int(maxn) beginer = [False] * int(maxn) g = defaultdict(list) n, p = map(int, input().split()) en = [] q = deque() for i in range(1, n + 1): c[i], u[i] = map(int, input().split()) if c[i] != 0: q.append(i) beginer[i] = True else: en.append(i) if not en: for i in range(1, n + 1): print(i, c[i]) exit() for _ in range(p): s, e, w = map(int, input().split()) g[s].append(e) wei[s][e] = w while q: t = q.popleft() if not beginer[t]: c[t] -= u[t] base = c[t] if base \u0026gt; 0: for j in g[t]: c[j] += base * wei[t][j] if not vis[j]: q.append(j) vis[j] = True ans = 0 for i in en: if c[i] \u0026gt; 0 and not g[i]: print(i, c[i]) ans += 1 if not ans: print(\u0026#34;NULL\u0026#34;) ","permalink":"https://kennems.github.io/zh/posts/tech/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0%E4%BA%8C%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84python%E5%AE%9E%E7%8E%B0/","summary":"算法笔记（二）——数据结构(Python实现) 数据结构 单链表 N = int(1e5+10) e=[0]*N ne=[0]*N head=-1 idx=1 def insert(x): global idx, head e[idx]=x ne[idx]=head head=idx idx+=1 def add(k, x): global idx e[idx]=x ne[idx]=ne[k] ne[k]=idx idx+=1 def remove(k): global idx, head if k==0: head = ne[head] else: ne[k]=ne[ne[k]] n = int(input())","title":"算法笔记（二）——数据结构(Python实现)"},{"content":"算法笔记（三）——图论（Python实现） 图论 树的存储 邻接矩阵 # 创建一个二维列表表示邻接矩阵 n = 10 # 顶点数量 g = [[0] * n for _ in range(n)] # 添加一条边a-\u0026gt;b def add_edge(a, b): g[a][b] = 1 # 初始化 g = [[0] * n for _ in range(n)] 邻接表 # 创建一个列表表示邻接表 n = 10 # 顶点数量 h = [-1] * n e = [0] * n ne = [0] * n idx = 0 # 添加一条边a-\u0026gt;b def add_edge(a, b): global idx e[idx] = b ne[idx] = h[a] h[a] = idx idx += 1 # 初始化 idx = 0 h = [-1] * n 树和图的存储 # 邻接表表示的图 N = 100010 # 根据具体需求设置合适的最大节点数量 # 对于每个点k，开一个单链表，存储k所有可以走到的点。h[k]存储这个单链表的头结点 h = [-1] * N # 存储边的目标节点 e = [0] * N # 存储下一条边的索引 ne = [0] * N # 边的索引 idx = 0 # 添加一条边a-\u0026gt;b def add(a, b): global idx e[idx] = b ne[idx] = h[a] h[a] = idx idx += 1 # 初始化 idx = 0 for i in range(N): h[i] = -1 树和图的遍历 DFS def dfs(u): st[u] = True i = h[u] while i!=-1: j = e[i] if not st[j]: dfs(j) i = ne[i] BFS from collections import deque q = deque() st[1] = True q.append(1) while q: t = q.popleft() i = h[t] while i!=-1: j=e[i] if not st[j]: st[j] = True q.append(j) i=ne[i] 拓扑排序 from sys import stdin from collections import deque input = lambda:stdin.readline().strip() def topsort(): q = deque() res = [] for i in range(1, n+1): if ind[i]==0: res.append(i) q.append(i) while q: u = q.popleft() for v in g[u]: ind[v] -= 1 if ind[v]==0: q.append(v) res.append(v) return res n = int(input()) ind = [0]*(n+1) g = [[] for _ in range(n+1)] for i in range(1, n+1): a = list(map(int, input().split())) for j in range(len(a)-1): g[i].append(a[j]) ind[a[j]]+=1 res = topsort() print(*res, sep=\u0026#39; \u0026#39;) 奖金 from sys import stdin from collections import deque def topsort(): res = [] q = deque() ans = 0 for i in range(1, n+1): if ind[i]==0: res.append(i) q.append((i, 100)) ans += 100 while q: u, m = q.popleft() for v in g[u]: ind[v] -= 1 if ind[v]==0: q.append((v, m+1)) res.append(v) ans += m+1 if len(res)==n: print(ans) else: print(\u0026#34;Poor Xed\u0026#34;) n, m = map(int, input().split()) ind = [0]*(n+1) g = [[] for _ in range(n+1)] for i in range(m): a, b = map(int, input().split()) ind[a] += 1 g[b].append(a) topsort() LCA def lca(x,y): if dep[x] \u0026lt; dep[y]: x,y = y,x d = dep[x]-dep[y] while d: # 循环直到深度差为 0 v = d \u0026amp; -d # 获取 d 的最低位的 1 所在的位置 i = v.bit_length() - 1 # 计算最低位的位置索引 x = fa[i][x] # 将节点 x 上移到和节点 y 同一深度 d -= v # 更新深度差 if x==y: return x for k in range(K-1, -1, -1): if fa[k][x] != fa[k][y]: x = fa[k][x] y = fa[k][y] return fa[0][x] # 初始化深度以及父节点信息 dep[x]=dep[val]+1 dep[y]=dep[val]+1 fa[0][x] = val fa[0][y] = val for k in range(K-1): fa[k+1][x] = fa[k][fa[k][x]] # 自己的第2^(1+1)级父亲即为 自己的第2^(1)级父亲 的第2^(1)级父亲 fa[k+1][y] = fa[k][fa[k][y]] 祖孙询问 from sys import stdin from collections import deque, defaultdict from math import inf K = 17 N = int(4*10e4) + 10 dep = [inf]*(N) fa = [[0]*N for _ in range(K)] def bfs(): dep[0] = 0; dep[root] = 1 q = deque([root]) while q: u = q.popleft() for v in g[u]: if dep[v] \u0026gt; dep[u] + 1: dep[v] = dep[u] + 1 q.append(v) fa[0][v] = u for k in range(1, K-1): fa[k][v] = fa[k-1][fa[k-1][v]] def lca(x, y): if dep[x] \u0026lt; dep[y]: x, y = y, x d = dep[x] - dep[y] while d: v = d \u0026amp; -d i = v.bit_length() - 1 x = fa[i][x] d -= v if x==y: return x for k in range(K-1, -1, -1): if fa[k][x] != fa[k][y]: x = fa[k][x] y = fa[k][y] return fa[0][x] n = int(input()) g = defaultdict(list) for i in range(n): a, b = map(int, input().split()) if b==-1: root = a else: g[a].append(b) g[b].append(a) bfs() # print(dep) m = int(input()) for i in range(m): x, y = map(int, input().split()) res = lca(x, y) if res == x and res != y: print(1) elif res == y and res != x: print(2) else: print(0) 最短路 单元最短路\n​\t所有边权为正：\n​\t朴素版Dijkstra $O(n^2)$,堆优化版的Dijkstra $O(mlogn)$, ​\t存在负权边\n​\tBellman-Ford $O(nm)$, SPFA 队列优化的Bellman-Ford, 一般情况：$O(m)$ 最坏情况：$O(nm)$ 多元汇最短路：\n​\tFloyed $O(n^3)$ 朴素Dijkstra Dijkstra不能处理负权边：\nN = int(5e2)+10 INF = 0x3f3f3f3f g = [[INF]*N for _ in range(N)] #g = defaultdict(lambda:defaultdict(lambda:INF)) 同样的效果 dis = [INF]*N st = [False]*N def dijkstra(): dis[1]=0 for i in range(n-1): t=-1 for j in range(1,n+1): if not st[j] and (t==-1 or dis[j]\u0026lt;dis[t]): t=j for j in range(1,n+1): dis[j]=min(dis[j], dis[t] + g[t][j]) st[t]=True if dis[n]==INF: return -1 return dis[n] n, m = map(int, input().split()) for _ in range(m): x, y, z = map(int ,input().split()) g[x][y] = min(g[x][y], z) print(dijkstra()) 堆优化版Dijkstra from heapq import * import sys input = lambda:sys.stdin.readline().strip() N = 150010 INF = 0x3f3f3f3f e, ne, head, w, dis= [0]*N, [0]*N, [-1]*N, [0]*N, [INF]*N st = [False]*N idx=0 def add(a, b, x): global idx e[idx]=b w[idx]=x ne[idx]=head[a] head[a]=idx idx+=1 def dijkstra(): dis[1]=0 h=[] heappush(h, (0,1)) while h: dist, ver = heappop(h) if st[ver]: continue st[ver]=True i=head[ver] while i!=-1: j=e[i] if not st[j] and dis[j]\u0026gt;dist+w[i]: dis[j]=dist+w[i] heappush(h, (dis[j], j)) i=ne[i] if dis[n]==INF: print(-1) else: print(dis[n]) n, m = map(int, input().split()) for _ in range(m): x, y, z = map(int, input().split()) add(x,y,z) dijkstra() 另一种写法 from sys import stdin from math import inf from collections import deque, defaultdict from heapq import heappush, heappop input = lambda:stdin.readline().strip() def dijkstra(): h = [(0, 1)] dis[1] = 0 while h: dist, ver = heappop(h) if vis[ver]: continue vis[ver] = True for nx, z in g[ver]: if dis[nx] \u0026gt; dis[ver] + z: dis[nx] = dis[ver] + z heappush(h, (dis[nx], nx)) return dis[n] n, m = map(int, input().split()) dis = [inf]*(n+1) vis = [False]*(n+1) g = defaultdict(list) for i in range(m): x, y, z = map(int, input().split()) g[x].append((y, z)) res = dijkstra() print(res if res != inf else -1) Bellman-Ford # n表示点数，m表示边数 dist = [float(\u0026#39;inf\u0026#39;)] * (n + 1) # dist[x]存储1到x的最短路距离 # 边，a表示出点，b表示入点，w表示边的权重 edges = [] # 求1到n的最短路距离，如果无法从1走到n，则返回-1。 def bellman_ford(): dist[1] = 0 # 如果第n次迭代仍然会松弛三角不等式，就说明存在一条长度是n+1的最短路径，由抽屉原理，路径中至少存在两个相同的点，说明图中存在负权回路。 for i in range(n): for j in range(m): a, b, w = edges[j][\u0026#39;a\u0026#39;], edges[j][\u0026#39;b\u0026#39;], edges[j][\u0026#39;w\u0026#39;] if dist[b] \u0026gt; dist[a] + w: dist[b] = dist[a] + w if dist[n] \u0026gt; float(\u0026#39;inf\u0026#39;) / 2: return -1 return dist[n] SPFA from collections import defaultdict, deque import sys input = lambda:sys.stdin.readline().strip() N, INF = int(1e5+10), 0x3f3f3f3f dis, st = [INF]*N, [False]*N g=defaultdict(list) def spfa(): q=deque() q.append(1) st[1]=True dis[1]=0 while q: x=q.popleft() st[x]=False for y, z in g[x]: if dis[y]\u0026gt;dis[x]+z: dis[y]=dis[x]+z if not st[y]: st[y]=True q.append(y) if dis[n]==INF: print(\u0026#39;impossible\u0026#39;) else: print(dis[n]) n, m = map(int, input().split()) for _ in range(m): x, y, z = map(int, input().split()) g[x].append((y, z)) spfa() 判断负环 from sys import stdin from collections import deque, defaultdict from math import inf input = lambda:stdin.readline().strip() def spfa(): q = deque() for i in range(1, n+1): q.append(i) st[i] = True while q: x = q.popleft() st[x] = False for y, z in g[x]: if dis[y] \u0026gt; dis[x] + z: dis[y] = dis[x] + z cnt[y] = cnt[x] + 1 if cnt[y] \u0026gt;= n: return True if not st[y]: q.append(y) st[y] = True return False n, m = map(int, input().split()) g = defaultdict(list) cnt = [0]*(n+1) st = [False]*(n+1) dis = [0]*(n+1) for i in range(m): x, y, z = map(int, input().split()) g[x].append((y, z)) res = spfa() print(\u0026#34;Yes\u0026#34; if res else \u0026#34;No\u0026#34;) floyd from sys import stdin from math import inf def floyd(): for k in range(1, n+1): for i in range(1, n+1): for j in range(1, n+1): d[i][j] = min(d[i][j], d[i][k] + d[k][j]) n, m, k = map(int, input().split()) d = [[0 if i==j else inf for i in range(n+1)] for j in range(n+1)] for i in range(m): x, y, z = map(int, input().split()) d[x][y] = min(d[x][y], z) floyd() for i in range(k): x, y = map(int, input().split()) print(d[x][y] if d[x][y]!=inf else \u0026#34;impossible\u0026#34;) Prim from math import inf from sys import stdin def prim(): res = 0 dis[1] = 0 for i in range(n): t = -1 for j in range(1, n+1): if not st[j] and (t==-1 or dis[t] \u0026gt; dis[j]): t = j if i and dis[t]==inf: return inf if i: res += dis[t] st[t] = True for j in range(1, n+1): dis[j] = min(dis[j], g[t][j]) return res n, m = map(int, input().split()) g = [[inf]*(n+1) for _ in range(n+1)] dis = [inf]*(n+1) st = [False]*(n+1) for i in range(m): u, v, w = map(int, input().split()) g[u][v] = g[v][u] = min(w, g[u][v]) res = prim() if res==inf: print(\u0026#34;impossible\u0026#34;) else: print(res) Kruskal import sys input = lambda:sys.stdin.readline().strip() def find(x): while p[x] != x: p[x] = p[p[x]] x = p[x] return x def kruskal(): res, cnt = 0, 0 ans = [] for u, v, w in g: fu, fv = find(u), find(v) if fu != fv: res += w cnt += 1 p[fu] = fv ans.append((u, v, w)) ans.sort() if cnt == n-1: print(res) # print(ans) # 记录选择的是哪些边 else: print(\u0026#34;impossible\u0026#34;) n, m = map(int, input().split()) g = [] p = [i for i in range(n+1)] for i in range(m): u, v, w = map(int, input().split()) g.append((u, v, w)) g.sort(key = lambda e:e[2]) kruskal() 染色法 使用了深度优先搜索算法（DFS）来判断一个图是否是二分图\n二分图：顶点分为两个集合，边仅存在于两个不同的集合中，而集合内部都没有边。\nPython优先使用BFS，因为DFS会出现各种问题，爆栈，段错误（还没搞清楚原因）等\n这段代码使用了染色法来判断一个无向图是否为二分图。下面我来解释一下：\n题目大意： 给定一个无向图，判断是否可以将其顶点集合划分为两个不相交的子集，使得每条边的两个端点分别属于这两个子集。如果可以，则输出\u0026quot;Yes\u0026quot;，否则输出\u0026quot;No\u0026quot;。\n实现思路：\n使用邻接表 g 来表示无向图，其中 g[u] 存储与顶点 u 相连的所有顶点。 定义一个数组 color 来标记每个顶点的染色情况，初始值设为 -1 表示未染色。 定义一个 BFS 函数 bfs(u, c)，其中 u 表示起始顶点，c 表示初始颜色。该函数使用 BFS 遍历图，并将顶点染色，保证相邻顶点颜色不同。 在主体部分，遍历所有顶点，对于每个未染色的顶点，调用 bfs 函数进行染色。如果染色过程中发现相邻顶点颜色相同，则返回 \u0026ldquo;No\u0026rdquo;，表示无法划分为二分图；否则返回 \u0026ldquo;Yes\u0026rdquo;。 import sys from collections import deque, defaultdict input = lambda:sys.stdin.readline().strip() N = int(1e5)+10 g = defaultdict(list) color = [-1]*N def bfs(u, c): color[u] = c q = deque() q.append((u, c)) while q: cur, col = q.popleft() for nx in g[cur]: if color[nx]==-1: color[nx] = 1-col q.append((nx, 1-col)) elif color[nx]==col: return False return True n, m = map(int, input().split()) for i in range(m): u, v = map(int, input().split()) # if u==v: #***自环不能去掉*** # continue if u not in g[v]: g[v].append(u) if v not in g[u]: g[u].append(v) for i in range(1, n+1): if color[i]==-1: if not bfs(i, 0): print(\u0026#34;No\u0026#34;) exit() print(\u0026#34;Yes\u0026#34;) 匈牙利算法 题目大意： 给定一个二分图，其中左侧顶点集合为 (N_1)，右侧顶点集合为 (N_2)，图中存在一些边。需要找到尽可能多的匹配，使得左侧的每个顶点最多与一个右侧的顶点相连，而右侧的每个顶点最多与一个左侧的顶点相连。\n实现思路：\n使用一个二维数组 g 存储图的邻接表表示。其中 g[u] 表示与左侧顶点 u 相连的所有右侧顶点的集合。 定义一个函数 find(x)，用于从左侧顶点 x 开始尝试寻找增广路径，如果找到了增广路径就返回 True，否则返回 False。 在主体部分，遍历左侧的每个顶点，对每个顶点调用 find 函数进行匹配，若成功匹配，则匹配数加一。 from sys import stdin from collections import defaultdict def find(u): for v in g[u]: if not st[v]: st[v] = True if mat[v]==0 or find(mat[v]): mat[v] = u return True return False n1, n2, m = map(int, input().split()) mat = [0]*(n2 + 1) g = defaultdict(list) for i in range(m): u, v = map(int, input().split()) g[u].append(v) res = 0 for i in range(1, n1+1): st = [False]*(n2 + 1) if find(i): res += 1 print(res) DFS之连通性 题意：在一个给定迷宫中，从起点A到终点B是否存在一条路径的问题。迷宫由一个由 '.' 和 '#' 构成的矩阵表示，其中 '.' 表示可通行的格点，'#' 表示不可通行的格点。Extense只能向东南西北四个方向移动到相邻的可通行格点上，而且要求起点和终点都是可通行的。你需要编写一个程序来确定在给定的迷宫中，是否存在一条从A到B的路径。\nimport sys input = lambda:sys.stdin.readline().strip() sys.setrecursionlimit(150000) dir = [(-1, 0), (0, 1), (1, 0), (0, -1)] def dfs(x, y): if g[x][y]==\u0026#39;#\u0026#39; or vis[x][y]: return False if (x, y)==end: return True vis[x][y] = True for i in range(4): a, b = x + dir[i][0], y+dir[i][1] if 0\u0026lt;=a\u0026lt;n and 0\u0026lt;=b\u0026lt;n: if dfs(a, b): return True return False k = int(input()) N = 110 g = [[] for _ in range(N)] for _ in range(k): n = int(input()) vis = [[False]*(n+1) for _ in range(n+1)] for i in range(n): g[i] = list(input()) x1, y1, x2, y2 = map(int, input().split()) end = (x2, y2) if dfs(x1, y1): print(\u0026#34;YES\u0026#34;) else: print(\u0026#34;NO\u0026#34;) 魔板 题目大意：给定一个 8 个格子的魔板，每个格子有一种颜色，用 1 到 8 的整数表示。有三种基本操作可以改变魔板的状态：A：交换上下两行；B：将最右边的一列插入到最左边；C：魔板中央对的4个数作顺时针旋转。现在给定一个目标状态，求用最少的基本操作完成基本状态到目标状态的转换，并输出基本操作序列。\n实现思路：\n首先实现三种基本操作 A、B、C 的函数。 使用广度优先搜索（BFS）算法来找到从基本状态到目标状态的最短操作序列。 使用一个队列存储待处理状态，并使用一个字典记录每个状态的前驱状态和执行的操作。 在每一步中，尝试对当前状态进行三种基本操作，得到新的状态，如果新状态未被访问过，则将其加入队列，并记录其前驱状态和操作。 当找到目标状态时，根据前驱状态回溯得到最短操作序列。 输出最短操作序列的长度和具体操作序列。 from collections import deque def A(t): return t[::-1] def B(t): return t[3] + t[:3] + t[5:] + t[4] def C(t): return t[0] + t[6] + t[1] + t[3] + t[4] + t[2] + t[5] + t[7] pre = dict() def bfs(): q = deque() q.append(st) while q: t = q.popleft() if t==ed: break m = [A(t), B(t), C(t)] for i in range(3): if m[i] not in pre: pre[m[i]] = (chr(65+i), t) q.append(m[i]) nums = input().split() ed = \u0026#39;\u0026#39;.join(nums) st = \u0026#34;12345678\u0026#34; bfs() cnt = 0 res = \u0026#34;\u0026#34; while ed != st: cnt+=1 res = pre[ed][0] + res ed = pre[ed][1] print(cnt) if cnt: print(res) 单词接龙 题目大意：给定一组单词和一个开头的字母，要求找出以这个字母开头的最长的“龙”，每个单词最多被使用两次。在构成龙时，两个单词相连时，它们的重合部分合并为一部分，但重合部分的长度必须大于等于1且小于两个单词的长度。\n实现思路：\n首先读入输入数据，包括单词数 n、n 个单词以及开头的字母。 构建一个字典 g，用于存储每个单词对应的可连接的单词以及对应的重合部分的长度。 对于每一对单词，比较它们的重合部分，如果符合条件，则将其加入字典 g 中。 使用深度优先搜索（DFS）来搜索以开头字母开头的最长的“龙”。 在搜索过程中，使用一个字典 cnt 来记录每个单词的使用次数，每个单词最多只能被使用两次。 递归搜索每个可连接的单词，并更新最长“龙”的长度。 最终输出最长“龙”的长度。 from collections import defaultdict n = int(input()) wds = [] for i in range(n): wds.append(input()) st = input() g = {w:[] for w in wds} for i in range(n): for j in range(n): for k in range(1, min( len(wds[i]), len(wds[j]) )): if wds[i][-k:] == wds[j][:k]: g[wds[i]].append((wds[j], k)) cnt = defaultdict(int) def dfs(dra, x): global ans cnt[x] += 1 ans = max(ans, len(dra)) for nx, k in g[x]: if cnt[nx] \u0026lt; 2: dfs(dra + nx[k:], nx) cnt[x] -= 1 ans = 0 for w in wds: if w[0] == st: dfs(w, w) print(ans) 分成互质组 题目大意：给定 n 个正整数，要求将它们分组，使得每组中任意两个数互质。求最少需要分成多少个组。\n实现思路：\n首先读入输入数据，包括正整数的个数 n 和 n 个正整数。 使用深度优先搜索（DFS）来搜索分组的方法。 构建一个列表 g，用于存储分组情况，每个分组是一个列表，列表中存储分组中的数。 编写 DFS 函数，在函数中递归尝试将当前数放入已有的分组或新建一个分组。 在递归过程中，如果当前数可以和某个分组中的所有数互质，则将当前数加入该分组，并继续递归。 如果当前数无法加入任何分组，则新建一个分组，并继续递归。 当所有数都被分组完毕时，更新最少需要的组数。 最终输出最少需要的组数。 from math import gcd n = int(input()) a = list(map(int, input().split())) g = [] def dfs(u, i): global ans if i==n: ans = min(ans, u) return if u\u0026gt;=ans: return for j in range(u): cnt = sum(1 for k in g[j] if gcd(a[i], k)==1) if cnt==len(g[j]): g[j].append(a[i]) dfs(u, i+1) g[j].pop() g.append([a[i]]) dfs(u+1, i+1) g.pop() ans = n dfs(0, 0) print(ans) 迭代加深 加成序列 题目大意：给定一个整数 n，找出满足以下条件的最小长度的“加成序列”：序列的第一个元素为1，最后一个元素为 n，序列中的元素满足每个元素都可以表示为序列中其他两个元素的和。\n实现思路：\n定义一个深度优先搜索（DFS）函数 dfs，用于搜索符合条件的加成序列。 在 dfs 函数中，使用一个列表 path 来记录当前搜索的加成序列，初始化 path[0] = 1。 递归地搜索加成序列的下一个元素，使得新的元素是前面元素的两两相加的结果，并满足条件 path[u] \u0026lt;= n，其中 u 表示当前搜索的位置。 如果搜索成功，即找到了符合条件的加成序列，返回 True；否则返回 False。 在主程序中，不断读取输入的 n，并通过调用 dfs 函数来搜索符合条件的加成序列。 输出满足条件的加成序列。 def dfs(u): if u==dep: return path[u-1]==n vis = [False]*(n+1) for i in range(u-1, -1, -1): for j in range(i, -1, -1): s = path[i] + path[j] if s\u0026gt;n or s\u0026lt;=path[u-1] or vis[s]: continue vis[s] = True path[u] = s if dfs(u+1): return True return False path = [0]*(110) path[0] = 1 while True: n = int(input()) if not n: break dep = 1 while not dfs(1): dep += 1 print(*path[:dep]) 双向DFS 送礼物 题目大意：达达帮翰翰送礼物，他一次可以搬动的重量之和不超过 W，一共有 N 个礼物，其中第 i 个礼物的重量是 G[i]。求达达在他的力气范围内一次性能搬动的最大重量。\n实现思路：\n定义两个深度优先搜索（DFS）函数 dfs1 和 dfs2，用于求解达达一次性能搬动的最大重量。 dfs1 函数用于遍历前一半的礼物，求得所有可能的搬动重量之和，并存储在集合 wgh 中。 dfs2 函数用于遍历后一半的礼物，并通过二分查找在 wgh 中找到合适的搬动重量，求得最大重量。 在主程序中，首先读入输入的 W 和 N，然后读入 N 个礼物的重量，并按照重量从大到小排序。 调用 dfs1 和 dfs2 函数求解最大重量，并输出结果。 def dfs1(u, tot): if u\u0026gt;k: wgh.add(tot) return if tot + a[u] \u0026lt;= w: dfs1(u+1, tot + a[u]) dfs1(u+1, tot) def dfs2(u, tot): global ans if u\u0026gt;=n: l, r = 0, cnt-1 while l\u0026lt;r: mid = (l+r+1)\u0026gt;\u0026gt;1 if wgh[mid] + tot \u0026lt;= w: l = mid else: r = mid - 1 ans = max(ans, wgh[r] + tot) return if a[u] + tot \u0026lt;= w: dfs2(u+1, a[u] + tot) dfs2(u+1, tot) w, n = map(int, input().split()) a = [] for i in range(n): a.append(int(input())) a.sort(reverse = True) wgh = set() k = n//2 dfs1(0, 0) wgh = sorted(list(wgh)) cnt = len(wgh) ans = -1 dfs2(k+1, 0) print(ans) 37. 解数独 \\166. 数独 题目大意：数独是一种益智游戏，要求填写一个9×9的网格，使得每行、每列、每个3×3的九宫格内数字1∼9均恰好出现一次。\n实现思路：该实现采用深度优先搜索（DFS）的方法解决数独问题。首先，通过将每个数字映射到二进制位来进行位运算，以便快速获取已填充数字的状态。然后，利用DFS递归填充数独中的空白格子，优先选择当前空白格子填充数字的选择空间较小的位置。递归的终止条件是所有空白格子都填充完毕。\nimport sys N = 9 M = 1 \u0026lt;\u0026lt; N row, col, cell = [0] * N, [0] * N, [[0] * 3 for _ in range(3)] mp = dict() ones = [0] * M for i in range(N): mp[1 \u0026lt;\u0026lt; i] = i for i in range(1 \u0026lt;\u0026lt; N): for j in range(N): ones[i] += (i \u0026gt;\u0026gt; j) \u0026amp; 1 def lowbit(x): return x \u0026amp; -x def get(x, y): return row[x] \u0026amp; col[y] \u0026amp; cell[x // 3][y // 3] def draw(x, y, t, flag): global st, row, col, cell if flag: st[x * N + y] = chr(49 + t) else: st[x * N + y] = \u0026#34;.\u0026#34; v = 1 \u0026lt;\u0026lt; t if not flag: v = -v row[x] -= v col[y] -= v cell[x // 3][y // 3] -= v def dfs(cnt): global st if not cnt: return True minv = 10 for i in range(N): for j in range(N): if st[i * N + j] == \u0026#34;.\u0026#34;: state = get(i, j) if ones[state] \u0026lt; minv: minv = ones[state] x, y = i, j i = get(x, y) while i: t = mp[lowbit(i)] draw(x, y, t, True) if dfs(cnt - 1): return True draw(x, y, t, False) i -= lowbit(i) return False while True: st = sys.stdin.readline().strip() if st == \u0026#34;end\u0026#34;: break st = list(st) cnt = 0 for i in range(N): row[i] = col[i] = M - 1 for i in range(3): for j in range(3): cell[i][j] = M - 1 for i in range(N): for j in range(N): if st[i * N + j] != \u0026#34;.\u0026#34;: t = int(st[i * N + j]) - 1 draw(i, j, t, True) else: cnt += 1 dfs(cnt) print(\u0026#34;\u0026#34;.join(st)) 最短路 188. 武士风度的牛 题目大意：农民 John 想交易他的一头被 Don 称为 The Knight 的牛。这头牛有特殊能力，可以按照象棋中马的走法跳跃。农场被表示为一个二维坐标图，其中包含了树、灌木、石头以及草的位置。The Knight 起始位置为 K，草的位置为 H。任务是确定 The Knight 要跳多少次才能到达草的位置。\n实现思路：\n首先解析输入，得到农场的列数和行数，以及地图信息，包括障碍物和目标位置（草的位置）。 使用广度优先搜索（BFS）算法来找到从起始位置到达目标位置的最短路径。 初始化一个队列，并将起始位置加入队列中。 在循环中，每次从队列中取出一个位置，并尝试向八个方向跳跃（象棋中马的所有可能走法），如果跳跃后的位置合法且没有障碍物且未被访问过，则将该位置加入队列，并标记为已访问。 当取出的位置为目标位置时，输出跳跃的次数，即最短路径的长度，然后退出循环。 如果队列为空仍未找到目标位置，则说明数据保证一定有解，不需要处理这种情况。 from collections import deque dir = [(-2, 1), (-1, 2), (1, 2), (2, 1), (2, -1), (1, -2), (-1, -2), (-2, -1)] c, r = map(int, input().split()) g = [[] for _ in range(r)] vis = [[False]*(c+1) for _ in range(r+1)] for i in range(r): g[i] = list(input()) for j, ch in enumerate(g[i]): if ch==\u0026#39;H\u0026#39;: end = (i, j) if ch==\u0026#39;K\u0026#39;: start = (i, j) q = deque() q.append((*start, 0)) while q: x, y, d= q.popleft() if (x, y)==end: print(d) break for i in range(8): a, b = x + dir[i][0], y + dir[i][1] if 0\u0026lt;=a\u0026lt;r and 0\u0026lt;=b\u0026lt;c: if g[a][b]!=\u0026#39;*\u0026#39; and not vis[a][b]: vis[a][b] = True q.append((a, b, d+1)) 多源BFS 题目大意：给定一个 N 行 M 列的 01 矩阵 A，定义矩阵中每个位置与所有值为1的位置的曼哈顿距离。曼哈顿距离为该位置与所有值为1的位置行坐标之差的绝对值与列坐标之差的绝对值之和。\n实现思路：\n首先读入矩阵的行数和列数，以及矩阵本身。 使用BFS（广度优先搜索）来计算每个位置到所有值为1的位置的距离。 初始化一个队列，将所有值为1的位置入队，距离初始化为0。 对队列进行BFS遍历，每次取出队首元素，计算其周围四个方向的位置，若位置合法且为0且未被访问过，则更新距离并入队。 最终输出距离矩阵B。 import sys from collections import deque input = lambda:sys.stdin.readline().strip() N = int(1e3+10) g = [[] for _ in range(N)] dis = [[-1]*N for _ in range(N)] n, m = map(int, input().split()) for i in range(1, n+1): g[i] = [0] + list(input()) q = deque() for i in range(1, n+1): for j in range(1, m+1): if g[i][j] == \u0026#39;1\u0026#39;: q.append((i, j, 0)) dis[i][j] = 0 dx = [1, 0, -1, 0] dy = [0, 1, 0, -1] while q: x, y, d = q.popleft() for i in range(4): xx = x+dx[i]; yy = y+dy[i] if xx\u0026gt;0 and xx\u0026lt;=n and yy\u0026gt;0 and yy\u0026lt;=m: if g[xx][yy] == \u0026#39;0\u0026#39; and dis[xx][yy] == -1: dis[xx][yy] = d+1 q.append((xx, yy, d+1)) for i in range(1, n+1): print(*dis[i][1:m+1]) 双端队列BFS175. 电路维修 题目大意：有一个电路板，由 R 行 C 列的网格组成，每个格点都是电线的接点，每个格子包含一个可旋转的电子元件，电子元件连接一条对角线上的两个接点。达达希望通过旋转最少数量的元件，使电源与发动装置通过若干条短缆相连，但因为某些元件的方向不正确，导致电路板可能处于断路的状态。需要计算最少旋转的次数来使得电源和发动机之间连通。\n实现思路：可以使用广度优先搜索（BFS）来解决此问题。首先，初始化一个二维数组 d 用于存储从起点到每个点的最短距离。然后，利用广度优先搜索的方式遍历电路板的每个格点，如果发现某个格点的状态需要改变（即当前格点的元件方向与所需方向不一致），则更新该格点的状态并将其加入到队列中。最后，返回终点的最短距离即可，如果无法到达终点，则输出 \u0026ldquo;NO SOLUTION\u0026rdquo;。\nimport sys input = lambda:sys.stdin.readline().strip() from collections import deque dire = [(-1, -1), (-1, 1), (1, 1), (1, -1)] mov = [(-1, -1), (-1, 0), (0, 0), (0, -1)] ch = \u0026#34;\\\\/\\\\/\u0026#34; def bfs(): dq = deque() d = [[float(\u0026#39;inf\u0026#39;)]*(c+1) for _ in range(r+1)] d[0][0] = 0 dq.append((0, 0)) while dq: x, y = dq.popleft() for i in range(4): xx, yy = x + dire[i][0], y + dire[i][1] if 0\u0026lt;=xx\u0026lt;=r and 0\u0026lt;=yy\u0026lt;=c: j, k = x+mov[i][0], y + mov[i][1] w = 1 if g[j][k] != ch[i] else 0 if d[xx][yy] \u0026gt; d[x][y] + w: d[xx][yy] = d[x][y] + w if w: dq.append((xx, yy)) else: dq.appendleft((xx, yy)) return -1 if d[r][c] == float(\u0026#39;inf\u0026#39;) else d[r][c] t = int(input()) for _ in range(t): r, c = map(int, input().split()) g = [input() for _ in range(r)] res = bfs() print(res if res != -1 else \u0026#34;NO SOLUTION\u0026#34;) A* 179. 八数码 题目大意：在一个 3×3 的网格中，数字 1∼8 与一个 x 恰好不重不漏地分布在这个网格中。可以通过把 x 与其上、下、左、右四个方向之一的数字交换（如果存在）来改变网格的状态，目标是通过最少的移动次数，使得网格变为正确排列。\n实现思路：使用 A* 算法来解决该问题。首先，定义一个启发函数用于估计当前状态到达目标状态的最小移动次数。然后，利用 A* 算法进行搜索，不断更新当前状态到达目标状态的最小移动次数，并记录每一步的移动操作。最后，输出得到的完整行动记录即可。如果不存在解决方案，则输出 \u0026ldquo;unsolvable\u0026rdquo;。\nfrom heapq import heappush, heappop d = [(-1, 0), (0, 1), (1, 0), (0, -1)] op = \u0026#34;urdl\u0026#34; def heuristic(state): # 启发式 ans = 0 for i, st in enumerate(state): if st==\u0026#39;x\u0026#39;: continue t = int(st)-1 ans += abs(t//3 - i//3) + abs(t%3 - i%3) return ans def astar(): dis, pre = dict(), dict() end = \u0026#34;12345678x\u0026#34; dis[start] = 0 h = [] heappush(h, (heuristic(start), start)) while h: _, state = heappop(h) if state == end: break x, y = divmod(state.index(\u0026#39;x\u0026#39;), 3) src = state for i in range(4): a, b = x+d[i][0], y+d[i][1] if 0\u0026lt;=a\u0026lt;3 and 0\u0026lt;=b\u0026lt;3: ls = list(state) ls[3*x+y], ls[3*a+b] = ls[3*a+b], ls[3*x+y] new_state = \u0026#39;\u0026#39;.join(ls) if new_state not in dis or dis[new_state] \u0026gt; dis[src] + 1: dis[new_state] = dis[src] + 1 pre[new_state] = (op[i], src) heappush(h, (dis[new_state] + heuristic(new_state), new_state)) ans = \u0026#39;\u0026#39; while end != start: ans = pre[end][0] + ans end = pre[end][1] return ans start = \u0026#39;\u0026#39;.join(input().split()) s = start.replace(\u0026#39;x\u0026#39;, \u0026#39;\u0026#39;) cnt = sum(s[i]\u0026gt;s[j] for i in range(8) for j in range(i, 8)) if cnt\u0026amp;1: print(\u0026#34;unsolvable\u0026#34;) else: print(astar()) IDA* 排书 寻找估价函数， 一定小于等于真实值，并越接近真实值\n这道题目要求给定 n 本书，每本书编号为 1 到 n，初始状态下，书是任意排列的。每次操作可以抽取其中连续的一段，再把这段插入到其他某个位置。目标是将书按照 1 到 n 的顺序依次排列。要求计算最少需要多少次操作。\n实现思路：\n首先定义一个函数 f()，用来计算当前状态与目标状态之间的最小操作次数。这个函数通过遍历每对相邻书的编号，判断它们是否连续，如果不连续则需要进行一次操作。最后返回操作次数。 然后定义一个深度优先搜索函数 dfs(u)，其中 u 表示当前搜索的深度。在每次搜索中，我们需要判断当前深度加上到目标状态的最小操作次数是否超过已经得到的最小操作次数，如果超过则直接返回 False，否则继续搜索。 在 dfs 函数中，首先判断如果当前状态已经是目标状态，则直接返回 True。否则，我们遍历所有可能的操作，从中选择一种操作方式，然后递归调用 dfs 函数。 在主程序中，依次读入每组数据，然后进行深度优先搜索，直到得到结果或者搜索深度达到 5。最后根据得到的结果输出最小操作次数或者 \u0026ldquo;5 or more\u0026rdquo;。 def f(): res = 0 for i in range(n-1): if a[i] != a[i+1]-1: res += 1 return (res+2)//3 def dfs(u): global a if u + f() \u0026gt; dep: return False if f()==0: return True for leng in range(n, 0, -1): for l in range(n-leng+1): r = l+leng-1 for k in range(l, r+1): bk = a[:] j = l for i in range(k+1, r+1): a[j] = bk[i] j+=1 for i in range(l, k+1): a[j] = bk[i] j+=1 if dfs(u+1): return True a = bk[:] t = int(input()) while t: t-=1 n = int(input()) a = list(map(int, input().split())) dep = 0 while dep\u0026lt;5 and not dfs(0): dep += 1 if dep \u0026lt; 5: print(dep) else: print(\u0026#34;5 or more\u0026#34;) ","permalink":"https://kennems.github.io/zh/posts/tech/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0%E4%B8%89%E5%9B%BE%E8%AE%BApython%E5%AE%9E%E7%8E%B0/","summary":"算法笔记（三）——图论（Python实现） 图论 树的存储 邻接矩阵 # 创建一个二维列表表示邻接矩阵 n = 10 # 顶点数量 g = [[0] * n for _ in range(n)] # 添加一条边a","title":"算法笔记（三）——图论（Python实现）"},{"content":"算法笔记（四）——数学（Python实现） 数学 试除法判定质数 def check(x): # 判定 if x\u0026lt;2: return False for i in range(2, int(x**0.5)+1): if x%i==0: return False return True n = int(input()) for i in range(n): x = int(input()) if check(x): print(\u0026#34;Yes\u0026#34;) else: print(\u0026#34;No\u0026#34;) 试除法分解质因数 def get(x): #分解 for i in range(2, int(x**0.5)+1): if x%i==0: cnt=0 while x%i==0: x//=i cnt+=1 print(i, cnt, sep=\u0026#39; \u0026#39;) if x\u0026gt;1: print(x, 1, sep=\u0026#39; \u0026#39;) n = int(input()) for i in range(n): x = int(input()) get(x) print() 线性筛法求素数 N = int(1e6+10) primes = [] st = [False]*N def get(n): for i in range(2, n+1): if not st[i]: primes.append(i) for j in range(len(primes)): if i*primes[j]\u0026gt;n: break st[i*primes[j]]=True if i%primes[j]==0: break n = int(input()) get(n) print(len(primes)) 朴素筛法求素数 N = 1000005 # 根据需要修改 primes = [] # 存储所有素数 st = [False] * N # st[x]存储x是否被筛掉 # 筛素数函数 def get_primes(n): global primes global st for i in range(2, n + 1): if not st[i]: primes.append(i) for j in range(i, n + 1, i): st[j] = True # Example usage: # get_primes(100) # print(primes) 试除法求所有约数 def get(x): res = [1] for i in range(2, int(x**0.5)+1): if x%i==0: res.append(i) if i!=x//i: res.append(x//i) if x\u0026gt;1: res.append(x) return sorted(res) n = int(input()) for i in range(n): x = int(input()) res = get(x) print(*res) 约数个数和约数之和 如果 N = p1^c1 * p2^c2 * ... *pk^ck\r约数个数： (c1 + 1) * (c2 + 1) * ... * (ck + 1)\r约数之和： (p1^0 + p1^1 + ... + p1^c1) * ... * (pk^0 + pk^1 + ... + pk^ck) 约数之和 题目大意：给定两个自然数 A 和 B，定义 S 为 A*B 的所有约数之和。求 S mod 9901 的值。\n实现思路：首先，我们需要编写一个快速幂函数 qpow(a, k) 来计算幂运算的结果。然后，定义一个函数 calc(p, k) 来计算 p^k 的结果并对 mod 取余。在主程序中，我们对 A 进行质因数分解，并计算每个质因数的幂次方与 B 的乘积，并累加到最终结果 res 中。最后，输出 res 的值对 mod 9901 取余的结果。\nimport sys input = lambda:sys.stdin.readline().strip() mod = 9901 def qpow(a, k): res = 1 while k: if k\u0026amp;1: res = res*a%mod a = a*a%mod k\u0026gt;\u0026gt;=1 return res def calc(p, k): if k==0: return 1 if k%2==1: return (1+qpow(p, k//2+1)) * calc(p, k//2) % mod return (qpow(p, k)%mod + (1 + qpow(p, (k-1)//2+1)) * calc(p, (k-1)//2)) % mod a, b = map(int, input().split()) res = 1 for i in range(2, a+1): if a\u0026lt;i: break s = 0 while a%i==0: s+=1 a//=i if s: res = res * calc(i, s*b) % mod print(res if a else 0) gcd def gcd(a, b): return gcd(b, a % b) if b else a 求欧拉函数 def get(x): res = x for i in range(2, int(x**0.5)+1): if x%i==0: res = res//i*(i-1) while x%i==0: x//=i if x\u0026gt;1: res = res//x*(x-1) return res n = int(input()) for i in range(n): x = int(input()) print(get(x)) 筛法求欧拉函数 N = int(1e6+10) primes = [] euler = [0]*N st = [False]*N cnt = 0 def get(n): euler[1] = 1 for i in range(2, n+1): if not st[i]: primes.append(i) euler[i] = i-1 for j in range(len(primes)): t = primes[j]*i if t\u0026gt;n: break st[t] = True if i%primes[j]==0: euler[t] = euler[i]*primes[j] break euler[t] = euler[i]*(primes[j]-1) n = int(input()) get(n) for i in range(1,n+1): cnt+=euler[i] print(cnt) 快速幂 # 快速幂函数 def qmi(m, k, p): res, t = 1 % p, m while k: if k \u0026amp; 1: res = res * t % p t = t * t % p k \u0026gt;\u0026gt;= 1 return res # Example usage: # result = qmi(2, 10, 1000000007) # print(result) 拓展欧几里得 # 求 x, y，使得 ax + by = gcd(a, b) def exgcd(a, b, x, y): if b == 0: x[0], y[0] = 1, 0 return a d = exgcd(b, a % b, y, x) y[0] -= (a // b) * x[0] return d # Example usage: # x = [0] # y = [0] # gcd = exgcd(30, 20, x, y) # print(\u0026#34;x:\u0026#34;, x[0], \u0026#34;y:\u0026#34;, y[0], \u0026#34;gcd:\u0026#34;, gcd) P1082 [NOIP2012 提高组] 同余方程 题目描述：求解关于x的同余方程$ax ≡ 1 (mod b)$的最小正整数解。\n实现思路：这个问题可以转化为求解$ax + by = gcd(a, b)$的解，其中x就是我们需要的结果。可以利用扩展欧几里得算法来求解这个方程。具体地，通过递归的方式求解出最大公约数，并且求解出使得$ax + by = gcd(a, b)$成立的整数x和y。然后通过对x取模b的操作得到最小正整数解x。最后输出x即可。\n# 求 x, y，使得 ax + by = gcd(a, b) def exgcd(a, b, x, y): if b == 0: x[0], y[0] = 1, 0 return a d = exgcd(b, a % b, y, x) y[0] -= (a // b) * x[0] return d a, b = map(int, input().split()) x, y = [0], [0] exgcd(a, b, x, y) x = x[0] x = (x%b+b)%b print(x) 递推法求组合数 N = int(2e3)+10 mod = int(1e9)+7 c = [[0]*N for _ in range(N)] def get(n): for i in range(n+1): for j in range(i+1): if j==0: c[i][j] = 1 else: c[i][j] = (c[i-1][j]+c[i-1][j-1])%mod MN = int(2e3) get(MN) n = int(input()) for i in range(n): a, b = map(int, input().split()) print(c[a][b]) 通过预处理逆元的方式求组合数 mod = int(1e9)+7 N = int(2e5)+10 fact, infact = [0]*N, [0]*N def qpow(a, k, p): res = 1 while k: if k\u0026amp;1: res = (res*a)%p a = (a*a)%p k\u0026gt;\u0026gt;=1 return res def init(): fact[0] = infact[0] = 1 for i in range(1, N): fact[i] = (fact[i-1]*i)%mod infact[i] = (infact[i-1]*qpow(i, mod-2, mod))%mod def C(n, m): if n\u0026lt;m: return 0 return (fact[n]*infact[m]%mod*infact[n-m]%mod) init() n = int(input()) for i in range(n): a, b = map(int, input().split()) print(C(a, b)) Lucas定理 p = 1000000007 # 根据需要调整 # 快速幂模板 def qmi(a, k): res = 1 while k: if k \u0026amp; 1: res = (res * a) % p a = (a * a) % p k \u0026gt;\u0026gt;= 1 return res # 通过定理求组合数C(a, b) def C(a, b): res = 1 for i in range(1, b + 1): res = (res * (a - i + 1)) % p res = (res * qmi(i, p - 2)) % p return res # Lucas定理计算组合数 def lucas(a, b): if a \u0026lt; p and b \u0026lt; p: return C(a, b) return (C(a % p, b % p) * lucas(a // p, b // p)) % p # Example usage: # result = lucas(10, 5) # 计算组合数 C(10, 5) # print(result) 分解质因数法求组合数 分解质因数法计算组合数：\n获取小于等于 a 的所有质数。 初始化质数的幂次列表 s。 对每个质数 p，计算在 a!，b! 和 (a-b)! 中 p 的幂次，通过 get(a, p) - get(b, p) - get(a - b, p) 得到组合数分解中 p 的总幂次。 通过快速幂计算每个质数 p 的幂次乘积，最终得到组合数。 def get_primes(n): primes = [] st = [False]*(n+1) for i in range(2, n+1): if not st[i]: primes.append(i) for p in primes: if i*p\u0026gt;n: break st[i*p] = True if i%p==0: break return primes def get(n, p): cnt = 0 while n: cnt += n//p n//=p return cnt def qpow(a, k): res = 1 while k: if k\u0026amp;1: res = res * a a = a*a k\u0026gt;\u0026gt;=1 return res def calc(a, b): primes = get_primes(a) n = len(primes) res = 1 for i, p in enumerate(primes): s = get(a, p) - get(b, p) - get(a-b, p) res *= qpow(p, s) return res a, b = map(int, input().split()) print(calc(a, b)) 高斯消元 eps = 1e-8 # 根据需要调整 # a 是增广矩阵，n 是矩阵维度 def gauss(a, n): c, r = 0, 0 for c in range(n): t = r for i in range(r, n): if abs(a[i][c]) \u0026gt; abs(a[t][c]): t = i if abs(a[t][c]) \u0026lt; eps: continue for i in range(c, n + 1): a[r][i], a[t][i] = a[t][i], a[r][i] for i in range(n, c - 1, -1): a[r][i] //= a[r][c] for i in range(r + 1, n): if abs(a[i][c]) \u0026gt; eps: for j in range(n, c - 1, -1): a[i][j] -= a[r][j] * a[i][c] r += 1 if r \u0026lt; n: for i in range(r, n): if abs(a[i][n]) \u0026gt; eps: return 2 # 无解 return 1 # 有无穷多组解 for i in range(n - 1, -1, -1): for j in range(i + 1, n): a[i][n] -= a[i][j] * a[j][n] return 0 # 有唯一解 # Example usage: # a = [[2, 1, -1, 8], [-3, -1, 2, -11], [-2, 1, 2, -3]] # n = 3 # result = gauss(a, n) # print(result) ","permalink":"https://kennems.github.io/zh/posts/tech/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0%E5%9B%9B%E6%95%B0%E5%AD%A6python%E5%AE%9E%E7%8E%B0/","summary":"算法笔记（四）——数学（Python实现） 数学 试除法判定质数 def check(x): # 判定 if x\u0026lt;2: return False for i in range(2, int(x**0.5)+1): if x%i==0: return False return True n = int(input()) for i in range(n): x = int(input()) if check(x): print(\u0026#34;Yes\u0026#34;) else: print(\u0026#34;No\u0026#34;) 试除法分解","title":"算法笔记（四）——数学（Python实现）"},{"content":"算法笔记（五）——DP（Python实现） DP 数字三角形 f=[] n=int(input()) for _ in range(n): f.append([int(x) for x in input().split()]) for i in range(n-2,-1,-1): for j in range(i+1): f[i][j]=max(f[i+1][j], f[i+1][j+1])+f[i][j] print(f[0][0]) 背包 空间优化成1维之后，只有完全背包问题的体积是从小到大循环的\n01背包 N = int(1e3+10) f=[ 0 for _ in range(N) ] n,v=map(int,input().split()) for i in range(n): vi,wi=map(int,input().split()) for j in range(v, vi-1,-1): f[j]=max(f[j],f[j-vi]+wi) print(f[v]) 多重背包 单调队列 MN = int(2e4+10) f=[0 for _ in range(MN)] q=[0 for _ in range(MN)] g=[0 for _ in range(MN)] N,V = map(int, input().split()) for i in range(N): v,w,s=map(int, input().split()) g=f[:] for j in range(v): hh,tt=0,-1 for k in range(j,V+1,v): while hh\u0026lt;=tt and q[hh]\u0026lt;k-s*v: hh+=1 while hh\u0026lt;=tt and g[q[tt]]+(k-q[tt])//v*w \u0026lt;= g[k]: tt-=1 tt+=1 q[tt]=k f[k]=g[q[hh]]+(k-q[hh])//v*w print(f[V]) 二维费用背包 N = int(1e2+10) f=[[0]*N for _ in range(N)] n,V,M = map(int , input().split()) for i in range(n): v,m,w=map(int , input().split()) for j in range(V,v-1,-1): for k in range(M, m-1, -1): f[j][k]=max(f[j][k], f[j-v][k-m]+w) print(f[V][M]) 宠物小精灵 题目大意：小智在野外捕捉宠物小精灵，他带了一些精灵球和皮卡丘，精灵球可以捕捉小精灵，但每捕捉一个小精灵都会消耗精灵球和减少皮卡丘的体力。现在给定小智拥有的精灵球数量、皮卡丘的初始体力值以及每个小精灵需要的精灵球数量和对皮卡丘造成的伤害数目，问小智最多能捕捉多少个小精灵，并且在这种情况下，皮卡丘的剩余体力值最多是多少。\n实现思路：\n使用动态规划，定义状态 f[i][j] 表示使用 i 个精灵球时，对皮卡丘造成 j 伤害时能够捕捉到的小精灵数量。 遍历每个野生小精灵，更新状态数组 f。 最后输出 f[n][m-1] 表示捕捉到的小精灵数量，然后再计算皮卡丘的剩余体力值。 N = int(1e3+10) M = int(5e2+10) f=[[0]*M for _ in range(N)] n,m,kk = map(int, input().split()) for i in range(kk): v1,v2=map(int, input().split()) for j in range(n, v1-1, -1): for k in range(m-1,v2-1,-1): f[j][k]=max(f[j][k], f[j-v1][k-v2]+1) print(f[n][m-1], end=\u0026#34; \u0026#34;) t=m-1 while t\u0026gt;0 and f[n][m-1]==f[n][t-1]: t-=1 print(m-t) 潜水 最多\n恰好\n最少\n题目大意：潜水员需要使用特殊装备下潜，装备有两种气缸，一种氧气，一种氮气，每个气缸有一定的重量和气体容量。下潜的深度需要一定数量的氧气和氮气。现在给定潜水员需要的氧气和氮气的量，以及每个气缸的氧气、氮气容量和重量，求完成工作所需气缸的总重的最低值。\n实现思路：\n使用动态规划，定义状态 f[i][j] 表示满足氧气需求为 i，氮气需求为 j 时的最小气缸总重量。 遍历每个气缸，更新状态数组 f。 最后输出 f[m][n] 表示完成工作所需的气缸的总重的最低值。 N = int(1e2+10) INF = 0x3f3f3f3f f=[ [INF]*N for _ in range(N) ] f[0][0]=0 m,n=map(int, input().split()) k=int(input()) for i in range(k): a,b,c=map(int, input().split()) for j in range(m,-1,-1): for k in range(n,-1,-1): f[j][k]=min(f[j][k], f[max(j-a, 0)][max(k-b, 0)]+c) print(f[m][n]) 庆功会 题目大意：为了庆祝班级在学校运动会上取得第一名，班主任决定开一场庆功会，并拨款购买奖品犒劳运动员。需要选择购买的奖品，使得购买的奖品的总价值最大，且不超过拨款金额。\n实现思路：\n使用动态规划，定义状态 f[i] 表示拨款金额为 i 时可以购买的奖品的最大总价值。 遍历每个奖品，更新状态数组 f。 最后输出 f[m]，即拨款金额为 m 时可以购买的奖品的最大总价值。 N = int(6e3+10) f=[0 for _ in range(N)] n,m = map(int, input().split()) for i in range(n): v,w,s=map(int, input().split()) for j in range(1,s+1): for k in range(m, v-1, -1): f[k]=max(f[k], f[k-v]+w) print(f[m]) 分组背包 分组背包的顺序：\n物品组 体积 决策 N = int(1e2+10) f=[0 for _ in range(N)] v=[0 for _ in range(N)] w=[0 for _ in range(N)] N,V = map(int, input().split()) for i in range(N): # 物品组 s=int(input()) for j in range(s): v[j],w[j]=map(int, input().split()) for j in range(V,-1,-1): #体积 for k in range(s): #决策 if j\u0026gt;=v[k]: f[j]=max(f[j], f[j-v[k]]+w[k]) print(f[V]) 机器分配 多重背包变种\n题目大意：总公司有M台相同的高效设备，要分给N个分公司。每个分公司根据分配的设备数量能够为国家带来一定的盈利。问如何分配这M台设备才能使国家得到的盈利最大，输出最大盈利值和分配方案。\n实现思路：这是一个经典的背包问题，可以使用动态规划来解决。定义状态dp[i][j]表示前i个分公司中，分配j台设备所能获得的最大盈利。转移方程为dp[i][j] = max(dp[i-1][j-k] + w[i][k])，其中k表示第i个分公司分配的设备数量，0 \u0026lt;= k \u0026lt;= j。最后遍历求解得到最大盈利值，并记录分配方案。\nN = 100 f=[0 for _ in range(N)] w=[[0]*N for _ in range(N)] c=[[0]*N for _ in range(N)] n,m=map(int, input().split()) for i in range(n): w[i]=[0]+[int(x) for x in input().split()] for i in range(n): for j in range(m,-1,-1): for k in range(1,j+1): if f[j-k]+w[i][k] \u0026gt; f[j]: f[j]=f[j-k]+w[i][k] c[i][j]=k print(f[m]) t=m for i in range(n-1,-1,-1): print(i+1, c[i][t]) t-=c[i][t] 金明的预算方案 题目描述：金明想购买物品，其中有主件和附件。每个主件可以有0个、1个或2个附件，附件不能有从属于自己的附件。金明希望在不超过N元（可以等于N元）的前提下，使每件物品的价格与重要度的乘积的总和最大。物品的价格都是10元的整数倍。\n实现思路：这个问题可以使用动态规划来解决。首先，需要将主件和附件分开处理。对于每一个物品，分别考虑不同附件数量的情况，计算可能的价格与重要度乘积的总和，然后更新动态规划数组f。最终，返回f[n]即可得到结果。\nN = 80 M = 32010 f=[0 for _ in range(M)] mas=[[0,0] for _ in range(N)] ser=[[] for _ in range(N)] n,m=map(int,input().split()) for i in range(1,m+1): v,p,q=map(int, input().split()) if q==0: mas[i]=[v,v*p] else: ser[q].append((v, v*p)) for i in range(1,m+1): for j in range(n, -1, -1): for k in range( (1 \u0026lt;\u0026lt; len(ser[i]) )): v,p=mas[i] for l in range(len(ser[i])): if k\u0026gt;\u0026gt;l \u0026amp; 1: v+=ser[i][l][0] p+=ser[i][l][1] if j\u0026gt;=v: f[j]=max(f[j], f[j-v]+p) print(f[n]) 摘花生 N = 105 f=[ [0]*N for _ in range(N)] t=int(input()) for _ in range(t): r,c=map(int, input().split()) for i in range(1,r+1): f[i] = [0] + [int(x) for x in input().split()] for j in range(1,c+1): f[i][j]+=max(f[i-1][j], f[i][j-1]) print(f[r][c]) 最小通行费 N = int(1e3+10) INF = 0x3f3f3f3f f = [[INF]*N for _ in range(N)] f[1][0]=f[0][1]=0 n=int(input()) for i in range(1,n+1): f[i]=[INF]+[int(x) for x in input().split()] for i in range(1,n+1): for j in range(1,n+1): f[i][j]+=min(f[i-1][j],f[i][j-1]) print(f[n][n]) 方格 N = 15 g = [[0]*N for _ in range(N)] f = [[[[0]*N for _ in range(N)] for _ in range(N)] for _ in range(N)] n=int(input()) while True: r,c,x=map(int,input().split()) if r==0 and c==0 and x==0: break g[r][c]=x for i in range(1,n+1): for j in range(1,n+1): for k in range(1,n+1): for l in range(1,n+1): if i==k and j==l: f[i][j][k][l] = max(f[i-1][j][k-1][l], f[i-1][j][k][l-1], f[i][j-1][k-1][l], f[i][j-1][k][l-1]) + g[i][j] else: f[i][j][k][l] = max(f[i-1][j][k-1][l], f[i-1][j][k][l-1], f[i][j-1][k-1][l], f[i][j-1][k][l-1]) + g[i][j] + g[k][l] print(f[n][n][n][n]) N = 55 g=[[0]*N for _ in range(N)] f=[[[[0]*N for _ in range(N)] for _ in range(N)] for _ in range(N)] m,n=map(int, input().split()) for i in range(1,m+1): g[i]=[0]+[int(x) for x in input().split()] for i in range(1,m+1): for j in range(1,n+1): for k in range(1,m+1): for l in range(1,n+1): if i==k and j==l: f[i][j][k][l]=max(f[i-1][j][k-1][l], f[i-1][j][k][l-1], f[i][j-1][k-1][l], f[i][j-1][k][l-1])+g[i][j] else: f[i][j][k][l]=max(f[i-1][j][k-1][l], f[i-1][j][k][l-1], f[i][j-1][k-1][l], f[i][j-1][k][l-1])+g[i][j]+g[k][l] print(f[m][n][m][n]) LIS \u0026amp; LCS LIS N=int(1e3+10) f=[1 for _ in range(N)] a=[] n=int(input()) a=[0]+[int(x) for x in input().split()] for i in range(1,n+1): for j in range(1,i): if a[i]\u0026gt;a[j]: f[i]=max(f[i],f[j]+1) ans = 0 for i in range(1,n+1): ans = max(ans, f[i]) print(ans) LCS N = int(1e3+10) f=[[0]*N for _ in range(N)] a=\u0026#34;\u0026#34; b=\u0026#34;\u0026#34; n,m=map(int, input().split()) a=input() b=input() for i in range(n): for j in range(m): f[i][j]=max(f[i-1][j], f[i][j-1]) if a[i]==b[j]: f[i][j]=f[i-1][j-1]+1 print(f[n-1][m-1]) 回溯寻找所有的最长公共子序列\ndef lcs_length(X, Y): m, n = len(X), len(Y) dp = [[0] * (n + 1) for _ in range(m + 1)] for i in range(1, m + 1): for j in range(1, n + 1): if X[i - 1] == Y[j - 1]: dp[i][j] = dp[i - 1][j - 1] + 1 else: dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]) return dp def find_all_lcs(X, Y, dp): def backtrack(i, j): if i == 0 or j == 0: return {\u0026#34;\u0026#34;} elif X[i - 1] == Y[j - 1]: return {lcs + X[i - 1] for lcs in backtrack(i - 1, j - 1)} else: lcs_set = set() if dp[i - 1][j] \u0026gt;= dp[i][j - 1]: lcs_set.update(backtrack(i - 1, j)) if dp[i][j - 1] \u0026gt;= dp[i - 1][j]: lcs_set.update(backtrack(i, j - 1)) return lcs_set return backtrack(len(X), len(Y)) 最大上升子序列和 import copy a=[] f=[] ans=0 n=int(input()) a=[int(x) for x in input().split()] f=copy.deepcopy(a) for i in range(n): for j in range(i): if a[i]\u0026gt;a[j]: f[i]=max(f[i], f[j]+a[i]) for i in range(n): ans = max(ans, f[i]) print(ans) N = int(1e3+10) f=[0 for _ in range(N)] ans = 0 n=int(input()) a=[0]+[int(x) for x in input().split()] for i in range(1,n+1): f[i]=a[i] for j in range(1,i): if a[i]\u0026gt;a[j]: f[i]=max(f[i], f[j]+a[i]) ans = max(ans, f[i]) print(ans) 最大上升子序列II N = int(1e5+10) INF = 0x3f3f3f3f q=[INF for _ in range(N)] ans=0 n=int(input()) a=[0]+[int(x) for x in input().split()] for i in range(1,n+1): l,r=0,i while l\u0026lt;r: mid = (l+r+1)\u0026gt;\u0026gt;1 if q[mid]\u0026lt;a[i]: l=mid else: r=mid-1 ans = max(ans, l+1) q[l+1]=min(q[l+1], a[i]) print(ans) N = int(1e5+10) q=[0 for _ in range(N)] len = 0 n=int(input()) a=[0]+[int(x) for x in input().split()] for i in range(1, n+1): l,r=0,len while l\u0026lt;r: mid = (l+r+1)\u0026gt;\u0026gt;1 if q[mid]\u0026lt;a[i]: l=mid else: r=mid-1 len=max(len, l+1) q[l+1]=a[i] print(len) N = int(1e5+10) q=[0 for _ in range(N)] len = 0 n=int(input()) a=[0]+[int(x) for x in input().split()] for i in range(1,n+1): l,r=0,len while l\u0026lt;r: mid = (l+r+1)\u0026gt;\u0026gt;1 if q[mid]\u0026gt;=a[i]: r=mid-1 else: l=mid len = max(len, l+1) q[l+1]=a[i] print(len) 二分原则：\n有单调性，并且二分之后能保持单调性\n怪盗基德的滑翔翼 **题意：**怪盗基德需要逃跑，城市中有N幢建筑排成一条线，每幢建筑的高度各不相同。他希望尽可能多地经过不同建筑的顶部，以减缓下降时的冲击力，减少受伤的可能性。他可以选择一个方向逃跑，但不能中途改变方向，且只能从较高的建筑滑翔到较低的建筑。怪盗基德最多可以经过多少幢不同建筑的顶部（包含初始时的建筑）。\n**实现思路：**可以使用动态规划来解决。首先，对于每一座建筑，分别计算以该建筑为终点的最长递增子序列长度，得到从左往右和从右往左的两个最长递增子序列数组。然后将这两个数组对应位置的最大值相加，再减去1（因为初始位置也算一座建筑），即为怪盗基德最多可以经过的不同建筑数量。\nN = int(1e3+10) f=[0 for _ in range(N)] t=int(input()) while t: t-=1 ans=0 n=int(input()) a=[0]+[int(x) for x in input().split()] for i in range(1,n+1): f[i]=1 for j in range(1,i): if a[i]\u0026gt;a[j]: f[i]=max(f[i], f[j]+1) ans = max(ans, f[i]) for i in range(n,0,-1): f[i]=1 for j in range(n,i,-1): if a[i]\u0026gt;a[j]: f[i]=max(f[i], f[j]+1) ans = max(ans, f[i]) print(ans) 登山 N = int(1e3+10) f=[1 for _ in range(N)] g=[1 for _ in range(N)] ans = 0 n=int(input()) a=[0]+[int(x) for x in input().split()] for i in range(1,n+1): for j in range(1,i): if a[i]\u0026gt;a[j]: f[i]=max(f[i], f[j]+1) for i in range(n,0,-1): for j in range(n,i,-1): if a[i]\u0026gt;a[j]: g[i]=max(g[i], g[j]+1) for i in range(1,n+1): ans = max(ans, f[i]+g[i]-1) print(ans) 合唱队形 N = int(1e3+10) f=[1 for _ in range(N)] g=[1 for _ in range(N)] ans = 0 n=int(input()) a=[0]+[int(x) for x in input().split()] for i in range(1,n+1): for j in range(1,i): if a[i]\u0026gt;a[j]: f[i]=max(f[i], f[j]+1) for i in range(n,0,-1): for j in range(n,i,-1): if a[i]\u0026gt;a[j]: g[i]=max(g[i], g[j]+1) for i in range(1,n+1): ans = max(ans, f[i]+g[i]-1) print(n-ans) 友好城市 N = int(5e3+10) a=[(-1,-1)] f=[1 for _ in range(N)] ans = 0 n=int(input()) for i in range(n): x,y=map(int, input().split()) a.append((x,y)) a.sort(key=lambda x:x[0]) for i in range(1,n+1): for j in range(1,i): if a[i][1]\u0026gt;a[j][1]: f[i]=max(f[i], f[j]+1) ans = max(f[i], ans) print(ans) 拦截导弹 贪心证明\n题意：某国为了防御敌国的导弹袭击，发展出一种导弹拦截系统，但有缺陷：每一发炮弹都不能高于前一发的高度。给定导弹依次飞来的高度，计算这套系统最多能拦截多少导弹，并且如果要拦截所有导弹，最少需要配备多少套这种导弹拦截系统。\n实现思路：首先使用动态规划求解最多能拦截的导弹数，然后再利用贪心算法求解最少需要配备的系统数。具体实现时，先从左往右依次计算每个位置能拦截的最大导弹数，然后再从右往左依次计算每个位置能拦截的最大导弹数。接着，利用贪心算法，遍历导弹高度，如果当前高度大于已有系统的高度，则增加系统数；否则，更新已有系统的高度。最终得到最多能拦截的导弹数和最少需要配备的系统数。\nN = int(1e3+10) f=[1 for _ in range(N)] g=[0 for _ in range(N)] ans = 0 cnt = 0 a=[0]+[int(x) for x in input().split()] n=len(a) for i in range(n-1,0,-1): for j in range(n-1,i,-1): if a[i]\u0026gt;=a[j]: f[i]=max(f[i], f[j]+1) ans = max(ans, f[i]) print(ans) for i in range(1, n): k=0 while k\u0026lt;cnt and g[k]\u0026lt;a[i]: k+=1 if k\u0026gt;=cnt: cnt+=1 g[k]=a[i] print(cnt) 导弹防御系统 **题意：**R国更新了导弹防御系统，一套系统的导弹拦截高度要么一直严格单调上升，要么一直严格单调下降。给定即将袭来的一系列导弹的高度，请你求出至少需要多少套防御系统，才能将它们全部击落。\n**实现思路：**可以利用深度优先搜索（DFS）来解决。首先定义两个数组up和down，分别表示上升序列和下降序列。然后使用DFS进行状态搜索，每次尝试将当前导弹加入上升序列或下降序列，并更新当前的防御系统数量。最终得到至少需要的防御系统数量。代码中的dfs函数用于进行状态搜索，尝试将当前导弹加入上升序列或下降序列，并递归调用下一个导弹的处理。最终输出最少需要的防御系统数量。\nN = int(1e2+10) up=[0 for _ in range(N)] down=[0 for _ in range(N)] ans=0 def dfs(u, su, sd): global ans if su + sd\u0026gt;=ans: return if u==n: ans=su+sd return k=0 while k\u0026lt;su and up[k]\u0026gt;=a[u]: k+=1 t=up[k] up[k]=a[u] if k\u0026gt;=su: dfs(u+1, su+1, sd) else: dfs(u+1, su, sd) up[k]=t k=0 while k\u0026lt;sd and down[k]\u0026lt;=a[u]: k+=1 t=down[k] down[k]=a[u] if k\u0026gt;=sd: dfs(u+1, su, sd+1) else: dfs(u+1, su, sd) down[k]=t while True: n=int(input()) ans = n if n==0: break a=[int(x) for x in input().split()] dfs(0,0,0) print(ans) 最长公共上升子序列 题意：熊大妈的奶牛们在小沐沐的指导下研究了最长公共上升子序列，即两个数列中都包含一段位置不一定连续的严格递增的数段，要求找出最长的这样的子序列。现在你需要告诉奶牛们最长公共上升子序列的长度。\n实现思路：可以使用动态规划来解决。定义一个二维数组f，其中f[i][j]表示数列A的前i个元素和数列B的前j个元素中，以数列A的第i个元素和数列B的第j个元素结尾的最长公共上升子序列的长度。然后使用动态规划的方式填表，最终找出最长的公共上升子序列的长度。\n代码中的f[i][j]的状态转移方程如下：\n如果a[i]等于b[j]，则f[i][j]等于f[i-1][j-1]+1（表示在a[i]和b[j]相等的情况下可以构成更长的公共上升子序列）。\n如果a[i]大于b[j]，则f[i][j]等于f[i-1][j]（表示a[i]不在公共上升子序列中）。\n否则，f[i][j]等于f[i][j-1]（表示b[j]不在公共上升子序列中）。\nN = int(3e3+10) f=[[0]*N for _ in range(N)] ans=0 n=int(input()) a=[0]+[int(x) for x in input().split()] b=[0]+[int(x) for x in input().split()] for i in range(1,n+1): maxv=1 for j in range(1,n+1): f[i][j]=f[i-1][j] if a[i]==b[j]: f[i][j]=max(f[i][j], maxv) if a[i]\u0026gt;b[j]: maxv=max(maxv, f[i][j]+1) for i in range(1,n+1): ans = max(ans, f[n][i]) print(ans) 状态机模型 闫氏DP分析法——状态机分析法\n大盗阿福 N = int(1e5+10) t=int(input()) while t: t-=1 f=[[0]*2 for _ in range(N)] n=int(input()) a=[0]+[int(x) for x in input().split()] f[1][0]=0 f[1][1]=a[1] for i in range(2,n+1): f[i][0]=max(f[i-1][1],f[i-1][0]) f[i][1]=max(f[i-1][0], f[i-2][1])+a[i] print(max(f[n][0], f[n][1])) 买卖股票 IV 题目大意：给定一个长度为n的数组，表示一个给定股票在n天内的价格。设计一个算法，计算可以获取的最大利润，最多可以完成k笔交易。每次买入卖出合为一笔交易，且不能同时参与多笔交易。\n实现思路：\n使用动态规划解决该问题，定义一个三维数组f，其中f[i][j][0]表示第i天，已完成j笔交易，并且手上没有股票时的最大利润；f[i][j][1]表示第i天，已完成j笔交易，并且手上有股票时的最大利润。 初始化数组f，将所有位置的利润初始化为负无穷-INF，表示不可达。 遍历股票价格数组，使用动态规划递推出f[i][j][0]和f[i][j][1]，即在第i天已完成j笔交易时的最大利润。 最终，取f[n][k][0]中的最大值作为最终结果，表示第n天已完成k笔交易，并且手上没有股票时的最大利润。 代码实现已给出，其中使用了两重循环来填充动态规划数组f，时间复杂度为O(nk)，因为n的最大值为10^5，k的最大值为100，所以算法的时间复杂度为可接受的范围内。\n这个算法的核心思想是利用动态规划逐步计算出在每一天已完成一定数量交易时的最大利润，然后根据问题要求取得最优解。\nK = 110 INF = 0x3f3f3f3f f=[[[-INF]*2 for _ in range(K)] for _ in range(2)] n,k = map(int ,input().split()) w=[0]+[int(x) for x in input().split()] f[1][0][0]=0 t=0 for i in range(1,n+1): for j in range(k+1): f[t][j][0]=max(f[t^1][j][0], f[t^1][j][1]+w[i]) f[t][j][1]=max(f[t^1][j][1], f[t^1][j-1][0]-w[i]) t^=1 res =max(f[t^1][i][0] for i in range(k+1)) print(res) 股票交易V 题目大意：给定一个整数数组prices，其中第i天的股票价格为prices[i]。设计一个算法计算出在满足约束条件下可以获取的最大利润。约束条件为：卖出股票后，你无法在第二天买入股票（即冷冻期为1天），且不能同时参与多笔交易（必须在再次购买前出售掉之前的股票）。\n实现思路：\n使用动态规划解决该问题，定义一个二维数组f，其中f[i][j]表示第i天的交易状态为j时的最大利润，j有三种状态：0表示持有股票，1表示不持有股票且处于冷冻期，2表示不持有股票且不处于冷冻期。 初始化数组f，将所有位置的利润初始化为负无穷-INF，表示不可达。并且将f[0][2]初始化为0，表示第0天结束时，不持有股票且不处于冷冻期时的最大利润为0。 遍历股票价格数组，使用动态规划递推出f[i][j]，即在第i天的交易状态为j时的最大利润。 最终，取f[n][1]和f[n][2]中的最大值作为最终结果，表示最后一天结束时的最大利润。 代码实现已给出，其中使用了一重循环来填充动态规划数组f，时间复杂度为$O(n)$，因为n的最大值为5000，所以算法的时间复杂度为可接受的范围内。\n这个算法的核心思想是利用动态规划逐步计算出在每一天不同交易状态下的最大利润，然后根据问题要求取得最优解。\nN = int(1e5+10) INF = 0x3f3f3f3f f=[[-INF]*3 for _ in range(N)] n=int(input()) w=[0]+[int(x) for x in input().split()] f[0][2]=0 for i in range(1,n+1): f[i][0]=max(f[i-1][0], f[i-1][2]-w[i]) f[i][1]=f[i-1][0]+w[i] f[i][2]=max(f[i-1][1], f[i-1][2]) print(max(f[n][1], f[n][2])) P1220 关路灯 题意：这个问题是关于优化老张关灯顺序以最小化总功耗的。老张每次在天亮时首先关掉自己所处位置的路灯，然后可以向左或向右关灯。为了最小化总功耗，需要找到一个最优的关灯顺序。\n实现思路：\n首先，我们可以使用动态规划来解决这个问题。我们定义一个三维数组f，其中f[i][j][k]表示从第i盏灯到第j盏灯，老张最后一个关灯位置在第k盏灯时的最小功耗。 然后，我们初始化数组f，将所有位置的功耗都初始化为无穷大INF，表示不可达。 对于每一对路灯i和j，我们通过动态规划递推出f[i][j][0]和f[i][j][1]，分别表示老张从左边或右边走到位置i到j的最小功耗。 最后，我们只需比较f[1][n][0]和f[1][n][1]，取其中较小的值作为最终答案。 使用了三重循环来填充动态规划数组f，时间复杂度为$O(n^3)$，因为n的最大值为50，所以算法的时间复杂度为可接受的范围内。这个算法的核心思想是利用动态规划逐步计算出老张从左或右关灯到达每个位置的最小功耗，然后比较两种情况下的最小功耗，找到最优解。\nmaxn = int(8e2) + 100 INF = 0x3f3f3f3f f = [[[INF] * 2 for _ in range(maxn)] for _ in range(maxn)] a = [0] * (maxn + 1) w = [0] * (maxn + 1) sum = [0] * (maxn + 1) n, r = map(int, input().split()) for i in range(1, n + 1): a[i], w[i] = map(int, input().split()) sum[i] = sum[i - 1] + w[i] f[r][r][0] = f[r][r][1] = 0 for i in range(2, n + 1): for j in range(1, n - i + 2): l = j + i - 1 f[j][l][0] = min(f[j + 1][l][0] + (a[j + 1] - a[j]) * (sum[j] + sum[n] - sum[l]), f[j + 1][l][1] + (a[l] - a[j]) * (sum[j] + sum[n] - sum[l])) f[j][l][1] = min(f[j][l - 1][0] + (a[l] - a[j]) * (sum[j - 1] + sum[n] - sum[l - 1]), f[j][l - 1][1] + (a[l] - a[l - 1]) * (sum[j - 1] + sum[n] - sum[l - 1])) ans = min(f[1][n][0], f[1][n][1]) print(ans) 状态压缩DP 小国王 N = 13 M = 1\u0026lt;\u0026lt;N K = 110 state=[] h=[[] for _ in range(M)] cnt = [0]*M f=[[[0]*M for _ in range(K)] for _ in range(N)] def check(x): global n for i in range(n): if (x\u0026gt;\u0026gt;i)\u0026amp;1 and (x\u0026gt;\u0026gt;i+1)\u0026amp;1: return False return True def count(x): global n cnt=0 for i in range(n): if (x\u0026gt;\u0026gt;i)\u0026amp;1: cnt+=1 return cnt n,m = map(int, input().split()) for i in range(1\u0026lt;\u0026lt;n): if check(i): state.append(i) cnt[i]=count(i) for i in range(len(state)): for j in range(len(state)): a = state[i] b = state[j] if (a\u0026amp;b)==0 and check(a|b): h[i].append(j) f[0][0][0]=1 for i in range(1,n+2): for j in range(m+1): for k in range(len(state)): for t in h[k]: c = cnt[state[k]] if j\u0026gt;=c: f[i][j][state[k]]+=f[i-1][j-c][state[t]] print(f[n+1][m][0]) 愤怒的小鸟 eps = 1e-6 N = 18 M = 1\u0026lt;\u0026lt;18 INF = 0x3f3f3f3f def cmp(a,b): if abs(a-b)\u0026lt;eps: return 0 if a\u0026gt;b: return 1 return -1 t = int(input()) for _ in range(t): f = [INF]*M path = [[0]*N for _ in range(N)] q = [0]*N n,m = map(int, input().split()) for i in range(n): x,y = map(float, input().split()) q[i]=(x,y) for i in range(n): path[i][i]=1\u0026lt;\u0026lt;i #关键点：与其他点的抛物线可能都不合法，所以需要独立出一条抛物线 for j in range(n): x1,y1 = q[i] x2,y2 = q[j] if cmp(x1,x2)==0: continue a = (y1/x1-y2/x2)/(x1-x2) if cmp(a,0)\u0026gt;=0: continue b = y1/x1-a*x1 state=0 for k in range(n): x3,y3 = q[k] if cmp(a*x3*x3+b*x3, y3) == 0: state+=(1\u0026lt;\u0026lt;k) path[i][j]=state f[0]=0 for i in range(1\u0026lt;\u0026lt;n): for j in range(n): if not (i\u0026gt;\u0026gt;j)\u0026amp;1: x=j break for j in range(n): f[i | path[x][j]] = min(f[i | path[x][j]], f[i]+1) print(f[(1\u0026lt;\u0026lt;n)-1]) 集合类状态压缩DP 最短Hamilton距离 N = 22 M = 1\u0026lt;\u0026lt;20 INF = 0x3f3f3f3f f=[[INF]*N for _ in range(M)] w=[[]*N for _ in range(N)] n=int(input()) for i in range(n): w[i]=[int(_) for _ in input().split()] f[1][0]=0 for i in range(1\u0026lt;\u0026lt;n): for j in range(n): if i\u0026gt;\u0026gt;j\u0026amp;1: for k in range(n): if i\u0026gt;\u0026gt;k\u0026amp;1: f[i][j]=min(f[i][j], f[i-(1\u0026lt;\u0026lt;j)][k]+w[k][j]) print(f[(1\u0026lt;\u0026lt;n)-1][n-1]) 区间DP 石子合并 N = 1010 INF = 0x3f3f3f3f f=[[INF]*N for _ in range(N)] s=[0]*N n = int(input()) a=[0]+[int(_) for _ in input().split()] for i in range(1,n+1): f[i][i]=0 s[i]=s[i-1]+a[i] for l in range(2,n+1): for i in range(1,n-l+2): j=i+l-1 for k in range(i,j): f[i][j] = min(f[i][j], f[i][k] + f[k+1][j] + s[j]-s[i-1]) print(f[1][n]) 环形石子合并 N = 410 w=[0]*N s=[0]*N INF = 0x3f3f3f3f f=[[-INF]*N for _ in range(N)] g=[[INF]*N for _ in range(N)] n=int(input()) a= [0]+[int(_) for _ in input().split()] for i in range(1,n+1): w[i] = w[i+n] = a[i] for i in range(1,n*2+1): s[i]=s[i-1]+w[i] for l in range(1,n+1): for i in range(1,n*2-l+2): j=i+l-1 if l==1: f[i][j]=g[i][j]=0 for k in range(i,j): f[i][j] = max(f[i][j], f[i][k]+f[k+1][j]+s[j]-s[i-1]) g[i][j] = min(g[i][j], g[i][k]+g[k+1][j]+s[j]-s[i-1]) minv, maxv = INF, -INF for i in range(1,n+1): minv = min(minv, g[i][i+n-1]) maxv = max(maxv, f[i][i+n-1]) print(minv, maxv, sep=\u0026#39;\\n\u0026#39;) 能量项链 N = 210 w=[0]*N f=[[0]*N for _ in range(N)] n = int(input()) a=[0]+[int(_) for _ in input().split()] for i in range(1,n+1): w[i]=w[i+n]=a[i] for l in range(3,n+2): for i in range(1,n*2-l+2): j=i+l-1 for k in range(i+1,j): f[i][j] = max(f[i][j], f[i][k]+f[k][j]+w[i]*w[k]*w[j]) maxv = -1 for i in range(1,n+1): maxv = max(maxv, f[i][i+n]) print(maxv) 凸多边形的划分 N = 55 INF = 1e30 f=[[INF]*N for _ in range(N)] n = int(input()) w=[0]+[int(_) for _ in input().split()] for i in range(1,n+1): f[i][i+1]=0 for l in range(3,n+1): for i in range(1, n-l+2): j=i+l-1 for k in range(i+1,j): f[i][j] = min(f[i][j], f[i][k]+f[k][j]+w[i]*w[k]*w[j]) print(f[1][n]) 加分二叉树 N = 50 def dfs(l, r): if l\u0026gt;r: return k=root[l][r] print(k,end=\u0026#39; \u0026#39;) dfs(l,k-1) dfs(k+1,r) n = int(input()) w = [0]+[int(_) for _ in input().split()] f=[[0]*N for _ in range(N)] root=[[0]*N for _ in range(N)] for l in range(1,n+1): for i in range(1,n-l+2): j=i+l-1 for k in range(i,j+1): left = 1 if k==i else f[i][k-1] right = 1 if k==j else f[k+1][j] s = left*right+w[k] if i==j: s=w[k] if f[i][j]\u0026lt;s: f[i][j]=s root[i][j]=k print(f[1][n]) dfs(1,n) 树形DP 树的最长路径 注意注意再注意，while循环链不符合要求是需要 i=ne[i]\nimport sys sys.setrecursionlimit(int(1e5+10)) N = 10010*2 e = [0]*N ne = [0]*N w = [0]*N h = [-1]*N idx = 1 ans = -1 def add(a, b, c): global idx e[idx]=b w[idx]=c ne[idx]=h[a] h[a]=idx idx+=1 def dfs(root, father): global ans dis, d1, d2 = 0,0,0 i=h[root] while i!=-1: j = e[i] if j==father: i=ne[i] # 重点 continue d = dfs(j, root)+w[i] dis = max(dis, d) if d\u0026gt;d1: d2=d1 d1=d else: d2 = max(d2, d) i=ne[i] ans = max(ans, d1+d2) return dis n = int(input()) for i in range(n-1): a,b,c = map(int, input().split()) add(a,b,c) add(b,a,c) dfs(1,-1) print(ans) 树的中心 题目大意：给定一棵包含 n 个节点的树，每条边都有一个权值。要求在树中找到一个点，使得该点到树中其他节点的最远距离最近。\n实现思路：\n构建无向图的邻接表，其中每个节点对应一个链表，存储其相邻的节点以及对应的边权值。 使用 DFS 遍历树，分别计算每个节点到其他节点的最长距离 d1 和次长距离 d2，并记录其相邻节点 s1。 再次使用 DFS 遍历树，计算每个节点到其相邻节点的最长距离 up。 最后，遍历所有节点，求出所有节点中最大的 max(up[i], d1[i])，即为所求的最近距离。 N = 10010*2 e = [0]*N ne=[0]*N h=[-1]*N w=[0]*N d1=[0]*N d2=[0]*N s1=[0]*N up=[0]*N idx = 1 def add(a,b,c): global idx e[idx]=b w[idx]=c ne[idx]=h[a] h[a]=idx idx+=1 def dfs1(u, father): i=h[u] while i!=-1: j=e[i] if j==father: i=ne[i] continue dfs1(j,u) dis = d1[j]+w[i] if dis\u0026gt;d1[u]: d2[u]=d1[u] d1[u], s1[u]=dis, j elif dis\u0026gt;d2[u]: d2[u]=dis i=ne[i] def dfs2(u, father): i=h[u] while i!=-1: j=e[i] if j==father: i=ne[i] continue if s1[u]==j: up[j]=max(up[u], d2[u])+w[i] else: up[j]=max(up[u], d1[u])+w[i] i=ne[i] dfs2(j, u) n = int(input()) for i in range(n-1): a,b,c = map(int ,input().split()) add(a,b,c) add(b,a,c) dfs1(1,-1) dfs2(1,-1) ans = 1e10 for i in range(1,n+1): ans = min(ans, max(up[i], d1[i])) print(ans) 数字转换 题目大意：给定一个正整数 n，如果一个数 x 的约数之和 y（不包括 x 本身）比它本身小，那么 x 可以变为 y，y 也可以变为 x。限定所有数字变换在不超过 n 的正整数范围内进行，求不断进行数字变换且不出现重复数字的最多变换步数。\n实现思路：\n首先，对于每个数 i，计算其所有约数之和，并存储在数组 s 中。 然后，遍历所有的数 i，如果约数之和 s[i] 小于 i，则将其作为一个节点添加到有向图中，表示可以从 s[i] 变换到 i。 构建有向图后，使用深度优先搜索（DFS）算法遍历图中的每个节点，并求出每个节点的最长路径长度。 在DFS过程中，使用变量 ans 记录图中最长路径的长度，即最多变换步数。 最后，输出 ans 即可。 N = int(5e4+10) s=[0]*N st=[False]*N e=[0]*N ne=[0]*N h=[-1]*N idx=1 ans = -1 def add(a,b): global idx e[idx]=b ne[idx]=h[a] h[a]=idx idx+=1 def dfs(u): global ans d1,d2=0,0 i=h[u] while i!=-1: j=e[i] dis = dfs(j)+1 if dis\u0026gt;d1: d2,d1=d1,dis elif dis\u0026gt;d2: d2=dis i=ne[i] ans = max(ans, d1+d2) return d1 n = int(input()) for i in range(1,n+1): for j in range(2,n+1): if i\u0026gt;n//j: break s[i*j]+=i for i in range(2,n+1): if s[i]\u0026lt;i: add(s[i], i) st[i]=True # for i in range(1,n+1): # if not st[i]: # dfs(i) dfs(1) print(ans) 没有上司的舞会 题目大意：Ural大学有N名职员，编号为1∼N。他们的关系像一棵以校长为根的树，父节点就是子节点的直接上司。每个职员有一个快乐指数，用整数Hi表示。现在要召开一场周年庆宴会，但没有职员愿意和直接上司一起参会。在满足这个条件的前提下，主办方希望邀请一部分职员参会，使得所有参会职员的快乐指数总和最大，求这个最大值。\n实现思路：\n首先，建立一棵以校长为根的树，使用一个二维数组v来存储树的结构关系，其中v[i]表示第i个职员的直接下属。 使用一个二维数组f来记录每个职员参加和不参加宴会时的最大快乐指数，其中f[i][0]表示第i个职员不参加宴会时的最大快乐指数，f[i][1]表示第i个职员参加宴会时的最大快乐指数。 使用深度优先搜索（DFS）来遍历树的每个节点，计算每个节点不参加和参加宴会时的最大快乐指数。 在DFS过程中，对于每个节点i，首先更新该节点参加宴会时的最大快乐指数f[i][1]为当前节点的快乐指数h[i]，然后遍历当前节点的直接下属，更新当前节点参加和不参加宴会时的最大快乐指数。 最终，取根节点的参加和不参加宴会时的最大快乐指数的较大值作为最终结果。 代码实现已给出，其中使用了深度优先搜索来遍历树的每个节点，时间复杂度为O(N)，因为N的最大值为6000，所以算法的时间复杂度为可接受的范围内。\n这个算法的核心思想是利用深度优先搜索逐步计算出每个节点参加和不参加宴会时的最大快乐指数，然后根据问题要求找到最大的快乐指数。\nimport sys sys.setrecursionlimit(int(1e4)) N = int(7e3) v=[[] for _ in range(N)] f=[[0]*2 for _ in range(N)] st=[False]*N h=[0]*N root=0 def dfs(u): f[u][1]+=h[u] for i in v[u]: dfs(i) f[u][1]+=f[i][0] f[u][0]+=max(f[i][0], f[i][1]) n = int(input()) for i in range(1,n+1): h[i]=int(input()) for i in range(n-1): l,k = map(int, input().split()) v[k].append(l) st[l]=True for i in range(1,n+1): if not st[i]: root=i dfs(root) print(max(f[root][0], f[root][1])) 单调队列优化的DP 最大子序和 题目大意：给定一个长度为n的整数序列，从中找出一段长度不超过m的连续子序列，使得子序列中所有数的和最大。要求输出该序列的最大子序和。\n实现思路：\n首先，将输入的序列进行预处理，计算出前缀和数组s，其中s[i]表示序列的前i个数的和。 使用单调队列来解决该问题。单调队列维护的是前缀和数组s中的下标，队列中的元素按照前缀和的值单调递增。队列中的下标表示的是以该下标结尾的连续子序列的最大和。 遍历序列，对于每个位置i，更新单调队列中的元素，使得队列中的下标符合要求，即满足长度不超过m的连续子序列的条件。 在遍历的过程中，不断更新记录最大子序和的变量ans，最终得到的ans即为所求结果。 代码实现已给出，其中使用了单调队列来维护满足条件的下标，时间复杂度为O(n)，因为n的最大值为300000，所以算法的时间复杂度为可接受的范围内。\n这个算法的核心思想是利用单调队列维护以每个位置结尾的满足条件的子序列的最大和，然后根据问题要求找到最大子序和。\nN = 300010 q, s = [0]*N, [0]*N ans = -2**33 hh, tt = 0, 0 n,m = map(int, input().split()) s = [0]+list(map(int, input().split())) for i in range(1,n+1): s[i]+=s[i-1] for i in range(1,n+1): if q[hh]\u0026lt;i-m: hh+=1 ans = max(ans, s[i]-s[q[hh]]) while hh\u0026lt;=tt and s[q[tt]]\u0026gt;=s[i]: tt-=1 tt+=1 q[tt]=i print(ans) 数位DP 1081\nfrom typing import List N = 35 def init() -\u0026gt; List[List[int]]: f = [[0] * N for _ in range(N)] for i in range(N): for j in range(i + 1): if j == 0: f[i][j] = 1 else: f[i][j] = f[i - 1][j] + f[i - 1][j - 1] return f def dp(n: int, k: int, b: int, f: List[List[int]]) -\u0026gt; int: if n == 0: return 0 nums = [] while n: nums.append(n % b) n //= b res = 0 last = 0 for i in range(len(nums) - 1, -1, -1): x = nums[i] if x \u0026gt; 0: res += f[i][k - last] if x \u0026gt; 1: if k - last - 1 \u0026gt;= 0: res += f[i][k - last - 1] break else: last += 1 if last \u0026gt; k: break if i == 0 and last == k: res += 1 return res def solve(l: int, r: int, k: int, b: int) -\u0026gt; int: f = init() return dp(r, k, b, f) - dp(l - 1, k, b, f) if __name__ == \u0026#34;__main__\u0026#34;: l, r, k, b = map(int, input().split()) print(solve(l, r, k, b)) 记忆化 滑雪 题目大意：Michael喜欢滑雪，并希望知道在一个区域中最长的滑坡。给定一个二维数组表示区域，数组中的每个数字代表点的高度。一个人可以从某个点滑向上下左右相邻四个点之一，当且仅当高度会减小。要求找到最长的滑坡，即从一个高点开始，一直滑到一个低点。\n实现思路：\n使用优先队列（堆）来实现广度优先搜索（BFS）。 首先，初始化一个二维数组f用于存储从每个点出发的最长滑坡距离，初始化优先队列pq用于存储待搜索的点。 将所有点按照高度从小到大加入优先队列pq。 对于优先队列中的每个点，依次向上下左右四个方向搜索，如果下一个点的高度小于当前点，则更新下一个点的最长滑坡距离为当前点的最长滑坡距离加1。 在搜索过程中，不断更新记录最长滑坡距离的变量ma，最终得到的ma即为最长滑坡的长度。 代码实现已给出，其中使用了优先队列pq来进行广度优先搜索，时间复杂度为O(nmlog(nm))，因为n和m的最大值为100，所以算法的时间复杂度为可接受的范围内。\n这个算法的核心思想是利用广度优先搜索逐步计算出从每个点出发的最长滑坡距离，然后根据问题要求找到最长的滑坡。\nfrom heapq import * n, m = map(int, input().split()) f = [[0] * (m + 5) for _ in range(n + 5)] # distance g = [[0] * (m + 5) for _ in range(n + 5)] # store heights pq = [] for i in range(1, n + 1): nums = [0] + list(map(int, input().split())) for j, num in enumerate(nums[1:]): f[i][j] = 1 g[i][j] = num heappush(pq, (num, i, j)) # Push (num, i, j) into the priority queue ma = -1 while pq: num, i, j = heappop(pq) if g[i - 1][j] \u0026lt; num: f[i][j] = max(f[i][j], f[i - 1][j] + 1) if g[i + 1][j] \u0026lt; num: f[i][j] = max(f[i][j], f[i + 1][j] + 1) if g[i][j - 1] \u0026lt; num: f[i][j] = max(f[i][j], f[i][j - 1] + 1) if g[i][j + 1] \u0026lt; num: f[i][j] = max(f[i][j], f[i][j + 1] + 1) ma = max(ma, f[i][j]) print(ma) from functools import lru_cache from sys import stdin input = stdin.readline def solve(matrix): if not matrix: return 0 dirs = [(-1, 0), (0, 1), (1, 0), (0, -1)] @lru_cache(None) def dfs(r, c): res = 1 for dx, dy in dirs: a, b = r + dx, c + dy if 0\u0026lt;= a \u0026lt;m and 0\u0026lt;= b \u0026lt;n and matrix[a][b] \u0026gt; matrix[r][c]: res = max(res, dfs(a, b) + 1) return res m, n = len(matrix), len(matrix[0]) res = 0 for i in range(m): for j in range(n): res = max(res, dfs(i, j)) return res r, c = map(int, input().split()) matrix = [[]for _ in range(r)] for i in range(r): matrix[i] = list(map(int, input().split())) print(solve(matrix)) ","permalink":"https://kennems.github.io/zh/posts/tech/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0%E4%BA%94dppython%E5%AE%9E%E7%8E%B0/","summary":"算法笔记（五）——DP（Python实现） DP 数字三角形 f=[] n=int(input()) for _ in range(n): f.append([int(x) for x in input().split()]) for i in range(n-2,-1,-1): for j in range(i+1): f[i][j]=max(f[i+1][j], f[i+1][j+1])+f[i][j] print(f[0][0]) 背包 空间优化成1维之后，只有完全背包问题的","title":"算法笔记（五）——DP（Python实现）"},{"content":"算法笔记（一）——基础+杂项（Python实现） 基础+杂项 快速排序 def quick_sort(q, l, r): if l\u0026gt;=r: return i,j,x=l-1,r+1,q[(l+r)\u0026gt;\u0026gt;1] while i\u0026lt;j: i+=1 while q[i]\u0026lt;x: i+=1 j-=1 while q[j]\u0026gt;x: j-=1 if i\u0026lt;j: q[i], q[j] = q[j], q[i] quick_sort(q, l, j) quick_sort(q, j+1, r) n=int(input()) arr=list(map(int, input().split())) quick_sort(arr,0,n-1) print(\u0026#34; \u0026#34;.join(map(str, arr))) 归并排序 j = mid+1 !!!\nfrom sys import stdin input = lambda:stdin.readline().strip() def merge_sort(q, l, r): if l\u0026gt;=r: return mid = l+r\u0026gt;\u0026gt;1 merge_sort(q, l, mid); merge_sort(q, mid+1, r) i, j = l, mid+1 tmp = [] while i\u0026lt;=mid and j\u0026lt;=r: if q[i] \u0026lt;= q[j]: tmp.append(q[i]) i += 1 else: tmp.append(q[j]) j += 1 if i\u0026lt;=mid: tmp.extend(q[i:mid+1]) if j\u0026lt;=r: tmp.extend(q[j:r+1]) q[l:r+1] = tmp n = int(input()) arr = list(map(int, input().split())) merge_sort(arr, 0, n-1) print(*arr) 二分 def check(x): # 检查 x 是否满足某种性质 pass # 这里需要根据具体的情况实现 def bsearch_1(l, r): while l \u0026lt; r: mid = (l + r) // 2 if check(mid): r = mid else: l = mid + 1 return l def bsearch_2(l, r): while l \u0026lt; r: mid = (l + r + 1) // 2 if check(mid): l = mid else: r = mid - 1 return l # 示例用法 # 首先定义 check 函数来检查性质 # 然后使用 bsearch_1 或 bsearch_2 来进行二分搜索 最佳牛围栏 题意：n块地，每块地上有奶牛，现在需要用围栏围起一些奶牛， 但至少有f块地，问最终围起的地中牛的数量的平均数的最大值为多少。 浮点数二分最大数量，判断所有数减去当前二分的平均数后，有没有一段长度为f并且是全为正数的，如果有则合法。判断方法：b数组存原数组减去平均数，求前缀和，用前缀和数组求某一段内的和是否为正数即可， 只要长度大于f的所有段都要枚举，但是我们只要求$s[i]-s[0-\u0026gt;i-f]$是否有一个大于0即可，所以只用求$min(s[0:i-f])$即可。注意浮点数二分因为误差需要用eps判断，并且r会稍微大于答案，l会稍微小于答案，题目问的是向下取整最近的整数，所以取r向下取整。 import sys input = lambda:sys.stdin.readline().strip() N = int(1e5+10) a, b = [0]*N, [0]*N n, f = map(int , input().split()) for i in range(1, n+1): a[i] = int(input()) l, r = 0.0, 2e3+10 eps = 1e-6 while r-l \u0026gt; eps: mid = (l+r)/2 s, mi, cur = [0]*N, 1e18, -1e18 for i in range(1, n+1): b[i] = a[i]-mid for i in range(1, n+1): s[i] = s[i-1]+b[i] for i in range(f, n+1): mi = min(mi, s[i-f]) cur = max(cur, s[i]-mi) if cur\u0026gt;=0: l = mid else: r = mid print(int(r*1000)) 浮点数二分 def check(x): # 检查x是否满足某种性质 pass # 这里需要根据具体情况实现check函数 def bsearch_3(l, r): eps = 1e-6 # eps 表示精度，取决于题目对精度的要求 while r - l \u0026gt; eps: mid = (l + r) / 2 if check(mid): r = mid else: l = mid return l 一维前缀和 def prefixSum(arr): n = len(arr) prefixSum = [0] * n prefixSum[0] = arr[0] for i in range(1, n): prefixSum[i] = prefixSum[i-1] + arr[i] for i in range(n): print(prefixSum[i], end=\u0026#34; \u0026#34;) arr = [1, 2, 3, 4, 5] prefixSum(arr) 二维前缀和 import sys # 重定向输入函数为sys.stdin.readline().strip()以去除末尾换行符 input = lambda:sys.stdin.readline().strip() # 读取n、m、q三个整数 n, m, q = map(int, input().split()) # 创建一个n+1行，m+1列的二维列表g，初始值均为0 g = [[0]*(m+1) for _ in range(n+1)] # 读取地图的每一行，并将值转换为整数，存储到g中 for i in range(1, n+1): g[i] = [0] + list(map(int, input().split())) # 计算前缀和，g[i][j]表示以(i,j)为右下角的矩形内所有元素之和 for i in range(1, n+1): for j in range(1, m+1): g[i][j] = (g[i][j] + g[i-1][j] + g[i][j-1] - g[i-1][j-1]) # 针对每个查询，计算给定矩形区域内元素之和 for i in range(q): x1, y1, x2, y2 = map(int, input().split()) # 计算矩形区域内元素之和，利用前缀和的性质 # g[x2][y2]表示右下角坐标为(x2,y2)的矩形内所有元素之和 # g[x1-1][y2]表示右上角坐标为(x1-1,y2)的矩形内所有元素之和 # g[x2][y1-1]表示左下角坐标为(x2,y1-1)的矩形内所有元素之和 # g[x1-1][y1-1]表示左上角坐标为(x1-1,y1-1)的矩形内所有元素之和 # 利用以上四个值，可以求得目标矩形区域内元素之和 print(g[x2][y2] - g[x1-1][y2] - g[x2][y1-1] + g[x1-1][y1-1]) 一维差分 差分和前缀和是逆运算。\n需要计算某一段区间$+-$操作时，运用差分操作 updateRange 需要先构造差分数组\n$s[i] = s[i-1]+a[i]$ 逆运算 $d[i]=a[i]-a[i-1]$ （原数组看作为前缀和数组）\ndef updateRange(B, l, r, c): B[l] += c B[r + 1] -= c def printArray(arr): for i in range(len(arr)): print(arr[i], end=\u0026#34; \u0026#34;) print() n= 5 B = [0] * (n + 1) updateRange(B, 1, 3, 2) updateRange(B, 2, 4, 3) printArray(B) import sys # 重定向输入函数为sys.stdin.readline().strip()以去除末尾换行符 input = lambda:sys.stdin.readline().strip() # 读取n和m两个整数，表示序列长度和操作次数 n, m = map(int, input().split()) # 读取序列a，长度为n，将其转换为整数列表，同时在开头添加0以便处理边界情况 a = [0] + list(map(int, input().split())) # 初始化差分数组d，长度为n+2，初始值均为0 d = [0]*(n+2) # 计算原始序列a中相邻元素的差值，存储到差分数组d中 for i in range(1, n+1): d[i] = a[i] - a[i-1] # 执行m次操作 for i in range(m): # 读取操作参数l、r、c，表示对[l,r]范围内元素增加c l, r, c = map(int, input().split()) # 在差分数组中更新对应区间[l,r]内元素的增量 d[l] += c d[r+1] -= c # 根据差分数组还原原始序列 for i in range(1, n+1): d[i] += d[i-1] # 输出还原后的原始序列 print(*d[1:n+1]) 二维差分 # 从输入中获取网格的行数、列数和操作数量 n, m, q = map(int, input().split()) # 初始化原始网格数组和操作影响数组 g = [[0]*(m+1) for _ in range(n+1)] d = [[0]*(m+2) for _ in range(n+2)] # 填充原始网格数组 for i in range(1, n+1): # 将每行的数据存入二维数组g中 g[i] = [0] + list(map(int, input().split())) # 处理每个操作 for i in range(q): # 获取操作的左上角坐标、右下角坐标和要添加到该区域内的值 x1, y1, x2, y2, c = map(int, input().split()) # 更新操作影响数组 d[x1][y1] += c d[x1][y2+1] -= c d[x2+1][y1] -= c d[x2+1][y2+1] += c # 根据操作影响数组更新原始网格数组 for i in range(1, n+1): for j in range(1, m+1): # 更新操作影响的累积值 d[i][j] = d[i][j] + d[i-1][j] + d[i][j-1] - d[i-1][j-1] # 更新原始网格数组中的值 g[i][j] += d[i][j] # 打印更新后的原始网格数组 for i in range(1, n+1): print(*g[i][1:m+1]) 双指针 for i in range(n): j = 0 while j \u0026lt; i and check(j, i): j += 1 # 具体问题的逻辑 # 常见问题分类： # (1) 对于一个序列，用两个指针维护一段区间 # (2) 对于两个序列，维护某种次序，比如归并排序中合并两个有序序列的操作 位运算 原码，反码，补码 求n二进制表示中第k位数字: n \u0026gt;\u0026gt; k \u0026amp; 1 返回n的最后一位1：lowbit(n) = n \u0026amp; -n 树状数组基本操作 离散化 alls = [] # 存储所有待离散化的值 # 将所有值排序 alls.sort() # 去掉重复元素 alls = list(set(alls)) # 二分求出x对应的离散化的值 def find(x): l, r = 0, len(alls) - 1 while l \u0026lt; r: mid = (l + r) // 2 if alls[mid] \u0026gt;= x: r = mid else: l = mid + 1 return r + 1 # 映射到1, 2, ...n import sys input = lambda:sys.stdin.readline().strip() def find(x): l, r = 0, num while l\u0026lt;r: mid = (l+r+1)\u0026gt;\u0026gt;1 if ls[mid] \u0026lt;= x: l = mid else: r = mid-1 return l N = int(1e5)+10 s = [0]*N ls = [] d = dict() n, m = map(int, input().split()) for i in range(n): x, c = map(int, input().split()) if x not in d: d[x] = c ls.append(x) else: d[x] += c ls.sort() num = len(d) ls = [0] + ls for i in range(1, num+1): s[i] = s[i-1] + d[ls[i]] for i in range(m): l, r = map(int, input().split()) pl, pr = find(l), find(r) if l in d: pl -= 1 print(s[pr] - s[pl]) 区间合并 def merge(segs): segs.sort() # 区间左端点排序 res = [] st, ed = -2e9, -2e9 for seg in segs: if ed \u0026lt; seg[0]: if st != -2e9: res.append((st, ed)) st, ed = seg[0], seg[1] else: ed = max(ed, seg[1]) if st != -2e9: res.append((st, ed)) segs[:] = res n = int(input()) st, ed = -int(2e9), -int(2e9) segs = [] for i in range(n): l, r = map(int, input().split()) segs.append((l, r)) segs.sort() cnt = 0 for seg in segs: s, e = seg if s\u0026gt;ed: st, ed = s, e cnt+=1 else: ed = max(e, ed) print(cnt) 矩阵快速幂 mod = int(1e9) + 7 def mul(a, b): t = [[0]*101 for _ in range(101)] for i in range(1, n+1): for j in range(1, n+1): for k in range(1, n+1): t[i][j] = (t[i][j] + a[i][k]*b[k][j]) % mod return t def qp(a, k): res = [[0]*101 for _ in range(101)] for i in range(1, n+1): res[i][i] = 1 while k: if k\u0026amp;1: res = mul(res, a) a = mul(a, a) k\u0026gt;\u0026gt;=1 return res n, k = map(int, input().split()) a = [[0]*101 for _ in range(101)] for i in range(1, n+1): row = [0] + list(map(int, input().split())) for j in range(1, n+1): a[i][j] = row[j] ans = qp(a, k) for i in range(1, n+1): print(*ans[i][1:n+1], sep=\u0026#39; \u0026#39;) 递归98. 分形之城 t = int(input()) def calc(n, m): if not m: return (0, 0) l, cnt = 1\u0026lt;\u0026lt;(n-1), 1\u0026lt;\u0026lt;(2*n-2) x, y = calc(n-1, m%cnt) z = m//cnt if z==0: return (y, x) if z==1: return (x, y+l) if z==2: return (x+l, y+l) if z==3: return (2*l-1 - y, l-1 - x) for i in range(t): n, a, b = map(int, input().split()) a-=1; b-=1 xa, ya = calc(n, a) xb, yb = calc(n, b) dis = int(( (xa-xb)**2 + (ya-yb)**2 ) ** 0.5 * 10 + 0.5) print(dis) 递推95. 费解的开关 题目大意：游戏规则如下：有 25 盏灯排成 5×5 的方形。每一盏灯都有一个开关，改变某一盏灯的状态会导致其上下左右相邻的灯也改变状态。给定初始状态，判断是否能在 6 步以内使所有的灯都变亮。\n实现思路：首先，我们需要实现一个函数 turn(x, y) 来实现改变灯的状态以及连锁反应。然后，我们对于每个初始状态，采用深度优先搜索或者广度优先搜索的方式来模拟游戏过程，尝试所有可能的开关状态组合，并记录达到目标状态所需的步数。最后，输出结果即可。\nfrom copy import deepcopy dx = [0, 1, 0, -1, 0] dy = [0, 0, 1, 0, -1] g = [[] for _ in range(5)] def turn(x, y): for i in range(5): xx = x+dx[i] yy = y+dy[i] if xx in range(5) and yy in range(5): g[xx][yy] ^= 1 def work(): global g backup = deepcopy(g) ans = float(\u0026#39;inf\u0026#39;) for k in range(1\u0026lt;\u0026lt;5): cur, flag = 0, True g = deepcopy(backup) for i in range(5): if (k\u0026gt;\u0026gt;i)\u0026amp;1: turn(0, i) cur+=1 for i in range(4): for j in range(5): if g[i][j]==0: turn(i+1, j) cur+=1 for i in range(5): if g[4][i]==0: flag = False break if flag: ans = min(ans, cur) return ans t = int(input()) for _ in range(t): for i in range(5): g[i] = [int(_) for _ in list(input())] if _ \u0026lt; t-1: input() res = work() if res\u0026lt;=6:print(res) else:print(-1) ST1273. 天才的记忆 题目大意：有一个长度为 N 的数字序列，编号为 1 到 N，每次询问给出两个数字 A 和 B，要求回答 A 到 B 区间内的最大数。\n实现思路：这是一个典型的区间最值查询问题，可以使用线段树进行求解。首先，需要初始化一个二维数组 f 用于存储区间最大值信息。然后，利用预处理的方式，计算出 log 数组，用于快速计算区间长度的对数。接着，利用动态规划的思想，初始化 f 数组，使得 f[i][0] 等于数字序列中对应位置的值。接下来，利用动态规划的思想，更新 f 数组，使得 f[i][j] 等于区间 [i, i+2^j-1] 内的最大值。最后，对于每个询问，利用预处理的区间最值信息，通过 log 数组快速确定区间长度的对数，然后利用区间最值信息查询区间最大值，即可得到答案。\nimport sys input = lambda:sys.stdin.readline().strip() N = int(2e5)+10 M = 20 f = [[0]*M for _ in range(N)] log = [0]*N def init(): log[0] = -1 for i in range(1, N): log[i] = log[i\u0026gt;\u0026gt;1] + 1 for j in range(M): for i in range(1, n+1): if not j: f[i][j] = w[i] else: if i + (1\u0026lt;\u0026lt;(j-1)) \u0026gt; n: break f[i][j] = max(f[i][j-1], f[i+(1\u0026lt;\u0026lt;(j-1))][j-1]) def query(l, r): leng = r-l+1 k = log[leng] return max(f[l][k], f[r-(1\u0026lt;\u0026lt;k)+1][k]) n = int(input()) w = [0] + list(map(int, input().split())) init() m = int(input()) for i in range(m): l, r = map(int, input().split()) print(query(l, r)) ","permalink":"https://kennems.github.io/zh/posts/tech/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0%E4%B8%80%E5%9F%BA%E7%A1%80+%E6%9D%82%E9%A1%B9python%E5%AE%9E%E7%8E%B0/","summary":"算法笔记（一）——基础+杂项（Python实现） 基础+杂项 快速排序 def quick_sort(q, l, r): if l\u0026gt;=r: return i,j,x=l-1,r+1,q[(l+r)\u0026gt;\u0026gt;1] while i\u0026lt;j: i+=1 while q[i]\u0026lt;x: i+=1 j-=1 while q[j]\u0026gt;x: j-=1 if i\u0026lt;j: q[i], q[j] = q[j], q[i] quick_sort(q, l, j) quick_sort(q, j+1, r) n=int(input()) arr=list(map(int, input().split())) quick_sort(arr,0,n-1) print(\u0026#34; \u0026#34;.join(map(str,","title":"算法笔记（一）——基础+杂项（Python实现）"},{"content":"周赛240407 出师不利，第一题变量名能写错，慢就是快，少就是多，提交之前一定要有万全的检查。\n第二题100242. 满足距离约束且字典序最小的字符串 纯思维题，先花时间想清楚基础问题再想后面的问题。吸取教训，代码一定要写的清晰明了，自己才能更好的看懂并写下去。\nPython 取模运算中余数符号和除数符号一致，并满足：$被除数-除数*商(整除)=余数$\n思路：转换问题，问不超过k，那么用完$k$是最优的，因为用$k$总能使字典序变小(除非原序列全是$a$), 那么就依次枚举，知道不能转换为$a$的情况下将剩余的$k$转换称可以转换成的最小的字典序字母。\nclass Solution: def getSmallestString(self, s: str, k: int) -\u0026gt; str: s = list(s) n = len(s) for i in range(n): d = min(ord(s[i])-ord(\u0026#39;a\u0026#39;), ord(\u0026#39;a\u0026#39;)-ord(s[i])+26) if k\u0026gt;=d: k-=d s[i]=\u0026#39;a\u0026#39; else: num = ord(s[i])-ord(\u0026#39;a\u0026#39;) ch = min((num-k)%26, (num+k)%26) ch = chr(ch+ord(\u0026#39;a\u0026#39;)) s[i] = ch break return \u0026#39;\u0026#39;.join(s) 第三题 3107. 使数组中位数等于 K 的最少操作数 这题比较简答，最后一刻用二分交的，结果右端点取值保守错了一发。\n实际不需要二分，在排好序的序列里，用中位数去靠近中位数更优，所以直接排序计算将前面比k大的和后面比$k$小的计算差值就可以了。\nclass Solution: def minOperationsToMakeMedianK(self, nums: List[int], k: int) -\u0026gt; int: nums.sort() n = len(nums) mid = n // 2 op=abs(nums[mid]-k) for i in range(mid): if nums[i]\u0026gt;k: op += nums[i] - k for i in range(mid+1, n): if nums[i]\u0026lt;k: op += k - nums[i] return op 第四题100244. 带权图里旅途的最小代价 并查集+思维题。如果一些数字相与$(and)$， 如果存在较小的数字二进制位中是$0$，那么就算有再多的数字在这一位上是$1$也没有用了。所以在一个连通块内最小代价就是所有边都走一遍，而连通块可以用并查集来判断。\nclass Solution: def minimumCost(self, n: int, edges: List[List[int]], query: List[List[int]]) -\u0026gt; List[int]: def find(x): if p[x]!=x: p[x]=find(p[x]) return p[x] p={i:i for i in range(n)} dis={} ret=[] for u,v,_ in edges: p[find(u)]=find(v) for u,v,w in edges: pu = find(u) if pu not in dis: dis[pu]=w else: dis[pu]\u0026amp;=w for x,y in query: if x==y: ret.append(0) continue #如果相等一定要continue px, py = find(x), find(y) if px==py: ret.append(dis[px]) else: ret.append(-1) return ret ","permalink":"https://kennems.github.io/zh/posts/tech/%E5%91%A8%E8%B5%9B240407/","summary":"周赛240407 出师不利，第一题变量名能写错，慢就是快，少就是多，提交之前一定要有万全的检查。 第二题100242. 满足距离约束且字典序最小的","title":"LeetCode周赛392(240407)"},{"content":"hugo new content posts/my-first-post.md\n","permalink":"https://kennems.github.io/zh/posts/life/my-first-post/","summary":"hugo new content posts/my-first-post.md","title":"My First Post"},{"content":"VP 周赛 第 389 场周赛 第三题3085. 成为 K 特殊字符串需要删除的最少字符数 双指针优化$O(n)$\n第三题做出来了但做法不优并且错的次数太多了。\n题目大意：给定一个字符串word和一个整数k，定义特殊字符串为满足|freq(word[i]) - freq(word[j])| \u0026lt;= k对于字符串中所有下标i和j都成立的字符串。其中，freq(x)表示字符x在word中的出现频率，|y|表示y的绝对值。要求计算使word成为k特殊字符串所需删除的字符的最小数量。\n实现思路：首先统计word中每个字符的出现频率，然后对频率进行排序。接着遍历频率列表，从最大的频率开始，逐步减少频率，直到满足特殊字符串的条件。在减少频率的过程中，利用一个指针指向频率列表中的当前位置，不断向前移动，更新需要删除的字符数量。最终得到使word成为k特殊字符串所需删除的最小字符数量。\nclass Solution: def minimumDeletions(self, word: str, k: int) -\u0026gt; int: ans = 2e9 cnt = sorted(Counter(word).values()) numFre = len(cnt)-1 delCnt = len(word) right = numFre for cur in range(numFre, -1, -1): delCnt-=cnt[cur] maxFre = cnt[cur]+k while right\u0026gt;cur and cnt[right]\u0026gt;maxFre: delCnt+=cnt[right] right-=1 ans = min(ans, delCnt-(numFre-right)*maxFre) return ans 第四题3086. 拾起 K 个 1 需要的最少行动次数 题目大意：给定一个二进制数组nums，长度为n，以及一个正整数k和非负整数maxChanges。Alice在一个游戏中需要从nums中拾起k个1，游戏开始时，Alice可以选择任意位置站立。Alice可以执行两种行动：一是将一个0改为1，次数不超过maxChanges；二是交换相邻位置的1和0。返回Alice拾取k个1所需的最少行动次数。\n实现思路：首先，统计nums中1的位置，同时记录每个1的前缀和。然后确定最多可以拾取的1的个数，即为maxChanges和当前1的个数的最小值。如果最大变化次数maxChanges足够多，那么不需要交换1的位置，直接计算需要变化的次数即可；否则，利用二分搜索确定需要交换的1的位置，计算交换和变化的次数。最终返回行动次数。\nclass Solution: def minimumMoves(self, nums: List[int], k: int, maxChanges: int) -\u0026gt; int: pos = [] n=len(nums) c=0 for i, v in enumerate(nums): if not v: continue pos.append(i) if c==3: continue c=max(c, 1) if i\u0026gt;0 and nums[i]==nums[i-1]: c = max(2, c) if i\u0026gt;1 and nums[i]==nums[i-1] and nums[i]==nums[i-2]: c = max(3, c) c = min(c, k) if maxChanges\u0026gt;=k-c: return max(0, (k-c)*2)+max(0, c-1) n = len(pos) preSum = list(accumulate(pos, initial = 0)) ret = inf rest = k-maxChanges for right in range(rest, n+1): left = right-rest i=left+right\u0026gt;\u0026gt;1 s1 = pos[i]*(i-left) - (preSum[i]-preSum[left]) s2 = preSum[right]-preSum[i]-pos[i]*(right-i) ret = min(ret, s1+s2) return ret+maxChanges*2 ","permalink":"https://kennems.github.io/zh/posts/tech/vp-%E5%91%A8%E8%B5%9B389/","summary":"VP 周赛 第 389 场周赛 第三题3085. 成为 K 特殊字符串需要删除的最少字符数 双指针优化$O(n)$ 第三题做出来了但做法不优并且错的次数太多了。 题目大","title":"LeetCode周赛VP389"},{"content":"周赛240331 第四题 100240 最小化曼哈顿距离\n题目大意：给定一个二维平面上的点集，求移除其中一个点后，剩余点集中任意两点之间的最大曼哈顿距离的最小值。\n实现思路：首先，对于曼哈顿距离而言，它的定义是两点在各个坐标轴上的差的绝对值之和。所以移除一个点后，影响到最大曼哈顿距离的主要是距离移除点最近的点。我们可以将点的坐标进行转换，将其转换为(x+y)和(x-y)的形式，这样在平面上的曼哈顿距离就可以等效为在转换后的坐标系下的欧几里得距离。然后我们用两个有序集合分别维护x+y和x-y的坐标轴上的值，分别为xset和yset。然后遍历每个点，从点集中移除一个点，更新最大距离，找到最小值。\nfrom sortedcontainers import SortedList class Solution: def minimumDistance(self, points: List[List[int]]) -\u0026gt; int: xset, yset = SortedList(), SortedList() for x, y in points: xset.add(x+y) yset.add(x-y) ans = inf for x, y in points: xx = x+y yy = x-y xset.remove(xx) yset.remove(yy) ans = min( ans, max(xset[-1]-xset[0], yset[-1]-yset[0]) ) xset.add(xx) yset.add(yy) return ans ","permalink":"https://kennems.github.io/zh/posts/tech/%E5%91%A8%E8%B5%9B240331/","summary":"周赛240331 第四题 100240 最小化曼哈顿距离 题目大意：给定一个二维平面上的点集，求移除其中一个点后，剩余点集中任意两点之间的最大曼哈顿距离的最小","title":"LeetCode周赛240331"},{"content":"周赛 24/3/24 第三题 100258 3092. 最高频率的 ID 题目大意：给定两个长度为n的整数数组nums和freq，nums中的每个元素表示一个ID，对应的freq中的元素表示这个ID在集合中此次操作后需要增加或者减少的数目。现要求在每一步操作后，返回出现频率最高的ID数目，若集合为空则为0。 SortedList实现\nfrom sortedcontainers import SortedList class Solution: def mostFrequentIDs(self, nums: List[int], freq: List[int]) -\u0026gt; List[int]: sl = SortedList(key = lambda x : -x) d = defaultdict(int) ret = [] for x,y in zip(nums, freq): if d[x]!=0: sl.remove(d[x]) d[x]+=y sl.add(d[x]) else: d[x]=y sl.add(d[x]) if sl: ret.append(sl[0]) else: ret.append(0) return ret heap 实现\n实现思路： 使用一个字典d来动态记录ID的出现频率，初始化一个空堆heap和结果列表ret。\n遍历nums和freq数组，对于每对nums[i]和freq[i]，更新字典d中对应ID的频率。\n将(-d[x], x)元组加入堆heap，其中-d[x]表示ID x的出现频率的相反数，x表示ID本身。堆按照频率从高到低排序。\n进入循环，检查堆顶元素是否满足当前频率，若不满足则弹出直至满足。\n将当前堆顶元素的频率加入结果列表ret。\n返回结果列表ret。\nclass Solution: def mostFrequentIDs(self, nums: List[int], freq: List[int]) -\u0026gt; List[int]: d = defaultdict(int) heap = [] ret = [] for x,y in zip(nums, freq): d[x]+=y heapq.heappush(heap, (-d[x], x)) while True: tx, ty = heap[0] if -tx != d[ty]: heapq.heappop(heap) continue ret.append(-tx) break return ret 第四题 1002683093. 最长公共后缀查询 Trie树\n题目大意： 给定两个字符串数组wordsContainer和wordsQuery，对于每个wordsQuery[i]，需要从wordsContainer中找到一个与wordsQuery[i]有最长公共后缀的字符串。若有多个满足条件的字符串，选择长度最短的一个，若长度相同则选择在wordsContainer中出现较早的一个。返回一个整数数组ans，其中ans[i]表示wordsContainer中与wordsQuery[i]有最长公共后缀的字符串的下标。\n实现思路：\n初始化一个变量mi记录wordsContainer中最短字符串的长度，并记录其下标为idx。 构建字典trie，用于存储wordsContainer中每个字符串的逆序形式，并记录最短字符串的下标和长度。 遍历wordsQuery，对于每个查询字符串，将其逆序，然后在trie中搜索与之匹配的最长公共后缀，并返回其对应的下标。 将所有查询结果存入结果列表ret，并返回。 class Solution: def stringIndices(self, c: List[str], q: List[str]) -\u0026gt; List[int]: mi = inf idx = -1 ret = [] for i, w in enumerate(c): if len(w)\u0026lt;mi: mi = len(w) idx = i trie = {} #dict for i, w in enumerate(c): w=w[::-1] cur=trie for wi in w: if wi not in cur: cur[wi] = {} cur = cur[wi] if \u0026#39;#\u0026#39; not in cur: cur[\u0026#39;#\u0026#39;] = (i, len(w)) elif len(w)\u0026lt;cur[\u0026#39;#\u0026#39;][1]: cur[\u0026#39;#\u0026#39;] = (i,len(w)) for i, w in enumerate(q): w=w[::-1] cur = trie ans = idx for wi in w: if wi not in cur: break else: cur = cur[wi] ans = cur[\u0026#39;#\u0026#39;][0] ret.append(ans) return ret ","permalink":"https://kennems.github.io/zh/posts/tech/%E5%91%A8%E8%B5%9B240324/","summary":"周赛 24/3/24 第三题 100258 3092. 最高频率的 ID 题目大意：给定两个长度为n的整数数组nums和freq，nums中的每个元素表示一个ID，对应的freq中的元素","title":"LeetCode周赛240324"},{"content":"机器学习简介 Different types of Functions\nRegression : The function outputs a scalar(标量）.\npredict the PM2.5 Classification ： Given options (classes), the function outputs the correct one.\nSpam filtering Structured Learning ： create something with structure(image, document)\nExample : YouTube Channel\n1.Function with Unknown Parameters. $$ y=b+wx_1 $$\n2.Define Loss from Training Data Loss is a function of parameters $$ L(b,w) $$\nLoss : how good a set of values is. L is mean absolute error (MAE) $$ e=\\left | y-\\hat{y} \\right | $$\nL is mean square error (MSE) $$ e=(y-\\hat{y})^2 $$\n$$ L=\\frac{1}{N} \\sum_{n}^{}e_n $$\n3.Optimization $$ w^,b^=arg,\\min_{w,b} ,L $$\nGradient Descent\n(Randomly) Pick an initial value ： $$ w^0 $$\nCompute : $$ \\frac {\\partial L} {\\partial w} |_{w=w_0} $$\nNegative : Increase w\nPositive : Decrease w\n$$ \\eta\\frac {\\partial L} {\\partial w} |_{w=w_0} $$\nη：learning rate (hyperparameters)\nUpdate w iteratively Local minima global minima 类似一个参数，推广到多个参数。\nLinear Models Linear models have severe limitation. Model Bias.\nWe need a more flexible model!\ncurve = constant + sum of a set of Hard Sigmoid Function\n$$ y=c\\frac {1} {1+exp(-(b+wx_1))} \\ =csigmoid(b+wx_1) $$\n$$ y=b+\\sum_{i}sigmoid(b_i+w_ix_i) $$\n$$ y=b+\\sum_{i}sigmoid(b_i+\\sum_{j}w_{ij}x_j) $$\n线性代数角度：\n$$ r=b+Wx $$\n$$ a=\\sigma(r) $$\n$$ y=b+c^Ta $$\nLoss\nLoss is a function of parameters L(θ) Loss means how good a set of values is. Optimization of New Model $$ \\theta= \\begin{bmatrix}\n\\theta_1 \\ \\theta_2 \\ \\theta_3 \\ \\dots \\end{bmatrix} $$\n$$ \\theta=arg \\min_\\theta L $$\n(Randomly) Pick initial values θ^0 1 epoch = see all the batched once\nupdate : update θ for each batch\nSigmoid -\u0026gt; ReLU (Rectified Linear Unit) 统称为 Activation function\nNeural Network\n","permalink":"https://kennems.github.io/zh/posts/tech/1.%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E7%AE%80%E4%BB%8B/","summary":"机器学习简介 Different types of Functions Regression : The function outputs a scalar(标量）. predict the PM2.5 Classification ： Given options (classes), the function outputs the correct one. Spam filtering Structured Learning ： create something with structure(image, document) Example : YouTube Channel 1.Function with Unknown Parameters. $$ y=b+wx_1 $$ 2.Define Loss from Training Data Loss is a","title":"1. 机器学习简介"},{"content":"PyTorch PyTorch Tutorial\nPython3中机器学习框架\ndataset = MyDataset(file) dataloader = DataLoader(dataset, batch_size = size , shuffle = True) Training : True Testing : False from torch.utils.data import Dataset, DateLoader class MyDataset(Dataset): def __init__(self, file): # read data \u0026amp; preprocess self.data = ... def __getitem__(self,index): #return one sample at a time return self.data[index] def __len__(self): #return the size of the dataset return len(self.data) dataset = MyDataset(file) dataloader = Dataloader(dataset, batch_size, shuffle = True) shuffle : Training -\u0026gt; true Testing -\u0026gt; false Tersors High-dimensional matrices(arrays)\n.shape() # show the dimension #Directly from data (list or numpy.ndarray) x = torch.tensor([1, -1], [-1, 1]) x = torch.from_numpy(np.array([[1, -1], [-1, 1]])) #Tensor of constant zeros \u0026amp; ones x = torch.zeros([2, 2]) x = torch.ones([1, 2, 5]) x+y x-y y=x.pow(2) y=x.sum() y=x.mean() #Transpose : transpose two specified dimensions x = x.transpose(dim0,dim1) # change the dimension dim0 and dim1 #Squeeze : remove the specified dimension with length 1 x = x.squeeze(1) #unsqueeze expand a new dimension x = x.unsqueeze(1) dim in PyTorch == axis in NumPy\ndimensional\nCheck with.shape()\tCreating Tensors Directly from data (list or numpy.ndarray)\nx = torch.tensor([1, -1], [-1, 1]) x = torch.from_numpy(np.array([[1, -1], [-1, 1]])) Tensor of constant zeros \u0026amp; ones\nx = torch.zeros([2,2]) x = torch.ones([1, 2, 5]) Common Operations addition subtraction power summation mean\ntranspose x.shape x.transpose(0,1) Unsqueeze : expand a new dimension\nx = x.unsqueeze(1) **Cat **: conncatenate multiple tensors 合并多个矩阵\ntorch.cat([x, y, z], dim = 1) Data Type: Using different data types for model and data will case errors.\n32-bit -torch.float\n64-bit -torch.long\nDevice\nTensors \u0026amp; modules will be computed with CPU by default Use .to() to move tensors to appropriate devices CPU x = x.to('cpu')\t- ```py x = x.to('cuda') GPU check if your computer has NVIDIA GPU torch.cuda.is_available() - Multiple GPUs : specify- ``` 'cuda:0', 'cuda:1', 'cuda:2',... Cradient Calculation import torch # 定义一个需要求导的张量 x，并将 requires_grad 参数设置为 True x = torch.tensor([[1., 0.], [-1., 1.]], requires_grad=True) # 计算 x 的平方并对其进行求和，得到张量 z z = x.pow(2).sum() # 对张量 z 进行反向传播，自动计算出 x 的梯度 z.backward() # 输出 x 的梯度 print(x.grad) torch.nn Network Layers Linear Layer (Fully-connected Layer) nn.linear(in_features, out_features) #### Non-linear Activation Functions```pynn.Sigmoid()nn.ReLU() Build your own neural network import torch.nn as nn class MyModel(nn.Module): #initialize your model \u0026amp; define layers def __init__(self): super(MyModel, self).__init__() self.net = nn.Sequential( nn.Linear(10, 32), nn.Sigmoid(), nn.Linear(32,1) ) #compute output of your nn def forward(self, x): return self.next() Loss Functions Mean squared Error (for regression tasks) criterion = nn.MSELoss() Cross Entropy (for classification tasks) 交叉熵 criterion = nn.CrossEntropyLoss() loss = criterion(model_output, expected_value) ### torch.optim- Stochastic Gradient Descent (SGD) - ```py torch.optim.SGD(model.parameters(), lr, momentum = 0) For every batch of data Call optimizer.zero_grad() to reset gradients of model parameters. Call loss.backward() to backpropagate gradients of prediction loss Call optimizer.step() to adjust model parameters Neural Network Training Setup dataset = MyDataSet(file) tr_set = DataLoader(dataset, 16, shuffle = True) model = MyModel().to(device) criterion = nn.MSELoss() optimizer = torch.optim.SGD(model.parameters(), 0.1) Training Loop for epoch in range(n_epochs): # Iterate over n_epochs model.train() # Set the model to training mode for x, y in tr_set: # Iterate over the training set optimizer.zero_grad() # Clear the gradients x, y = x.to(device), y.to(device) # Move data to the device (e.g., GPU) pred = model(x) # Forward pass, compute predictions loss = criterion(pred, y) # Compute the loss loss.backward() # Backward pass, compute gradients optimizer.step() # Update the model\u0026#39;s parameters using the gradients Validation Loop model.eval() # Set the model to evaluation mode total_loss = 0 for x, y in dv_set: # Iterate over the validation set x, y = x.to(device), y.to(device) # Move data to the device with torch.no_grad(): # Disable gradient computation pred = model(x) # Forward pass, compute predictions loss = criterion(pred, y) # Compute the loss total_loss += loss.cpu().item() * len(x) # Accumulate the loss avg_loss = total_loss / len(dv_set) # Calculate the average loss per sample Testing Loop model.eval() # Set the model to evaluation mode preds = [] for x in tt_set: # Iterate over the test set x = x.to(device) # Move data to the device with torch.no_grad(): # Disable gradient computation pred = model(x) # Forward pass, compute predictions preds.append(pred.cpu()) # Append the predictions to the list Data, demo1 Load data : use pandas to load a csv file\ntrain_data = pd.read_cav(\u0026#39;./name.csv\u0026#39;).drop(columns=[\u0026#39;date\u0026#39;]).values x_train, y_train = train_data[:,:-1], train_data[:,:-1] Dataset init : Read data and preproces\ngetitem : Return one sample at a time, In this case, one sample includes a 117 dimensional feature and a label\nlen : Return the size of the dataset. In this case, it is 2699\nclass COVID19Dataset(Dataset): \u0026#39;\u0026#39;\u0026#39; x: np.ndarray 特征矩阵. y: np.ndarray 目标标签, 如果为None,则是预测的数据集 \u0026#39;\u0026#39;\u0026#39; def __init__(self, x, y=None): if y is None: self.y = y else: self.y = torch.FloatTensor(y) self.x = torch.FloatTensor(x) def __getitem__(self, idx): if self.y is None: return self.x[idx] return self.x[idx], self.y[idx] def __len__(self): return len(self.x) Dataloader train_loader = DataLoader(train_dataset, batch_size = 32, shuffle = True, pin_memory = True) Model class My_Model(nn.Module): def __init__(self, input_dim): super(My_Model, self).__init__() # TODO: 修改模型结构, 注意矩阵的维度（dimensions） self.layers = nn.Sequential( nn.Linear(input_dim, 16), nn.ReLU(), nn.Linear(16, 8), nn.ReLU(), nn.Linear(8, 1) ) def forward(self, x): x = self.layers(x) x = x.squeeze(1) # (B, 1) -\u0026gt; (B) return x Criterion criterion = torch.nn.MSELoss(reduction = \u0026#39;mean\u0026#39;) Optimizer optimizer = torch.optim.SGD(model.parameters(), lr = 1e-5, momentum = 0.9) Training Loop Documentation and Common Errors read pytorch tutorial\nColab（highly recommended） ","permalink":"https://kennems.github.io/zh/posts/tech/2.pytorch/","summary":"PyTorch PyTorch Tutorial Python3中机器学习框架 dataset = MyDataset(file) dataloader = DataLoader(dataset, batch_size = size , shuffle = True) Training : True Testing : False from torch.utils.data import Dataset, DateLoader class MyDataset(Dataset): def __init__(self, file): # read data \u0026amp; preprocess self.data = ... def __getitem__(self,index): #return one sample at a time return self.data[index] def __len__(self): #return the size of","title":"2. PyTorch"},{"content":"Officially begin Deep = Many hidden layers\nNeurall Network Find a function in function set.\nGoodness of function Pick the best function\nBackpropagation - Backward Pass(反向传播) 反向的neural network\nRegression Stock Market Forecast Self-driving Car Recommendation Step 1 : Model A set of function\nStep 2 : Goodness of Function $$ \\hat{y}^1代表x^1对应的确切值 $$\nLoss function L： $$ L(f)=L(w,b) ~ Estimated ~ y ~ basedoninputfunction $$\n$$ L(w,b)=\\sum_{n=1}^{10}(\\hat{y}^n-(b+w\\cdot x_{cp}^n))^2 $$\nStep 3 ：Best Function In linear regression, the loss function L is convex.\nOverfitting\nRegularization $$ L(w,b)=\\sum_{n=1}^{10}(\\hat{y}^n-(b+w\\cdot x_{cp}^n))^2+\\lambda\\cdot \\sum(w_i)^2 $$\n不需要考虑bias，调整平滑程度，smooth\nGradient descent Overfitting and Regularization Classification independently and identically distributed(i.i.d) $$ L(h^{train},D_{all})-L(h^{all}, d_{all}) \\leq \\delta\\ we\\ need \\ \\forall h \\in \\H, |L(h,D_{train}) -L(h,D_{all}) | \\leq \\delta/2\\ L(h^{train},D_{all})\\leq L(h^{train},D_{all}) + \\delta/2 $$ 重温数码宝贝：\n模型出现bad的概率： $$ P(D_{train}\\ is\\ bad)\\leq |H| \\cdot 2exp(-2N\\epsilon^2 ) \\ N \\ge \\frac{log(2|H|/\\delta)}{2\\epsilon^2} $$ Tradeoff of Model Complexity\nTraining data for Classification pair\nIdeal Alternatives Function(Model): $$ f(x)\\ x -\u0026gt; g(x)\u0026gt;0~Output=class1\\ else\\ Output=class2 $$\nlossfunction: The number of times of get incotrrect results on training data. $$ L(f) = \\sum_{n}\\delta(f(x^n)\\neq\\hat{y}^n) $$\nFind the best function; Example : Perceptron, SVM Prior $$ P(C_1|x)=\\frac{P(x|C_1)P(C_1)}{P(x|C_1)P(C_1)+P(x|C_2)P(C_2)} $$\nGaussian Maximum Likelihood\n2D array or 3D array mean the array with 2 or 3 axes respectively, but the n-dimensional vector mean the vector of length n.\nLearn something that can really differ you from others.\nLogistics Regression Function Set $$ f_{w,b}=\\sigma(\\sum_{i}w_ix_i)+b $$\nOutput : Between 0 and 1 $$ f_{w,b}(x)=P_{w,b}(C_1|x) $$\n$$ w^,b^=arg\\ \\underset{w,b}{max}L(w,b)\\ 等同于 w^,b^ = arg\\ \\underset{w,b}{min}-lnL(w,b) $$\nCross Entropy: $$ Distribution \\ p: p(x=1)=\\hat{y}^n\\ p(x=0)=1-\\hat{y}^n\\ Distribution \\ q: q(x=1)=f(x^n)\\ q(x=0)=1-f(x^n)\\ H(p,q)=-\\sum_xp(x)ln(q(x)) $$\nLoss Function $$ L(f)=\\sum_nC(f(x^n),\\hat{y}^n)\\ C(f(x^n),\\hat{y}^n)=-[\\hat{y}^nlnf(x^n)+(1-\\hat{y}^n)ln(1-f(x^n))] $$\nUpdate logistic regression 和 linear regression 形式完全相同 $$ w_i\\gets w_i-\\eta \\sum_{n}-(\\hat{y}^n-f_{w,b}(x^n))x_i^n $$\nDiscriminative (logistic) \u0026amp; Generative (Gaussian描述) Generative做了某些假设。\nBenefit of generative model With the assumption of probability distribution, less training data is needed With the assumption of probability distribution, more robust to the noise Priors and class-dependent probabilities can be estimated from different sources. Multi-class Classification SoftMax $$ Softmax(z_i)=\\frac{e^{z_i}}{\\sum_{c=1}^{C} e^{z_c}}\\ 1 \u0026gt; y_i\u0026rsquo; \u0026gt; 0\\ \\sum_iy_i\u0026rsquo;=1 $$\nLimitation of Logistic Regression 只能画一条直线\nFeature Transformation Cascading logistic regression models Optimization Issue 层数较多表现的反而没有层数较少的好\nOver fitting 增加训练资料\nData augmentation\nconstrained model\nLess parameters, sharing parameters Less features Early stopping CNN-\u0026gt;比较没有弹性的model\n分Training Set\nN-fold Cross Validation Optimization Fail H : Hessian\nTayler Series Approximation $$ L(\\theta) \\approx L(\\theta^\\prime)+\\frac{1}{2}(\\theta-\\theta^\\prime)^TH(\\theta-\\theta^\\prime) $$\nH is positive definte = All eigen values are positive -\u0026gt; local minima H is negative definte = All eigen values are negative -\u0026gt; **local ** Some eigen values are positive , and some are negative -\u0026gt; Saddle point 在高维下local minima可能会变成saddle poing\nTips for training : Batch and Momentum Batch 1 epoch = see all the batches once -\u0026gt; shuffle after each epoch\nMomentum Movement not just based on gradient, but previous movement.\nDifferent parameters needs different learning rate $$ \\theta_i^{t+1} \\gets \\theta_i^t-\\frac{\\eta}{\\sigma_i^t}g_i^t\\ \\sigma_i^t=\\sqrt{\\frac{1}{t+1}\\sum_{i=0}^t(g_i^t)^2} $$\nAdagred\nRMSProp $$ \\theta_i^{t+1} \\gets \\theta_i^t-\\frac{\\eta}{\\sigma_i^t}g_i^t\\ \\sigma_i^t = \\sqrt{\\alpha(\\sigma_i^{t-1})^2+(1-\\alpha)(g_i^t)^2} $$\nAdam : RMSProp + Momentum\nLearning Rate Sceduling $$ \\theta_i^{t+1} \\gets \\theta_i^t-\\frac{\\eta^t}{\\sigma_i^t}g_i^t\\ $$\nWarm Up New Optimization ","permalink":"https://kennems.github.io/zh/posts/tech/3.regression-and-classification/","summary":"Officially begin Deep = Many hidden layers Neurall Network Find a function in function set. Goodness of function Pick the best function Backpropagation - Backward Pass(反向传播) 反向的neural network Regression Stock Market Forecast Self-driving Car Recommendation Step 1 : Model A set of function Step 2 : Goodness of Function $$ \\ha","title":"3. Regression and Classification"},{"content":"Convolutional network (CNN) Network的架构调整\n1、All the images to be classified have the same size.\nReceptive filed\nSimplification 1 - Typical Setting all channels : 会看所有的channels\nkernel size : 长和宽 （e.g., 3*3)\nStride : 移动的步长,希望有高度的重叠\npadding : 补值，补充超出范围的值\nEach receptive field has a set of neurons.\nEach receptive field has the neurons with the same set of parameters, which called filter.\nPooling Flatten ","permalink":"https://kennems.github.io/zh/posts/tech/4.cnn/","summary":"Convolutional network (CNN) Network的架构调整 1、All the images to be classified have the same size. Receptive filed Simplification 1 - Typical Setting all channels : 会看所有的channels kernel size : 长和宽 （e.g., 3*3) Stride : 移动的","title":"4. CNN"},{"content":"Spatial Transformer（STN） 处理旋转和放大图形的CNN分类\ninterpolation 插值法 Self-attention Sequence Labeling consider the context -\u0026gt; 参数很大并且容易Over fitting\nSelf-attention会持有整个sequence的信息\ninput : vector\noutput : vector $$ q_i=W^qa^i\\ k_i=W^ka^i\\ v^i=W^va^i $$ Multi-head Self-attention 其中 $$ q_i, k_i, v_i均可以有多个 $$\nSelf-attention for Speech Truncated(截短的) Self-attention\nSelf-attention is the complex version of CNN\nCNN is simplified self-attention\nRecurrent Neural Network(RNN) RNN所做的事情都可以用Self-attention来替代\nSelf-attention更有效率\nRNN\nTransformer Sequence to sequence (Seq2seq) Encoder -\u0026gt; Decoder\nEncoder input some vectors and output some vectors\nDecoder Autoregressive Non-autoregressive Decoder 同时输出BEGIN并且同时输出结果和END\nAdvantage ： parallel, controllable output length\nNAT is usually worse than AT\nEncoder-Decoder Cross Attention\nTeacher Forcing : using the ground truth as input\nCopy Mechanism\nPointer Network Copying Mechanism Guided Attention Beam Search Scheduled Sampling\n","permalink":"https://kennems.github.io/zh/posts/tech/5.transformer/","summary":"Spatial Transformer（STN） 处理旋转和放大图形的CNN分类 interpolation 插值法 Self-attention Sequence Labeling consider the context -\u0026gt; 参数很大并且容易Over fitting Self-attention","title":"5. Transformer"},{"content":" 名称： Sulv\u0026rsquo;s Blog 网址： https://www.sulvblog.cn 图标： https://www.sulvblog.cn/img/Q.gif 描述： 一个记录技术、阅读、生活的博客 ","permalink":"https://kennems.github.io/zh/links/","summary":"名称： Sulv\u0026rsquo;s Blog 网址： https://www.sulvblog.cn 图标： https://www.sulvblog.cn/img/Q.gif 描述： 一个记录技术、阅读、生活的博客","title":"🤝友链"},{"content":" 欢迎来到我的博客😆， 🤝个人简历!！\n名称: ShowGuan😶‍🌫️ 自我介绍: 一名电子信息专业的大三学生，但是热衷于软件，这里记录了我的学习笔记，曾经遇到的问题，以及在学习过程中遇到的好用的工具。👍 ","permalink":"https://kennems.github.io/zh/about---%E5%89%AF%E6%9C%AC/","summary":"欢迎来到我的博客😆， 🤝个人简历!！ 名称: ShowGuan😶‍🌫️ 自我介绍: 一名电子信息专业的大三学生，但是热衷于软件，这里记录了我的学习笔记","title":"🙋🏻‍♂️关于"},{"content":" 欢迎来到我的博客😆！\n名称: ShowGuan😶‍🌫️ 自我介绍: 一名电子信息专业的大三学生，但是热衷于软件，这里记录了我的学习笔记，曾经遇到的问题，以及在学习过程中遇到的好用的工具。👍 ","permalink":"https://kennems.github.io/zh/about/","summary":"欢迎来到我的博客😆！ 名称: ShowGuan😶‍🌫️ 自我介绍: 一名电子信息专业的大三学生，但是热衷于软件，这里记录了我的学习笔记，曾经遇到的问","title":"🙋🏻‍♂️关于"},{"content":"acwing算法学习 [TOC]\n第一章 课上：学思想\n课下：背代码\n题目，一道题写好几遍\n理解没有任何意义，体力活+脑力活\n记忆力 毅力/自制力\n沉下心背东西\n快速排序算法模板 —— 模板题 AcWing 785. 快速排序 分治\n1、确定分界点，l、r、（l+r)/2 随机\n2、调整区间，分为两边，左边小于等于x,右边大于等于x\n3、递归处理左右两段\nvoid quick_sort(int q[], int l, int r) { if (l \u0026gt;= r) return; int i = l - 1, j = r + 1, x = q[l + r \u0026gt;\u0026gt; 1]; while (i \u0026lt; j) { do i ++ ; while (q[i] \u0026lt; x); do j -- ; while (q[j] \u0026gt; x); if (i \u0026lt; j) swap(q[i], q[j]); } quick_sort(q, l, j), quick_sort(q, j + 1, r); } -std=c++11 归并排序算法模板 —— 模板题 AcWing 787. 归并排序 排序稳定：序列中相同的值排序后的相对位置是否发生改变\n时间复杂度有 （nlogn)\n1）确定分界点mid\n2）递归排序两边\n2）归并，合并为一个有序数组\nvoid merge_sort(int q[], int l, int r) { if (l \u0026gt;= r) return; int mid = l + r \u0026gt;\u0026gt; 1; merge_sort(q, l, mid); merge_sort(q, mid + 1, r); int k = 0, i = l, j = mid + 1; while (i \u0026lt;= mid \u0026amp;\u0026amp; j \u0026lt;= r) if (q[i] \u0026lt; q[j]) tmp[k ++ ] = q[i ++ ]; else tmp[k ++ ] = q[j ++ ]; while (i \u0026lt;= mid) tmp[k ++ ] = q[i ++ ]; while (j \u0026lt;= r) tmp[k ++ ] = q[j ++ ]; for (i = l, j = 0; i \u0026lt;= r; i ++, j ++ ) q[i] = tmp[j]; } 整数二分算法模板 —— 模板题 AcWing 789. 数的范围 边界问题\n本质：区间内一半满足一半不满足\nl=mid时加一\nbool check(int x) {/* ... */} // 检查x是否满足某种性质 // 区间[l, r]被划分成[l, mid]和[mid + 1, r]时使用： int bsearch_1(int l, int r) { while (l \u0026lt; r) { int mid = l + r \u0026gt;\u0026gt; 1; if (check(mid)) r = mid; // check()判断mid是否满足性质 else l = mid + 1; } return l; } // 区间[l, r]被划分成[l, mid - 1]和[mid, r]时使用： int bsearch_2(int l, int r) { while (l \u0026lt; r) { int mid = l + r + 1 \u0026gt;\u0026gt; 1; if (check(mid)) l = mid; else r = mid - 1; } return l; } 浮点数二分算法模板 —— 模板题 AcWing 790. 数的三次方根 浮点数二分，比较对应整数二分\nbool check(double x) {/* ... */} // 检查x是否满足某种性质 double bsearch_3(double l, double r) { const double eps = 1e-6; // eps 表示精度，取决于题目对精度的要求 while (r - l \u0026gt; eps) { double mid = (l + r) / 2; if (check(mid)) r = mid; else l = mid; } return l; } 高精度加法 —— 模板题 AcWing 791. 高精度加法 // C = A + B, A \u0026gt;= 0, B \u0026gt;= 0 vector\u0026lt;int\u0026gt; add(vector\u0026lt;int\u0026gt; \u0026amp;A, vector\u0026lt;int\u0026gt; \u0026amp;B) { if (A.size() \u0026lt; B.size()) return add(B, A); vector\u0026lt;int\u0026gt; C; int t = 0; for (int i = 0; i \u0026lt; A.size(); i ++ ) { t += A[i]; if (i \u0026lt; B.size()) t += B[i]; C.push_back(t % 10); t /= 10; } if (t) C.push_back(t); return C; } 高精度减法 —— 模板题 AcWing 792. 高精度减法 // C = A - B, 满足A \u0026gt;= B, A \u0026gt;= 0, B \u0026gt;= 0 vector\u0026lt;int\u0026gt; sub(vector\u0026lt;int\u0026gt; \u0026amp;A, vector\u0026lt;int\u0026gt; \u0026amp;B) { vector\u0026lt;int\u0026gt; C; for (int i = 0, t = 0; i \u0026lt; A.size(); i ++ ) { t = A[i] - t; if (i \u0026lt; B.size()) t -= B[i]; C.push_back((t + 10) % 10); if (t \u0026lt; 0) t = 1; else t = 0; } while (C.size() \u0026gt; 1 \u0026amp;\u0026amp; C.back() == 0) C.pop_back(); return C; } 高精度乘低精度 —— 模板题 AcWing 793. 高精度乘法 // C = A * b, A \u0026gt;= 0, b \u0026gt; 0 vector\u0026lt;int\u0026gt; mul(vector\u0026lt;int\u0026gt; \u0026amp;A, int b) { vector\u0026lt;int\u0026gt; C; int t = 0; for (int i = 0; i \u0026lt; A.size() || t; i ++ ) { if (i \u0026lt; A.size()) t += A[i] * b; C.push_back(t % 10); t /= 10; } return C; } 高精度除以低精度 —— 模板题 AcWing 794. 高精度除法 // A / b = C ... r, A \u0026gt;= 0, b \u0026gt; 0 vector\u0026lt;int\u0026gt; div(vector\u0026lt;int\u0026gt; \u0026amp;A, int b, int \u0026amp;r) { vector\u0026lt;int\u0026gt; C; r = 0; for (int i = A.size() - 1; i \u0026gt;= 0; i -- ) { r = r * 10 + A[i]; C.push_back(r / b); r %= b; } reverse(C.begin(), C.end()); while (C.size() \u0026gt; 1 \u0026amp;\u0026amp; C.back() == 0) C.pop_back(); return C; } 一维前缀和 —— 模板题 AcWing 795. 前缀和 快速求区间和\nS[i] = a[1] + a[2] + ... a[i] a[l] + ... + a[r] = S[r] - S[l - 1] 从1开始，便于处理边界 二维前缀和 —— 模板题 AcWing 796. 子矩阵的和 S[i, j] = 第i行j列格子左上部分所有元素的和 以(x1, y1)为左上角，(x2, y2)为右下角的子矩阵的和为： S[x2, y2] - S[x1 - 1, y2] - S[x2, y1 - 1] + S[x1 - 1, y1 - 1] 一维差分 —— 模板题 AcWing 797. 差分 给区间[l, r]中的每个数加上c： B[l] += c, B[r + 1] -= c 二维差分 —— 模板题 AcWing 798. 差分矩阵/二维差分 给以(x1, y1)为左上角，(x2, y2)为右下角的子矩阵中的所有元素加上c： S[x1, y1] += c, S[x2 + 1, y1] -= c, S[x1, y2 + 1] -= c, S[x2 + 1, y2 + 1] += c 双指针算法 —— 模板题 AcWIng 799. 最长连续不重复子序列, AcWing 800. 数组元素的目标和 __滑动窗口？ 核心：把O(n^2)算法优化为O(n)\nfor (int i = 0, j = 0; i \u0026lt; n; i ++ ) { while (j \u0026lt; i \u0026amp;\u0026amp; check(j, i)) j ++ ; // 具体问题的逻辑 } 常见问题分类： (1) 对于一个序列，用两个指针维护一段区间 (2) 对于两个序列，维护某种次序，比如归并排序中合并两个有序序列的操作 位运算 —— 模板题 AcWing 801. 二进制中1的个数 原码，反码，补码 求n二进制表示中第k位数字: n \u0026gt;\u0026gt; k \u0026amp; 1 返回n的最后一位1：lowbit(n) = n \u0026amp; -n 树状数组基本操作 整数离散化 —— 模板题 AcWing 802. 区间和 vector\u0026lt;int\u0026gt; alls; // 存储所有待离散化的值 sort(alls.begin(), alls.end()); // 将所有值排序 alls.erase(unique(alls.begin(), alls.end())返回去重后数组末尾端点, alls.end()); // 去掉重复元素 // 二分求出x对应的离散化的值 int find(int x) // 找到第一个大于等于x的位置 { int l = 0, r = alls.size() - 1; while (l \u0026lt; r) { int mid = l + r \u0026gt;\u0026gt; 1; if (alls[mid] \u0026gt;= x) r = mid; else l = mid + 1; } return r + 1; // 映射到1, 2, ...n } 区间合并 —— 模板题 AcWing 803. 区间合并 // 将所有存在交集的区间合并 贪心 void merge(vector\u0026lt;PII\u0026gt; \u0026amp;segs) { vector\u0026lt;PII\u0026gt; res; sort(segs.begin(), segs.end()); //区间左端点排序 int st = -2e9, ed = -2e9; for (auto seg : segs) if (ed \u0026lt; seg.first) { if (st != -2e9) res.push_back({st, ed}); st = seg.first, ed = seg.second; } else ed = max(ed, seg.second); if (st != -2e9) res.push_back({st, ed}); segs = res; } 作者：yxc 链接：https://www.acwing.com/blog/content/277/ 来源：AcWing 著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。\n第二章 数据结构，以数组模拟的形式\n指针+结构体 ： 面试题\n单链表 —— 模板题 AcWing 826. 单链表 邻接表-存储树和图 静态链表\n下标从0开始\n// head存储链表头，e[]存储节点的值，ne[]存储节点的next指针，idx表示当前用到了哪个节点 int head, e[N], ne[N], idx; // 初始化 void init() { head = -1; idx = 0; } // 在链表头插入一个数a void insert(int a) { e[idx] = a, ne[idx] = head, head = idx ++ ; } // 插入下标k后面 void add(int k,int x) { e[idx]= x, ne[idx] = ne[k], ne[k] = idx++ ; } // 将头结点删除，需要保证头结点存在 void remove() { head = ne[head]; } // 将k后面的点删掉 void remove(int k) { ne[k] = ne[ne[k]]; } 双链表 —— 模板题 AcWing 827. 双链表 优化某些问题\n// e[]表示节点的值，l[]表示节点的左指针，r[]表示节点的右指针，idx表示当前用到了哪个节点 int e[N], l[N], r[N], idx; // 初始化 void init() { //0是左端点，1是右端点 r[0] = 1, l[1] = 0; idx = 2; } // 在节点a的右边插入一个数x void insert(int a, int x) { e[idx] = x; l[idx] = a, r[idx] = r[a]; l[r[a]] = idx, r[a] = idx ++ ; } // 删除节点a void remove(int a) { l[r[a]] = l[a]; r[l[a]] = r[a]; } 栈 —— 模板题 AcWing 828. 模拟栈 // tt表示栈顶 int stk[N], tt = 0; // 向栈顶插入一个数 stk[ ++ tt] = x; // 从栈顶弹出一个数 tt -- ; // 栈顶的值 stk[tt]; // 判断栈是否为空 if (tt \u0026gt; 0) { } 队列 —— 模板题 AcWing 829. 模拟队列 普通队列\n// hh 表示队头，tt表示队尾 int q[N], hh = 0, tt = -1; // 向队尾插入一个数 q[ ++ tt] = x; // 从队头弹出一个数 hh ++ ; // 队头的值 q[hh]; // 判断队列是否为空 if (hh \u0026lt;= tt) { //不空 } 循环队列\n// hh 表示队头，tt表示队尾的后一个位置 int q[N], hh = 0, tt = 0; // 向队尾插入一个数 q[tt ++ ] = x; if (tt == N) tt = 0; // 从队头弹出一个数 hh ++ ; if (hh == N) hh = 0; // 队头的值 q[hh]; // 判断队列是否为空 if (hh != tt) { } 单调栈 —— 模板题 AcWing 830. 单调栈 常见模型：找出每个数左边离它最近的比它大/小的数 int tt = 0; for (int i = 1; i \u0026lt;= n; i ++ ) { while (tt \u0026amp;\u0026amp; check(stk[tt], i)) tt -- ; stk[ ++ tt] = i; } 单调队列 —— 模板题 AcWing 154. 滑动窗口 常见模型：找出滑动窗口中的最大值/最小值 int hh = 0, tt = -1; for (int i = 0; i \u0026lt; n; i ++ ) { while (hh \u0026lt;= tt \u0026amp;\u0026amp; check_out(q[hh])) hh ++ ; // 判断队头是否滑出窗口 while (hh \u0026lt;= tt \u0026amp;\u0026amp; check(q[tt], i)) tt -- ; q[ ++ tt] = i; } KMP —— 模板题 AcWing 831. KMP字符串 用模板串来匹配模式串，找到模式串\ns的真前缀以及真后缀是指不等于s的前缀以及后缀，即至少是s[1~n-2]或s[0~n-1]\nne[i] : 以i结尾的串中 最长真前缀与真后缀相等的串 的长度，如果没有则为0。\n//前缀h vector\u0026lt;int\u0026gt; prefix_function(string s) { int n = (int)s.length(); vector\u0026lt;int\u0026gt; pi(n); for (int i = 1; i \u0026lt; n; i++) { int j = pi[i - 1]; while (j \u0026gt; 0 \u0026amp;\u0026amp; s[i] != s[j]) j = pi[j - 1]; if (s[i] == s[j]) j++; pi[i] = j; } return pi; } 实际使用范例（下面这个例子字符串从1开始）\n// 求Next数组： // ne[i] 存储真前缀和真后缀相等的长度，所以至少从2开始： //abcab,从b开始才有真前缀 // s[]是模式串，p[]是模板串, n是s的长度，m是p的长度 for (int i = 2, j = 0; i \u0026lt;= m; i ++ ) { while (j \u0026amp;\u0026amp; p[i] != p[j + 1]) j = ne[j]; if (p[i] == p[j + 1]) j ++ ; ne[i] = j; } // 匹配 for (int i = 1, j = 0; i \u0026lt;= n; i ++ ) { while (j \u0026amp;\u0026amp; s[i] != p[j + 1]) j = ne[j]; if (s[i] == p[j + 1]) j ++ ; if (j == m) { j = ne[j]; // 匹配成功后的逻辑 } } Trie树 —— 模板题 AcWing 835. Trie字符串统计 int son[N][26], cnt[N], idx; // 0号点既是根节点，又是空节点 // son[][]存储树中每个节点的子节点 // cnt[]存储以每个节点结尾的单词数量 // 插入一个字符串 void insert(char *str) { int p = 0; for (int i = 0; str[i]; i ++ ) { int u = str[i] - \u0026#39;a\u0026#39;; if (!son[p][u]) son[p][u] = ++ idx; p = son[p][u]; } cnt[p] ++ ; } // 查询字符串出现的次数 int query(char *str) { int p = 0; for (int i = 0; str[i]; i ++ ) { int u = str[i] - \u0026#39;a\u0026#39;; if (!son[p][u]) return 0; p = son[p][u]; } return cnt[p]; } 并查集 —— 模板题 AcWing 836. 合并集合, AcWing 837. 连通块中点的数量 按秩合并\n字符按字符串读入\n(1)朴素并查集：\nint p[N]; //存储每个点的祖宗节点 // 返回x的祖宗节点 int find(int x) { if (p[x] != x) p[x] = find(p[x]); return p[x]; } // 初始化，假定节点编号是1~n for (int i = 1; i \u0026lt;= n; i ++ ) p[i] = i; // 合并a和b所在的两个集合： p[find(a)] = find(b); (2)维护size的并查集：\nint p[N], size[N]; //p[]存储每个点的祖宗节点, size[]只有祖宗节点的有意义，表示祖宗节点所在集合中的点的数量 // 返回x的祖宗节点 int find(int x) { if (p[x] != x) p[x] = find(p[x]); return p[x]; } // 初始化，假定节点编号是1~n for (int i = 1; i \u0026lt;= n; i ++ ) { p[i] = i; size[i] = 1; } // 合并a和b所在的两个集合： p[find(a)] = find(b); size[b] += size[a]; (3)维护到祖宗节点距离的并查集：\nint p[N], d[N]; //p[]存储每个点的祖宗节点, d[x]存储x到p[x]的距离 // 返回x的祖宗节点 int find(int x) { if (p[x] != x) { int u = find(p[x]); d[x] += d[p[x]]; p[x] = u; } return p[x]; } // 初始化，假定节点编号是1~n for (int i = 1; i \u0026lt;= n; i ++ ) { p[i] = i; d[i] = 0; } // 合并a和b所在的两个集合： p[find(a)] = find(b); d[find(a)] = distance; // 根据具体问题，初始化find(a)的偏移量 堆 —— 模板题 AcWing 838. 堆排序, AcWing 839. 模拟堆 维护集合的数据结构 （大根堆，父节点值不小于子节点值）\n// h[N]存储堆中的值, h[1]是堆顶，x的左儿子是2x, 右儿子是2x + 1 // pos[k]存储第k个插入的点在堆中的位置 // ord[k]存储堆中下标是k的点是第几个插入的 int h[N], ph[N], hp[N], size; // 交换两个点，及其映射关系 void heap_swap(int a, int b) { //swap(ph[hp[a]],ph[hp[b]]); 根据题意 //swap(hp[a], hp[b]); swap(h[a], h[b]); } void down(int u) { int t = u; if (u * 2 \u0026lt;= size \u0026amp;\u0026amp; h[u * 2] \u0026lt; h[t]) t = u * 2; if (u * 2 + 1 \u0026lt;= size \u0026amp;\u0026amp; h[u * 2 + 1] \u0026lt; h[t]) t = u * 2 + 1; if (u != t) { heap_swap(u, t); down(t); } } void up(int u) { while (u / 2 \u0026amp;\u0026amp; h[u] \u0026lt; h[u / 2]) { heap_swap(u, u / 2); u \u0026gt;\u0026gt;= 1; } } // O(n)建堆 for (int i = n / 2; i; i -- ) down(i); heap[++size] = x; up(size); //添加元素 heap[1]; //堆顶元素 heap[1]=heap[size]; size--; down(1);//删除第size个结点 heap[k]=heap[size]; size---; down(k);up(k);//删除第k个结点 heap[k]=x; down(k); up(k); //将第k个元素赋值为x 一般哈希 —— 模板题 AcWing 840. 模拟散列表 (1) 拉链法 int h[N], e[N], ne[N], idx; // 向哈希表中插入一个数 void insert(int x) { int k = (x % N + N) % N; e[idx] = x; ne[idx] = h[k]; h[k] = idx ++ ; } // 在哈希表中查询某个数是否存在 bool find(int x) { int k = (x % N + N) % N; for (int i = h[k]; i != -1; i = ne[i]) if (e[i] == x) return true; return false; } (2) 开放寻址法 int h[N]; // 如果x在哈希表中，返回x的下标；如果x不在哈希表中，返回x应该插入的位置 int find(int x) { int t = (x % N + N) % N; while (h[t] != null \u0026amp;\u0026amp; h[t] != x) { t ++ ; if (t == N) t = 0; } return t; } 字符串哈希 —— 模板题 AcWing 841. 字符串哈希 核心思想：将字符串看成P进制数，P的经验值是131或13331，取这两个值的冲突概率低 小技巧：取模的数用2^64，这样直接用unsigned long long存储，溢出的结果就是取模的结果。\ntypedef unsigned long long ULL; const int P = 131 or 13331 ; ULL h[N], p[N]; // h[k]存储字符串前k个字母的哈希值, p[k]存储 P^k mod 2^64 // 初始化 p[0] = 1; for (int i = 1; i \u0026lt;= n; i ++ ) { h[i] = h[i - 1] * P + str[i]; p[i] = p[i - 1] * P; } // 计算子串 str[l ~ r] 的哈希值 ULL get(int l, int r) { return h[r] - h[l - 1] * p[r - l + 1]; } C++ STL简介 所有容器都有size() empty() vector, 变长数组，倍增的思想 size() 返回元素个数 empty() 返回是否为空 clear() 清空 front()/back() push_back()/pop_back() begin()/end() [] 支持比较运算，按字典序 vector\u0026lt;int\u0026gt; a(10,2); a.empty(); pair\u0026lt;int, int\u0026gt; first, 第一个元素 second, 第二个元素 支持比较运算，以first为第一关键字，以second为第二关键字（字典序） pair\u0026lt;int,int\u0026gt; p; p=make_pair(1,1); p={1,1}; string，字符串 size()/length() 返回字符串长度 empty() clear() substr(起始下标，(子串长度)) 返回子串 c_str() 返回字符串所在字符数组的起始地址 strcpy(c,s.c_str());//c_str()的使用方法 queue, 队列 没有clear函数 清空用新建queue size() empty() push() 向队尾插入一个元素 front() 返回队头元素 back() 返回队尾元素 pop() 弹出队头元素 priority_queue, 优先队列，默认是大根堆 push() 插入一个元素 top() 返回堆顶元素 pop() 弹出堆顶元素 定义成小根堆的方式：priority_queue\u0026lt;int, vector\u0026lt;int\u0026gt;, greater\u0026lt;int\u0026gt;\u0026gt; q; stack, 栈 size() empty() push() 向栈顶插入一个元素 top() 返回栈顶元素 pop() 弹出栈顶元素 deque, 双端队列 size() empty() clear() front()/back() push_back()/pop_back() push_front()/pop_front() begin()/end() [] set, map, multiset, multimap, 基于平衡二叉树（红黑树），动态维护有序序列 size() empty() clear() begin()/end() ++, -- 返回前驱和后继，时间复杂度 O(logn) set/multiset insert() 插入一个数 find() 查找一个数 count() 返回某一个数的个数 erase() (1) 输入是一个数x，删除所有x O(k + logn) (2) 输入一个迭代器，删除这个迭代器 lower_bound()/upper_bound() lower_bound(x) 返回大于等于x的最小的数的迭代器 upper_bound(x) 返回大于x的最小的数的迭代器 map/multimap insert() 插入的数是一个pair erase() 输入的参数是pair或者迭代器 find() [] 注意multimap不支持此操作。 时间复杂度是 O(logn) lower_bound()/upper_bound() unordered_set, unordered_map, unordered_multiset, unordered_multimap, 哈希表 和上面类似，增删改查的时间复杂度是 O(1) 不支持 lower_bound()/upper_bound()， 迭代器的++，-- bitset, 圧位 bitset\u0026lt;10000\u0026gt; s; ~, \u0026amp;, |, ^ \u0026gt;\u0026gt;, \u0026lt;\u0026lt; ==, != [] count() 返回有多少个1 none() 判断是否全为0 any() 判断是否至少有一个1 set() 把所有位置成1 set(k, v) 将第k位变成v reset() 把所有位变成0 flip() 等价于~ flip(k) 把第k位取反 作者：yxc 链接：https://www.acwing.com/blog/content/404/ 来源：AcWing 著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。\n第三章 树与图的存储 树是一种特殊的图: 无环连通图，与图的存储方式相同。 对于无向图中的边ab，存储两条有向边a-\u0026gt;b, b-\u0026gt;a。 因此我们可以只考虑有向图的存储。\n(1) 邻接矩阵：g[a][b] 存储边a-\u0026gt;b (2) 邻接表： // 对于每个点k，开一个单链表，存储k所有可以走到的点。h[k]存储这个单链表的头结点 int h[N], e[N], ne[N], idx; // 添加一条边a-\u0026gt;b void add(int a, int b) { e[idx] = b, ne[idx] = h[a], h[a] = idx ++ ; } // 初始化 idx = 0; memset(h, -1, sizeof h); 树与图的遍历 时间复杂度 O(n+m)O(n+m), nn 表示点数，mm 表示边数\n(1) 深度优先遍历 —— 模板题 AcWing 846. 树的重心 int dfs(int u) { st[u] = true; // st[u] 表示点u已经被遍历过 for (int i = h[u]; i != -1; i = ne[i]) { int j = e[i]; if (!st[j]) dfs(j); } } (2) 宽度优先遍历 —— 模板题 AcWing 847. 图中点的层次 queue\u0026lt;int\u0026gt; q; st[1] = true; // 表示1号点已经被遍历过 q.push(1); while (q.size()) { int t = q.front(); q.pop(); for (int i = h[t]; i != -1; i = ne[i]) { int j = e[i]; if (!st[j]) { st[j] = true; // 表示点j已经被遍历过 q.push(j); } } } 拓扑排序 —— 模板题 AcWing 848. 有向图的拓扑序列 时间复杂度 O(n+m)O(n+m), nn 表示点数，mm 表示边数\nbool topsort() { int hh = 0, tt = -1; // d[i] 存储点i的入度 for (int i = 1; i \u0026lt;= n; i ++ ) if (!d[i]) q[ ++ tt] = i; while (hh \u0026lt;= tt) { int t = q[hh ++ ]; for (int i = h[t]; i != -1; i = ne[i]) { int j = e[i]; if (-- d[j] == 0) q[ ++ tt] = j; } } // 如果所有点都入队了，说明存在拓扑序列；否则不存在拓扑序列。 return tt == n - 1; } 最短路 单源最短路\n所有边权均为正：朴素Dijkstra O(n^2)；堆优化版的Dijkstra(mlogn)\n存在负权变：Bellman-Ford O(nm) ； SPFA（队列优化Bellman-Ford) 一般：O(m) 最坏 O(nm)\n多元汇最短路：Floyed算法 O(n^3)\n朴素dijkstra算法 —— 模板题 AcWing 849. Dijkstra求最短路 I 基于贪心 时间复杂是 O(n^2+m), n 表示点数，m 表示边数\nint g[N][N]; // 存储每条边， int dist[N]; // 存储1号点到每个点的最短距离 bool st[N]; // 存储每个点的最短路是否已经确定 // 求1号点到n号点的最短路，如果不存在则返回-1 int dijkstra() { memset(dist, 0x3f, sizeof dist); dist[1] = 0; for (int i = 0; i \u0026lt; n - 1; i ++ ) { int t = -1; // 在还未确定最短路的点中，寻找距离最小的点 for (int j = 1; j \u0026lt;= n; j ++ ) if (!st[j] \u0026amp;\u0026amp; (t == -1 || dist[t] \u0026gt; dist[j])) t = j; // 用t更新其他点的距离 for (int j = 1; j \u0026lt;= n; j ++ ) dist[j] = min(dist[j], dist[t] + g[t][j]); st[t] = true; } if (dist[n] == 0x3f3f3f3f) return -1; return dist[n]; } 堆优化版dijkstra —— 模板题 AcWing 850. Dijkstra求最短路 II 时间复杂度 O(mlogn), n 表示点数，m 表示边数\ntypedef pair\u0026lt;int, int\u0026gt; PII; int n; // 点的数量 int h[N], w[N], e[N], ne[N], idx; // 邻接表存储所有边 int dist[N]; // 存储所有点到1号点的距离 bool st[N]; // 存储每个点的最短距离是否已确定 // 求1号点到n号点的最短距离，如果不存在，则返回-1 int dijkstra() { memset(dist, 0x3f, sizeof dist); dist[1] = 0; priority_queue\u0026lt;PII, vector\u0026lt;PII\u0026gt;, greater\u0026lt;PII\u0026gt;\u0026gt; heap; heap.push({0, 1}); // first存储距离，second存储节点编号 while (heap.size()) { auto t = heap.top(); heap.pop(); int ver = t.second, distance = t.first; if (st[ver]) continue; st[ver] = true; for (int i = h[ver]; i != -1; i = ne[i]) { int j = e[i]; if (dist[j] \u0026gt; distance + w[i]) { dist[j] = distance + w[i]; heap.push({dist[j], j}); } } } if (dist[n] == 0x3f3f3f3f) return -1; return dist[n]; } Bellman-Ford算法 —— 模板题 AcWing 853. 有边数限制的最短路 时间复杂度 O(nm), n 表示点数，m表示边数 注意在模板题中需要对下面的模板稍作修改，加上备份数组，详情见模板题。\nint n, m; // n表示点数，m表示边数 int dist[N]; // dist[x]存储1到x的最短路距离 struct Edge // 边，a表示出点，b表示入点，w表示边的权重 { int a, b, w; }edges[M]; // 求1到n的最短路距离，如果无法从1走到n，则返回-1。 int bellman_ford() { memset(dist, 0x3f, sizeof dist); dist[1] = 0; // 如果第n次迭代仍然会松弛三角不等式，就说明存在一条长度是n+1的最短路径，由抽屉原理，路径中至少存在两个相同的点，说明图中存在负权回路。 for (int i = 0; i \u0026lt; n; i ++ ) { for (int j = 0; j \u0026lt; m; j ++ ) { int a = edges[j].a, b = edges[j].b, w = edges[j].w; if (dist[b] \u0026gt; dist[a] + w) dist[b] = dist[a] + w; } } if (dist[n] \u0026gt; 0x3f3f3f3f / 2) return -1; return dist[n]; } spfa 算法（队列优化的Bellman-Ford算法） —— 模板题 AcWing 851. spfa求最短路 时间复杂度 平均情况下 O(m)，最坏情况下 O(nm), n 表示点数，m 表示边数\nint n; // 总点数 int h[N], w[N], e[N], ne[N], idx; // 邻接表存储所有边 int dist[N]; // 存储每个点到1号点的最短距离 bool st[N]; // 存储每个点是否在队列中 // 求1号点到n号点的最短路距离，如果从1号点无法走到n号点则返回-1 int spfa() { memset(dist, 0x3f, sizeof dist); dist[1] = 0; queue\u0026lt;int\u0026gt; q; q.push(1); st[1] = true; while (q.size()) { auto t = q.front(); q.pop(); st[t] = false; for (int i = h[t]; i != -1; i = ne[i]) { int j = e[i]; if (dist[j] \u0026gt; dist[t] + w[i]) { dist[j] = dist[t] + w[i]; if (!st[j]) // 如果队列中已存在j，则不需要将j重复插入 { q.push(j); st[j] = true; } } } } if (dist[n] == 0x3f3f3f3f) return -1; return dist[n]; } spfa判断图中是否存在负环 —— 模板题 AcWing 852. spfa判断负环 时间复杂度是 O(nm), n 表示点数，m 表示边数\nint n; // 总点数 int h[N], w[N], e[N], ne[N], idx; // 邻接表存储所有边 int dist[N], cnt[N]; // dist[x]存储1号点到x的最短距离，cnt[x]存储1到x的最短路中经过的点数 bool st[N]; // 存储每个点是否在队列中 // 如果存在负环，则返回true，否则返回false。 bool spfa() { // 不需要初始化dist数组 // 原理：如果某条最短路径上有n个点（除了自己），那么加上自己之后一共有n+1个点，由抽屉原理一定有两个点相同，所以存在环。 queue\u0026lt;int\u0026gt; q; for (int i = 1; i \u0026lt;= n; i ++ ) { q.push(i); st[i] = true; } while (q.size()) { auto t = q.front(); q.pop(); st[t] = false; for (int i = h[t]; i != -1; i = ne[i]) { int j = e[i]; if (dist[j] \u0026gt; dist[t] + w[i]) { dist[j] = dist[t] + w[i]; cnt[j] = cnt[t] + 1; if (cnt[j] \u0026gt;= n) return true; // 如果从1号点到x的最短路中包含至少n个点（不包括自己），则说明存在环 if (!st[j]) { q.push(j); st[j] = true; } } } } return false; } floyd算法 —— 模板题 AcWing 854. Floyd求最短路 时间复杂度是 O(n3)O(n3), nn 表示点数 初始化： for (int i = 1; i \u0026lt;= n; i ++ ) for (int j = 1; j \u0026lt;= n; j ++ ) if (i == j) d[i][j] = 0; else d[i][j] = INF; // 算法结束后，d[a][b]表示a到b的最短距离 void floyd() { for (int k = 1; k \u0026lt;= n; k ++ ) for (int i = 1; i \u0026lt;= n; i ++ ) for (int j = 1; j \u0026lt;= n; j ++ ) d[i][j] = min(d[i][j], d[i][k] + d[k][j]); } 最小生成树（无向图） Prim : 朴素版Prim O(n^2)(稠密图) ; 堆优化版Prim O(mlogn)(一般不会用)\nKruskal : O(mlogm)(稀疏图)\n朴素版prim算法 —— 模板题 AcWing 858. Prim算法求最小生成树 时间复杂度是 O(n^2+m), n 表示点数，m 表示边数\n初始化距离为正无穷，迭代所有点，找到集合中最近的点，更新它到集合的距离，把t加到集合中。\nint n; // n表示点数 int g[N][N]; // 邻接矩阵，存储所有边 int dist[N]; // 存储其他点到当前最小生成树的距离 bool st[N]; // 存储每个点是否已经在生成树中 // 如果图不连通，则返回INF(值是0x3f3f3f3f), 否则返回最小生成树的树边权重之和 int prim() { memset(dist, 0x3f, sizeof dist); int res = 0; for (int i = 0; i \u0026lt; n; i ++ ) { int t = -1; for (int j = 1; j \u0026lt;= n; j ++ ) if (!st[j] \u0026amp;\u0026amp; (t == -1 || dist[t] \u0026gt; dist[j])) t = j; if (i \u0026amp;\u0026amp; dist[t] == INF) return INF; if (i) res += dist[t]; st[t] = true; for (int j = 1; j \u0026lt;= n; j ++ ) dist[j] = min(dist[j], g[t][j]); } return res; } Kruskal算法 —— 模板题 AcWing 859. Kruskal算法求最小生成树 时间复杂度是 O(mlogm), n 表示点数，m 表示边数\nint n, m; // n是点数，m是边数 int p[N]; // 并查集的父节点数组 struct Edge // 存储边 { int a, b, w; // 重载小于号运算符 // 用于比较两个Edge对象的大小关系 bool operator \u0026lt; (const Edge \u0026amp;W) const { return w \u0026lt; W.w; // 如果当前对象的边权小于W对象的边权，返回true，否则返回false } }edges[M]; int find(int x) // 并查集核心操作 { if (p[x] != x) p[x] = find(p[x]); return p[x]; } int kruskal() { sort(edges, edges + m); for (int i = 1; i \u0026lt;= n; i ++ ) p[i] = i; // 初始化并查集 int res = 0, cnt = 0; for (int i = 0; i \u0026lt; m; i ++ ) { int a = edges[i].a, b = edges[i].b, w = edges[i].w; a = find(a), b = find(b); if (a != b) // 如果两个连通块不连通，则将这两个连通块合并 { p[a] = b; res += w; cnt ++ ; } } if (cnt \u0026lt; n - 1) return INF; return res; } 染色法（本质dfs)判别二分图 —— 模板题 AcWing 860. 染色法判定二分图 给定一个 n 个点m条边的无向图，图中可能存在重边和自环。请你判断这个图是否是二分图。\n时间复杂度是 O(n+m), n 表示点数，m 表示边数\nint n; // n表示点数 int h[N], e[M], ne[M], idx; // 邻接表存储图 int color[N]; // 表示每个点的颜色，-1表示为染色，0表示白色，1表示黑色 // 参数：u表示当前节点，c表示当前点的颜色 bool dfs(int u, int c) { color[u] = c; for (int i = h[u]; i != -1; i = ne[i]) { int j = e[i]; if (color[j] == -1) { if (!dfs(j, !c)) return false; } else if (color[j] == c) return false; } return true; } bool check() { memset(color, -1, sizeof color); bool flag = true; for (int i = 1; i \u0026lt;= n; i ++ ) if (color[i] == -1) if (!dfs(i, 0)) { flag = false; break; } return flag; } 匈牙利算法 —— 模板题 AcWing 861. 二分图的最大匹配 时间复杂度最坏是 O(nm)，实际运行时间一般远小于O(nm)， n 表示点数，m 表示边数\n做错一件事，错过一件事\nint n1, n2; // n1表示第一个集合中的点数，n2表示第二个集合中的点数 int h[N], e[M], ne[M], idx; // 邻接表存储所有边，匈牙利算法中只会用到从第二个集合指向第一个集合的边，所以这里只用存一个方向的边 int match[N]; // 存储第二个集合中的每个点当前匹配的第一个集合中的点是哪个 bool st[N]; // 表示第二个集合中的每个点是否已经被遍历过 bool find(int x) { for (int i = h[x]; i != -1; i = ne[i]) { int j = e[i]; if (!st[j]) { st[j] = true; if (match[j] == 0 || find(match[j])) { match[j] = x; return true; } } } return false; } // 求最大匹配数，依次枚举第一个集合中的每个点能否匹配第二个集合中的点 int res = 0; for (int i = 1; i \u0026lt;= n1; i ++ ) { memset(st, false, sizeof st); if (find(i)) res ++ ; } 作者：yxc 链接：https://www.acwing.com/blog/content/405/ 来源：AcWing 著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。\n第四章 试除法判定质数 —— 模板题 AcWing 866. 试除法判定质数 质数：大于1的整数中，如果只包含1和本身两个约束，称为质数（素数）\n（1）判定，试除法\n（2）分解质因数\nbool is_prime(int x) { if (x \u0026lt; 2) return false; for (int i = 2; i \u0026lt;= x / i; i ++ ) if (x % i == 0) return false; return true; } 试除法分解质因数 —— 模板题 AcWing 867. 分解质因数 void divide(int x) { for (int i = 2; i \u0026lt;= x / i; i ++ ) if (x % i == 0) { int s = 0; while (x % i == 0) x /= i, s ++ ; cout \u0026lt;\u0026lt; i \u0026lt;\u0026lt; \u0026#39; \u0026#39; \u0026lt;\u0026lt; s \u0026lt;\u0026lt; endl; } if (x \u0026gt; 1) cout \u0026lt;\u0026lt; x \u0026lt;\u0026lt; \u0026#39; \u0026#39; \u0026lt;\u0026lt; 1 \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; endl; } 朴素筛法求素数 —— 模板题 AcWing 868. 筛质数 int primes[N], cnt; // primes[]存储所有素数 bool st[N]; // st[x]存储x是否被筛掉 void get_primes(int n) { for (int i = 2; i \u0026lt;= n; i ++ ) { if (st[i]) continue; primes[cnt ++ ] = i; for (int j = i; j \u0026lt;= n; j += i) st[j] = true; } } 线性筛法求素数 —— 模板题 AcWing 868. 筛质数 被最小质因子筛掉\nint primes[N], cnt; // primes[]存储所有素数 bool st[N]; // st[x]存储x是否被筛掉 void get_primes(int n) { for (int i = 2; i \u0026lt;= n; i ++ ) { if (!st[i]) primes[cnt ++ ] = i; for (int j = 0; primes[j] \u0026lt;= n / i; j ++ ) { st[primes[j] * i] = true; if (i % primes[j] == 0) break; } } } 试除法求所有约数 —— 模板题 AcWing 869. 试除法求约数 int范围内约数个数最多为1500个左右\nvector\u0026lt;int\u0026gt; get_divisors(int x) { vector\u0026lt;int\u0026gt; res; for (int i = 1; i \u0026lt;= x / i; i ++ ) if (x % i == 0) { res.push_back(i); if (i != x / i) res.push_back(x / i); } sort(res.begin(), res.end()); return res; } 约数个数和约数之和 —— 模板题 AcWing 870. 约数个数, AcWing 871. 约数之和 如果 N = p1^c1 * p2^c2 * ... *pk^ck 约数个数： (c1 + 1) * (c2 + 1) * ... * (ck + 1) 约数之和： (p1^0 + p1^1 + ... + p1^c1) * ... * (pk^0 + pk^1 + ... + pk^ck) 欧几里得算法 —— 模板题 AcWing 872. 最大公约数 int gcd(int a, int b) { return b ? gcd(b, a % b) : a; } 求欧拉函数 —— 模板题 AcWing 873. 欧拉函数 欧拉函数公式（容斥原理) : n*(1-p1)*(1-p2)\u0026hellip;(1-pk)\nint phi(int x) { int res = x; for (int i = 2; i \u0026lt;= x / i; i ++ ) if (x % i == 0) { res = res / i * (i - 1); while (x % i == 0) x /= i; } if (x \u0026gt; 1) res = res / x * (x - 1); return res; } 筛法求欧拉函数 —— 模板题 AcWing 874. 筛法求欧拉函数 O(n) 线性求所有数的欧拉函数\n应用：欧拉定理：a与n互质 a^φ(n)=1(mod n)\nint primes[N], cnt; // primes[]存储所有素数 int euler[N]; // 存储每个数的欧拉函数 bool st[N]; // st[x]存储x是否被筛掉 void get_eulers(int n) { euler[1] = 1; for (int i = 2; i \u0026lt;= n; i ++ ) { if (!st[i]) { primes[cnt ++ ] = i; euler[i] = i - 1; } for (int j = 0; primes[j] \u0026lt;= n / i; j ++ ) { int t = primes[j] * i; st[t] = true; if (i % primes[j] == 0) { euler[t] = euler[i] * primes[j]; break; } euler[t] = euler[i] * (primes[j] - 1); } } } 快速幂 —— 模板题 AcWing 875. 快速幂 求 m^k mod p，时间复杂度 O(logk)。\nint qmi(int m, int k, int p) { int res = 1 % p, t = m; while (k) { if (k\u0026amp;1) res = res * t % p; t = t * t % p; k \u0026gt;\u0026gt;= 1; } return res; } 扩展欧几里得算法 —— 模板题 AcWing 877. 扩展欧几里得算法 // 求x, y，使得ax + by = gcd(a, b) int exgcd(int a, int b, int \u0026amp;x, int \u0026amp;y) { if (!b) { x = 1; y = 0; return a; } int d = exgcd(b, a % b, y, x); y -= (a/b) * x; return d; } 高斯消元 —— 模板题 AcWing 883. 高斯消元解线性方程组 O(n^3)时间内解n个方程n个未知数的解。\n解：无解 ； 无穷多组解 ； 唯一解 ；\n完美阶梯型：唯一解 *0=*非零 ： *无解 0=0 ： 无穷多组解 高斯消元：\n枚举每一列c：\n找到绝对值最大的一行 将该行换到最上面 将该行第一个数变成1 将下面所有行的第c列消成0 // a[N][N]是增广矩阵 int gauss() { int c, r; for (c = 0, r = 0; c \u0026lt; n; c ++ ) { int t = r; for (int i = r; i \u0026lt; n; i ++ ) // 找到绝对值最大的行 if (fabs(a[i][c]) \u0026gt; fabs(a[t][c])) t = i; if (fabs(a[t][c]) \u0026lt; eps) continue; for (int i = c; i \u0026lt;= n; i ++ ) swap(a[t][i], a[r][i]); // 将绝对值最大的行换到最顶端 for (int i = n; i \u0026gt;= c; i -- ) a[r][i] /= a[r][c]; // 将当前上的首位变成1 for (int i = r + 1; i \u0026lt; n; i ++ ) // 用当前行将下面所有的列消成0 if (fabs(a[i][c]) \u0026gt; eps) for (int j = n; j \u0026gt;= c; j -- ) a[i][j] -= a[r][j] * a[i][c]; r ++ ; } if (r \u0026lt; n) { for (int i = r; i \u0026lt; n; i ++ ) if (fabs(a[i][n]) \u0026gt; eps) return 2; // 无解 return 1; // 有无穷多组解 } for (int i = n - 1; i \u0026gt;= 0; i -- ) for (int j = i + 1; j \u0026lt; n; j ++ ) a[i][n] -= a[i][j] * a[j][n]; return 0; // 有唯一解 } 递归法求组合数 —— 模板题 AcWing 885. 求组合数 I 十万 1\u0026lt;b\u0026lt;a\u0026lt;2000 O(n^2)\n// c[a][b] 表示从a个苹果中选b个的方案数 for (int i = 0; i \u0026lt; N; i ++ ) for (int j = 0; j \u0026lt;= i; j ++ ) if (!j) c[i][j] = 1; else c[i][j] = (c[i - 1][j] + c[i - 1][j - 1]) % mod; 通过预处理逆元的方式求组合数 —— 模板题 AcWing 886. 求组合数 II 一万 1\u0026lt;b\u0026lt;a\u0026lt;10^5 O(logn)\n首先预处理出所有阶乘取模的余数fact[N]，以及所有阶乘取模的逆元infact[N] 如果取模的数是质数，可以用费马小定理求逆元 int qmi(int a, int k, int p) // 快速幂模板 { int res = 1; while (k) { if (k \u0026amp; 1) res = (LL)res * a % p; a = (LL)a * a % p; k \u0026gt;\u0026gt;= 1; } return res; } // 预处理阶乘的余数和阶乘逆元的余数 fact[0] = infact[0] = 1; for (int i = 1; i \u0026lt; N; i ++ ) { fact[i] = (LL)fact[i - 1] * i % mod; infact[i] = (LL)infact[i - 1] * qmi(i, mod - 2, mod) % mod; } ll C(ll n,ll m){ if(m\u0026gt;n) return 0ll; return fact[n]*infact[m]%mod*infact[n-m]%mod; } Lucas定理 —— 模板题 AcWing 887. 求组合数 III 组合数，1\u0026lt;b\u0026lt;a\n若p是质数，则对于任意整数 1 \u0026lt;= m \u0026lt;= n，有： C(n, m) = C(n % p, m % p) * C(n / p, m / p) (mod p) int qmi(int a, int k) // 快速幂模板 { int res = 1; while (k) { if (k \u0026amp; 1) res = (LL)res * a % p; a = (LL)a * a % p; k \u0026gt;\u0026gt;= 1; } return res; } int C(int a, int b) // 通过定理求组合数C(a, b) { int res = 1; for (int i = 1, j = a; i \u0026lt;= b; i ++, j -- ) { res = (LL)res * j % p; res = (LL)res * qmi(i, p - 2) % p; } return res; } int lucas(LL a, LL b) { if (a \u0026lt; p \u0026amp;\u0026amp; b \u0026lt; p) return C(a, b); return (LL)C(a % p, b % p) * lucas(a / p, b / p) % p; } 分解质因数法求组合数 —— 模板题 AcWing 888. 求组合数 IV 当我们需要求出组合数的真实值，而非对某个数的余数时，分解质因数的方式比较好用：\n1. 筛法求出范围内的所有质数 2. 通过 C(a, b) = a! / b! / (a - b)! 这个公式求出每个质因子的次数。 n! 中p的次数是 n / p + n / p^2 + n / p^3 + ... 3. 用高精度乘法将所有质因子相乘 int primes[N], cnt; // 存储所有质数 int sum[N]; // 存储每个质数的次数 bool st[N]; // 存储每个数是否已被筛掉 void get_primes(int n) // 线性筛法求素数 { for (int i = 2; i \u0026lt;= n; i ++ ) { if (!st[i]) primes[cnt ++ ] = i; for (int j = 0; primes[j] \u0026lt;= n / i; j ++ ) { st[primes[j] * i] = true; if (i % primes[j] == 0) break; } } } int get(int n, int p) // 求n！中的次数 { int res = 0; while (n) { res += n / p; n /= p; } return res; } vector\u0026lt;int\u0026gt; mul(vector\u0026lt;int\u0026gt; a, int b) // 高精度乘低精度模板 { vector\u0026lt;int\u0026gt; c; int t = 0; for (int i = 0; i \u0026lt; a.size(); i ++ ) { t += a[i] * b; c.push_back(t % 10); t /= 10; } while (t) { c.push_back(t % 10); t /= 10; } return c; } get_primes(a); // 预处理范围内的所有质数 for (int i = 0; i \u0026lt; cnt; i ++ ) // 求每个质因数的次数 { int p = primes[i]; sum[i] = get(a, p) - get(b, p) - get(a - b, p); } vector\u0026lt;int\u0026gt; res; res.push_back(1); for (int i = 0; i \u0026lt; cnt; i ++ ) // 用高精度乘法将所有质因子相乘 for (int j = 0; j \u0026lt; sum[i]; j ++ ) res = mul(res, primes[i]); 卡特兰数 —— 模板题 AcWing 889. 满足条件的01序列 给定n个0和n个1，它们按照某种顺序排成长度为2n的序列，满足任意前缀中0的个数都不少于1的个数的序列的数量为： $$ Cat(n) = C(2n, n) / (n + 1) $$\n容斥原理 找1~n中能至少被素数p1,p2,\u0026hellip;,pn一个整除的整数有多少个。\n位运算对应容斥原理集合，1~n中能被x整除的个数为n/x，奇数加上，偶数减去\nNIM(尼姆)游戏 —— 模板题 AcWing 891. Nim游戏 给定N堆物品，第i堆物品有Ai个。两名玩家轮流行动，每次可以任选一堆，取走任意多个物品，可把一堆取光，但不能不取。取走最后一件物品者获胜。两人都采取最优策略，问先手是否必胜。\n我们把这种游戏称为NIM博弈。把游戏过程中面临的状态称为局面。整局游戏第一个行动的称为先手，第二个行动的称为后手。若在某一局面下无论采取何种行动，都会输掉游戏，则称该局面必败。 所谓采取最优策略是指，若在某一局面下存在某种行动，使得行动后对面面临必败局面，则优先采取该行动。同时，这样的局面被称为必胜。我们讨论的博弈问题一般都只考虑理想情况，即两人均无失误，都采取最优策略行动时游戏的结果。 NIM博弈不存在平局，只有先手必胜和先手必败两种情况。\n定理： NIM博弈先手必胜，当且仅当 A1 ^ A2 ^ … ^ An != 0\n公平组合游戏ICG 若一个游戏满足：\n由两名玩家交替行动； 在游戏进程的任意时刻，可以执行的合法行动与轮到哪名玩家无关； 不能行动的玩家判负； 则称该游戏为一个公平组合游戏。 NIM博弈属于公平组合游戏，但城建的棋类游戏，比如围棋，就不是公平组合游戏。因为围棋交战双方分别只能落黑子和白子，胜负判定也比较复杂，不满足条件2和条件3。\n有向图游戏 给定一个有向无环图，图中有一个唯一的起点，在起点上放有一枚棋子。两名玩家交替地把这枚棋子沿有向边进行移动，每次可以移动一步，无法移动者判负。该游戏被称为有向图游戏。 任何一个公平组合游戏都可以转化为有向图游戏。具体方法是，把每个局面看成图中的一个节点，并且从每个局面向沿着合法行动能够到达的下一个局面连有向边。\nMex运算 设S表示一个非负整数集合。定义mex(S)为求出不属于集合S的最小非负整数的运算，即： mex(S) = min{x}, x属于自然数，且x不属于S\nSG函数 在有向图游戏中，对于每个节点x，设从x出发共有k条有向边，分别到达节点y1, y2, …, yk，定义SG(x)为x的后继节点y1, y2, …, yk 的SG函数值构成的集合再执行**mex(S)**运算的结果，即： SG(x) = mex({SG(y1), SG(y2), …, SG(yk)}) 特别地，整个有向图游戏G的SG函数值被定义为有向图游戏起点s的SG函数值，即SG(G) = SG(s)。\nint sg(int x){ if (f[x] != -1) return f[x]; unordered_set\u0026lt;int\u0026gt; S; for(int i = 0; i \u0026lt; m; i++ ) { int sum = s[i]; if (x \u0026gt;= sum) S.insert(sg(x - sum)); } for (int i=0; ; i++ ) if (!S.count(i)) return f[x] = i; } 有向图游戏的和 —— 模板题 AcWing 893. 集合-Nim游戏 设G1, G2, …, Gm 是m个有向图游戏。定义有向图游戏G，它的行动规则是任选某个有向图游戏Gi，并在Gi上行动一步。G被称为有向图游戏G1, G2, …, Gm的和。 有向图游戏的和的SG函数值等于它包含的各个子游戏SG函数值的异或和，即： SG(G) = SG(G1) ^ SG(G2) ^ … ^ SG(Gm)\n定理 有向图游戏的某个局面必胜，当且仅当该局面对应节点的SG函数值大于0。 有向图游戏的某个局面必败，当且仅当该局面对应节点的SG函数值等于0。\n作者：yxc 链接：https://www.acwing.com/blog/content/406/ 来源：AcWing 著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。\n时空复杂度分析 当处理ACM或笔试题时，通常时间限制为1秒或2秒。在这种情况下，C++代码中的操作次数应控制在10^7 到 10^8之间，这是最佳范围。\n以下是在不同数据规模下，代码的时间复杂度和算法选择的指导：\nn ≤ 30：指数级别，使用DFS+剪枝，状态压缩DP。 n ≤ 100：O(n^3)，适用于Floyd、DP、高斯消元。 n ≤ 1000：O(n^2)或O(n^2*logn)，适用于DP、分治、高斯消元、朴素版Dijkstra、朴素版Prim、Bellman-Ford。 n ≤ 10000：O(n * √n)，适用于块状链表、分块、莫队。 n ≤ 100000：O(nlogn)，适用于各种排序、线段树、树状数组、集合/映射、堆、拓扑排序、Dijkstra+堆、Prim、Kruskal、SPFA、求凸包、求半平面交、二分、CDQ分治、整体二分、后缀数组、树链剖分、动态树。 n \u0026lt; 1000000：O(n)或常数较小的O(nlogn)，适用于单调队列、哈希映射、双指针扫描、BFS、并查集、KMP、AC自动机、常数较小的O(nlogn)的做法（如排序、树状数组、堆、Dijkstra、SPFA）。 n \u0026lt; 10000000：O(n)，适用于双指针扫描、KMP、AC自动机、线性筛素数。 n ≤ 10^9：O(n√n)，适用于判断质数。 n ≤ 10^18：O(logn)，适用于最大公约数、快速幂、数位DP。 n ≤ 10^1000：O((logn)^2)，适用于高精度加减乘除。 n ≤ 10^100000：O(logk × loglogk)，其中k表示位数，适用于高精度加减、FFT/NTT。 动态规划计算量 ： 状态数 * 状态转移数量\n1 Byte = 8 bit\n1KB = 1024 Byte\n1MB = 102410241024 Byte\n1GB = 1024 * 1024 * 1024 Byte\nint 4 Byte\nchar 1 Byte\ndouble, long long 8 Byte\n动态规划 常见模型\n背包 九讲 01背包 每件物品最多可以用一次\n体积从大到小的原因 ： 如果从小到大，则f[j-w[i]]+v[i]实际是f[i-1][j-w[i]]+v[i]，需要的是上一维度f[i-1]维度，所以从大到小可以使用上一维度的，因为这一维度的还没有被计算到。\nfor(int i=1;i\u0026lt;=N;i++){ for(int j=V;j\u0026gt;=w[i];j--){ f[j]=max(f[j],f[j-w[i]]+v[i]); } } 完全背包 每件物品可以用无限次\nfor(int i=1;i\u0026lt;=N;i++){ for(int j=w[i];j\u0026lt;=V;j++){ f[j]=max(f[j],f[j-w[i]]+v[i]); } } 多重背包 每件物品特定数量\n二进制优化 for(int i=1;i\u0026lt;=N;i++){ cin\u0026gt;\u0026gt;a\u0026gt;\u0026gt;b\u0026gt;\u0026gt;c; //权重a,价值b，数量c int k=1; while(k\u0026lt;=c){ cnt++; c-=k; w[cnt]=k*a; v[cnt]=k*b; k*=2; } if(c){ cnt++; w[cnt]=c*a; v[cnt]=c*b; } } //之后用01背包 单调队列优化 for(int i=1;i\u0026lt;=N;i++){ // 遍历每件物品 memcpy(g, f, sizeof g); // 将上一轮的最优解拷贝给g数组 for(int r=0;r\u0026lt;v[i];r++){ // 遍历余数r（用于优化循环） int h=0,t=-1; // 滑动窗口的起始索引和结束索引 for(int l=r;l\u0026lt;=V;l+=v[i]){ // 遍历背包容量，间隔为当前物品体积 while(h\u0026lt;=t \u0026amp;\u0026amp; l-q[h]\u0026gt;s[i]*v[i]) h++; // 如果窗口左边界超出限制，则左边界右移 while(h\u0026lt;=t \u0026amp;\u0026amp; g[q[t]] + (l-q[t])/v[i]*w[i]\u0026lt;=g[l]) t--; // 保持窗口单调性，将窗口内不符合条件的解移除 q[++t] = l; // 将当前状态的背包容量加入窗口 f[l] = g[q[h]] + (l-q[h])/v[i]*w[i]; // 更新当前状态的最优解 } } } 分组背包 若干组，一组只能选一个\nfor(int i=1;i\u0026lt;=N;i++){ for(int j=V;j\u0026gt;=0;j--){ for(int k=1;k\u0026lt;=s[i];k++){ if(w[i][k]\u0026lt;=j){ f[j]=max(f[j],f[j- w[i][k] ]+v[i][k]); } } } } 混合背包 转换成01背包问题\nfor(int i=1;i\u0026lt;=N;i++){ cin\u0026gt;\u0026gt;a\u0026gt;\u0026gt;b\u0026gt;\u0026gt;s; if(s==-1) s=1; else if(s==0) s=V/a; k=1; while(k\u0026lt;=s){ s-=k; cnt++; v[cnt] = k*a; w[cnt] = k*b; k*=2; } if(s){ cnt++; v[cnt] = s*a; w[cnt] = s*b; } } for(int i=1;i\u0026lt;=cnt;i++){ for(int j=V;j\u0026gt;=v[i];j--){ f[j] = max(f[j], f[j-v[i]]+w[i]); } } 二维费用的背包问题 采用两层循环\ncin\u0026gt;\u0026gt;N\u0026gt;\u0026gt;V\u0026gt;\u0026gt;W; for(int i=1;i\u0026lt;=N;i++){ cin\u0026gt;\u0026gt;v\u0026gt;\u0026gt;m\u0026gt;\u0026gt;w; for(int j=V;j\u0026gt;=v;j--){ for(int k=W;k\u0026gt;=m;k--){ f[j][k] = max(f[j][k], f[j-v][k-m] + w); } } } cout\u0026lt;\u0026lt;f[V][W]\u0026lt;\u0026lt;endl; 线性dp 数字三角形 for(int i=1;i\u0026lt;=n;i++){ for(int j=1;j\u0026lt;=i;j++){ a[i][j]+=max(a[i-1][j],a[i-1][j-1]); } } LIS for(int i=1;i\u0026lt;=n;i++){ for(int j=1;j\u0026lt;i;j++){ if(a[j]\u0026lt;a[i]) f[i]=max(f[j]+1,f[i]); } } for(int i=1;i\u0026lt;=n;i++){ ma=max(f[i],ma); } LCS for(int i=1;i\u0026lt;=n;i++){ for(int j=1;j\u0026lt;=m;j++){ f[i][j]=max(f[i-1][j],f[i][j-1]); if(a[i]==b[j]) f[i][j]=f[i-1][j-1]+1; } } 区间dp 石子合并 memset(f, 0x3f, sizeof f); for(int len=2;len\u0026lt;=n;len++){ for(int i=1;i+len-1\u0026lt;=n;i++){ int j=i+len-1; if (len == 1) { f[i][j] = 0; // 边界初始化 continue; } for(int k=i;k\u0026lt;j;k++){ f[l][r]=min(f[l][r],f[l][k]+f[k+1][r]+s[r]-s[l-1]); } } } cout\u0026lt;\u0026lt;f[1][n]; 数位统计dp 状态表示\n分情况讨论\n状态压缩 dp 蒙德里安的梦想\n最短Hamilton距离\n树形dp 没有上司的舞会\n记忆化 滑雪\n#include\u0026lt;bits/stdc++.h\u0026gt; using namespace std; #define ll long long const int maxn=1e4; ll f[maxn][maxn],g[maxn][maxn]; //distance struct node{ ll i,j,num; }a[maxn]; struct cmp { bool operator () (node x,node y){ return x.num\u0026gt;y.num; } }; int main() { ios::sync_with_stdio(false); cin.tie(0); cout.tie(0); ll n,m,ma=-1; cin\u0026gt;\u0026gt;n\u0026gt;\u0026gt;m; priority_queue\u0026lt;node, vector\u0026lt;node\u0026gt;,cmp\u0026gt;pq; for(ll i=1;i\u0026lt;=n;i++){ for(ll j=1;j\u0026lt;=m;j++){ f[i][j]=1; node a; a.i=i; a.j=j; cin\u0026gt;\u0026gt;a.num; g[i][j]=a.num; pq.push(a); } } while(!pq.empty()){ node t=pq.top(); pq.pop(); ll i=t.i; ll j=t.j; ll nu=t.num; if(g[i-1][j]\u0026lt;nu) f[i][j]=max(f[i][j],f[i-1][j]+1); if(g[i+1][j]\u0026lt;nu) f[i][j]=max(f[i][j],f[i+1][j]+1); if(g[i][j-1]\u0026lt;nu) f[i][j]=max(f[i][j],f[i][j-1]+1); if(g[i][j+1]\u0026lt;nu) f[i][j]=max(f[i][j],f[i][j+1]+1); ma=max(ma,f[i][j]); } cout\u0026lt;\u0026lt;ma\u0026lt;\u0026lt;endl; return 0; } 习题课 ","permalink":"https://kennems.github.io/zh/posts/tech/acwing/","summary":"acwing算法学习 [TOC] 第一章 课上：学思想 课下：背代码 题目，一道题写好几遍 理解没有任何意义，体力活+脑力活 记忆力 毅力/自制力 沉下心背东西 快速排","title":""},{"content":"Acwing记录 易错点：\n变量名，符号写错（已知算法的情况下重新写一遍） 函数写了没有调用 保分\n根据数据量用不同的算法\nDP， 数学，哈希，分块，树状数组线段树\ndef check(x): if x\u0026lt;2: return False for i in range(2, int(x**0.5) + 1): if x%i==0: return False return True n = int(input()) for i in range(n): x = int(input()) if check(x): print(\u0026#34;Yes\u0026#34;) else: print(\u0026#34;No\u0026#34;) def get(x): for i in range(2, int(x**0.5) + 1): cnt = 0 if x%i==0: while x%i==0: x//=i cnt+=1 if cnt: print(i, cnt) if x!=1: print(x, 1) n = int(input()) for i in range(n): x = int(input()) get(x) print() 阶乘分解 def get(n): for i in range(2, n+1): if not st[i]: primes.append(i) for p in primes: if i*p\u0026gt;n: break st[i*p]=True if i%p==0: break n = int(input()) primes = [] st = [False]*(n+1) get(n) for p in primes: s, t = 0, n while t: s += t//p t//=p print(p, s) \\196. 质数距离 import math inf = math.inf def get(n): for i in range(2, n+1): if not st[i]: primes.append(i) for p in primes: if i*p\u0026gt;n: break st[i*p] = True if i%p==0: break N = 50000 primes = [] st = [False]*(N + 5) get(N) while True: try: l, r = map(int, input().split()) except: exit() isprimes = [False]*(r-l+1) inprimes = [] for p in primes: for i in range(max(2*p, (l+p-1)//p*p), r+1, p): isprimes[i-l] = True for i in range(l, r+1): if i\u0026gt;1 and not isprimes[i-l]: inprimes.append(i) if len(inprimes)\u0026lt;2: print(\u0026#34;There are no adjacent primes.\u0026#34;) continue mx, mxl, mxr = -inf, 0, 0 mn, mnl, mnr = inf, 0, 0 for i in range(len(inprimes)-1): p1, p2 = inprimes[i], inprimes[i+1] d = p2 - p1 if d\u0026lt;mn: mn, mnl, mnr = d, p1, p2 if d\u0026gt;mx: mx, mxl, mxr = d, p1, p2 print(\u0026#34;{},{} are closest, {},{} are most distant.\u0026#34;.format(mnl, mnr, mxl, mxr)) AcWing 1293. 夏洛克和他的女朋友 def get(n): for i in range(2, n+1): if not st[i]: primes.append(i) for p in primes: if i*p\u0026gt;n: break st[i*p] = True if i%p==0: break N = 100010 primes = [] st = [False]*(N+10) get(N) n = int(input()) if n\u0026lt;=2: print(1) else: print(2) for i in range(2, n+2): if not st[i]: print(1, end=\u0026#39; \u0026#39;) else: print(2, end=\u0026#39; \u0026#39;) 分解约数\ndef get(x): res = [] for i in range(1, int(x**0.5) + 1): if x%i==0: res.append(i) if i!=x//i: res.append(x//i) return res n = int(input()) for i in range(n): x = int(input()) res = sorted(get(x)) print(*res, sep=\u0026#39; \u0026#39;) from collections import defaultdict mod = int(1e9) + 7 n = int(input()) res = 1 d = defaultdict(int) for i in range(n): x = int(input()) for i in range(2, int(x**0.5) + 1): cnt = 0 if x%i==0: while x%i==0: x//=i cnt += 1 d[i] += cnt if x\u0026gt;1: d[x] += 1 for x in d: res = res * (d[x]+1) % mod print(res) 约数之和 from collections import defaultdict d = defaultdict(int) mod = 9901 def qpow(a, k): res = 1 while k: if k\u0026amp;1: res = res*a%mod a = a*a%mod k\u0026gt;\u0026gt;=1 return res def calc(a, k): if k==0: return 1 if k\u0026amp;1: return (1 + qpow(a, k//2 + 1)) * calc(a, k//2) % mod return (1 + qpow(a, (k-1)//2 + 1)) * calc( a, (k-1)//2 ) + qpow(a, k) a, b = map(int, input().split()) x = a for i in range(2, int(x**0.5) + 1): if x%i==0: cnt = 0 while x%i==0: x//=i cnt += 1 d[i] += cnt if x\u0026gt;1: d[x] += 1 res = 1 for x in d: res = res * calc(x, d[x]*b) % mod print(res if a else 0) 约数之和 from collections import defaultdict def qpow(a, k): res = 1 while k: if k\u0026amp;1: res = res*a%mod a = a*a%mod k\u0026gt;\u0026gt;=1 return res def calc(a, k): if k==0: return 1 if k\u0026amp;1: return (1 + qpow(a, k//2+1)) * calc(a, k//2) % mod return ( qpow(a, k) + (1 + qpow(a, (k-1)//2+1)) * calc(a, (k-1)//2) ) % mod n = int(input()) mod = int(1e9) + 7 d = defaultdict(int) for i in range(n): x = int(input()) for j in range(2, int(x**0.5) + 1): if x%j==0: cnt = 0 while x%j==0: cnt += 1 x//=j d[j] += cnt if x\u0026gt;1: d[x] += 1 res = 1 for x in d: res = res * calc(x, d[x])%mod print(res) 分解质因数法求组合数 def get_primes(n): primes = [] st = [False]*(n+1) for i in range(2, n+1): if not st[i]: primes.append(i) for p in primes: if i*p\u0026gt;n: break st[i*p] = True if i%p==0: break return primes def get(n, p): res = 0 while n: res += n//p n//=p return res def qpow(a, k): res = 1 while k: if k\u0026amp;1: res = res * a a = a*a k\u0026gt;\u0026gt;=1 return res def calc(a, b): primes = get_primes(a) s = [0]*len(primes) for i, p in enumerate(primes): s[i] = get(a, p) - get(b, p) - get(a-b, p) res = 1 for i in range(len(primes)): res = res * qpow(primes[i], s[i]) return res a, b = map(int, input().split()) print(calc(a, b)) Kruskal import sys input = lambda:sys.stdin.readline().strip() def find(x): while p[x] != x: p[x] = p[p[x]] x = p[x] return x def kruskal(): res, cnt = 0, 0 ans = [] for u, v, w in g: fu, fv = find(u), find(v) if fu != fv: res += w cnt += 1 p[fu] = fv ans.append((u, v, w)) ans.sort() if cnt == n-1: print(res) # print(ans) else: print(\u0026#34;impossible\u0026#34;) n, m = map(int, input().split()) g = [] p = [i for i in range(n+1)] for i in range(m): u, v, w = map(int, input().split()) g.append((u, v, w)) g.sort(key = lambda e:e[2]) kruskal() prim from math import inf from sys import stdin def prim(): res = 0 dis[1] = 0 for i in range(n): t = -1 for j in range(1, n+1): if not st[j] and (t==-1 or dis[t] \u0026gt; dis[j]): t = j if i and dis[t]==inf: return inf if i: res += dis[t] st[t] = True for j in range(1, n+1): dis[j] = min(dis[j], g[t][j]) return res n, m = map(int, input().split()) g = [[inf]*(n+1) for _ in range(n+1)] dis = [inf]*(n+1) st = [False]*(n+1) for i in range(m): u, v, w = map(int, input().split()) g[u][v] = g[v][u] = min(w, g[u][v]) res = prim() if res==inf: print(\u0026#34;impossible\u0026#34;) else: print(res) floyd from sys import stdin from math import inf def floyd(): for k in range(1, n+1): for i in range(1, n+1): for j in range(1, n+1): d[i][j] = min(d[i][j], d[i][k] + d[k][j]) n, m, k = map(int, input().split()) d = [[0 if i==j else inf for i in range(n+1)] for j in range(n+1)] for i in range(m): x, y, z = map(int, input().split()) d[x][y] = min(d[x][y], z) floyd() for i in range(k): x, y = map(int, input().split()) print(d[x][y] if d[x][y]!=inf else \u0026#34;impossible\u0026#34;) spfa from sys import stdin from collections import defaultdict, deque from math import inf def spfa(): q = deque([1]) dis[1] = 0 st[1] = True while q: x = q.popleft() st[x] = False for y, z in g[x]: if dis[y] \u0026gt; dis[x] + z: dis[y] = dis[x] + z if not st[y]: q.append(y) st[y] = True return dis[n] n, m = map(int, input().split()) dis = [inf]*(n+1) st = [False]*(n+1) g = defaultdict(list) for i in range(m): x, y, z = map(int, input().split()) g[x].append((y, z)) res = spfa() print(res if res != inf else \u0026#34;impossible\u0026#34;) SPFA判断负环 from sys import stdin from collections import deque, defaultdict from math import inf input = lambda:stdin.readline().strip() def spfa(): q = deque() for i in range(1, n+1): q.append(i) st[i] = True while q: x = q.popleft() st[x] = False for y, z in g[x]: if dis[y] \u0026gt; dis[x] + z: dis[y] = dis[x] + z cnt[y] = cnt[x] + 1 if cnt[y] \u0026gt;= n: return True if not st[y]: q.append(y) st[y] = True return False n, m = map(int, input().split()) g = defaultdict(list) cnt = [0]*(n+1) st = [False]*(n+1) dis = [0]*(n+1) for i in range(m): x, y, z = map(int, input().split()) g[x].append((y, z)) res = spfa() print(\u0026#34;Yes\u0026#34; if res else \u0026#34;No\u0026#34;) 二分图 from sys import stdin from collections import defaultdict, deque def bfs(u, c): color[u] = c q = deque([(u, c)]) while q: cur, col = q.popleft() for nx in g[cur]: if color[nx]==-1: color[nx] = col^1 q.append((nx, col^1)) elif color[nx] == col: return False return True n, m = map(int, input().split()) g = defaultdict(list) color = [-1]*(n+1) for i in range(m): u, v = map(int, input().split()) if u not in g[v]: g[v].append(u) if v not in g[u]: g[u].append(v) for i in range(1, n+1): if color[i] == -1: if not bfs(i, 0): print(\u0026#34;No\u0026#34;) exit() print(\u0026#34;Yes\u0026#34;) 匈牙利算法 from sys import stdin from collections import defaultdict def find(u): for v in g[u]: if not st[v]: st[v] = True if mat[v]==0 or find(mat[v]): mat[v] = u return True return False n1, n2, m = map(int, input().split()) mat = [0]*(n2 + 1) g = defaultdict(list) for i in range(m): u, v = map(int, input().split()) g[u].append(v) res = 0 for i in range(1, n1+1): st = [False]*(n2 + 1) if find(i): res += 1 print(res) TopSort from sys import stdin from collections import deque input = lambda:stdin.readline().strip() def topsort(): q = deque() res = [] for i in range(1, n+1): if ind[i]==0: res.append(i) q.append(i) while q: u = q.popleft() for v in g[u]: ind[v] -= 1 if ind[v]==0: q.append(v) res.append(v) return res n = int(input()) ind = [0]*(n+1) g = [[] for _ in range(n+1)] for i in range(1, n+1): a = list(map(int, input().split())) for j in range(len(a)-1): g[i].append(a[j]) ind[a[j]]+=1 res = topsort() print(*res, sep=\u0026#39; \u0026#39;) Dijkstra from math import inf from sys import stdin from collections import deque def dijkstra(): dis[1] = 0 # st[1] = True for i in range(n-1): t = -1 for j in range(1, n+1): if not st[j] and (t==-1 or dis[j] \u0026lt; dis[t]): t = j st[t] = True for j in range(1, n+1): dis[j] = min(dis[j], dis[t] + g[t][j]) return dis[n] n, m = map(int, input().split()) g = [[inf]*(n+1) for _ in range(n+1)] st = [False]*(n+1) dis = [inf]*(n+1) for i in range(m): x, y, z = map(int, input().split()) g[x][y] = min(g[x][y], z) res =dijkstra() print(res if res != inf else -1) from sys import stdin from math import inf from collections import defaultdict, deque def spfa(): q = deque([1]) dis[1] = 0 st[1] = True while q: u = q.popleft() st[u] = False for v, z in g[u]: if dis[v] \u0026gt; dis[u] + z: dis[v] = dis[u] + z if not st[v]: st[v] = True q.append(v) return dis[n] n, m = map(int, input().split()) g = defaultdict(list) dis = [inf]*(n+1) st = [False]*(n+1) for i in range(m): x, y, z = map(int, input().split()) g[x].append((y, z)) res = spfa() print(res if res != inf else \u0026#34;impossible\u0026#34;) 热浪 from sys import stdin from collections import deque, defaultdict from math import inf input = lambda:stdin.readline().strip() def spfa(): q = deque([st]) dis[st] = 0 vis[st] = True while q: x = q.popleft() vis[x] = False for y, z in g[x]: if dis[y] \u0026gt; dis[x] + z: dis[y] = dis[x] + z if not vis[y]: vis[y] = True q.append(y) return dis[ed] n, m, st, ed = map(int, input().split()) g = defaultdict(list) dis = [inf]*(n+1) vis = [False]*(n+1) for i in range(m): x, y, z = map(int, input().split()) g[x].append((y, z)) g[y].append((x, z)) res = spfa() print(res) 堆优化版Dijkstra() from sys import stdin from math import inf from collections import deque, defaultdict from heapq import heappush, heappop input = lambda:stdin.readline().strip() def dijkstra(): h = [(0, 1)] dis[1] = 0 while h: dist, ver = heappop(h) if vis[ver]: continue vis[ver] = True for nx, z in g[ver]: if dis[nx] \u0026gt; dis[ver] + z: dis[nx] = dis[ver] + z heappush(h, (dis[nx], nx)) return dis[n] n, m = map(int, input().split()) dis = [inf]*(n+1) vis = [False]*(n+1) g = defaultdict(list) for i in range(m): x, y, z = map(int, input().split()) g[x].append((y, z)) res = dijkstra() print(res if res != inf else -1) 1275 最大数 from sys import stdin input = lambda:stdin.readline().strip() def pushup(u): tr[u] = max(tr[u\u0026lt;\u0026lt;1], tr[u\u0026lt;\u0026lt;1|1]) def build(u, l, r): if l==r: tr[u] = 0 else: mid = l+r\u0026gt;\u0026gt;1 build(u\u0026lt;\u0026lt;1, l, mid) build(u\u0026lt;\u0026lt;1|1, mid+1, r) pushup(u) def modify(u, l, r, x, v): if l==r: tr[u] = v return mid = l+r\u0026gt;\u0026gt;1 if x\u0026lt;=mid: modify(u\u0026lt;\u0026lt;1, l, mid, x, v) else: modify(u\u0026lt;\u0026lt;1|1, mid+1, r, x, v) pushup(u) def query(u, l, r, ql, qr): if ql\u0026lt;=l and r\u0026lt;=qr: return tr[u] mid = l+r\u0026gt;\u0026gt;1 res = 0 if ql\u0026lt;=mid: res = query(u\u0026lt;\u0026lt;1, l, mid, ql, qr) if qr\u0026gt;mid: res = max(res, query(u\u0026lt;\u0026lt;1|1, mid+1, r, ql, qr)) return res m, p = map(int, input().split()) tr = [0]*(1\u0026lt;\u0026lt;m.bit_length() + 1) pre = 0 cnt = 0 for i in range(m): op, x = input().split() x = int(x) if op==\u0026#39;Q\u0026#39;: l, r = cnt-x+1, cnt pre = query(1, 1, m, l, r) print(pre) else: cnt += 1 val = (x + pre)%p modify(1, 1, m, cnt, val) 反素数 from sys import stdin input = lambda:stdin.readline().strip() def get(n): primes = [] st = [False]*(n+1) for i in range(2, n+1): if not st[i]: primes.append(i) for p in primes: if i*p\u0026gt;n: break st[i*p] = True if i%p==0: break return primes def dfs(i, od, p, cnt): global mxp, mxn if cnt\u0026gt;mxn or (cnt==mxn and p\u0026lt;mxp): mxp, mxn = p, cnt if i\u0026gt;10: return for j in range(1, od+1): if p*primes[i]\u0026gt;n: return p *= primes[i] dfs(i+1, j, p, cnt*(j+1)) primes = get(50) # print(primes) n = int(input()) mxp, mxn = 0, 0 dfs(0, 30, 1, 1) print(mxp) from sys import stdin def get(n): primes = [] st = [False]*(n+1) for i in range(2, n+1): if not st[i]: primes.append(i) for p in primes: if i*p\u0026gt;n: break st[i*p] = True if i%p==0: break return primes def dfs(i, od, p, cnt): global mxn, mxp if cnt\u0026gt;mxn or (cnt==mxn and p\u0026lt;mxp): mxp, mxn = p, cnt if i\u0026gt;10: return for j in range(1, od+1): if p * primes[i] \u0026gt; n: break p *= primes[i] dfs(i+1, j, p, cnt*(j+1)) primes = get(50) n = int(input()) mxp, mxn = 0, 0 dfs(0, 30, 1, 1) print(mxp) \\200. Hankson的趣味题 from sys import stdin from math import gcd input = lambda:stdin.readline().strip() def lcm(a, b): return a*b//gcd(a, b) def get(n): for i in range(2, n+1): if not st[i]: primes.append(i) for p in primes: if i*p\u0026gt;n: break st[i*p] = True if i%p==0: break def dfs(i, p): if i==len(pd): if p\u0026lt;=b1: div.append(p) return dfs(i+1, p) for j in range(1, pd[i][1] + 1): p *= pd[i][0] dfs(i+1, p) n = int(input()) N = int(2e9) + 10 N = int(N**0.5) st = [False]*(N+10) primes = [] get(N) for i in range(n): a0, a1, b0, b1 = map(int, input().split()) t = b1 pd = [] for p in primes: if t%p==0: cnt = 0 while t%p==0: cnt += 1 t//=p pd.append((p, cnt)) if t\u0026gt;1: pd.append((t, 1)) div = [] dfs(0, 1) # print(div) res = 0 for x in div: if gcd(x, a0)==a1 and lcm(x, b0)==b1: res += 1 print(res) 楼兰图腾 from sys import stdin M = int(2e5) + 10 tr = [0]*M def lowbit(x): return x\u0026amp;-x def add(x, v): while x\u0026lt;M: tr[x] += v x += lowbit(x) def query(x): res = 0 while x: res += tr[x] x -= lowbit(x) return res n = int(input()) a = list(map(int, input().split())) suml, sumu = 0, 0 for x in a: lwl = query(x) lwr = (x-1) - lwl upr = query(n) - query(x) upl = n-x - upr suml += (lwl * lwr) sumu += (upl * upr) add(x, 1) print(sumu, suml) 多重背包 from sys import stdin input = lambda:stdin.readline().strip() N, V = map(int, input().split()) f = [0]*(V+1) v, w = [], [] for i in range(N): vi, wi, si = map(int, input().split()) c = 1 while si\u0026gt;=c: v.append(c*vi) w.append(c*wi) si -= c c *= 2 if si: v.append(si*vi) w.append(si*wi) l = len(v) for i in range(l): for j in range(V, v[i]-1, -1): f[j] = max(f[j], f[j-v[i]] + w[i]) print(f[V]) 欧拉函数 def get(x): res = x for i in range(2, int(x**0.5) + 1): if x%i==0: res = res//i*(i-1) while x%i==0: x//=i if x\u0026gt;1: res = res//x*(x-1) return res n = int(input()) for i in range(n): x = int(input()) print(get(x)) 线性筛法求欧拉函数 def get(n): euler[1] = 1 for i in range(2, n+1): if not st[i]: primes.append(i) euler[i] = i-1 for p in primes: t = i*p if t\u0026gt;n: break st[t] = True if i%p==0: euler[t] = euler[i] * p break euler[t] = euler[i] * (p-1) n = int(input()) st = [False] * (n+1) primes = [] euler = [0]*(n+1) get(n) res = 0 for i in range(1, n+1): res += euler[i] print(res) ","permalink":"https://kennems.github.io/zh/posts/tech/acwing%E8%AE%B0%E5%BD%95/","summary":"Acwing记录 易错点： 变量名，符号写错（已知算法的情况下重新写一遍） 函数写了没有调用 保分 根据数据量用不同的算法 DP， 数学，哈希，分块，树状","title":""},{"content":"LeetCode每日一题(2405) 1235. 规划兼职工作 题目大意：给定n份兼职工作，每份工作都有开始时间、结束时间和报酬。任务是选择一些工作，使得在不重叠的情况下能够获得最大报酬。\n实现思路：首先对工作按照结束时间进行排序，然后使用动态规划来求解最大报酬。在动态规划的过程中，维护一个数组f，其中f[i]表示在考虑前i个工作时可以获得的最大报酬。遍历每个工作，对于第i个工作，找到在其开始时间之前且结束时间最接近的工作j，然后更新f[i]为f[j] + 第i个工作的报酬。最终返回f[n]即为所求的最大报酬。\nclass Solution: def jobScheduling(self, startTime: List[int], endTime: List[int], profit: List[int]) -\u0026gt; int: # 兵贵神速，现在能领先一秒，以后就能按照复利一直领先 n = len(startTime) job = [(0, 0, 0)] + sorted(zip(endTime, startTime, profit)) f = [0]*(n+1) for i, (_, st, p) in enumerate(job[1:], start = 1): # l, r = 0, i-1 # while l\u0026lt;r: # mid = (l+r+1)\u0026gt;\u0026gt;1 # if job[mid][0] \u0026gt; st: # r = mid-1 # else: # l = mid # f[i] = max(f[i-1], f[l] + p) l = bisect_left(job, (st+1, ), hi = i, lo = 0) # 内置库只能查找 严格 \u0026gt; \u0026lt; 的值 # 无法找到 \u0026gt;= \u0026lt;=的值，但是可以在找到最大的 \u0026lt;目标值的 i, i-1即为\u0026lt;=目标值的下标 f[i] = max(f[i-1], f[l-1] + p) return f[n] 741. 摘樱桃 题目大意：给定一个网格，其中包含空格、樱桃和荆棘，要求从左上角到右下角，然后返回左上角，按照规定的走法，最多能摘到的樱桃数量。\n实现思路：这是一个动态规划问题。定义一个递归函数dfs(t, j, l)，表示在时刻t，第一个人位于(j, t-j)，第二个人位于(l, t-l)时，能够得到的最大樱桃数量。递归终止条件是当其中一个人走到了边界之外或者碰到了荆棘时，返回负无穷。然后递归地计算四种可能的移动方向：向下走、向右走、向下和向右走、向左走，同时更新樱桃数量。最后返回经过路径能够摘到的最多樱桃数量。\nclass Solution: def cherryPickup(self, g: List[List[int]]) -\u0026gt; int: @cache def dfs(t, j, l): if j\u0026lt;0 or l\u0026lt;0 or t-j\u0026lt;0 or t-l\u0026lt;0 or g[t-j][j]==-1 or g[t-l][l]==-1: return -inf if t==0: return g[0][0] return max(dfs(t-1, j, l), dfs(t-1, j-1, l), dfs(t-1, j, l-1), dfs(t-1, j-1, l-1)) \\ + g[t-j][j] + (g[t-l][l] if j!=l else 0) n = len(g) return max(0, dfs(2*n-2, n-1, n-1)) ","permalink":"https://kennems.github.io/zh/posts/tech/leetcode%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%982405/","summary":"LeetCode每日一题(2405) 1235. 规划兼职工作 题目大意：给定n份兼职工作，每份工作都有开始时间、结束时间和报酬。任务是选择一些工作，使得","title":""},{"content":"title = \u0026lsquo;后端八股学习笔记\u0026rsquo; date = 2024-04-06T17:47:22+08:00 draft = false\n+++\n后端八股学习笔记 想要生活能进步，就不能走退步路。\n计算机网络 网络是把主机连接起来，而互联网(Internet)是把多种不同的网络连接起来，因此互联网是网络的网络，而互联网(Internet)是全球范围的互联网。 ISP 互联网服务提供商ISP可以从互联网管理机构获得许多IP地址，同时拥有通信线路以及路由器等联网设备，个人或机构向ISP缴纳一定的费用就可以接入互联网。\n目前的互联网是一种多层次ISP结构，ISP根据覆盖面积的大小分为第一层ISP，区域ISP和接入ISP。**互联网交换点IXP（Internet Exchange Point)**允许两个ISP直接相连而不用经过第三个ISP。\n主机之间的通信方式 客户-服务器（C/S）：客户是服务的请求方，服务器 是服务的提供方。\n对等（P2P）：不区分客户和服务器\n电路交换与分组交换 1.电路交换 电路交换用于电话通信系统，两个用户要通信之前需要建立一条专用的物理链路，并且在整个通信过程中始终占用该链路。由于通信的过程中不可能一直在使用传输线路，因此电路交换对线路的利用率很低，往往不到10%。\n2.分组交换 每个分组都有首部和尾部，包含了源地址和目的地址等控制信息，在同一个传输线路上同时传输多个分组互相不影响，因此在同一条传输线路上允许同时传输多个分组，也就是说分组交换不需要占用传输线路。\n在同一个邮局通信系统中，邮局收到一份邮件之后，先存储下来，然后把相同目的地的邮件一起转发到下一个目的地，这个过程就是存储转发的过程，分组交换也使用了存储转发过程。\n时延 总时延 = 排队时延 + 处理时延 + 传输时延 + 传播时延\n1.排队时延 分组在路由器的输入队列和输出队列中排队等待的时间，取决于网络当前的通信量。\n2.处理时延 主机或路由器收到分组时进行处理所需要的时间，例如分析首部、从分组中提取数据、进行差错检验或查找适当的路由等。\n3.传输时延 主机或路由器传输数据帧所需要的时间。 $$ delay = \\frac{l(bit)}{v(bit/s)} $$ $l$:数据帧的长度, $v$:传输速率\n4.传播时延 电磁波在信道中传播所需要花费的时间，电磁波传播的速度接近光速。 $$ delay = \\frac{l(m)}{v(m/s)} $$ $l$:表示信道长度， $v$:表示电磁波在信道上的传播速度\n计算机网络体系结构 1.五层协议 应用层：为特定应用程序提供数据传输服务，例如HTTP，DNS等协议。数据单位为报文。\n传输层：为进程提供通用数据传输服务。由于应用层协议很多，定义通用的传输层协议就可以支持不断增多的应用层协议。运输层包括两种协议：传输控制协议TCP，提供面向连接、可靠的数据传输服务，数据单位为报文段；用户数据报协议UDP，提供无连接的、尽最大努力的数据传输服务，数据单位为用户数据报。TCP主要提供完整性服务，UDP主要提供及时性服务。\n网络层：为主机提供数据传输服务。而传输层协议是为主机中的进程提供数据传输服务。网络层把传输层传递下来的报文段或者用户数据报封装成分组。\n数据链路层：网络层针对的还是主机之间的数据传输服务，而主机之间可以有很多链路，链路层协议就是为同一链路的主机提供数据传输服务。数据链路层把网络层传下来的分组封装成帧。\n物理层：考虑的是怎样在传输媒体上传输比特流，而不是指具体的传输媒体。物理层的作用是尽可能屏蔽传输媒体和通信手段的差异，使数据链路层感觉不到这些差异。\n2.OSI (Open Systems Interconnection，开放式系统互联)\n其中表示层和会话层用途如下：\n表示层：数据压缩、加密以及数据描述，这使得应用程序不必关心在各台主机中数据内部格式不同的问题。 会话层：建立及管理会话。 五层协议没有表示层和会话层，而是将这些功能留给应用程序开发者处理。\n3.TCP/IP 只有四层，相当于五层协议中数据链路层和物理层合并为网络接口层。\nTCP/IP体系结构不严格遵循OSI分层概念，应用层可能会直接使用IP层或者网络接口层。\n4.数据在各层之间的传递过程 在向下的过程中，需要添加下层协议所需要的首部和尾部，而在向上的过程中不断拆开首部和尾部。\n路由器只有下面三层协议，因为路由器位于网络核心中，不需要为进程或者应用程序提供服务，因此也就不需要传输层和应用层。\n物理层 通信方式 根据信息在传输线上的传送方向，分为一下三种通信方式：\n单工通信：单向传输 半双工通信：双向交替传输 全双工通信：双向同时传输 带通调制 模拟信号是连续的信号，数字信号是离散的信号。带通调制把数字信号转换为模拟信号。\n链路层 基本问题 1.封装成帧 把网络层传下来的分组添加首部和尾部，用于标记帧的开始和结束。\n2.透明传输 透明表示一个实际存在的事物看起来好像不存在一样。\n帧使用首部和尾部进行定界，如果帧的数据部分含有和首部尾部相同的内容，那么帧的开始和结束位置就会被错误的判定。需要在数据部分出现首部尾部相同的内容前面插入转义字符。如果数据部分出现转义字符，那么就在转义字符前面再加个转义字符。在接收端处理之后可以还原出原始数据。这个过程透明传输的内容是转义字符，用户察觉不到转义字符的存在。\n3.差错检测 目前数据链路层广泛使用了**循环冗余检验（CRC，Cyclic Redundancy Check）**来检查比特差错。\n信道分类 1.广播信号 一对多通信，一个节点发送的数据能够被广播信道上所有的节点接受到。\n所有的节点都在同一个广播信道上发送数据，因此需要有专门的控制方法进行协调，避免发生冲突（冲突也叫碰撞）。\n主要有两种控制方法进行协调，一个是使用信道复用技术；另一个是使用CSMA/CD协议。\n2.点对点信道 一对一通信。\n因为不会发生碰撞，因此也比较简单，使用PPP（Point-to-Point Protocol）协议进行控制。\n信道复用技术 1.频分复用 频分复用的所有主机在相同的时间占用不同的频率带宽资源。\n2.时分复用 时分复用的所有主机在不同的事件占用相同的频率带宽资源。\n使用频分复用和时分复用进行通信，在通信的过程中主机会一直占用一部分信道资源。但是由于计算机数据的突发性质，通信过程没必要一直占用信道资源而不让出给其他用户使用，因此这两种方式对信道的利用率都不高。\n3.统计时分复用 是对时分复用的一种改进，不固定每个用户在时分复用帧中的位置，只要有数据就集中起来组成统计时分复用帧然后发送。\n4.波分复用 光的频分复用。由于光的频率很高，因此习惯上用波长而不是频率来表示所使用的光载波。\n5.码分复用 为每个用户分配$m\\ bit$ 的码片，并且所有的码片正交，对于任意两个码片$\\vec{S}$和$\\vec{T}$有 $$ \\frac{1}{m}\\vec{S}\\ \\cdot \\vec{T} = 0 $$ 为了讨论方便，取$m=8$, 设码片$\\vec{S}$为$00011011$。在拥有该码片额用户发送比特1时就发送该码片，发送比特0时就发送该码片的反码$11100100$\n在计算时将$00011011$记作（$-1-1-1+1+1-1+1+1$）,可以得到： $$ \\frac{1}{m}\\vec{S} \\cdot \\vec{S}=1 $$\n$$ \\frac{1}{m}\\vec{S} \\cdot \\vec{S}\u0026rsquo;=-1 $$\n其中$\\vec{S}\u0026rsquo;$是$\\vec{S}$的反码\n利用上面的式子可知，当接收端使用码片$\\vec{S}\u0026rsquo;$对接受到的数据进行内积运算时， 结果为0的是其它用户发送的数据，结果为1的是用户发送的比特1,结果为-1的是用户发送的比特0。\n码分复用需要发送的数据量为原先的m倍。\nCSMA/CD协议 CSMA/CD表示载波监听多点接入/碰撞检测。\n多点接入：说明这是总线型网络，许多主机以多点的方式连接到总线上 载波监听：每个主机都必须不停地监听信道。在发送前，如果监听到信道正在使用，就必须等待。 碰撞检测：在发送中，如果监听到信道已有其他主机正在发送数据，就表示发生了碰撞。虽然每个主机在发送数据之前都已经监听到信道为空闲，但是由于电磁波的传播时延的存在，还是有可能会发生碰撞。 记端到端的传播时延为$\\tau$, 最先发送的站点最多经过$2\\tau$就可以知道是否发生了碰撞，称$2\\tau$为争用期。只有经过争用期之后还没有检测到碰撞，才能肯定这次发送不会发生碰撞。\n当发生碰撞时， 站点要停止发送，等待一段时间再发送。这个时间采用截断二进制指数退避算法来确定。从离散的整数集合${0, 1, \u0026hellip;, (2^k-1)}$中随机取出一个数，记作$r$， 然后取$r$倍的争用期作为重传等待时间。\nPPP协议 互联网用户通常需要连接到某个ISP之后才能接入互联网，PPP协议时用户计算机和ISP进行通信时所使用的数据链路层协议。\nPPP的帧格式：\nF字段为帧的定界符 A和C字段暂时没有意义 FCS字段是使用CRC的检验序列 信息部分的长度不超过1500 MAC地址 MAC地址是链路层地址，长度为6字节（48位）， 用于唯一表示网络适配器（网卡）。\n一台主机拥有多少个网络适配器就有多少个MAC地址。例如笔记本电脑普遍存在无限网络适配器和有线网络适配器，因此就有两个MAC地址。\n局域网 局域网是一种典型的广播信道，主要特点是网络为一个单位所拥有， 且地理范围和站点数目均有限。\n主要有以太网、令牌环网络、FDDI和ATM等局域网技术，目前以太网占领着有线局域网市场。\n可以按照网络拓扑结构对局域网进行分类。\n以太网 以太网是一种星型拓扑结构局域网。\n早起使用集线器进行连接，集线器是一种物理层设备。作用于比特而不是帧，当一个比特到达接口时，集线器重新生成这个比特，并将其能量强度放大，从而扩大网络的传输距离，之后再将这个比特发送到其他所有接口。如果集线器同时收到两个不同接口的帧，那么就发生了碰撞。\n目前以太网使用交换机替代了集线器，交换机是一种链路层设备，它不会发生碰撞，能根据MAC地址进行存储转发。\n以太网格式：\n类型：标记上层使用的协议 数据：长度为46~1500之间，如果太小则需要填充 FCS：真检验序列，使用的时CRC检验方法 交换机 ","permalink":"https://kennems.github.io/zh/posts/tech/%E5%90%8E%E7%AB%AF%E5%85%AB%E8%82%A1%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/","summary":"title = \u0026lsquo;后端八股学习笔记\u0026rsquo; date = 2024-04-06T17:47:22+08:00 draft = false +++ 后端八股学习笔记 想要生活能进步，就不能走退步路。 计算机网络 网络是把主机连接起来","title":""},{"content":"通信原理大作业 题目七：2DPSK系统的仿真\n要求：\n（1）模块直接实现法，绘制系统的眼图和误比特率曲线；\n信道中加入高斯白噪声，改变高斯白噪声的参数，观察接受端输出信号的变化情况，并绘制系统的眼图和误比特率曲线。\n（2）根据原理间接实现调制解调过程，用示波器显示2FSK调制波形和解调波形。\n（3）改变信号源的频率和载波的频率，调整带通滤波器和低通滤波器的截止频率，再次观察示波器显示2FSK调制波形和解调波形。\n","permalink":"https://kennems.github.io/zh/posts/tech/%E9%80%9A%E4%BF%A1%E5%8E%9F%E7%90%86%E5%A4%A7%E4%BD%9C%E4%B8%9A/","summary":"通信原理大作业 题目七：2DPSK系统的仿真 要求： （1）模块直接实现法，绘制系统的眼图和误比特率曲线； 信道中加入高斯白噪声，改变高斯白噪声的参","title":""}]